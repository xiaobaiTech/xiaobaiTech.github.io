---
title: 都是同样条件的mysql select语句，为什么读到的内容却不一样？
date: 2022-04-26 22:57:55
tags:
categories: "图解mysql"
---

<br>

假设当前数据库里有下面这张表。

![user表数据库原始状态](https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%814.drawio.png)

老规矩，以下内容还是默认发生在 innodb 引擎的**可重复读隔离级别**下。

![都是select结果却不同](https://cdn.xiaobaidebug.top/image/%E9%83%BD%E6%98%AFselect%E7%BB%93%E6%9E%9C%E5%8D%B4%E4%B8%8D%E5%90%8C1.drawio.png)

<!-- more -->

大家可以看到，**线程 1**，同样都是读 `age >= 3` 的数据。第一次读到**1 条数据**，这个是原始状态。这之后线程 2 将 id=2 的 age 字段也改成了 3。

线程 1 此时再读两次，一次读到的结果还是原来的**1 条**，另一次读的结果却是**2 条**，**区别在于加没加 for update。**

为什么同样条件下，都是读，读出来的数据却不一样呢？

可重复读不是要求每次读出来的内容要一样吗？

<br>

要回答这个问题。

我需要从盘古是怎么开天辟地这个话题开始聊起。

<br>

不好意思。

失态了。

那就从事务是怎么回滚的开始聊起吧。

<br>

## 事务的回滚是怎么实现的

我们在执行事务的时候，一般都是下面这样的格式

```sql
begin;
操作1;
操作2;
操作3;
xxxxx
....
commit;
```

在提交事务之前，会执行各种操作，里面可以包含各种逻辑。

只要是执行逻辑，那就**有可能**会报错。

回想下事务的`ACID`里有个`A`，**原子性**，整个事务就是个整体，要么一起成功，要么一起失败。

![ACID](https://cdn.xiaobaidebug.top/image/ACID.png)

如果失败了的话，那就要让执行到一半的事务有能力回到没执行事务前的状态，这就是**回滚**。

执行事务的代码就类似写成下面这样。

```sql
begin;
try:
	操作1;
  操作2;
  操作3;
  xxxxx
  ....
  commit;
except Exception:
	rollback;
```

如果执行`rollback`能回到事务执行前的状态的话，那说明 mysql 需要知道某些行，执行事务前的数据长什么样子。

那数据库是怎么做到的呢？

这就要提到**undo 日志**了，它记录了某一行数据，在执行事务前是怎么样的。

比如`id=1`那行数据，`name`字段从**"小白"**更新成了**"小白 debug"**，那就会新增一个 undo 日志，用于记录之前的数据。

![undo日志会记录之前的数据](https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E4%BC%9A%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE.drawio.png)

由于同时并发执行的事务可以有很多，于是可能会有很多 undo 日志，日志里加入事务的 id（`trx_id`）字段，用于标明这是哪个事务下产生的 undo 日志。

同时将它们用**链表的形式**组织起来，在 undo 日志里加入一个指针（`roll_pointer`），指向上一个 undo 日志，于是就形成了一条**版本链**。

![undo日志版本链](https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E7%89%88%E6%9C%AC%E9%93%BE.png)

有了这个版本链，当某个事务执行到一半发现失败时，就直接回滚，这时候就可以顺着这个版本链，回到执行事务前的状态。

<br>

## 当前读和快照读是什么

有了上面的 undo 日志版本链之后，我们可以看到**最新的数据在表头**，在这之后的都是一个个旧的数据版本。不管是最新的，还是旧的数据版本，我们都叫它数据**快照**。

**当前读**，读的就是版本链的表头，也就是**最新的数据**。

**快照读**，读的就是版本链里的其中一个快照，当然如果这个快照正好就是表头，那此时快照读和当前读的结果一样。

![当前读和快照读](https://cdn.xiaobaidebug.top/image/%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB.drawio.png)

我们平时执行的普通 select 语句，比如下面这种，就是**快照读**。

```
select * from user where phone_no=2；
```

而特殊的 select 语句，比如在`select`后面加上`lock in share mode`或`for update`，都属于**当前读**。

除此之外`insert，update，delete`操作都属于**写操作**，既然写，那必然是写最新的数据，所以都会引发当前读。

<br>

那么问题来了。

**当前读**，读的是版本链的**表头**，那么执行当前读的时候，有没有可能恰好有其他事务，生成更加新的快照，替代当前表头，成为新的表头呢，**那这时候岂不是读的不是最新数据了？**

答案是**不会**，不管是 select ... for update 这些（特殊的）读操作，还是 insert、update 这些写操作，**都会对这行数据加锁**。而生成 undo 日志快照，也是在**写操作**的情况下生成的，执行写操作前**也需要获得锁**。所以写操作需要阻塞等待**当前读**完成后，获得锁后才能更新版本链。

<br>

## read view

数据库里可以同时并发执行非常多的事务, **每个事务都会被分配一个事务 ID, 这个 ID 是递增的，越新的事务，ID 越大。**

而数据表里某行数据的 undo 日志版本链，每个 undo 日志上面也有一个事务 id (`trx_id`)，它是创建这个 undo 日志的**事务 id**。

并不是所有事务都会生成 undo 日志，也就是说某行数据的 undo 日志版本链上只有**部分**事务的 id。但是，**所有**事务都有可能会访问这行数据对应的版本链。而且版本链上虽然有很多 undo 日志快照，但也不是所有 undo 日志都能被读，毕竟有些 undo 日志，创建它们的事务还没提交呢，人家随时可能失败并回滚。

现在的问题就成了，**现在有一个事务，通过快照读的方式去读 undo 日志版本链，那它能读哪些快照？并且它应该读哪个快照？**

这里就要引入一个**read view**的概念。它就像是一个有上下边界的滑动窗口。

整个数据库里有那么多事务，这些事务分为已经提交（commit）的，和没提交的。没提交的，意味着这些事务还在进行中，也就是所谓的**活跃事务**。所有的活跃事务的 id，组成**m_ids**。而这其中最小的事务 id 就是 read view 的**下边界，叫 min_trx_id。**

产生 read view 的那一刻，**所有事务里最大的事务 id**，加个 1，就是这个 read view 的**上边界，叫 max_trx_id。**

概念太多，有点乱？没事的，继续往下看，后面会有例子的。

<br>

### 事务能读哪些快照

有了这些基础信息之后，我们先看下事务在 read view 下，他**能读哪些快照呢？**

记住一个大前提：**事务只能读到自己产生的 undo 日志数据（事务提不提交都行），或者是其他事务已经提交完成的数据**。

现在事务（假设就叫**事务 A**吧）有了 read view 之后，不管看哪个 undo 日志版本链，我们都可以把 read view 往版本链上一放。版本链就被分成了好几部分。

![readview](https://cdn.xiaobaidebug.top/image/readview2.drawio.png)

- **版本链快照的 trx_id < read view 的 min_trx_id**

  从上面的描述中，我们可以知道 read view 的 m_ids 来源于数据库所有**活跃事务的 id**，而最小的 min_trx_id 就是 read view 的下边界，因为事务 id 是根据时间递增的，所以**如果版本链快照的 trx_id 比 min_trx_id 还要小，那这些肯定都是非活跃（已经提交）的事务 id，这些快照都能被事务 A 读到。**

- **版本链快照的 trx_id >= read view 的 max_trx_id**

  max_trx_id 是在**事务 A 创建 read view 的那一刻产生的**，它比**那时候**所有数据库已知的事务 id 都还要大。所以如果 undo 日志版本链上的某个快照上含有比 max_trx_id 还要大的 trx_id，那说明这个快照已经超出事务 A 的"理解范围了"，它不该被读到。

- **read view 的 min_trx_id <= 版本链快照的 trx_id < read view 的 max_trx_id**

  - 如果版本链快照的 trx_id 正好就是事务 A 的 id，那正好是它自己生成的 undo 日志快照，那不管有没有提交，**都能读**。
  - 如果版本链快照的 trx_id 正好在活跃事务 m_ids 中, 那这些事务数据都还没提交，所以事务 A 不能读到它们
  - 除了上面两种情况外，剩下的都是**已经提交**的事务数据，可以放心读。

<br>

### 事务会读哪个快照

上面提到，事务在 read view 的可见范围里，有机会能读到 N 多快照。但那么**多快照版本，事务具体会读哪个快照呢？**

事务会**从表头开始**遍历这个 undo 日志版本链，它会拿每个 undo 日志里的 trx_id 去跟自己的 read view 的上下边界去做判断。**第一个出现的小于 max_trx_id 的快照**。

- 如果快照是自己产生，那**提不提交都行**，就决定是读它了。
- 如果快照是别人产生的，且**已经提交完成**了，那也行，决定读它了。

比如下图，`undo日志1`正好小于`max_trx_id`，且事务已经提交，那么就读它了。

![readview与undo版本链](https://cdn.xiaobaidebug.top/image/readview%E4%B8%8Eundo%E7%89%88%E6%9C%AC%E9%93%BE3.drawio.png)

<br>

### MVCC 是什么

像上面这种，维护一个多快照的**undo 日志版本链**，事务根据自己的`read view`去决定具体读那个 undo 日志**快照**，最理想的情况下是每个事务都读自己的一份快照，然后在这个快照上做自己的逻辑，只有在写数据的时候，才去操作最新的行数据，这样**读和写就被分开了**，比起单行数据没有快照的方式，它能更好的解决读写冲突，所以数据库并发性能也更好。其实这就是面试里常问的**MVCC**，全称**M**ulti-**V**ersion **C**oncurrency **C**ontrol，即**多版本并发控制。**

![MVCC](https://cdn.xiaobaidebug.top/image/MVCC.png)

<br>

## 四个隔离级别是怎么实现的

之前的写的[一篇文章](https://mp.weixin.qq.com/s/2UxF7GJrAW2nY8bB57ZogQ)最后留了个问题，四个隔离级别是怎么实现的。

知道了**undo 日志版本链**和**MVCC**之后，我们再回过头来看下这个问题。

![四层隔离级别](https://cdn.xiaobaidebug.top/image/四层隔离级别.png)

**读未提交**，每次读到的都是最新的数据，也不管数据行所在的事务是否提交。实现也很简单，只需要每次都读 undo 日志版本链的**链表头**（最新的快照）就行了。

与读未提交不同，**读提交和可重复读隔离级别都是基于 MVCC 的 read view 实现的**，反过来说, **MVCC 也只会出现在这两个隔离级别里**。

**读已提交**隔离级别，**每次执行普通 select，都会重新生成一个新的 read view**，然后拿着这个**最新的 read view**到某行数据的版本链上挨个遍历，找到第一个合适的数据。这样就能做到每次都读到其他事务最新**已提交**的数据。

**可重复读**隔离级别下的事务只会在**第一次**执行**普通 select**时生成`read view`，后续不管执行几次普通 select，都会**复用**这个 read view。这样就能保持每次读的时候都是在同一标准下进行读取，那读到的数据也会是一样的。

**串行化**目的就是让并发事务看起来就像单线程执行一样，那实现也很简单，**和读未提交隔离级别一样**，串行化隔离界别下事务只读 undo 日志链的链表头，也就是**最新版本的快照**，并且就算是普通 select，也会在版本链的**最新快照**上加入**读锁**。这样其他事务想写，也得等这个读锁释放掉才行。所有对这行数据进行操作的事务，都老老实实地阻塞等待加锁，一个接一个进行处理，从效果上看就跟单线程处理一样。

<br>

## 再看文章开头的例子

我们用上面提到的概念，重新回到文章开头的例子，梳理一遍。

![user表数据库原始状态](https://cdn.xiaobaidebug.top/image/user表数据库原始状态4.drawio.png)

我们**假设**数据库一开始的三条数据，都是由`trx_id=1`的事务`insert`生成的。

于是数据表一开始长下面这样。每行数据只有一个快照。注意快照里，`trx_id`填的是创建它们的事务 id，也就是刚刚提到的事务`1`。`roll_pointer`原本应该指向 insert 产生的 undo 日志，为了简化，这里写为`null`（insert undo 日志在事务提交后可以被清理掉）。

![user表数据库原始trx信息.drawio](https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8Btrx%E4%BF%A1%E6%81%AF.drawio.png)

下面这个图，还是文章开头的图，这里放出来是为了方便大家，不用划回去看了。

![都是select结果却不同](https://cdn.xiaobaidebug.top/image/都是select结果却不同1.drawio.png)

在**线程 1**启动事务，我们假设它的事务`trx_id=2`，**第一次执行普通 select，是快照读**，在**可重复读**隔离级别，会生成一个`read view`。当前这个数据库，活跃事务只有它一个，那`m_ids =[2]`。 m_ids 里最小的 id，也就是`min_trx_id=2`。max_trx_id 是当前最大数据库事务 id（只有它自己，所以也是 2），加个 1，也就是`max_trx_id=3`

![事务1的readview](https://cdn.xiaobaidebug.top/image/%E4%BA%8B%E5%8A%A11%E7%9A%84readview.drawio.png)

此时**线程 1**的事务，拿着这个 read view 去读数据库表。

因为这三条数据的 trx_id=1 都小于 min_trx_id=2，都属于可见范围，因此能读到这三条数据的所有快照，最后返回符合条件（age>=3）的数据，有 1 条。

<br>

这时候事务 2，假设它的事务`trx_id=3`，执行更新操作，生成新的 undo 日志快照。

![user表数据库加入undo日志](https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E5%85%A5undo%E6%97%A5%E5%BF%97.drawio.png)

此时线程 1**第二次执行普通 select**，还是**快照读**，由于是可重复读，会复用之前的 read view，再执行一次读操作，这里重点关注 id=2 的那行数据，从版本链表头开始遍历，**第一个快照 trx_id=3** `>=` **read view 的 max_trx_id=3**，因此不可读，遍历下一个快照**trx_id=1** `<` **min_trx_id=2**，可读。于是 id=2 的那行数据，还是拿到 age=2，而不是更新后的 age=3，因此快照读结果还是只有**1 条**数据符合 age>=3。

但是线程 1**第三次读，执行 select for update**，就成了**当前读**了，直接读 undo 日志版本链里**最新的那行快照**，于是能读到 id=2，age=3，所以最终结果返回**符合 age>=3 的数据有 2 条**。

总的来说就是，由于快照读和当前读，读数据的规则不同，我们看到了不一样的结果。

<br>

看到这里，大家应该理解了，所谓的可重复读**每次读**都要读到一样的数据，这里头的**"读"**，指的是**快照读**。

如果下次面试官问你，**可重复读隔离级别下每次读到的数据都是一样的吗？**

你该知道怎么回答了吧？

<br>

## 总结

- 事务通过 undo 日志实现回滚的功能，从而实现事务的原子性（Atomicity）。
- 多个事务生成的 undo 日志构成一条版本链。**快照读**时事务根据 read view 来决定具体读哪个快照。**当前读**时事务直接读最新的快照版本。
- mysql 的 innodb 引擎通过 MVCC 提升了读写并发。

<br>

## 最后

最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。

我有个不成熟的请求。

![](https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg)

<br>

**离开广东好长时间了，好久没人叫我靓仔了。**

大家可以在**评论区**里，叫我一靓仔吗？

我这么善良质朴的愿望，能被满足吗？

如果实在叫不出口的话，能帮我点下右下角的**点赞和在看**吗？

<br>

##### 别说了，一起在知识的海洋里呛水吧

**点击**下方名片，关注公众号:【小白 debug】
![](https://cdn.xiaobaidebug.top/1696069689495.png)

<br>

不满足于在留言区说骚话？

加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就**超！开！心！**

<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center />

![](https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif)

## 文章推荐：

- [既然有 HTTP 协议，为什么还要有 RPC](https://www.xiaobaidebug.top/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/)
- [TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解](https://www.xiaobaidebug.top/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/)
- [动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？](https://www.xiaobaidebug.top/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/)
