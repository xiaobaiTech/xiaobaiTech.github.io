<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>动图图解 | UDP就一定比TCP快吗？</title>
      <link href="/2022/10/17/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97/"/>
      <url>/2022/10/17/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>话说，<strong>UDP 比 TCP 快吗？</strong></p><p>相信就算不是八股文老手，也会下意识的脱口而出：”<strong>是</strong>“。</p><p>这要追问为什么，估计大家也能说出个大概。</p><p><img src="https://cdn.xiaobaidebug.top/1663680963848.png"></p><p>但这也让人好奇，<strong>用 UDP 就一定比用 TCP 快吗？什么情况下用 UDP 会比用 TCP 慢？</strong></p><p>我们今天就来聊下这个话题。</p><br><h3 id="使用-socket-进行数据传输"><a href="#使用-socket-进行数据传输" class="headerlink" title="使用 socket 进行数据传输"></a>使用 socket 进行数据传输</h3><p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p><p>socket 就像是一个<strong>电话或者邮箱</strong>（邮政的信箱）。当你想要发送消息的时候，拨通电话或者将信息塞到邮箱里，socket 内核会自动完成将数据传给对方的这个过程。</p><p>基于 socket 我们可以选择使用 TCP 或 UDP 协议进行通信。</p><p>对于 TCP 这样的可靠性协议，每次消息发出后都能明确知道对方收没收到，就<strong>像打电话一样</strong>，只要”喂喂”两下就能知道对方有没有在听。</p><p>而 UDP 就像是<strong>给邮政的信箱寄信一样</strong>，你寄出去的信，根本就不知道对方有没有正常收到，丢了也是有可能的。</p><blockquote><p>这让我想起了大概 17 年前，当时还没有现在这么发达的网购，想买一本《掌机迷》杂志，还得往信封里塞钱，然后一等就是一个月，好几次都怀疑信是不是丢了。我至今印象深刻，因为那是我和我哥攒了好久的钱。。。</p></blockquote><br><p>回到 socket 编程的话题上。</p><p>创建 socket 的方式就像下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET, 具体协议,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>注意上面的”<strong>具体协议</strong>“，如果传入的是<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p><p>如果传入的是<code>SOCK_DGRAM</code>，是指使用<strong>数据报</strong>传输数据，也就是<strong>UDP 协议</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1663557075676.png" alt="UDP是什么"></p><p>返回的<code>fd</code>是指 socket 句柄，可以理解为 socket 的<strong>身份证号</strong>。通过这个<code>fd</code>你可以在内核中找到<strong>唯一</strong>的 socket 结构。</p><p>如果想要通过这个 socket 发消息，只需要操作这个 fd 就行了，比如执行 <code>send(fd, msg, ...)</code>，内核就会通过这个 fd 句柄找到 socket 然后进行发数据的操作。</p><p><strong>如果一切顺利</strong>，此时对方执行接收消息的操作，也就是 <code>recv(fd, msg, ...)</code>，就能拿到你发的消息。</p><p><img src="https://cdn.xiaobaidebug.top/1663602070263.gif" alt="udp发送接收过程"></p><h3 id="对于异常情况的处理"><a href="#对于异常情况的处理" class="headerlink" title="对于异常情况的处理"></a>对于异常情况的处理</h3><p><strong>但如果不顺利呢？</strong></p><p>比如消息发到一半，丢包了呢?</p><blockquote><p>丢包的原因有很多，之前写过的<a href="https://juejin.cn/post/7126710506936598558">《用了 TCP 协议，就一定不会丢包吗？》</a>有详细聊到过，这里就不再展开。</p></blockquote><p>那 UDP 和 TCP 的态度就不太一样了。</p><br><p>UDP 表示，”哦，是吗？然后呢？关我 x 事”</p><p>TCP 态度就截然相反了，”啊？那可不行，是不是我发太快了呢？是不是链路太堵被别人影响到了呢？不过你放心，我肯定给你补发”</p><p>TCP 老实人石锤了。我们来看下这个老实人在背后都默默做了哪些事情。</p><h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>对于 TCP，它会给发出的消息打上一个<strong>编号（sequence）</strong>，接收方收到后回一个**确认(ack)**。发送方可以通过<code>ack</code>的数值知道接收方收到了哪些<code>sequence</code>的包。</p><p>如果长时间等不到对方的确认，TCP 就会重新发一次消息，这就是所谓的<strong>重传机制</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1663597929404.png" alt="TCP重传"></p><br><h4 id="流量控制机制"><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h4><p>但重传这件事本身对性能影响是比较严重的，所以是<strong>下下策</strong>。</p><p>于是 TCP 就需要思考有没有办法可以尽量<strong>避免重传</strong>。</p><p>因为数据发送方和接收方处理数据能力可能不同，因此如果可以根据双方的能力去调整发送的数据量就好了，于是就有了<strong>发送和接收窗口</strong>，基本上从名字就能看出它的作用，比如<strong>接收窗口的大小</strong>就是指，接收方当前<strong>能接收的数据量大小</strong>，<strong>发送窗口的大小</strong>就指发送方当前能发的数据量大小。TCP 根据窗口的大小去控制自己发送的数据量，这样就能大大减少丢包的概率。</p><p><img src="https://cdn.xiaobaidebug.top/1663597968469.png" alt="流量控制机制"></p><br><h4 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h4><p>接收方的接收到数据之后，会不断处理，<strong>处理能力也不是一成不变的</strong>，有时候处理的快些，那就可以收多点数据，处理的慢点那就希望对方能少发点数据。毕竟发多了就有可能处理不过来导致丢包，丢包会导致重传，这可是下下策。因此我们需要动态的去调节这个接收窗口的大小，于是就有了<strong>滑动窗口机制</strong>。</p><p>看到这里大家可能就有点迷了，<strong>流量控制和滑动窗口机制貌似很像，它们之间是啥关系？</strong>我总结一下。其实现在 TCP 是<strong>通过滑动窗口机制来实现流量控制机制的</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1663597995829.png" alt="滑动窗口机制"></p><br><h4 id="拥塞控制机制"><a href="#拥塞控制机制" class="headerlink" title="拥塞控制机制"></a>拥塞控制机制</h4><p>但这还不够，有时候发生丢包，<strong>并不是因为发送方和接收方的处理能力问题导致的</strong>。而是跟<strong>网络环境</strong>有关，大家可以将网络想象为一条公路。马路上可能堵满了别人家的车，只留下一辆车的空间。那就算你家有 5 辆车，目的地也正好有 5 个停车位，你也没办法同时全部一起上路。于是 TCP 希望能感知到外部的网络环境，根据网络环境及时调整自己的发包数量，比如马路只够两辆车跑，那我就只发两辆车。但外部环境这么复杂，TCP 是怎么感知到的呢？</p><p>TCP 会先慢慢试探的发数据，不断加码数据量，越发越多，先发一个，再发 2 个，4 个…。直到出现丢包，这样 TCP 就知道现在当前网络大概吃得消几个包了，这既是所谓的<strong>拥塞控制机制</strong>。</p><p>不少人会疑惑流量控制和拥塞控制的关系。我这里小小的总结下。<strong>流量控制</strong>针对的是<strong>单个连接</strong>数据处理能力的控制，<strong>拥塞控制</strong>针对的是<strong>整个网络环境</strong>数据处理能力的控制。</p><p><img src="https://cdn.xiaobaidebug.top/1663598420295.png" alt="1663598420295"></p><br><h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h4><p>但上面提到的都是怎么<strong>降低</strong>重传的概率，似乎重传这个事情就是无法避免的，<strong>那如果确实发生了，有没有办法降低它带来的影响呢？</strong></p><p>有。当我们需要发送一个超大的数据包时，如果这个数据包丢了，那就得重传同样大的数据包。但如果我能将其分成一小段一小段，那就算真丢了，那我也就只需要重传那一小段就好了，大大减小了重传的压力，这就是 TCP 的<strong>分段机制</strong>。</p><p>而这个所谓的一小段的长度，在传输层叫<strong>MSS</strong>（<strong>Maximum Segment Size</strong>），数据包长度大于 MSS 则会分成 N 个小于等于 MSS 的包。</p><p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%88%86%E5%8C%85.gif" alt="MSS分包"></p><p>而在网络层，如果数据包还大于<strong>MTU（Maximum Transmit Unit）</strong>，那还会继续分包。</p><p><img src="https://cdn.xiaobaidebug.top/image/mtu%E5%88%86%E5%8C%85.gif" alt="MTU分包"></p><p>一般情况下，<code>MSS=MTU-40Byte</code>，所以<strong>TCP 分段后，到了 IP 层大概率就不会再分片了</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="MSS和MTU的区别"></p><br><h4 id="乱序重排机制"><a href="#乱序重排机制" class="headerlink" title="乱序重排机制"></a>乱序重排机制</h4><p>既然数据包会被分段，链路又这么复杂还会丢包，那数据包乱序也就显得不奇怪了。比如发数据包 1,2,3。1 号数据包走了其他网络路径，2 和 3 数据包先到，1 数据包后到，于是数据包顺序就成了 2,3,1。这一点 TCP 也考虑到了，依靠数据包的<code>sequence</code>，接收方就能知道数据包的先后顺序。</p><p>后发的数据包先到是吧，那就先放到专门的<strong>乱序队列</strong>中，等数据都到齐后，重新整理好乱序队列的数据包顺序后再给到用户，这就是<strong>乱序重排机制</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5.drawio.png" alt="乱序队列等待数据包的到来"></p><br><h4 id="连接机制"><a href="#连接机制" class="headerlink" title="连接机制"></a>连接机制</h4><p>前面提到，UDP 是无连接的，而 TCP 是面向连接的。</p><p>这里提到的<strong>连接</strong>到底是啥？</p><p>TCP 通过上面提到的各种机制实现了数据的可靠性。这些机制背后是通过一个个数据结构来实现的逻辑。而为了实现这套逻辑，操作系统内核需要在两端代码里维护一套复杂的状态机（三次握手，四次挥手，RST，closing 等异常处理机制），<strong>这套状态机其实就是所谓的”连接”<strong>。这其实就是 TCP 的</strong>连接机制</strong>，而 UDP 用不上这套状态机，因此它是”无连接”的。</p><br><p>网络环境链路很长，还复杂，数据丢包是很常见的。</p><p>我们平常用 TCP 做各种数据传输，完全对这些事情无感知。</p><p><strong>哪有什么岁月静好，是 TCP 替你负重前行。</strong></p><p>这就是 TCP 三大特性”面向连接、可靠的、基于字节流”中”<strong>可靠</strong>“的含义。</p><p>不信你改用 UDP 试试，丢包那就是真丢了，丢到你怀疑人生。</p><br><h3 id="用-UDP-就一定比用-TCP-快吗？"><a href="#用-UDP-就一定比用-TCP-快吗？" class="headerlink" title="用 UDP 就一定比用 TCP 快吗？"></a>用 UDP 就一定比用 TCP 快吗？</h3><p>这时候 UDP 就不服了：”<strong>正因为没有这些复杂的 TCP 可靠性机制，所以我很快啊</strong>“</p><p>嗯，这也是大部分人认为 UDP 比 TCP 快的原因。</p><p><strong>实际上大部分情况下也确实是这样的。这话没毛病。</strong></p><br><p>那问题就来了。</p><p><strong>有没有用了 UDP 但却比 TCP 慢的情况呢？</strong></p><p>其实也有。</p><p>在回答这个问题前，我需要先说下<strong>UDP 的用途</strong>。</p><p>实际上，<strong>大部分</strong>人也不会尝试<strong>直接拿裸 udp</strong>放到生产环境中去做项目。</p><p>那 UDP 的价值在哪？</p><p>在我看来，UDP 的存在，本质是内核提供的一个<strong>最小网络传输功能</strong>。</p><p>很多时候，大家虽然号称自己用了 UDP，但实际上都很<strong>忌惮</strong>它的丢包问题，所以大部分情况下都会在 UDP 的基础上做各种不同程度的<strong>应用层</strong>可靠性保证。比如王者农药用的<code>KCP</code>，以及最近很火的<code>QUIC（HTTP3.0）</code>，其实都<strong>在 UDP 的基础上做了重传逻辑</strong>，实现了一套<strong>类似</strong>TCP 那样的可靠性机制。</p><p>教科书上最爱提 UDP 适合用于<strong>音视频传输</strong>，因为这些场景允许丢包。但其实也不是什么包都能丢的，比如重要的关键帧啥的，该重传还得重传。除此之外，还有一些<strong>乱序处理机制</strong>。举个例子吧。</p><p>打音视频电话的时候，你可能遇到过丢失中间某部分信息的情况，但应该从来没遇到过乱序的情况吧。</p><p>比如对方打网络电话给你，说了：”<strong>我好想给小白来个点赞在看！</strong>“</p><p>这时候网络信号不好，你可能会听到”我….点赞在看”。</p><p>但却从来没遇到过”在看小白好想赞”这样的<strong>乱序</strong>场景吧？</p><p>所以说，<strong>虽然选择了使用 UDP，但一般还是会在应用层上做一些重传机制的</strong>。</p><p>于是问题就来了，<strong>如果现在我需要传一个特别大的数据包</strong>。</p><p>在<code>TCP</code>里，它内部会根据<code>MSS</code>的大小<strong>分段</strong>，这时候进入到 IP 层之后，每个包大小都不会超过<code>MTU</code>，因此 IP 层一般不会再进行分片。这时候发生丢包了，只需要<strong>重传每个 MSS 分段</strong>就够了。</p><p><img src="https://cdn.xiaobaidebug.top/1663602192374.gif" alt="TCP分段"></p><p>但对于<code>UDP</code>，其本身并不会分段，如果数据过大，到了 IP 层，就会进行分片。此时发生丢包的话，再次重传，就会<strong>重传整个大数据包</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1663602173391.gif" alt="UDP不分段"></p><p>对于上面这种情况，<strong>使用 UDP 就比 TCP 要慢</strong>。</p><p>当然，解决起来也不复杂。这里的关键点在于是否实现了数据分段机制，<strong>使用 UDP 的应用层如果也实现了分段机制的话，那就不会出现上述的问题了</strong>。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>TCP 为了实现可靠性，引入了重传机制、流量控制、滑动窗口、拥塞控制、分段以及乱序重排机制。而 UDP 则没有实现，因此一般来说 TCP 比 UDP 慢。</li><li>TCP 是面向连接的协议，而 UDP 是无连接的协议。这里的”<strong>连接</strong>“其实是，操作系统内核在两端代码里维护的一套复杂状态机。</li><li>大部分项目，会在基于 UDP 的基础上，模仿 TCP，实现不同程度的可靠性机制。比如王者农药用的 KCP 其实就在基于 UDP 在应用层里实现了一套<strong>重传</strong>机制。</li><li>对于 UDP+重传的场景，如果要传<strong>超大数据包</strong>，并且没有实现<strong>分段机制</strong>的话，那数据就会在 IP 层分片，一旦丢包，那就需要重传整个超大数据包。而 TCP 则不需要考虑这个，内部会自动分段，丢包重传分段就行了。这种场景下，其实 TCP 更快。</li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" /><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我<strong>点下关注</strong>和右下角的<strong>点赞+收藏</strong>吗？</p><p>如果评论区没人叫我靓仔，文章也没人点赞，我感觉我下篇文章要开始收费了，价钱我都想好了，8 块 8，毕竟男人都拒绝不了这种价格以 8 结尾的项目。</p><p>你说是吧，易峰。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么有HTTP协议，还要有websocket协议</title>
      <link href="/2022/09/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/"/>
      <url>/2022/09/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>平时我们打开网页，比如购物网站某宝。都是点一下<strong>列表商品</strong>，跳转一下网页就到了<strong>商品详情</strong>。</p><p>从 HTTP 协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次 HTTP 请求，网站返回一次 HTTP 响应</strong>。</p><p>这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</p><p>但有没有发现，这种情况下，服务器从来就不会<strong>主动</strong>给客户端发一次消息。</p><p>就像你喜欢的女生从来不会主动找你一样。</p><br><p>但如果现在，你在刷网页的时候<strong>右下角</strong>突然弹出一个<strong>小广告</strong>，提示你【<strong>一个人在家偷偷才能玩哦</strong>】。</p><p><strong>求知，好学，勤奋</strong>，这些刻在你 DNA 里的东西都动起来了。</p><p>你点开后发现。</p><p>长相平平无奇的古某提示你”道士 9 条狗，全服横着走”。</p><p>影帝某辉老师跟你说”系兄弟就来砍我”。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220827161615614.png"></p><p>来都来了，你就选了个角色进到了游戏界面里。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2%E9%A1%B5%E9%9D%A2.jpeg" alt="创建角色页面"></p><p>这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。</p><p><strong>你全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。</p><p>这….太暖心了。</p><p>感动之余，问题就来了，</p><p>像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？</p><p>在真正回答这个问题之前，我们先来聊下一些相关的知识背景。</p><br><h3 id="使用-HTTP-不断轮询"><a href="#使用-HTTP-不断轮询" class="headerlink" title="使用 HTTP 不断轮询"></a>使用 HTTP 不断轮询</h3><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p><p>最常见的解决方案是，<strong>网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。</strong></p><p>这其实时一种<strong>伪</strong>服务器推的形式。</p><p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p><p>用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。</p><p>比如某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概 1 到 2 秒的间隔去不断发出请求，这样可以保证用户在扫码后能在 1 到 2s 内得到及时的反馈，不至于<strong>等太久</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%BD%BF%E7%94%A8HTTP%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A23.drawio.png" alt="使用HTTP定时轮询"></p><p>但这样，会有两个比较明显的问题</p><ul><li>当你打开 F12 页面时，你会发现满屏的 HTTP 请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li><li>最坏情况下，用户在扫码后，需要等个 1~2s，正好才触发下一次 http 请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li></ul><p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个 1~2s</strong>，页面才跳转。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220824090204629.png" alt="不断轮询查看是否有扫码"></p><p>那么问题又来了，<strong>有没有更好的解决方案？</strong></p><p>有，而且实现起来成本还非常低。</p><br><h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>我们知道，HTTP 请求发出后，一般会给服务器留一定的时间做响应，比如 3s，规定时间内没返回，就认为是超时。</p><p>如果我们的 HTTP 请求<strong>将超时设置的很大</strong>，比如 30s，<strong>在这 30s 内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p><p>这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30s 的区间内做扫码操作，所以响应也是及时的。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%95%BF%E8%BD%AE%E8%AF%A2.drawio.png" alt="长轮询"></p><p>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220824085627057.png" alt="长轮询的方式来替代"></p><p>真一举两得。</p><p>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长轮询机制</strong>。我们常用的消息队列 RocketMQ 中，消费者去取数据时，也用到了这种方式。</p><p><img src="https://cdn.xiaobaidebug.top/RocketMQ%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E8%BF%87%E9%95%BF%E8%BD%AE%E8%AF%A2%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.drawio.png" alt="RocketMQ的消费者通过长轮询获取数据"></p><p>像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong>技术，大家听过就好。</p><br><p>上面提到的两种解决方案，本质上，其实还是客户端主动去取数据。</p><p>对于像扫码登录这样的<strong>简单场景</strong>还能用用。</p><p>但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。</p><p>这就得说下<strong>websocket</strong>了。</p><br><h3 id="websocket-是什么"><a href="#websocket-是什么" class="headerlink" title="websocket 是什么"></a>websocket 是什么</h3><p>我们知道 TCP 连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p><p>而现在使用最广泛的<code>HTTP1.1</code>，也是基于 TCP 协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p><p>也就是说，好好的全双工 TCP，被 HTTP 用成了半双工。</p><p>为什么？</p><p>这是由于 HTTP 协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p><p>所以为了更好的支持这样的场景，我们需要另外一个<strong>基于 TCP 的新协议</strong>。</p><p>于是新的应用层协议<strong>websocket</strong>就被设计出来了。</p><p>大家别被这个名字给带偏了。虽然名字带了个 socket，但其实 socket 和 websocket 之间，就跟雷峰和雷峰塔一样，二者接近<strong>毫无关系</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/websocket%E5%9C%A8%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.drawio.png" alt="websocket在四层网络协议中的位置"></p><br><h3 id="怎么建立-websocket-连接"><a href="#怎么建立-websocket-连接" class="headerlink" title="怎么建立 websocket 连接"></a>怎么建立 websocket 连接</h3><p>我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是<strong>HTTP 协议</strong>，一会打开网页游戏，这时候就得切换成我们新介绍的<strong>websocket 协议</strong>。</p><p>为了兼容这些使用场景。浏览器在<strong>TCP 三次握手</strong>建立连接之后，都<strong>统一使用 HTTP 协议</strong>先进行一次通信。</p><ul><li>如果此时是<strong>普通的 HTTP 请求</strong>，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。</li><li>如果这时候是<strong>想建立 websocket 连接</strong>，就会在 HTTP 请求里带上一些<strong>特殊的 header 头</strong>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure><p>这些 header 头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成 websocket 协议（Upgrade: websocket）</strong>。</p><p>同时带上一段<strong>随机生成的 base64 码（Sec-WebSocket-Key）</strong>，发给服务器。</p><p>如果服务器正好支持升级成 websocket 协议。就会走 websocket 握手流程，同时根据客户端生成的 base64 码，用某个<strong>公开的</strong>算法变成另一段字符串，放在 HTTP 响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols\r\n</span><br><span class="line">Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line">Upgrade: websocket\r\n</span><br><span class="line">Connection: Upgrade\r\n</span><br></pre></td></tr></table></figure><blockquote><p>http 状态码=200（正常响应）的情况，大家见得多了。101 确实不常见，它其实是指<strong>协议切换</strong>。</p></blockquote><p><img src="https://cdn.xiaobaidebug.top/base64%E8%BD%AC%E4%B8%BA%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.drawio.png" alt="base64转为新的字符串"></p><p>之后，浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%AF%B9%E6%AF%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.drawio.png" alt="对比客户端和服务端生成的字符串"></p><p>就这样经历了一来一回两次 HTTP 握手，websocket 就建立完成了，后续双方就可以使用 webscoket 的数据格式进行通信了。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%BB%BA%E7%AB%8Bwebsocket%E8%BF%9E%E6%8E%A5.drawio.png" alt="建立websocket连接.drawio"></p><br><h3 id="websocket-抓包"><a href="#websocket-抓包" class="headerlink" title="websocket 抓包"></a>websocket 抓包</h3><p>我们可以用 wireshark 抓个包，实际看下数据包的情况。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220825222212533.png" alt="客户端请求升级为websocket"></p><p>上面这张图，注意画了红框的第<code>2445</code>行报文，是 websocket 的<strong>第一次握手</strong>，意思是发起了一次带有<code>特殊Header</code>的 HTTP 请求。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BEddddd.drawio.png" alt="服务器同意升级为websocket协议"></p><p>上面这个图里画了红框的<code>4714</code>行报文，就是服务器在得到第一次握手后，响应的<strong>第二次握手</strong>，可以看到这也是个 HTTP 类型的报文，返回的状态码是 101。同时可以看到返回的报文 header 中也带有各种<code>websocket</code>相关的信息，比如<code>Sec-WebSocket-Accept</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220825222810052.png" alt="两次HTTP请求之后正式使用websocket通信"></p><p>上面这张图就是全貌了，从截图上的注释可以看出，websocket 和 HTTP 一样都是基于 TCP 的协议。经历了三次 TCP 握手之后，利用 HTTP 协议升级为 websocket 协议。</p><p>你在网上可能会看到一种说法：”websocket 是基于 HTTP 的新协议”，<strong>其实这并不对</strong>，因为 websocket 只有在建立连接时才用到了 HTTP，<strong>升级完成之后就跟 HTTP 没有任何关系了</strong>。</p><p>这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟 HTTP 一样，都只是个<strong>工具人</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/1663378093150.png"></p><p>这就有点”<strong>借壳生蛋</strong>“的那意思。</p><p><img src="https://cdn.xiaobaidebug.top/HTTP%E5%92%8Cwebsocket%E7%9A%84%E5%85%B3%E7%B3%BB.drawio.png" alt="HTTP和websocket的关系"></p><br><h3 id="websocket-的消息格式"><a href="#websocket-的消息格式" class="headerlink" title="websocket 的消息格式"></a>websocket 的消息格式</h3><p>上面提到在完成协议升级之后，两端就会用 webscoket 的数据格式进行通信。</p><p>数据包在 websocket 中被叫做<strong>帧</strong>。</p><p>我们来看下它的数据格式长什么样子。</p><p><img src="https://cdn.xiaobaidebug.top/websocket%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F2.drawio.png" alt="websocket报文格式"></p><p>这里面字段很多，但我们只需要关注下面这几个。</p><p><strong>opcode 字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p><ul><li>等于 1 时是指 text 类型（<code>string</code>）的数据包</li><li>等于 2 是二进制数据类型（<code>[]byte</code>）的数据包</li><li>等于 8 是关闭连接的信号</li></ul><p><strong>payload 字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220826101644204.png"></p><p>另外，可以看到，我们存放<strong>payload 长度的字段有好几个</strong>，我们既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit或7+64bit。</code></p><p>那么问题就来了。</p><p>我们知道，在数据层面，大家都是 01 二进制流。我怎么知道<strong>什么情况下应该读 7bit，什么情况下应该读 7+16bit 呢？</strong></p><p>websocket 会用最开始的 7bit 做标志位。不管接下来的数据有多大，都<strong>先读最先的 7 个 bit</strong>，根据它的取值决定还要不要再读个 16bit 或 64bit。</p><ul><li>如果<code>最开始的7bit</code>的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的<code>7个bit</code>就完事了。</li></ul><p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%9C%A80%E5%88%B0125%E4%B9%8B%E9%97%B42.png" alt="payload长度在0到125之间"></p><ul><li>如果是<code>126（0x7E）</code>。那它表示 payload 的长度范围在 <code>126~65535</code> 之间，接下来还需要<strong>再读 16bit</strong>。这 16bit 会包含 payload 的真实长度。</li></ul><p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%9C%A8126%E5%88%B065535%E4%B9%8B%E9%97%B42.png" alt="payload长度在126到65535之间"></p><ul><li>如果是<code>127（0x7F）</code>。那它表示 payload 的长度范围<code>&gt;=65536</code>，接下来还需要<strong>再读 64bit</strong>。这 64bit 会包含 payload 的长度。这能放 2 的 64 次方 byte 的数据，换算一下好多个 TB，肯定够用了。</li></ul><p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E65536%E7%9A%84%E6%83%85%E5%86%B5.png" alt="payload长度大于等于65536的情况"></p><p><strong>payload data 字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的 payload 长度后，就可以根据这个值去截取对应的数据。</p><p>大家有没有发现一个小细节，websocket 的数据格式也是 <strong>数据头（内含 payload 长度） + payload data</strong> 的形式。</p><p><img src="https://cdn.xiaobaidebug.top/0bec52deb6276987.jpeg"></p><p>之前写的<a href="https://juejin.cn/post/7121882245605883934">《既然有 HTTP 协议，为什么还要有 RPC》</a>提到过，TCP 协议本身就是全双工，但直接使用<strong>纯裸 TCP</strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。</p><p>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p><p>HTTP 协议和大部分 RPC 协议，以及我们今天介绍的 websocket 协议，都是这样设计的。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%976.drawio.png" alt="消息边界长度标志"></p><br><h3 id="websocket-的使用场景"><a href="#websocket-的使用场景" class="headerlink" title="websocket 的使用场景"></a>websocket 的使用场景</h3><p>websocket 完美继承了 TCP 协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景。比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p><p>回到文章开头的问题，在使用 websocket 协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p><p><img src="https://cdn.xiaobaidebug.top/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.drawio.png" alt="websocket的使用场景"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>TCP 协议本身是<strong>全双工</strong>的，但我们最常用的 HTTP1.1，虽然是基于 TCP 的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 websocket 协议。</li><li>在 HTTP1.1 里。只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li><li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 websocket 协议。</li><li>websocket 和 socket 几乎没有任何关系，只是叫法相似。</li><li>正因为各个浏览器都支持 HTTP 协议，所以 websocket 会先利用 HTTP 协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 websocket 的数据格式进行收发数据。</li></ul><hr><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" /><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我<strong>点下关注</strong>和右下角的<strong>点赞+在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>能ping通，TCP就一定能连通吗？</title>
      <link href="/2022/08/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%83%BDping%E9%80%9A%EF%BC%8C%E5%B0%B1%E4%BB%A3%E8%A1%A8TCP%E4%B8%80%E5%AE%9A%E8%83%BD%E8%BF%9E%E9%80%9A%E5%90%97%EF%BC%9F/"/>
      <url>/2022/08/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%83%BDping%E9%80%9A%EF%BC%8C%E5%B0%B1%E4%BB%A3%E8%A1%A8TCP%E4%B8%80%E5%AE%9A%E8%83%BD%E8%BF%9E%E9%80%9A%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>平时，我们想要知道，自己的机器到目的机器之间，<strong>网络通不通</strong>，一般会执行<strong>ping 命令</strong>。</p><p>一般对于状况良好的网络来说，你能看到它对应的<code>loss</code>丢包率为<code>0%</code>，也就是所谓的<strong>能 ping 通</strong>。如果看到丢包率<code>100%</code>，也就是<strong>ping 不通</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/ping%E6%AD%A3%E5%B8%B8.png" alt="ping正常"></p><p><img src="https://cdn.xiaobaidebug.top/ping%E4%B8%8D%E9%80%9A.png" alt="ping不通"></p><br><p>那么问题来了，假设我能<strong>ping</strong>通某台机器，那这时候如果我改用<strong>TCP 协议</strong>去发数据到目的机器，<strong>也一定能通吗？</strong></p><p>或者换个问法，<strong>ping 和 tcp 协议走的网络路径是一样的吗？</strong></p><br><p>这时候第一反应就是<strong>不一定</strong>，因为 ping 完之后中间链路里的<strong>某个路由器可能会挂了（断电了）</strong>，再用 TCP 去连就会走别的路径。</p><p>也没错。但假设，<strong>中间链路没发生任何变化呢？</strong></p><p>我先直接说答案。</p><p><strong>不一定，走的网络路径还是有可能是不同的。</strong></p><p>今天就来聊聊为什么。</p><br><p>我之前写过一篇<a href="https://mp.weixin.qq.com/s/Gml_xxvGjq224L7zCoXm5w">《断网了，还能 ping 通 127.0.0.1 吗？》</a>,里面提到过<strong>ping 数据包和 tcp 数据包的区别</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/ping%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%B3%E7%B3%BB67.drawio.png" alt="ping和TCP发消息的区别"></p><br><p>我们知道网络是分层的，每一层都有对应协议。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90.png" alt="五层网络协议对应的消息体变化分析"></p><p>而这网络层就像搭积木一样，上层协议都是基于下层协议搭出来的。</p><p><strong>不管是 ping（用了 ICMP 协议）还是 tcp 本质上都是基于网络层 IP 协议的数据包，而到了物理层，都是二进制 01 串，都走网卡发出去了。</strong></p><p>如果网络环境没发生变化，目的地又一样，那按道理说他们走的网络路径应该是一样的，什么情况下会不同呢？</p><p>我们就从<strong>路由</strong>这个话题聊起吧。</p><br><h3 id="网络路径"><a href="#网络路径" class="headerlink" title="网络路径"></a>网络路径</h3><p>在我们的想象中，当我们想在两台机器之间传输数据。本机和目的机器之间会建立一条连接，像<strong>一条管道</strong>一样，数据从这头到那头。这条管道其实是我们为了方便理解而抽象出来的概念。</p><p>实际上，我们将数据包从本地网卡发出之后，会经过各种<strong>路由器（或者交换机）</strong>，才能到达目的机器。</p><p>这些路由器数量众多，相互之间可以互连，连起来之后就像是一张大网，所以叫**”网络”**可以说是非常的形象。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9E%84%E6%88%90%E7%9A%84%E7%BD%91%E7%BB%9C.drawio.png" alt="路由器构成的网络"></p><blockquote><p>考虑到交换机有的功能，路由器基本上都支持，所以我们这边只讨论路由器。</p></blockquote><p>那么现在问题来了，<strong>路由器收到数据后，怎么知道应该走哪条路径，传给哪个路由器？</strong></p><br><h3 id="路径由什么决定？"><a href="#路径由什么决定？" class="headerlink" title="路径由什么决定？"></a>路径由什么决定？</h3><p>在上面的那么大一张网络中，随便一个路由器都有可能走任何一个路径，将数据发到另外一个路由器上，</p><p>但路由和路由之间距离，带宽啥的可能都不同。</p><p>于是就很需要知道，<strong>两点之间走哪条路才是最优路径</strong>。</p><p>于是问题就变成了这样一个<strong>图状结构</strong>。每条边都带有<strong>成本或权重</strong>，算这上面<strong>任意两点的最短距离</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84Dijkstra.drawio.png" alt="路由器和Dijkstra"></p><p>这时候想必大家回忆压不住要上来了。</p><p>这题我熟，这就是大学时候刷的<strong>Dijkstra 算法</strong>。菊花厂的 OJ 笔试题集里也经常出现，现在终于明白为什么他们家的笔试题里图类题目比别的大厂貌似要多一些了吧，因为菊花厂就是搞通信的，做路由器的老玩家了。</p><br><h4 id="路由表的生成"><a href="#路由表的生成" class="headerlink" title="路由表的生成"></a>路由表的生成</h4><p>基于<strong>Dijkstra 算法</strong>，封装出了一个新的协议，<strong>OSPF 协议</strong>（<strong>O</strong>pen <strong>S</strong>hortest <strong>P</strong>ath <strong>F</strong>irst, 开放最短路径优先）。</p><p>有了 OSPF，路由器就得到了网络图里自己到其他点之间的<strong>最短距离</strong>，于是就知道了<strong>数据包要到某个点，该走哪条最优路径</strong>。</p><p>将这些信息汇成一张表，也就是我们常说的<strong>路由表</strong>。</p><p>路由表里记录了到什么 IP 需要走什么端口，以及走这条路径的成本（<code>metric</code>）。</p><p>可以通过 <code>route</code> 命令查看到。</p><p><img src="https://cdn.xiaobaidebug.top/route2.png" alt="route表"></p><br><h4 id="路由表决定数据包路径"><a href="#路由表决定数据包路径" class="headerlink" title="路由表决定数据包路径"></a>路由表决定数据包路径</h4><p>数据包在发送的过程中，会在<strong>网络层</strong>加入<strong>目标地址 IP</strong>。</p><p>路由器会根据这个<strong>IP</strong>跟<strong>路由表</strong>去做匹配。</p><p>然后路由表，会告诉路由器，什么样的消息该转发到什么端口。</p><p>举个例子。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E4%BA%92%E8%81%94%E6%97%B6%E6%96%B0%E7%89%88.drawio.png" alt="通过路由表转发数据"></p><p>假设 A 要发消息到 D。也就是<code>192.168.0.105/24</code>要发消息到<code>192.168.1.11/24</code>。</p><p>那么 A 会把消息经发到路由器。</p><p>路由器已知目的地 IP<code>192.168.1.11/24</code> ，去跟<strong>路由表</strong>做匹配，发现<code>192.168.1.0/24</code>, 就在 e2 端口，那么就会把消息从 e2 端口发出，（可能还会经过交换机）最后把消息打到目的机器。</p><p>当然，如果路由表里找不到，那就打到<strong>默认网关</strong>吧，也就是从 e1 口发出，发到 IP<code>192.0.2.1</code>。<strong>这个路由器的路由表不知道该去哪，说不定其他路由器知道</strong>。</p><br><h4 id="路由表的匹配规则"><a href="#路由表的匹配规则" class="headerlink" title="路由表的匹配规则"></a>路由表的匹配规则</h4><p>上面的例子里，是只匹配上了路由表里的<strong>一项</strong>，所以只能是它了。</p><p>但是，条条大路通罗马。实际上能到目的地的路径肯定有很多。</p><p><strong>如果路由表里有很多项都被匹配上了，会怎么选？</strong></p><br><p>如果多个路由项都能到目的地，那就优先选<strong>匹配长度更长</strong>的那个。比如，还是目的地<code>192.168.1.11</code>，发现路由表里的<strong>192.168.1</strong>.0/<strong>24</strong> 和 <strong>192.168</strong>.0.0/<strong>16</strong>都能匹配上，但明显<strong>前者匹配长度更长</strong>，所以最后会走 <strong>192.168.1</strong>.0/<strong>24</strong>对应的转发端口。</p><p><strong>但如果两个表项的匹配长度都一样呢？</strong></p><p>那就会看生成这个路由表项的<strong>协议</strong>是啥，选优先级高的，优先级越高也就是所谓的<strong>管理距离</strong>（<strong>AD</strong>，<strong>A</strong>dministrative<strong>D</strong>istance）越小。比如说优先选<strong>手动配</strong>的静态（<strong>static</strong>）路由，次优选<strong>OSPF</strong>动态学习过来的表项。</p><p>如果还是相同，就看<strong>度量值 metrics</strong>，其实也就是<strong>路径成本 cost</strong>，成本越小，越容易被选中。</p><p><strong>路由器能选的路线有很多，但按道理，最优的只有”一条”，所以到这里为止，我们都可以认为，对于同一个目的地，ping 和 TCP 走的路径是相同的。</strong></p><p>但是。</p><p><strong>如果连路径成本都一样呢？</strong>也就是说有多条最优路径呢。</p><p><strong>那就都用</strong>。</p><p>这也就是所谓的<strong>等价多路径，ECMP</strong>（<strong>E</strong>qual <strong>C</strong>ost <strong>M</strong>ulti<strong>P</strong>ath）。</p><p>我们可以通过<code>traceroute</code>看下链路是否存在等价多路径的情况。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220805122619206.png"></p><p>可以看到，中间某几行，有<strong>好几个 IP</strong>，也就是说这一跳里同时可以选好几个目的机器，说明这段路径<strong>支持 ECMP</strong>。</p><br><h4 id="ECMP-有什么用"><a href="#ECMP-有什么用" class="headerlink" title="ECMP 有什么用"></a>ECMP 有什么用</h4><p>利用等价多路径，我们<strong>可以增加链路带宽</strong>。</p><p>举个例子。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%B2%A1%E6%9C%89ECMP%E6%97%B6%E5%8F%AA%E8%83%BD%E9%80%89%E6%8B%A9%E6%9F%90%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84.drawio4.png" alt="没有ECMP时只能选择某一条路径"></p><p>从 A 点到 B 点，如果这两条路径成本不同，带宽都是<code>1千兆</code>。那数据包肯定就选成本低的那条路了，如果这条路出故障了，就走下面那条路。但不管怎么样，<strong>同一时间，只用到了一条路径</strong>。另外一条闲置就有些浪费了，有没有办法可以利用起来呢？</p><p>有，将它们两条路径的成本设置成一样，那它们就成了等价路由，然后中间的路由器开启<strong>ECMP</strong>特性，就可以同时利用这两条链路了。带宽就从原来的<code>1千兆</code>变成了<code>2千兆</code>。数据就可以在两条路径中随意选择了。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%88%A9%E7%94%A8ECMP%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E6%9D%A1%E9%93%BE%E8%B7%AF.drawi3o.png" alt="利用ECMP可以同时使用两条链路"></p><p>但这也带来了另外一个问题。<strong>加剧了数据包乱序</strong>。</p><p>原来我只使用一条网络路径，数据依次发出，如无意外，也是依次到达。</p><p>现在两个数据包走两条路径，先发的数据包可能后到。这就乱序了。</p><p>那么问题又又来了。</p><br><h4 id="乱序会有什么问题？"><a href="#乱序会有什么问题？" class="headerlink" title="乱序会有什么问题？"></a>乱序会有什么问题？</h4><p>对于我们最最最常使用的 TCP 协议来说，它是个可靠性网络的协议，这里提到的<strong>可靠</strong>，不仅是保证数据要能送到目的地，还要保证<strong>数据顺序</strong>要跟原来发送端的一样。</p><p>实现也很简单，<strong>TCP 为每个数据包（segment）做上编号</strong>。数据到了接收端后，根据<strong>数据包编号</strong>发现是<strong>乱序数据包</strong>，就会扔到<strong>乱序队列</strong>中对数据包进行排序。如果前面的数据包还没到，哪怕后面的数据包先到了，也得在乱序队列中一直等，到齐后才能被上层拿到。</p><p>举个例子，发送端发出三个数据包，<code>编号1,2,3</code>，假设在<strong>传输层</strong><code>2和3</code>先到了，<code>1</code>还没到。那此时<strong>应用层</strong>是没办法拿到<code>2和3</code>的数据包的，必须得等<code>1</code>来了之后，<strong>应用层才能一次性拿到这三个包</strong>。因为这三个包原来可能表示的是一个完整的消息，少了 1, 那么<strong>消息就不完整</strong>，应用层拿到了也毫无意义。</p><p>像这种，由于<strong>前面的数据丢失</strong>导致<strong>后面的数据没办法及时给到应用层</strong>的现象，就是我们常说的<strong>TCP 队头阻塞</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5.drawio.png" alt="乱序队列等待数据包的到来"></p><p>乱序发生时<code>2和3</code>需要待在乱序队列中，而<strong>乱序队列其实用的也是接收缓冲区的内存</strong>，而<strong>接收缓冲区是有大小限制的</strong>。通过下面的命令可以看到接收缓冲区的大小。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看接收缓冲区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysctl net.ipv4.tcp_rmem</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096(min)87380(default)6291456(max)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓冲区会在min和max之间动态调整</span></span><br></pre></td></tr></table></figure><p>乱序的情况越多，接收缓冲区的内存就被占用的越多，对应的<strong>接收窗口</strong>就会变小，那正常能收的数据就变少了，<strong>网络吞吐就变差</strong>了，也就是性能变差了。</p><p>因此，我们需要尽量保证所有<strong>同一个 TCP 连接下的所有 TCP 包都走相同路径，这样才能最大程度避免丢包</strong>。</p><br><h4 id="ECMP-的路径选择策略"><a href="#ECMP-的路径选择策略" class="headerlink" title="ECMP 的路径选择策略"></a>ECMP 的路径选择策略</h4><p><strong>当初开启 ECMP 就是为了提升性能，现在反而加重了乱序，降低了 TCP 传输性能。</strong></p><p>这怎么能忍。</p><p>为了解决这个问题，我们需要有一个合理的路径选择策略。为了避免同一个连接里的数据包乱序，我们需要保证同一个连接里的数据包，都走同样的路径。</p><p>这好办。我们可以通过连接的<strong>五元组</strong>（发送方的<strong>IP</strong>和<strong>端口</strong>，接收方的<strong>IP</strong>和<strong>端口</strong>，以及通信<strong>协议</strong>）信息定位到唯一一条连接。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%85%83%E7%BB%84.drawio.png" alt="五元组"></p><p>然后对五元组信息生成哈希键，让同一个哈希键的数据走同一条路径，问题就完美解决了。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%85%83%E7%BB%84%E6%98%A0%E5%B0%84%E6%88%90hash%E9%94%AE.drawio.png" alt="五元组映射成hash键"></p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AE%E4%BA%94%E5%85%83%E7%BB%84%E9%80%89%E6%8B%A9ECMP%E8%B7%AF%E5%BE%84.3.png" alt="根据五元组选择ECMP路径"></p><br><h3 id="TCP-和-Ping-走的网络路径一样吗"><a href="#TCP-和-Ping-走的网络路径一样吗" class="headerlink" title="TCP 和 Ping 走的网络路径一样吗"></a>TCP 和 Ping 走的网络路径一样吗</h3><p>现在我们回到文章开头的问题。</p><p>对于同样的发送端和接收端，<strong>TCP 和 Ping 走的网络路径一样吗？</strong></p><p>不一定一样，因为<strong>五元组</strong>里的信息里有一项是<strong>通信协议</strong>。ping 用的是<strong>ICMP 协议</strong>，跟<strong>TCP 协议</strong>不同，并且 ping 不需要用到端口，所以五元组不同，生成的<strong>哈希键不同</strong>，通过 ECMP 选择到的路径也可能不同。</p><p><img src="https://cdn.xiaobaidebug.top/TCP%E5%92%8Cping%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82.drawio.png" alt="TCP和ping的五元组差异"></p><br><h3 id="同样都用-TCP-协议，数据包走的网络路径一样吗"><a href="#同样都用-TCP-协议，数据包走的网络路径一样吗" class="headerlink" title="同样都用 TCP 协议，数据包走的网络路径一样吗"></a>同样都用 TCP 协议，数据包走的网络路径一样吗</h3><p>还是同样的发送端和接收端，同样是 TCP 协议，不同 TCP 连接走的网络路径是一样的吗？</p><p>跟上面的问题一样，其实<strong>还是五元组的问题</strong>，同样都是 TCP 协议，对于同样的发送端和接收端，他们的 IP 和接收端的端口肯定是一样的，但<strong>发送方的端口是可以随时变化</strong>的，因此通过 ECMP 走的路径也可能不同。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%8D%E5%90%8CTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82.drawio.png" alt="不同TCP连接的五元组差异"></p><br><p>但问题又来了。</p><p><strong>我知道这个有什么用呢？我做业务开发，又没有设置网络路由的权限。</strong></p><br><h3 id="利用这个知识点排查问题"><a href="#利用这个知识点排查问题" class="headerlink" title="利用这个知识点排查问题"></a>利用这个知识点排查问题</h3><p>对于业务开发，这绝对不是个没用的知识点。</p><p>如果某天，你发现，你能 ping 通目的机器，但用 TCP 去连，却<strong>偶尔连不上</strong>目的机器。而且两端机器都挺空闲，没什么性能上的瓶颈。实在<strong>走投无路</strong>了。</p><p>你就可以想想，会不会是网络中用到了<code>ECMP</code>，其中一条链路有问题导致的。</p><p><img src="https://cdn.xiaobaidebug.top/ping%E8%83%BD%E6%88%90%E5%8A%9F%E4%BD%86%E9%83%A8%E5%88%86TCP%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.drawio.png" alt="ping能成功但部分TCP连接失败"></p><p>排查方法也很简单。</p><p>你是知道本机的 IP 以及目的机器的 IP 和端口号的，也知道自己用的是 TCP 连接。</p><p>只要你在<strong>报错的时候打印下错误信息，你就知道了发送端的端口号了。</strong></p><p>这样<strong>五元组</strong>是啥你就知道了。</p><p>下一步就是<strong>指定发送端的端口号重新发起 TCP 请求，同样的五元组，走同样的路径，按理说如果链路有问题，就肯定会复现。</strong></p><p>如果不想改自己的代码，你可以用<strong>nc 命令指定客户端端口</strong>看下能不能正常建立 TCP 连接。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -p 6666 baidu.com 80</span><br></pre></td></tr></table></figure><p><code>-p 6666</code>是指定发出请求的客户端端口是<code>6666</code>，后面跟着的是<strong>连接的域名</strong>和<strong>80 端口</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220805141757559.png" alt="通过nc成功建立tcp连接"></p><p>假设用了<code>6666端口</code>的五元组去连接<strong>总是失败</strong>，改用<code>6667或其他端口</code><strong>却能成功</strong>，你可以带着这个信息去找找负责网络的同事。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>路由器可以通过 OSPF 协议生成路由表，利用数据包里的 IP 地址去跟路由表做匹配，选择最优路径后进行转发。</li><li>当路由表一个都匹配不上时会走默认网关。当匹配上多个的时候，会先看<strong>匹配长度</strong>，如果一样就看<strong>管理距离</strong>，还一样就看<strong>路径成本</strong>。如果连路径成本都一样，那<strong>等价路径</strong>。如果路由开启了 ECMP，那就可以同时利用这几条路径做传输。</li><li>ECMP 可以提高链路带宽，同时利用五元组做哈希键进行路径选择，保证了同一条连接的数据包走同一条路径，减少了乱序的情况。</li><li>可以通过 traceroute 命令查看到链路上是否有用到 ECMP 的情况。</li><li>开启了 ECMP 的网络链路中，TCP 和 ping 命令可能走的路径不同，甚至同样是 TCP，不同连接之间，走的路径也不同，因此出现了连接时好时坏的问题，实在是走投无路了，可以考虑下是不是跟 ECMP 有关。</li><li>当然，<strong>遇到问题多怀疑自己，要相信绝大部分时候真的跟 ECMP 无关</strong>。</li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《网络排查案例课》 ——极客时间</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>兄弟们。</p><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但我今天不想。</p><p>因为越是这样，评论区里叫我 diao 毛的兄弟就越多。</p><p><strong>上海快 40° 的天气，你们竟然能说出如此冰冷的话。</strong></p><p>但是。</p><p>只要你们还能给我文章右下角来个<strong>点赞和在看</strong>的话。</p><p>这口气，我还能忍。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi-20220806162638482.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP四次挥手中如果服务端没收到第四次挥手请求，服务端会一直等待吗？</title>
      <link href="/2022/08/13/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%94%B6%E5%88%B0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F/"/>
      <url>/2022/08/13/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%94%B6%E5%88%B0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>搬运一个在某乎的回答，水一篇文章吧。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220813113924022.png"></p><p><img src="https://cdn.xiaobaidebug.top/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B7.png" alt="TCP四次挥手"></p><p>正常情况下。只要数据传输完了，<strong>不管是客户端还是<a href="https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2613763971%7D">服务端</a>，都可以主动发起四次挥手</strong>，释放连接。</p><p>就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是<strong>主动方</strong>。服务器是被动接收客户端的挥手请求的，叫<strong>被动方</strong>。</p><p>客户端和服务器，一开始，都是处于<code>ESTABLISHED</code>状态。</p><p><strong>第一次挥手</strong>：一般情况下，主动方执行<code>close()</code>或 <code>shutdown()</code>方法，会发个<code>FIN报文</code>出来，表示”<strong>我不再发送数据了</strong>“。</p><p><strong>第二次挥手</strong>：在收到主动方的<code>FIN</code>报文后，被动方立马回应一个<code>ACK</code>，意思是”我收到你的 FIN 了，也知道你不再发数据了”。</p><p>上面提到的是<strong>主动方</strong>不再发送数据了。但如果这时候，<strong>被动方</strong>还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。</p><p><strong>第三次挥手</strong>：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 <code>close()</code>, 这时候就会发出第三次挥手的 <code>FIN-ACK</code>。</p><p><strong>第四次挥手</strong>：主动方回一个<code>ACK</code>，意思是收到了。</p><p>其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用<code>close()</code>方法），也就是我们平时写代码需要关注的地方。</p><p>第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。</p><p>另外不管是主动还是被动，每方发出了一个 <code>FIN</code> 和一个<code>ACK</code> 。也收到了一个 <code>FIN</code> 和一个<code>ACK</code> 。</p><p>回到题主的问题。</p><p><strong>TCP 四次挥手中如果服务端没收到第四次挥手请求，服务端会一直等待吗？</strong></p><p>第四次挥手是第三次挥手触发的。如果第四次挥手服务端一直没收到，那服务端会认为是不是自己的第三次挥手丢了，于是服务端不断重试发第三次挥手（FIN）.重发次数由系统的 tcp_orphan_retries 参数控制。重试多次还没成功，服务端直接断开链接。<strong>所以结论是服务端不会一直等待第四次挥手。</strong></p><p><img src="https://cdn.xiaobaidebug.top/TCP%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" alt="TCP第四次挥手丢失"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_orphan_retries</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>另外，你会发现<code>tcp_orphan_retries</code>参数是 0，但其实并不是不重试的意思。为 0 时，默认值为 8. 也就是重试 8 次。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate maximal number or retries on an orphaned socket. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_orphan_retries</span><span class="params">(struct sock *sk, <span class="keyword">int</span> alive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> retries = sysctl_tcp_orphan_retries; <span class="comment">/* May be zero. */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We know from an ICMP that something is wrong. */</span></span><br><span class="line"><span class="keyword">if</span> (sk-&gt;sk_err_soft &amp;&amp; !alive)</span><br><span class="line">retries = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* However, if socket sent something recently, select some safe</span></span><br><span class="line"><span class="comment"> * number of retries. 8 corresponds to &gt;100 seconds with minimal</span></span><br><span class="line"><span class="comment"> * RTO of 200msec. */</span></span><br><span class="line"><span class="keyword">if</span> (retries == <span class="number">0</span> &amp;&amp; alive)</span><br><span class="line">retries = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">return</span> retries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然如果服务端重试发第三次挥手 FIN 的过程中，还是同样的端口和 IP,起了个新的客户端，这时候服务端重试的 FIN 被收到后，客户端就会认为是不正常的数据包，直接发个 RST 给服务端，这时候两端连接也会断开。</p><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>查资料的时候发现<strong>小林大佬已经写过，而且写的巨好</strong>，感兴趣的可以看下他的这篇文章。</p><p><strong>《 如何优化 TCP?》</strong><a href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96</a></p><p>链接太长，懒得复制的话，点击<strong>阅读原文</strong>可以直接跳转。</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>新的文章快写好了，就缺个开头了。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220813115736303.png"></p><p><strong>我有个不成熟的请求。</strong></p><p><img src="https://cdn.xiaobaidebug.top/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi-20220806162638482.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>用了TCP协议，就一定不会丢包吗？</title>
      <link href="/2022/08/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%8D%E6%98%AF%E6%88%91%E4%B8%8D%E5%9B%9E%E4%BD%A0%E6%B6%88%E6%81%AF%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E4%BC%9A%E4%B8%A2%E5%8C%85/"/>
      <url>/2022/08/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%8D%E6%98%AF%E6%88%91%E4%B8%8D%E5%9B%9E%E4%BD%A0%E6%B6%88%E6%81%AF%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E4%BC%9A%E4%B8%A2%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>表面上我是个<strong>技术博主</strong>。</p><p>但没想到今天成了个<strong>情感博主</strong>。</p><p>我是没想到有一天，我会通过技术知识，来挽救粉丝即将破碎的感情。</p><p>掏心窝子的说。这件事情多少是沾点<strong>功德无量</strong>了。</p><p>事情是这样的。</p><p>最近就有个读者加了我的绿皮聊天软件，女生，<strong>头像挺好看</strong>的，就在我以为她要我拉她<strong>进群发成人专升本广告</strong>的时候。</p><p>画风突然不对劲。</p><p>她说她男朋友也是个<strong>程序员</strong>，异地恋，也关注了我，天天研究什么<strong>TCP，UDP 网络</strong>。一研究就是一晚上，一晚上都不回她消息的那种。</p><p>话里有话，懂。</p><p>不出意外的出了意外，她发出了灵魂拷问</p><p><strong>“你们程序员真的有那么忙吗？忙到连消息都不知道回。”</strong></p><p>没想到上来就是一记直拳。</p><p>但是，这一拳，我接住了。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%A4%AA%E5%BC%B1%E4%BA%86.jpg"></p><p>我很想告诉她”<strong>分了吧，下一题</strong>“。</p><p><strong>但我不能</strong>。因为这样我就伤害了我的读者兄弟。</p><p>沉默了一下。</p><p><img src="https://cdn.xiaobaidebug.top/cpu%E7%96%BC.png"></p><p>单核 cpu 都快转冒烟了，才颤颤巍巍在九宫格键盘上发出消息。</p><p>再回慢一点，我就感觉，我要对不起我这全日制本科学历了。</p><p><strong>“其实，他已经回了你消息了，但你知道吗？网络是会丢包的。”</strong></p><p>“我来帮他解释下，这个话题就要从<strong>数据包的发送流程</strong>聊起”</p><br><h3 id="数据包的发送流程"><a href="#数据包的发送流程" class="headerlink" title="数据包的发送流程"></a>数据包的发送流程</h3><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%89%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件三端通信"></p><p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP 协议</strong>进行通信。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%A4%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件两端通信"></p><br><p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立 TCP 连接。</p><p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过 RingBuffer 发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过 n 多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p><p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p><p><img src="https://cdn.xiaobaidebug.top/%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85%E5%85%A8%E6%99%AF%E5%9B%BE.drawio.png" alt="网络发包收包全景图"></p><blockquote><p>画了那么大一张图，只水了 200 字做解释，我多少是有些心痛的。</p></blockquote><br><p>到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p><br><p>可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p><p>整条链路下来，有不少地方可能会发生丢包。</p><p>但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p><br><h3 id="建立连接时丢包"><a href="#建立连接时丢包" class="headerlink" title="建立连接时丢包"></a>建立连接时丢包</h3><p>TCP 协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p><p><img src="https://cdn.xiaobaidebug.top/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BF%AE%E6%AD%A3%E7%89%882.png" alt="TCP三次握手"></p><p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p><p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%973-20220723214200932.png" alt="半连接队列和全连接队列"></p><p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p><p>可以通过下面的方式查看是否存在这种丢包行为。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全连接队列溢出次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -s | grep overflowed</span></span><br><span class="line">    4343 times the listen queue of a socket overflowed</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 半连接队列溢出次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -s | grep -i <span class="string">&quot;SYNs to LISTEN sockets dropped&quot;</span></span></span><br><span class="line">    109 times the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><p>从现象来看就是连接建立失败。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220723222050516.png"></p><p>这个话题在之前写的<a href="https://mp.weixin.qq.com/s/n17NjGRab1u5eXkOCro1gg">《没有 accept，能建立 TCP 连接吗？》</a>有更详细的聊过，感兴趣的可以回去看下。</p><br><h3 id="流量控制丢包"><a href="#流量控制丢包" class="headerlink" title="流量控制丢包"></a>流量控制丢包</h3><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p><p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p><p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p><p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p><p><img src="https://cdn.xiaobaidebug.top/qdisc%E4%B8%A2%E5%8C%85.drawio.png" alt="qdisc丢包"></p><p>可以通过下面的<code>ifconfig</code>命令，查看 TX 下的 dropped 字段，当它大于 0 时，则<strong>有可能</strong>是发生了流控丢包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.21.66.69  netmask 255.255.240.0  broadcast 172.21.79.255</span><br><span class="line">        inet6 fe80::216:3eff:fe25:269f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:25:26:9f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 6962682  bytes 1119047079 (1.0 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 9688919  bytes 2072511384 (1.9 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将 eth0 网卡的流控队列长度从 1000 提升为 1500.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0 txqueuelen 1500</span></span><br></pre></td></tr></table></figure><br><h3 id="网卡丢包"><a href="#网卡丢包" class="headerlink" title="网卡丢包"></a>网卡丢包</h3><p>网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p><br><h4 id="RingBuffer-过小导致丢包"><a href="#RingBuffer-过小导致丢包" class="headerlink" title="RingBuffer 过小导致丢包"></a>RingBuffer 过小导致丢包</h4><p>上面提到，在接收数据时，会将数据暂存到<code>RingBuffer</code>接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/RingBuffer%E6%BB%A1%E4%BA%86%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%8C%85.drawio.png" alt="RingBuffer满了导致丢包"></p><p>我们可以通过下面的命令去查看是否发生过这样的事情。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig</span></span><br><span class="line">eth0:  RX errors 0  dropped 0  overruns 0  frame 0</span><br></pre></td></tr></table></figure><p>查看上面的<code>overruns</code>指标，它记录了由于<code>RingBuffer</code>长度不足导致的溢出次数。</p><br><p>当然，用<code>ethtool</code>命令也能查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ethtool -S eth0|grep rx_queue_0_drops</span></span><br></pre></td></tr></table></figure><p>但这里需要注意的是，因为一个网卡里是可以有<strong>多个 RingBuffer</strong>的，所以上面的<code>rx_queue_0_drops</code>里的 0 代表的是<strong>第 0 个 RingBuffer</strong>的丢包数，对于多队列的网卡，这个 0 还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p><p>当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ethtool -g eth0</span></span><br><span class="line">Ring parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:4096</span><br><span class="line">RX Mini:0</span><br><span class="line">RX Jumbo:0</span><br><span class="line">TX:4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:1024</span><br><span class="line">RX Mini:0</span><br><span class="line">RX Jumbo:0</span><br><span class="line">TX:1024</span><br></pre></td></tr></table></figure><p>上面的输出内容，含义是<strong>RingBuffer 最大支持 4096 的长度，但现在实际只用了 1024。</strong></p><p>想要修改这个长度可以执行<code>ethtool -G eth1 rx 4096 tx 4096</code>将发送和接收 RingBuffer 的长度都改为 4096。</p><p><strong>RingBuffer</strong>增大之后，可以减少因为容量小而导致的丢包情况。</p><br><h4 id="网卡性能不足"><a href="#网卡性能不足" class="headerlink" title="网卡性能不足"></a>网卡性能不足</h4><p>网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p><p>我们可以通过<code>ethtool</code>加网卡名，获得当前网卡支持的最大速度。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ethtool eth0</span></span><br><span class="line">Settings for eth0:</span><br><span class="line">Speed: 10000Mb/s</span><br></pre></td></tr></table></figure><p>可以看到，我这边用的网卡能支持的最大传输速度<strong>speed=1000Mb/s</strong>。</p><p>也就是俗称的千兆网卡，但注意这里的单位是<strong>Mb</strong>，这里的<strong>b 是指 bit，而不是 Byte。1Byte=8bit</strong>。所以 10000Mb/s 还要除以 8，也就是理论上网卡最大传输速度是<code>1000/8 = 125MB/s</code>。</p><p>我们可以通过<code>sar命令</code>从网络接口层面来分析数据包的收发情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sar -n DEV 1</span></span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64  2022年07月27日 _x86_64_(1 CPU)</span><br><span class="line"></span><br><span class="line">08时35分39秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s    rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">08时35分40秒      eth0      6.06      4.04      0.35    121682.33   0.00    0.00     0.00</span><br></pre></td></tr></table></figure><p>其中 <strong>txkB/s 是指当前每秒发送的字节（byte）总数，rxkB/s 是指每秒接收的字节（byte）总数</strong>。</p><p>当两者加起来的值约等于<code>12~13w字节</code>的时候，也就对应大概<code>125MB/s</code>的传输速度。此时达到网卡性能极限，就会开始丢包。</p><p>遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p><br><h3 id="接收缓冲区丢包"><a href="#接收缓冲区丢包" class="headerlink" title="接收缓冲区丢包"></a>接收缓冲区丢包</h3><p>我们一般使用<code>TCP socket</code>进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p><p>当我们想要发一个数据包，会在代码里执行<code>send(msg)</code>，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。之前写过的《<a href="https://mp.weixin.qq.com/s/87BZzLmcntA1snJIIhUR0w">代码执行 send 成功后，数据就发出去了吗？</a>》里有比较详细的介绍。</p><p><img src="https://cdn.xiaobaidebug.top/tcp_sendmsg%E9%80%BB%E8%BE%913.png" alt="tcp_sendmsg逻辑"></p><p>而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p><p>这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看接收缓冲区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl net.ipv4.tcp_rmem</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096873806291456</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看发送缓冲区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl net.ipv4.tcp_wmem</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096163844194304</span><br></pre></td></tr></table></figure><p>不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在 min 和 max 之间动态调整。</strong></p><br><p><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p><p>对于<strong>发送缓冲区</strong>，执行 send 的时候，如果是阻塞调用，那就会等，等到缓冲区有空位可以发数据。</p><p><img src="https://cdn.xiaobaidebug.top/send%E9%98%BB%E5%A1%9E.gif" alt="send阻塞"></p><p>如果是非阻塞调用，就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是 <code>Try again</code> 。让应用程序下次再重试。这种情况下一般不会发生丢包。</p><p><img src="https://cdn.xiaobaidebug.top/send%E9%9D%9E%E9%98%BB%E5%A1%9E.gif" alt="send非阻塞"></p><p>当接受缓冲区满了，事情就不一样了，它的 TCP 接收窗口会变为 0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的<code>win=0</code>，告诉发送端，”球球了，顶不住了，别发了”。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/recv_buffer%E4%B8%A2%E5%8C%85.drawio.png" alt="recv_buffer丢包"></p><p>我们可以通过下面的命令里的<code>TCPRcvQDrop</code>查看到有没有发生过这种丢包现象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/netstat</span><br><span class="line">TcpExt: SyncookiesSent TCPRcvQDrop SyncookiesFailed</span><br><span class="line">TcpExt: 0              157              60116</span><br></pre></td></tr></table></figure><p>但是说个伤心的事情，我们一般也看不到这个<code>TCPRcvQDrop</code>，因为这个是<code>5.9版本</code>里引入的打点，而我们的服务器用的一般是<code>2.x~3.x</code>左右版本。你可以通过下面的命令查看下你用的是什么版本的 linux 内核。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/version</span></span><br><span class="line">Linux version 3.10.0-1127.19.1.el7.x86_64</span><br></pre></td></tr></table></figure><br><h3 id="两端之间的网络丢包"><a href="#两端之间的网络丢包" class="headerlink" title="两端之间的网络丢包"></a>两端之间的网络丢包</h3><p>前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p><p>这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p><br><h4 id="ping-命令查看丢包"><a href="#ping-命令查看丢包" class="headerlink" title="ping 命令查看丢包"></a>ping 命令查看丢包</h4><p>比如我们知道目的地的域名是 <code>baidu.com</code>。想知道你的机器到 baidu 服务器之间，有没有产生丢包行为。可以使用 ping 命令。</p><p><img src="https://cdn.xiaobaidebug.top/ping%E6%9F%A5%E7%9C%8B%E4%B8%A2%E5%8C%85.png" alt="ping查看丢包"></p><p>倒数第二行里有个<code>100% packet loss</code>，意思是**丢包率 100%**。</p><p>但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p><p><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p><p>有。</p><br><h4 id="mtr-命令"><a href="#mtr-命令" class="headerlink" title="mtr 命令"></a>mtr 命令</h4><p>mtr 命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p><p>像下面这样执行命令。</p><p><img src="https://cdn.xiaobaidebug.top/mtr_icmp.png" alt="mtr_icmp"></p><p>其中**-r 是指 report**，以报告的形式打印结果。</p><p>可以看到<code>Host</code>那一列，出现的都是链路中间每一跳的机器，<code>Loss</code>的那一列就是指这一跳对应的丢包率。</p><p>需要注意的是，中间有一些是 host 是<code>???</code>，那个是因为<strong>mtr 默认用的是 ICMP 包</strong>，有些节点限制了<strong>ICMP 包</strong>，导致不能正常展示。</p><p>我们可以在 mtr 命令里加个<code>-u</code>，也就是使用<strong>udp 包</strong>，就能看到**部分???**对应的 IP。</p><p><img src="https://cdn.xiaobaidebug.top/mtr-udp.png" alt="mtr-udp"></p><p>把<strong>ICMP 包和 UDP 包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p><p>还有个小细节，<code>Loss</code>那一列，我们在 icmp 的场景下，关注<strong>最后一行</strong>，如果是 0%，那不管前面 loss 是 100%还是 80%都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p><p>但如果<strong>最后一行是 20%，再往前几行都是 20%左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220727215553645.png"></p><br><h3 id="发生丢包了怎么办"><a href="#发生丢包了怎么办" class="headerlink" title="发生丢包了怎么办"></a>发生丢包了怎么办</h3><p>说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p><p>但问题来了，发生丢包了怎么办？</p><p>这个好办，用<strong>TCP 协议</strong>去做传输。</p><p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p><p>建立了 TCP 连接的两端，发送端在发出数据后会等待接收端回复<code>ack包</code>，<code>ack包</code>的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认 ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p><p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用 TCP 不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220727223315319.png"></p><p>这时候问题又来了。</p><p>假设<strong>某绿皮聊天软件用的就是 TCP 协议。</strong></p><p>那文章开头提到的女生，她男朋友回她的消息时为什么还会丢包？毕竟丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p><br><p>于是乎，问题就变成了，<strong>用了 TCP 协议，就一定不会丢包吗？</strong></p><br><h3 id="用了-TCP-协议就一定不会丢包吗"><a href="#用了-TCP-协议就一定不会丢包吗" class="headerlink" title="用了 TCP 协议就一定不会丢包吗"></a>用了 TCP 协议就一定不会丢包吗</h3><p>我们知道 TCP 位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的 HTTP 或者各类 RPC 协议。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE5.drawio.png" alt="四层网络协议"></p><p>TCP 保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP 只保证数据从 A 机器的传输层可靠地发到 B 机器的传输层。</strong></p><p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP 并不管。</p><p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层 TCP 协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层 TCP 接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里 TCP 的任务就结束了。</p><p>TCP 任务是结束了，但聊天软件的任务没结束。</p><p><strong>聊天软件还需要将数据从 TCP 的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p><p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p><p>于是乎，<strong>消息就丢了。</strong></p><p><img src="https://cdn.xiaobaidebug.top/%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%E5%8D%B4%E5%8F%91%E7%94%9F%E4%B8%A2%E5%8C%85.d2.png" alt="使用TCP协议却发生丢包"></p><p><strong>虽然概率很小，但它就是发生了</strong>。</p><p>合情合理，逻辑自洽。</p><br><p>所以从这里，我铿锵有力的得出结论，<strong>我的读者已经回了这位女生消息了，只是因为发生了丢包所以女生才没能收到，而丢包的原因是女生的手机聊天软件在接收消息的那一刻发生了闪退。</strong></p><p>到这里。女生知道自己错怪她男朋友了，哭着表示，一定要让她男朋友给她买一台不闪退的最新款 iphone。</p><p>额。。。</p><p>兄弟们觉得我做得对的，请在评论区扣个”<strong>正能量</strong>“。</p><br><h3 id="这类丢包问题怎么解决？"><a href="#这类丢包问题怎么解决？" class="headerlink" title="这类丢包问题怎么解决？"></a>这类丢包问题怎么解决？</h3><p>故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p><p><strong>其实前面说的都对，没有一句是假话</strong>。</p><p>但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p><p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p><p><strong>现在我们重新将服务器加回来。</strong></p><p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%89%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件三端通信"></p><p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个 id</strong>，服务器和聊天软件每次都拿<strong>最新消息的 id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p><p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p><p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p><p>可以看出，<strong>TCP 只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p><br><p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p><p>主要有三个原因。</p><ul><li><p>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</p></li><li><p>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</p></li><li><p>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</p></li></ul><p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说<strong>丢包不可避免</strong>。</p></li><li><p>平时没事也不用关注丢包，大部分时候 TCP 的重传机制保证了消息可靠性。</p></li><li><p>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用 ping 或者 mtr 命令看下是不是中间链路发生了丢包。</p></li><li><p>TCP 只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</p></li></ul><br><p>最后给大家留个问题吧，<strong>mtr 命令是怎么知道每一跳的 IP 地址的</strong>？</p><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Linux 内核技术实战》– 极客时间</p><p>《云网络丢包故障定位全景指南》–极客重生</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我一想到读者里还有不少兄弟还是单身，我就夜不能寐。</p><p>手心手背都是肉，<strong>一碗水要端平</strong>。</p><p>犹豫了很久，为她指了条明路。</p><p>“我读者里有很多<strong>微信不丢包</strong>的兄弟，他们都喜欢在我的文章底下<strong>点赞和再看</strong>。你可以考虑下他们”</p><p>“还有经常在我评论区<strong>叫我靓仔</strong>的那些个兄弟，一看就是深情种，<strong>请重点考虑</strong>“。</p><p>只能帮到这里了，懂？</p><br><p>我知道，这时候肯定就有兄弟要说我了，**”故事汇都不敢这么编！”**</p><p><img src="https://cdn.xiaobaidebug.top/u=3537235361,1595811612&fm=253&fmt=auto&app=138&f=GIF.gif"></p><p>嗯。</p><p>他们不敢，我敢。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>既然有HTTP协议，为什么还要有RPC</title>
      <link href="/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/"/>
      <url>/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>我想起了我刚工作的时候，第一次接触 RPC 协议，当时就很懵，<strong>我 HTTP 协议用的好好的，为什么还要用 RPC 协议？</strong></p><p>于是就到网上去搜。</p><p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p><p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p><p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p><br><h3 id="从-TCP-聊起"><a href="#从-TCP-聊起" class="headerlink" title="从 TCP 聊起"></a>从 TCP 聊起</h3><p>作为一个程序员，假设我们需要在 A 电脑的进程发一段数据到 B 电脑的进程，我们一般会在代码里使用 socket 进行编程。</p><p>这时候，我们可选项一般也就<strong>TCP 和 UDP 二选一。TCP 可靠，UDP 不可靠。</strong>除非是马总这种神级程序员（早期 QQ 大量使用 UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选 TCP 就对了。</p><p>类似下面这样。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP 协议</strong>。</p><p>在定义了 socket 之后，我们就可以愉快的对这个 socket 进行操作，比如用<code>bind()</code>绑定 IP 端口，用<code>connect()</code>发起建连。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B3.gif" alt="握手建立连接流程"></p><p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p><p>光这样一个纯裸的 TCP 连接，就可以做到收发数据了，那是不是就够了？</p><p>不行，这么用会有问题。</p><br><h3 id="使用纯裸-TCP-会有什么问题"><a href="#使用纯裸-TCP-会有什么问题" class="headerlink" title="使用纯裸 TCP 会有什么问题"></a>使用纯裸 TCP 会有什么问题</h3><p>八股文常背，TCP 是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p><p>这三个特点真的概括的<strong>非常精辟</strong>，这个八股文我们没白背。</p><p>每个特点展开都能聊一篇文章，而今天我们需要关注的是<strong>基于字节流</strong>这一点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 <strong>01 串</strong>。纯裸 TCP 收发的这些 01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。</p><p><img src="https://cdn.xiaobaidebug.top/01%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.drawio.png" alt="01二进制字节流"></p><p>正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用 TCP 发送**”夏洛”和”特烦恼”<strong>的时候，接收端收到的就是</strong>“夏洛特烦恼”<strong>，这时候接收端没发区分你是想要表达</strong>“夏洛”+”特烦恼”<strong>还是</strong>“夏洛特”+”烦恼”**。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E5%AF%B9%E6%AF%94_%E5%A4%8F%E6%B4%9B%E7%89%B9%E7%83%A6%E6%81%BC.drawio.png" alt="消息对比"></p><p>这就是所谓的<strong>粘包问题</strong>，之前也写过一篇专门的<a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">文章</a>聊过这个问题。</p><p>说这个的目的是为了告诉大家，纯裸 TCP 是不能直接拿来用的，你需要在这个基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。</p><p>于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%976.drawio.png" alt="消息边界长度标志"></p><p>而这里头提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p><p>每个使用 TCP 的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。</p><p><strong>于是基于 TCP，就衍生了非常多的协议，比如 HTTP 和 RPC。</strong></p><br><h3 id="HTTP-和-RPC"><a href="#HTTP-和-RPC" class="headerlink" title="HTTP 和 RPC"></a>HTTP 和 RPC</h3><p>我们回过头来看网络的分层图。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE5.drawio.png" alt="四层网络协议"></p><p><strong>TCP 是传输层的协议</strong>，而基于 TCP 造出来的 HTTP 和<strong>各类</strong>RPC 协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。</p><p><strong>HTTP</strong>协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是 HTTP 协议。</p><p><img src="https://cdn.xiaobaidebug.top/HTTP%E8%B0%83%E7%94%A8.drawio.png" alt="HTTP调用"></p><p>而<strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p><p>举个例子，我们平时调用一个<strong>本地方法</strong>就像下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = localFunc(req)</span><br></pre></td></tr></table></figure><p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = remoteFunc(req)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/RPC%E6%98%AF%E4%B8%80%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.drawio.png" alt="RPC可以像调用本地方法那样调用远端方法"></p><p>基于这个思路，大佬们造出了非常多款式的 RPC 协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p><p>值得注意的是，虽然大部分 RPC 协议底层使用 TCP，但实际上<strong>它们不一定非得使用 TCP，改用 UDP 或者 HTTP，其实也可以做到类似的功能。</strong></p><p><img src="https://cdn.xiaobaidebug.top/%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84HTTP%E5%92%8CRPC%E5%8D%8F%E8%AE%AE.drawio.png" alt="基于TCP协议的HTTP和RPC协议"></p><br><p>到这里，我们回到文章标题的问题。</p><p><strong>既然有 HTTP 协议，为什么还要有 RPC？</strong></p><p>其实，<code>TCP</code>是<strong>70 年</strong>代出来的协议，而<code>HTTP</code>是<strong>90 年代</strong>才开始流行的。而直接使用裸 TCP 会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有<strong>80 年代</strong>出来的<code>RPC</code>。</p><p>所以我们该问的不是<strong>既然有 HTTP 协议为什么要有 RPC</strong>，而是<strong>为什么有 RPC 还要有 HTTP 协议</strong>。</p><br><h4 id="那既然有-RPC-了，为什么还要有-HTTP-呢？"><a href="#那既然有-RPC-了，为什么还要有-HTTP-呢？" class="headerlink" title="那既然有 RPC 了，为什么还要有 HTTP 呢？"></a>那既然有 RPC 了，为什么还要有 HTTP 呢？</h4><p>现在电脑上装的各种<strong>联网</strong>软件，比如 xx 管家，xx 卫士，它们都作为<strong>客户端（client）</strong>需要跟<strong>服务端（server）</strong>建立连接收发消息，此时都会用到应用层协议，在这种**client/server (c/s)**架构下，它们可以使用自家造的 RPC 协议，因为它只管连自己公司的服务器就 ok 了。</p><p>但有个软件不同，<strong>浏览器（browser）</strong>，不管是 chrome 还是 IE，它们不仅要能访问自家公司的<strong>服务器（server）</strong>，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP 就是那个时代用于统一 <strong>browser/server (b/s)</strong> 的协议。</p><p>也就是说在多年以前，<strong>HTTP 主要用于 b/s 架构，而 RPC 更多用于 c/s 架构。但现在其实已经没分那么清了，b/s 和 c/s 在慢慢融合。</strong>很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和 pc 端</strong>，如果通信协议都用 HTTP 的话，那服务器只用同一套就够了。而 RPC 就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p><p>那这么说的话，<strong>都用 HTTP 得了，还用什么 RPC？</strong></p><p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p><br><h3 id="HTTP-和-RPC-有什么区别"><a href="#HTTP-和-RPC-有什么区别" class="headerlink" title="HTTP 和 RPC 有什么区别"></a>HTTP 和 RPC 有什么区别</h3><p>我们来看看 RPC 和 HTTP 区别比较明显的几个点。</p><br><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP 地址和端口</strong>。这个找到服务对应的 IP 端口的过程，其实就是<strong>服务发现</strong>。</p><p>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS 服务</strong>去解析得到它背后的 IP 地址，默认 80 端口。</p><p>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和 IP 信息，比如<strong>consul 或者 etcd，甚至是 redis</strong>。想要访问某个服务，就去这些中间服务去获得 IP 和端口信息。由于 dns 也是服务发现的一种，所以也有基于 dns 去做服务发现的组件，比如<strong>CoreDNS</strong>。</p><p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p><br><h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><p>以主流的<strong>HTTP1.1</strong>协议为例，其默认在建立底层 TCP 连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p><p>而<strong>RPC</strong>协议，也跟 HTTP 类似，也是通过建立 TCP 长链接进行数据交互，但不同的地方在于，RPC 协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</p><p><img src="https://cdn.xiaobaidebug.top/connection_pool3.drawio.png" alt="connection_pool"></p><p><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给 HTTP 加个连接池</strong>，比如<strong>go</strong>就是这么干的。</p><p>可以看出这一块两者也没太大区别，所以也不是关键。</p><br><h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>基于 TCP 传输的消息，说到底，无非都是<strong>消息头 header 和消息体 body。</strong></p><p><strong>header</strong>是用于标记一些特殊信息，其中最重要的是<strong>消息体长度</strong>。</p><p><strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制 01 串，毕竟计算机只认识这玩意。所以 TCP 传字符串和数字都问题不大，因为字符串可以转成编码再变成 01 串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制 01 串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong></p><p>这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.drawio.png" alt="序列化和反序列化"></p><br><p>对于主流的 HTTP1.1，虽然它现在叫<strong>超文本</strong>协议，支持音频视频，但 HTTP 设计初是用于做网页<strong>文本</strong>展示的，所以它传的内容以字符串为主。header 和 body 都是如此。在 body 这块，它使用<strong>json</strong>来<strong>序列化</strong>结构体数据。</p><p>我们可以随便截个图直观看下。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220716212628672.png" alt="HTTP报文"></p><p>可以看到这里面的内容非常多的<strong>冗余</strong>，显得<strong>非常啰嗦</strong>。最明显的，像<code>header</code>里的那些信息，其实如果我们约定好头部的第几位是 content-type，就<strong>不需要每次都真的把”content-type”这个字段都传过来</strong>，类似的情况其实在<code>body</code>的 json 结构里也特别明显。</p><p>而 RPC，因为它定制化程度更高，可以采用体积更小的 protobuf 或其他序列化协议去保存结构体数据，同时也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。</strong></p><p><img src="https://cdn.xiaobaidebug.top/HTTP%E5%8E%9F%E7%90%86.drawio.png" alt="HTTP原理"></p><p><img src="https://cdn.xiaobaidebug.top/RPC%E5%8E%9F%E7%90%86.drawio.png" alt="RPC原理"></p><p>当然上面说的 HTTP，其实<strong>特指的是现在主流使用的 HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以<strong>性能可能比很多 RPC 协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p><p>那么问题又来了。</p><br><h5 id="为什么既然有了-HTTP2，还要有-RPC-协议？"><a href="#为什么既然有了-HTTP2，还要有-RPC-协议？" class="headerlink" title="为什么既然有了 HTTP2，还要有 RPC 协议？"></a>为什么既然有了 HTTP2，还要有 RPC 协议？</h5><p>这个是由于 HTTP2 是 2015 年出来的。那时候很多公司内部的 RPC 协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>纯裸 TCP 是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。</li><li><strong>RPC 本质上不算是协议，而是一种调用方式</strong>，而像 gRPC 和 thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，<strong>不一定非得基于 TCP 协议</strong>。</li><li>从发展历史来说，<strong>HTTP 主要用于 b/s 架构，而 RPC 更多用于 c/s 架构。但现在其实已经没分那么清了，b/s 和 c/s 在慢慢融合。</strong>很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。</li><li>RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP1.1<strong>性能</strong>要更好，所以大部分公司内部都还在使用 RPC。</li><li><strong>HTTP2.0</strong>在<strong>HTTP1.1</strong>的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。</li></ul><br><p>最后留个问题吧，大家有没有发现，不管是 HTTP 还是 RPC，它们都有个特点，那就是消息都是客户端请求，服务端响应。<strong>客户端没问，服务端肯定就不答</strong>，这就有点僵了，但现实中肯定有需要<strong>下游主动发送消息给上游</strong>的场景，比如打个网页游戏，站在那啥也不操作，怪也会主动攻击我，这种情况该怎么办呢？</p><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.zhihu.com/question/41609070">https://www.zhihu.com/question/41609070</a></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但还是算了。因为我最近一直在想一个问题，希望兄弟们能在<strong>评论区</strong>告诉我答案。</p><p>最近手机借给别人玩了一下午，现在老是给我推荐<strong>练习时长两年半的练习生</strong>视频。</p><p>每个视频都在声嘶力竭的告诉我，<strong>鸡你太美</strong>。</p><p>所以我很想问，兄弟们。</p><p><strong>鸡，到底美不美？</strong></p><p>头疼。</p><br><p><strong>右下角的点赞和再看还是可以走一波的。</strong></p><p>先这样。</p><p>我是小白，我们下期见。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>什么情况下你该考虑离职</title>
      <link href="/2022/07/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E8%AF%A5%E8%80%83%E8%99%91%E7%A6%BB%E8%81%8C/"/>
      <url>/2022/07/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E8%AF%A5%E8%80%83%E8%99%91%E7%A6%BB%E8%81%8C/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>兄弟们！</p><p>出来讲骚话啊。</p><p><img src="https://cdn.xiaobaidebug.top/9e31678cgy1fn3oszal1xj20hr0m70u4.jpg"></p><br><p>大家都是打工人，尤其是我们互联网打工人，一般很少在一家公司待十年八年的。</p><p>一两年一跳很正常。</p><p>尤其是现在很多公司都没有普调，<strong>薪水入职即巅峰</strong>，所以在很长一段时间里，要涨薪只能靠跳槽，这话没啥毛病。</p><p>但问题来了。</p><p><strong>什么情况下你该考虑离职？</strong></p><br><p>之前听马老师提到过，一般离职就<strong>两个原因</strong>，<strong>钱给少了</strong>和<strong>心受委屈了</strong>。</p><p>可以说概括的相当精辟了，但这个偏<strong>主观</strong>因素多一点。</p><p>今天我想说的是离职的<strong>第三个原因：见势不妙</strong>。这个偏<strong>客观</strong>因素多一点。</p><p>很多时候，如果业务越做越凉，是有迹可循的。今天我们就来<strong>沉浸式</strong>体验一下这个过程。</p><p>看完你大概能知道<strong>什么情况下你该考虑离职了。</strong></p><br><h3 id="业务起步"><a href="#业务起步" class="headerlink" title="业务起步"></a>业务起步</h3><p>很多公司在某些业务上小赚了一笔之后，都会考虑开辟新的业务线，以期待这个新的业务线会成为新的收入增长点。而这时候，老板们就会观察当前行业的风口，大一点的公司还会有专门的部门做各种研究。</p><p>在多次 ppt 会议之后，最后也不知道是谁成功忽悠了谁。总之，老板显得有些深思熟虑，并在 ppt 的某页上重点画了一个圈，你以为这是个重点经济增长圈？</p><p>但其实，它只是个饼，圆一点的饼。</p><p>于是，一个新的业务线就这样，带着<strong>宏伟使命和伟大愿景</strong>来了。</p><p>干活，首先得先<strong>摇人</strong>，新的事业线<strong>放出了大量的 HC</strong>（head count，人头数），那段时间，HR 电话都打爆了。</p><p>而你也是在这次摇人中，加入到了这个具有伟大使命和宏大愿景的业务线里。</p><p>这之后，老板开了好几次<strong>动员会</strong>，一遍又一遍的重复着他做这番事业的初心，这个事情的社会价值，以及你们未来会是一个有多少万个小目标的公司。</p><p>老板这么说不要紧，那关键是你看到的网页新闻也是这么说。</p><p>公司放出更多 HC 疯狂<strong>扩招</strong>，显示出他们的决心。</p><p>各种晨会周会上，老板不断强调我们要<strong>加强内推</strong>，多搞点简历过来，太缺人了。</p><p><strong>“这件事，太有搞头了！”</strong></p><p>你心想，你就是下一个风口上的猪。闭上眼睛，你都能看到，自己以后跟各界互联网大佬手搭着肩，在 ktv 里哭着唱朋友一生一起走的画面了。</p><br><h3 id="业务中期"><a href="#业务中期" class="headerlink" title="业务中期"></a>业务中期</h3><p><strong>搞钱的事，怎么能在一棵树上干吊着呢？要多搞几棵树吊吊。</strong></p><p>于是本着<strong>养蛊</strong>的思路，公司开了更多同类型的细分业务，比如教育还能细分为小学教育，初中教育，再细分还能分为语文数学英语。这时候你会发现，业务变得越来越多了，你手上的需求也越来越多了。</p><p>你每天都在多线程切换，除了写代码，等待你的还有开不完的会，搞不完的 oncall，有时候新来的产品还会天真无邪的找你一对一咨询各种产品细节。白天一晃而过，晚上 8 点之后，你才能开始安心写代码。</p><p>在这种高压环境下待个一年，恍如隔世，照个镜子，<strong>原来人间已经过了三年</strong>。相对论诚不欺我，爱因斯坦棺材板的压不住了。</p><p>一般这种时候，你负责的<strong>老服务会越来越多，但新服务和新需求还在不停开发中。</strong>你在写新需求的同时还得处理各种老服务的问题和咨询。</p><p>产品开始吐槽你们开发越来越慢，为了加快需求的吞吐量，项目组<strong>从双周迭代改为了单周迭代</strong>。</p><p>这直接就是煽风点火了。</p><p>只要老服务出啥问题了，你原本绷紧的开发排期就得变得更脆。只要有一个需求延期了，那你后面就等着加班到天明吧。</p><p>很多项目在不断试错的过程中，过程中需要查看各种业务指标数据，产品、运营都会轮番要你写脚本算数据，只为说明他们拍大腿想出来的需求，是有数据支撑的，是 reasonable 的。</p><p>教育行业就更古怪，连教研老师都能给你提需求。</p><p>这种情况，在每个季度结束的时候会变得特别严重，你在用生命在为他们完成 kpi，你可真是互联网活雷锋。</p><p>雷锋做好事还知道写日记，你做的这些个事情，到底要不要写进周报好呢？</p><p>下班的路上，你拖着疲惫的身体，背着个电脑，开着小电瓶，在路灯的晃射下，你看到了路边的狗，你都一度怀疑，是不是连它，都能给你提需求。</p><p>你回想起，刚毕业的那会，那时候你虽然很穷，但你很快乐，现在不一样了，<strong>你还是很穷，但你不快乐了</strong>。</p><p>你总有开不完的会，做不完的需求，你一度想着<strong>要不离职算了</strong>。但每次这种时候，大老板就正好<strong>调整一波组织架构</strong>，然后发表下他这次调整架构的思考和决心，会议的最后再次回到诉说初心，然后展望愿景和理想的环节。</p><p>这是这一年里，<strong>第 4 次</strong>调整组织架构和方向了，你开始在想老板是不是连自己都没想清楚，但你看老板回答各种问题时，那笃定睿智的神情，你又感觉你行了，坚持下吧，说不定这次真的能行呢！</p><br><h3 id="业务后期"><a href="#业务后期" class="headerlink" title="业务后期"></a>业务后期</h3><p>古人说，公司内的消息要在公司外的八卦平台上才能看到。</p><p>古人诚不欺你，某天，你在某知名互联网茶水间 app 某脉上看到了自家公司正在裁员的消息，而裁员的对象，正好是你所在的业务线方向。</p><p>虽然<strong>身边陆续有同事在开始慢慢离职</strong>，之前合作对接过的几个开发老哥内部账号也变成了离职状态。</p><p>甚至连竞品的股价都开始在暴跌。</p><p>但你都没在意，因为你现在做的事情挺多的，哪有时间管这些。</p><p>唯一让你感到痛心疾首的是，<strong>坐门口的爱穿黑丝的小姐姐，突然有天也不见了</strong>。</p><p>那天傍晚，你的领导找组里的小伙伴们出去吃顿饭。吃到一半，你左手韭菜，右手羊腰子，<strong>领导却站起来说他要离职的事情</strong>，你突然愣神。反应过来时，大家正说着祝福的话，举起酒杯，好言相送，你看着杯子里的加多宝，又再一次陷入了慌神。</p><p>老领导走了，新领导上来第一件事就是盘点项目组的资源使用情况，每个服务使用了多少 cpu 和内存，能缩容就缩容。是的，他要搞<strong>降本提效</strong>。</p><p>降着降着，可能发现原来<strong>人</strong>才是最大的支出。于是你发现，不少业务线都消失了，不少人也走了。你手上接了越来越多别人交接过来的项目，从前五个人干的活，现在让你一个人干，你有些吃不消。老板说后面肯定会招人。但你很清楚，<strong>很长时间部门好像都没有面试了</strong>，以前周会每次都会提一下让大家内推一些简历，现在也不再提了。再后来，你听说业务线<strong>HC 被锁了</strong>，不再招人，<strong>甚至连转岗都不让转了</strong>。</p><br><p>再后来，你发现业务的需求越来越少了，你以为终于可以闲下来摸鱼了，但这时候你的新领导开始推大家<strong>开始重构服务</strong>了，他说”之前我们跑太快了，一直在堆屎山，现在业务的活少了，正是我们重新思考架构，降本提效的好时候！”。</p><p>于是你们又开始了一轮新的折腾，你听老员工说: “<strong>以前完成业务的需求，给业务提供价值就是老板的 KPI，那现在业务都没了，老板不折腾下重构，那哪来的 kpi</strong>“。</p><p>知道真相的你眼泪掉下来。</p><p>这时候，你终于想走了，可一想到<strong>再坚持下就发年终奖了</strong>，这么辛苦都过来了，再忍几个月吧。</p><p>发年终奖可是个大开支啊，降本提效可是老板的 kpi 啊，于是你发现身边的同事慢慢变少。</p><p>直到那天你收到老板发来的消息：”<strong>空吗？我们来聊下绩效</strong>“。</p><p>如无意外，他觉得你绩效不好，要你签一份**<a href="https://mp.weixin.qq.com/s/fuQAAjOMYW1tzyujh7GOHQ">PIP</a>协议<strong>，你很清楚</strong>这玩意签了就等于承认自己不行，离职连 N+x 都没有**。但你也无力反抗，你很清楚什么叫”欲加之罪，何患无辞”。</p><br><h3 id="什么时候该离职"><a href="#什么时候该离职" class="headerlink" title="什么时候该离职"></a>什么时候该离职</h3><p>你开始脑袋放空，过往发生的每一件事都像碎片那样串联了起来。明明有那么多迹象告诉你，快跑。但你都视而不见。</p><p><strong>“早知道我半年前就跑了”</strong></p><p>可是问题来了。</p><p>如果再让你回到半年前，你身处在一个<strong>温水煮青蛙</strong>的环境，你怎么知道该不该跑。</p><p>我们重新梳理一遍过往发生的事情。</p><p><strong>大环境舆论热议风口 → 开新业务，领导鼓励拉人内推 → 业务变多，开发很累但人员不断在补充 → 架构不断调整 → 工作主要以完成需求支持业务为主 → 大环境变差，政策变更，竞品或自家股票暴跌 → 业务可见的萎缩 ，不再强调内推 → 架构调整，信心鼓励 → 活很多，但就是不招人 → hc 锁死，人员只出不进 → 领导跑路，换新领导 → 资源盘点，提倡降本提效 → 业务量变少，重构之类的活排上日程 → 身边的人陆续离职 → 年终奖将近，身边出现大批人员离职 → 轮到你了 → 留下来的人接手离职人员的活，过得更苦了 → 团队裁员或部门打包转岗。</strong></p><p>这里其实涉及到<strong>一个业务线从 0 到 0.7 再到 0 的完整过程</strong>，任何一个时间节点，在会议上都是一片欣欣向荣的场面，就算是最后团队裁员，说的也是充满信心的话。</p><p><strong>但你不必看老板们说什么，你看老板们做什么就够了，行动永远比话语诚实。</strong></p><ul><li><p><strong>公司业务组织架构疯狂调整</strong>，一年能折腾个三四次，说明老板都没想清楚一件事要怎么做，所以想要拍大腿疯狂试错。不赚钱的业务才会不断折腾，<strong>赚钱的业务永远以稳定盈利为主要目标</strong>。这时候你就该明白这个业务线大概率不太能做出来了，<strong>如果你加入这个公司的目的是妄想暴富的话，那该醒过来了，该考虑刷题了</strong>。</p></li><li><p><strong>领导离职</strong>。这个要分情况，如果项目赚钱了，那可能只是宫斗，这种情况不考虑。但如果是不赚钱的项目，不管是领导是主动还是被动离职，这都不是什么好事情。如果是主动离职，如果一件事有搞头，你会想要跑吗？领导永远比你更接近第一手消息，而且能做到领导位置，那肯定目光和判断力要比你更强，连他都觉得没搞头，那你还不快跑？被动离职，这个更明显，搞事业，最忌讳中途换帅，但凡有点希望，也不至于这么搞。这时候你该明白，老板的老板已经慢慢失去耐心。这时候，<strong>八股文该背起来了</strong>。</p></li><li><p><strong>HC 锁死</strong>，说明从公司层面上，就不会再继续加大投入人力，对这个业务已经慢慢失去信心。如果现在离年终奖还远，<strong>简历改起来啊，你该考虑转岗或跑路了</strong>。</p></li><li><p><strong>锁死转岗</strong>，这种时候多发生在后半年，大部分有<strong>求生经验</strong>的人，不想失去年终奖，于是选择活水到其他业务线，这样还能保住年终奖，走不走明年再做打算。但这样的转岗太多了，会导致原来就可能要凉的业务线凉的更快，于是大老板就会选择冻结转岗。这时候如果离年终还远，那球球了，<strong>投简历吧</strong>。如果临近年终，那我劝你苟住，但如果不得不得跑，对面公司出于人道主义关怀，可能会有一笔<strong>签字费</strong>作为损失年终奖的激励 or 补偿，记得谈一谈。</p></li></ul><p><strong>如果你在转岗锁死前，能成功转岗或离职，那你一般损失会小一些。</strong>在这之后，走运些的老哥能被辞退拿个 N+X 赔偿，体面离开，但这个纯纯看运气。不走运的，等待你的只有超多离职老哥留下的活，以及老板的<strong>PUA 或 PIP 关怀套餐</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/006m97Kgly1ft9rx3wg9uj309j09qmxm-20220704214907793.jpg"></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我之前写过一篇关于 PIP 的文章，发在了某乎上，让我意外的是，最近时不时会有老哥看到后私信问我该怎么办，貌似最近大行情变差了，用这种方式劝退的公司越来越多了。</p><p>这是个<strong>屁股决定脑袋</strong>的世界，在老板视角里，用 pip 劝退员工可以省下赔款，如果他不能辞退足够多的人，他的绩效和年终就不好看，自己的利益当然比他人的利益重要。在员工视角里，用 pip 劝退员工的老板真实丧良心，但记住，没有人可以逼你签任何协议。<strong>大家做的都没错，都是各自系统的最优解。</strong></p><br><p>很多行业，你去之前都说是风口，去了之后就凉了，你以为你拿的是主角的剧本，结果连跑龙套都算不上。你也不想当行业冥灯，可人生如戏。</p><p><strong>还真是应了《桃花扇》里的那句唱词 “眼看他起高楼，眼看他宴宾客，眼看他楼塌了”。</strong></p><p>深夜网抑云，破防了兄弟们。</p><p>但发牢骚并不能解决问题，该<strong>想想自己能从这次经历中学到什么？</strong></p><p>一个要凉的业务，它总是会有一些苗头和规律的。今天这篇文章就是讲的这个，不过我相信，就算我告诉你，你也不会信的，<strong>每个人都总觉得自己是例外，</strong>每个人都觉得自己不会在厕所里边吃边哭。</p><p>就像每个舔狗追女神的时候，总感觉自己在她心里是不一样的。这里涉及到一个叫<strong>沉没成本</strong>的概念，不再展开。</p><p>你执意要去山的对面看看海，我很想告诉你山的对面没有海，但我知道，<strong>就算我说了，你也是不会信的，你需要亲自去看看。</strong></p><br><h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但我今天不想。</p><p>点一个<strong>赞</strong>，愿世界和平。</p><p>点一个<strong>在看</strong>，愿所有的伤痛都由发 pip 的那个人承担。</p><p><img src="https://cdn.xiaobaidebug.top/006APoFYly8gqby8ik6hgj30fa0hstft.jpg"></p><p>我是小白，我们下期见。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么mysql的count()方法这么慢？</title>
      <link href="/2022/06/30/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/"/>
      <url>/2022/06/30/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p><img src="https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif"></p><p>兄弟们。</p><p>浅浅的<strong>炫个富</strong>吧。</p><p>说出来你们可能不信。</p><p>手机你们有吗？我有。</p><p><strong>短信</strong>，知道吧？一条一毛钱，<strong>我天天发</strong>。</p><p>你敢想吗？</p><p>所以说，年轻人，有钱是真的好。</p><p>今天，我们就以短信为话题聊起。</p><p>短信，它又叫 SMS。</p><br><p>比如说，你有一张**短信表(sms)**，里面放了各种需要发送的短信信息。</p><p><img src="https://cdn.xiaobaidebug.top/sms%E5%BB%BA%E8%A1%A8sql.png" alt="sms建表sql"></p><p><img src="https://cdn.xiaobaidebug.top/sms%E8%A1%A8.drawio.png" alt="sms表"></p><p>需要注意的是<strong>state 字段，为 0 的时候说明这时候短信还未发送。</strong></p><p>此时还会有一个<strong>异步线程</strong>不断的捞起<strong>未发送（state=0）</strong>的短信数据，执行发短信操作，发送成功之后 state 字段会被<strong>置为 1（已发送）</strong>。也就是说<strong>未发送的数据会不断变少</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1.drawio.png" alt="异步线程发送短信"></p><br><p>假设由于某些原因，你现在需要做一些监控，比如监控的内容是，<strong>你的 sms 数据表里还有没有 state=0（未发送）的短信，方便判断一下堆积的未发送短信大概在什么样的一个量级。</strong></p><p>为了获取<strong>满足某些条件的行数是多少</strong>，我们一般会使用<strong>count()方法</strong>。</p><p>这时候为了获取未发送的短信数据，我们很自然就想到了使用下面的 sql 语句进行查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> sms <span class="keyword">where</span> state <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>然后再把获得数据作为打点发给监控服务。</p><br><p>当数据表小的时候，这是没问题的，但当数据量大的时候，比如未发送的短信到了<strong>百万量级</strong>的时候，你就会发现，<strong>上面的 sql 查询时间会变得很长，最后 timeout 报错，查不出结果了</strong>。</p><br><p>为什么？</p><br><p>我们先从<strong>count()方法的原理</strong>聊起。</p><br><h3 id="count-的原理"><a href="#count-的原理" class="headerlink" title="count()的原理"></a>count()的原理</h3><p>count()方法的目的是计算当前 sql 语句查询得到的<strong>非 NULL 的行数</strong>。</p><p>我们知道 mysql 是分为<strong>server 层和存储引擎层的</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio-20220613163829373.png" alt="Mysql架构"></p><p>存储引擎层里可以选择各种引擎进行存储，最常见的是 innodb、myisam。具体使用哪个存储引擎，可以通过建表 sql 里的<code>ENGINE</code>字段进行指定。比如这篇文章开头的建表 sql 里用了<code>ENGINE=InnoDB</code>，那这张表用的就是 innodb 引擎。</p><p><strong>虽然在 server 层都叫 count()方法，但在不同的存储引擎下，它们的实现方式是有区别的。</strong></p><p>比如同样是<strong>读全表数据</strong> <code>select count(*) from sms；</code>语句。</p><p>使用 <strong>myisam 引擎</strong>的数据表里有个记录当前表里有几行数据的字段，直接读这个字段返回就好了，因此速度快得飞起。</p><p>而使用<strong>innodb 引擎</strong>的数据表，则会选择<strong>体积最小的索引树</strong>，然后通过遍历叶子节点的个数挨个加起来，这样也能得到全表数据。</p><p>因此回到文章开头的问题里，当数据表行数变大后，<strong>单次 count 就需要扫描大量的数据</strong>，因此很可能就会出现超时报错。</p><br><p>那么问题就来了。</p><br><h4 id="为什么-innodb-不能像-myisam-那样实现-count-方法"><a href="#为什么-innodb-不能像-myisam-那样实现-count-方法" class="headerlink" title="为什么 innodb 不能像 myisam 那样实现 count()方法"></a><strong>为什么 innodb 不能像 myisam 那样实现 count()方法</strong></h4><p>myisam 和 innodb 这两个引擎，有几个比较明显的区别，这个是八股文常考了。</p><p>其中<strong>最大的区别在于 myisam 不支持事务，而 innodb 支持事务。</strong></p><p>而事务，有四层隔离级别，其中<strong>默认隔离级别就是可重复读隔离级别（RR）</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="四层隔离级别"></p><p>innodb 引擎通过 MVCC 实现了<strong>可重复隔离级别</strong>，事务开启后，多次执行同样的<strong>select 快照读</strong>，要能读到同样的数据。</p><p>于是我们看个例子。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E4%B8%8D%E5%8D%95%E7%8B%AC%E8%AE%B0%E5%BD%95%E8%A1%A8%E8%A1%8C%E6%95%B0.drawio.png" alt="为什么innodb不单独记录表行数"></p><p>对于两个事务 A 和 B，一开始 sms 表假设就<strong>2 条</strong>数据，那事务 A 一开始确实是读到 2 条数据。事务 B 在这期间插入了 1 条数据，按道理数据库其实有 3 条数据了，但由于可重复读的隔离级别，事务 A 依然还是只能读到 2 条数据。</p><p>因此由于事务隔离级别的存在，<strong>不同的事务在同一时间下，看到的表内数据行数是不一致的</strong>，因此 innodb，没办法，也没必要像 myisam 那样单纯的加个 count 字段信息在数据表上。</p><p>那如果不可避免要使用 count()，有没有办法让它快一点？</p><br><h3 id="各种-count-方法的原理"><a href="#各种-count-方法的原理" class="headerlink" title="各种 count()方法的原理"></a>各种 count()方法的原理</h3><p>count()的括号里，可以放各种奇奇怪怪的东西，想必大家应该看过，比如放个星号*，放个 1，放个索引列啥的。</p><p>我们来分析下他们的执行流程。</p><p><strong>count 方法的大原则是 server 层会从 innodb 存储引擎里读来一行行数据，并且只累计非 null 的值</strong>。但这个过程，根据 count()方法括号内的传参，有略有不同。</p><br><h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p>server 层拿到 innodb 返回的行数据，<strong>不对里面的行数据做任何解析和判断</strong>，默认取出的值肯定都不是 null，直接行数+1。</p><br><h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>server 层拿到 innodb 返回的行数据，每行放个 1 进去，默认不可能为 null，直接行数+1.</p><br><h4 id="count-某个列字段"><a href="#count-某个列字段" class="headerlink" title="count(某个列字段)"></a>count(某个列字段)</h4><p>由于指明了要 count 某个字段，innodb 在取数据的时候，会把这个字段<strong>解析出来</strong>返回给 server 层，所以会<strong>比 count(1)和 count(*)多了个解析字段出来的流程。</strong></p><ul><li>如果这个列字段是<strong>主键 id</strong>，主键是不可能为 null 的，所以 server 层也不用判断是否为 null，innodb 每返回一行，行数结果就+1.</li><li>如果这个列是<strong>普通索引字段</strong>，innodb 一般会<strong>走普通索引</strong>，每返回一行数据，server 层就会判断这个字段是否为 null，不是 null 的情况下+1。当然如果建表 sql 里字段定义为 not null 的话，那就不用做这一步判断直接+1。</li><li>如果这个列<strong>没有加过索引</strong>，那 innodb 可能会全表扫描，返回的每一行数据，server 层都会判断这个字段是否为 null，不是 null 的情况下+1。同上面的情况一样，字段加了 not null 也就省下这一步判断了。</li></ul><p>理解了原理后我们大概可以知道他们的性能排序是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) ≈ <span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="built_in">count</span>(主键id) <span class="operator">&gt;</span> <span class="built_in">count</span>(普通索引列) <span class="operator">&gt;</span> <span class="built_in">count</span>(未加索引列)</span><br></pre></td></tr></table></figure><p><strong>所以说 count(*)，已经是最快的了。</strong></p><br><p>知道真相的我眼泪掉下来。</p><img src="https://cdn.xiaobaidebug.top/u=3123397807,3516361318&fm=253&fmt=auto&app=138&f=JPEG.jpeg" style="zoom:50%;" /><p>那有没有其他更好的办法？</p><br><h3 id="允许粗略估计行数的场景"><a href="#允许粗略估计行数的场景" class="headerlink" title="允许粗略估计行数的场景"></a>允许粗略估计行数的场景</h3><p>我们回过头来细品下文章开头的需求，我们只是希望知道数据库里还有多少短信是堆积在那没发的，具体是 1k 还是 2k 其实都是差不多量级，等到了百万以上，具体数值已经不重要了，我们知道它现在堆积得很离谱，就够了。 因此这个场景，其实是允许使用<strong>比较粗略</strong>的估计的。</p><p><strong>那怎么样才能获得粗略的数值呢？</strong></p><p>还记得我们平时为了查看 sql 执行计划用的<strong>explain 命令</strong>不。</p><p>其中有个<strong>rows</strong>，会用来<strong>估计</strong>接下来执行这条 sql 需要扫描和检查多少行。它是通过采样的方式计算出来的，虽然会有一定的偏差，但它能反映一定的数量级。</p><p><img src="https://cdn.xiaobaidebug.top/explain%E9%87%8C%E7%9A%84rows.png" alt="explain里的rows"></p><p>有些语言的 orm 里可能没有专门的 explain 语法，但是肯定有执行 raw sql 的功能，你<strong>可以把 explain 语句当做 raw sql 传入，从返回的结果里将 rows 那一列读出来使用。</strong></p><p>一般情况下，explain 的 sql 如果能走索引，那会比不走索引的情况更准 。单个字段的索引会比多个字段组成的复合索引要准。索引区分度越高，rows 的值也会越准。</p><p>这种情况几乎满足大部分的监控场景。但总有一些场景，它要求必须得到精确的行数，这种情况该怎么办呢？</p><br><h3 id="必须精确估计行数的场景"><a href="#必须精确估计行数的场景" class="headerlink" title="必须精确估计行数的场景"></a>必须精确估计行数的场景</h3><p>这种场景就比较头疼了，但也不是不能做。</p><p>我们可以单独拉一张新的数据库表，只为保存各种场景下的 count。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `count_table` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `cnt_what` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;各种需要计算的指标&#x27;</span>,</span><br><span class="line">  `cnt` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;cnt指标值&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_cnt_what` (`cnt_what`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/%E4%BF%9D%E5%AD%98%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84count.drawio.png" alt="count_table表保存各种场景下的count"></p><p>当需要获取某个场景下的 cout 值时，可以使用下面的 sql 进行直接读取，<strong>快得飞起</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cnt <span class="keyword">from</span> count_table <span class="keyword">where</span> cnt_what <span class="operator">=</span> &quot;未发送的短信数量&quot;;</span><br></pre></td></tr></table></figure><br><p><strong>那这些 count 的结果值从哪来呢？</strong></p><p>这里分成两种情况。</p><br><h4 id="实时性要求较高的场景"><a href="#实时性要求较高的场景" class="headerlink" title="实时性要求较高的场景"></a>实时性要求较高的场景</h4><p>如果你对这个 cnt 计算结果的实时性要求很高，那你需要<strong>将更新 cnt 的 sql 加入到对应变更行数的事务中</strong>。</p><p>比如我们有两个事务 A 和 B，分别是增加未发送短信和减少未发送短信。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%B0%86%E6%9B%B4%E6%94%B9%E8%A1%A8%E8%A1%8C%E6%95%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8B%E5%8A%A1%E9%87%8C.drawio.png" alt="将更改表行数的操作放入到事务里"></p><p>这样做的<strong>好处</strong>是事务内的 cnt 行数依然符合隔离级别，事务回滚的时候，cnt 的值也会跟着回滚。</p><p><strong>坏处</strong>也比较明显，多个线程对同一个 cnt 进行写操作，会触发悲观锁，多个线程之间需要互相等待。对于<strong>高频写的场景</strong>，性能会有折损。</p><br><h4 id="实时性没那么高的场景"><a href="#实时性没那么高的场景" class="headerlink" title="实时性没那么高的场景"></a>实时性没那么高的场景</h4><p>如果实时性要求不高的话，比如可以一天一次，那你可以通过全表扫描后做计算。</p><p>举个例子，比如上面的短信表，可以<strong>按 id 排序</strong>，每次取出 1w 条数据，<strong>记下这一批里最大的 id，然后下次从最大 id 开始再拿 1w 条数据出来，不断循环。</strong></p><p>对于未发送的短信，就只需要在捞出的那 1w 条数据里，筛选出 state=0 的条数。</p><p><img src="https://cdn.xiaobaidebug.top/batch%E5%88%86%E6%89%B9%E8%8E%B7%E5%8F%96%E7%9F%AD%E4%BF%A1%E8%A1%A8.drawio.png" alt="batch分批获取短信表"></p><p>当然如果有条件，这种场景最好的方式还是<strong>消费 binlog 将数据导入到 hive 里</strong>，然后在 hive 里做查询，不少公司也已经有现成的组件可以做这种事情，不用自己写脚本，岂不美哉。</p><p><img src="https://cdn.xiaobaidebug.top/mysql%E5%90%8C%E6%AD%A5hive.drawio.png" alt="mysql同步hive"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>mysql 用 count 方法<strong>查全表数据</strong>，在不同的存储引擎里实现不同，myisam 有专门字段记录全表的行数，直接读这个字段就好了。而 innodb 则需要一行行去算。</p></li><li><p>性能方面 <code>count(*) ≈ count(1) &gt; count(主键id) &gt; count(普通索引列) &gt; count(未加索引列)</code>，但哪怕是性能最好的 count(*)，由于实现上就需要一行行去算，所以数据量大的时候就是不给力。</p></li><li><p>如果确实需要获取行数，且<strong>可以接受不那么精确的行数（只需要判断大概的量级）</strong>的话，那可以用 explain 里的 rows，这可以满足大部分的监控场景，实现简单。</p></li><li><p><strong>如果要求行数准确</strong>，可以建个新表，里面专门放表行数的信息。</p><ul><li>如果对<strong>实时性要求比较高</strong>的话，可以将更新行数的 sql 放入到对应事务里，这样既能满足事务隔离性，还能快速读取到行数信息。</li><li>如果对<strong>实时性要求不高</strong>，接受一小时或者一天的更新频率，那既可以自己写脚本遍历全表后更新行数信息。也可以将通过监听 binlog 将数据导入 hive，需要数据时直接通过 hive 计算得出。</li></ul></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《丁奇 mysql45 讲》</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>兄弟们，最近有点没出息，沉迷在刘亦菲的新剧里，都快忘了写文这件事了。</p><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但今天，我感觉我不配。</p><p>所以先这样。</p><br><p>但右下角的点赞和再看还是可以走一波的。</p><p>我是小白，我们下期见。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库主键一定要自增的吗？有哪些场景下不建议自增？</title>
      <link href="/2022/06/14/%E5%9B%BE%E8%A7%A3mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E8%A6%81%E8%87%AA%E5%A2%9E%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%8D%E8%87%AA%E5%A2%9E%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%A2%9E%EF%BC%9F/"/>
      <url>/2022/06/14/%E5%9B%BE%E8%A7%A3mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E8%A6%81%E8%87%AA%E5%A2%9E%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%8D%E8%87%AA%E5%A2%9E%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%A2%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>我们平时建表的时候，一般会像下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>出于习惯，我们一般会加一列<strong>id 作为主键</strong>，而这个主键一般边上都有个<code>AUTO_INCREMENT</code>, 意思是这个主键是自增的。自增就是 i++，也就是每次都加 1。</p><p>但问题来了。</p><p><strong>主键 id 不自增行不行？</strong></p><p><strong>为什么要用自增 id 做主键？</strong></p><p><strong>离谱点，没有主键可以吗？</strong></p><p><strong>什么情况下不应该自增？</strong></p><br><p>被这么一波追问，念头都不通达了？</p><p>这篇文章，我会尝试回答这几个问题。</p><br><h3 id="主键不自增行不行"><a href="#主键不自增行不行" class="headerlink" title="主键不自增行不行"></a>主键不自增行不行</h3><p>当然是可以的。比如我们可以把建表 sql 里的<code>AUTO_INCREMENT</code>去掉。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>然后执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`name`)  <span class="keyword">VALUES</span>(<span class="string">&#x27;debug&#x27;</span>);</span><br></pre></td></tr></table></figure><p>这时候会报错<code>Field &#39;id&#39; doesn&#39;t have a default value</code>。也就是说如果你不让主键自增的话，那你在写数据的时候需要自己指定 id 的值是多少，想要主键 id 是多少就写多少进去，不写就报错。</p><p>改成下面这样就好了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`,`name`)  <span class="keyword">VALUES</span>(<span class="number">10</span>, <span class="string">&#x27;debug&#x27;</span>);</span><br></pre></td></tr></table></figure><br><h3 id="为什么要用自增主键"><a href="#为什么要用自增主键" class="headerlink" title="为什么要用自增主键"></a>为什么要用自增主键</h3><p>我们在数据库里保存的数据就跟 excel 表一样，一行行似的。</p><p><img src="https://cdn.xiaobaidebug.top/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png" alt="user表"></p><p>而在底层，这一行行数据，就是保存在一个个<strong>16k 大小的页</strong>里。</p><p>每次都去遍历所有的行性能会不好，于是为了加速搜索，我们可以<strong>根据主键 id，从小到大排列这些行数据</strong>，将这些数据页用<strong>双向链表</strong>的形式组织起来，再将这些页里的部分信息提取出来放到一个新的 16kb 的数据页里，再加入<strong>层级的概念</strong>。于是，一个个数据页就被组织起来了，成为了一棵<strong>B+树索引</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%847.drawio.png" alt="B+树结构"></p><p>而当我们在建表 sql 里声明了<code>PRIMARY KEY (id)</code>时，mysql 的 innodb 引擎，就会为主键 id 生成一个<strong>主键索引</strong>，里面就是通过 B+树的形式来维护这套索引。</p><p>到这里，我们有<strong>两个点</strong>是需要关注的：</p><ul><li>数据页大小是<strong>固定 16k</strong></li><li>数据页内，以及数据页之间，数据主键 id 都是从<strong>小到大排序</strong>的</li></ul><p>由于数据页大小<strong>固定了是 16k</strong>，当我们需要插入一条新的数据，数据页会被慢慢<strong>放满</strong>，当超过 16k 时，这个数据页就有可能会进行<strong>分裂</strong>。</p><p>针对 B+树<strong>叶子节点</strong>，<strong>如果主键是自增的</strong>，那它产生的 id 每次都比前一次要大，所以每次都会将数据加在 B+树<strong>尾部</strong>，B+树的叶子节点本质上是<strong>双向链表</strong>，查找它的首部和尾部，**时间复杂度 O(1)**。而如果此时最末尾的数据页满了，那创建个新的页就好。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%8F%B6%E5%AD%90%E6%BB%A1%E4%BA%86%E4%BD%86%E9%9D%9E%E5%8F%B6%E5%AD%90%E6%9C%AA%E6%BB%A1.drawio-20220606092636547.png" alt="主键id自增的情况"></p><p><strong>如果主键不是自增的</strong>，比方说上次分配了 id=7，这次分配了 id=3，为了让新加入数据后<strong>B+树的叶子节点还能保持有序</strong>，它就需要往叶子结点的中间找，查找过程的<strong>时间复杂度是 O(lgn)<strong>，如果这个页正好也满了，这时候就需要进行</strong>页分裂</strong>了。并且页分裂操作本身是需要加<strong>悲观锁</strong>的。总体看下来，自增的主键遇到页分裂的可能性更少，因此性能也会更高。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BB%E9%94%AEid%E4%B8%8D%E8%87%AA%E5%A2%9E%E7%9A%84%E6%83%85%E5%86%B5.drawio.png" alt="主键id不自增的情况"></p><br><h3 id="没有主键可以吗"><a href="#没有主键可以吗" class="headerlink" title="没有主键可以吗"></a>没有主键可以吗</h3><p>mysql 表如果没有主键索引，查个数据都得全表扫描，那既然它这么重要，我今天就不当人了，<strong>不声明主键，可以吗？</strong></p><p>嗯，你完全可以不声明主键。</p><p>你确实可以在建表 sql 里写成这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure><p>看起来确实是没有主键的样子。然而实际上，mysql 的 innodb 引擎内部会帮你生成一个名为<code>ROW_ID</code>列，它是个 6 字节的隐藏列，你平时也看不到它，但实际上，它也是自增的。有了这层兜底机制保证，<strong>数据表肯定会有主键和主键索引</strong>。</p><p>跟 ROW_ID 被隐藏的列还有<code>trx_id</code>字段，用于记录当前这一行数据行是被<strong>哪个事务</strong>修改的，和一个<code>roll_pointer</code>字段，这个字段是用来指向当前这个数据行的上一个版本，通过这个字段，可以为这行数据形成一条版本链，从而实现<strong>多版本并发控制（MVCC）</strong>。有没有很眼熟，这个在之前写的<a href="https://mp.weixin.qq.com/s/SR0ZL1zAc_0QIQvpDCOANw">文章</a>里出现过。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%9A%90%E8%97%8F%E7%9A%84row_id%E5%88%97.drawio.png" alt="隐藏的row_id列"><br></p><h3 id="有没有建议主键不自增的场景"><a href="#有没有建议主键不自增的场景" class="headerlink" title="有没有建议主键不自增的场景"></a>有没有建议主键不自增的场景</h3><p>前面提到了主键自增可以带来很多好处，事实上<strong>大部分场景下，我们都建议主键设为自增。</strong></p><p>那有没有不建议主键自增的场景呢？</p><br><h4 id="mysql-分库分表下的-id"><a href="#mysql-分库分表下的-id" class="headerlink" title="mysql 分库分表下的 id"></a>mysql 分库分表下的 id</h4><p>聊到分库分表，那我就需要说明下，<strong>递增和自增的区别</strong>了，<strong>自增</strong>就是每次都+1，而<strong>递增</strong>则是新的 id 比上一个 id 要大就行了，具体大多少，没关系。</p><p>之前写过一篇<a href="https://mp.weixin.qq.com/s/HShytuc9Sw3p3kwCfbRbXw">文章</a>提到过，mysql 在水平分库分表时，一般有两种方式。</p><p>一种分表方式是通过<strong>对 id 取模进行分表</strong>，这种要求递增就好，不要求严格自增，因为取模后数据会被分散到多个分表中，就算 id 是严格自增的，在分散之后，都只能保证每个分表里 id 只能是递增的。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E5%8F%96%E6%A8%A1%E5%88%86%E8%A1%A8.drawio.png" alt="根据id取模分表"></p><p>另一种分表方式是<strong>根据 id 的范围进行分表（分片）</strong>，它会划出一定的范围，比如以 2kw 为一个分表的大小，那 0<del>2kw 就放在这张分表中，2kw</del>4kw 放在另一张分表中，数据不断增加，分表也可以不断增加，<strong>非常适合动态扩容</strong>，但它要求<strong>id 自增</strong>，如果<strong>id 递增</strong>，数据则会出现<strong>大量空洞</strong>。举个例子，比如第一次分配 id=2，第二次分配 id=2kw，这时候第一张表的范围就被打满了，后面再分配一个 id，比如是 3kw，就只能存到 2kw<del>4kw（第二张）的分表中。那我在 0</del>2kw 这个范围的分表，也就存了<strong>两条数据</strong>，这太浪费了。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E8%8C%83%E5%9B%B4%E5%88%86%E8%A1%A8.png" alt="根据id范围分表"></p><p>但不管哪种分表方式，一般是<strong>不可能继续用原来表里的自增主键的</strong>，原因也比较好理解，原来的每个表如果都从 0 开始自增的话，那好几个表就会出现好几次重复的 id，根据 id 唯一的原则，这显然不合理。</p><br><p>所以我们在分库分表的场景下，插入的 id 都是专门的 id 服务生成的，如果是要严格自增的话，那一般会通过 redis 来获得，当然不会是一个 id 请求获取一次，一般会<strong>按批次去获得，比如一次性获得 100 个。快用完了再去获取下一批 100 个。</strong></p><p>但这个方案有个问题，它严重依赖 redis，如果 redis 挂了，那整个功能就傻了。</p><p>有没有不依赖于其他第三方组件的方法呢？</p><br><h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>有，比如<strong>Twitter 开源的雪花算法。</strong></p><p>雪花算法通过 64 位有特殊含义的数字来组成 id。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.d4rawio.png" alt="雪花算法"></p><p>首先<strong>第 0 位</strong>不用。</p><p>接下来的<strong>41 位</strong>是<strong>时间戳</strong>。精度是<strong>毫秒</strong>，这个大小大概能表示个<code>69年</code>左右，因为时间戳随着时间流逝肯定是越来越大的，所以这部分决定了生成的 id 肯定是越来越大的。</p><p>再接下来的<strong>10 位</strong>是指产生这些雪花算法的<strong>工作机器 id</strong>，这样就可以让每个机器产生的 id 都具有相应的标识。</p><p>再接下来的<strong>12 位</strong>，<strong>序列号</strong>，就是指这个工作机器里生成的递增数字。</p><p>可以看出，只要处于同一毫秒内，所有的雪花算法 id 的前 42 位的值都是一样的，因此在这一毫秒内，能产生的 id 数量就是 <code>2的10次方✖️2的12次方</code>，大概<code>400w</code>，肯定是够用了，甚至有点多了。</p><br><p><strong>但是！</strong></p><p>细心的兄弟们肯定也发现了，雪花算法它算出的数字动不动就比上次的数字多个几百几万的，也就是它生成的 id 是<strong>趋势递增</strong>的，并不是严格**+1 自增**的，也就是说它并不太适合于根据范围来分表的场景。这是个非常疼的问题。</p><p>还有个<strong>小问题</strong>是，那 10 位工作机器 id，我每次扩容一个工作机器，这个机器怎么知道自己的 id 是多少呢？是不是得从某个地方读过来。</p><p><strong>那有没有一种生成 id 生成方案，既能让分库分表能做到很好的支持动态扩容，又能像雪花算法那样并不依赖 redis 这样的第三方服务。</strong></p><p>有。这就是这篇文章的重点了。</p><br><h5 id="适合分库分表的-uuid-算法"><a href="#适合分库分表的-uuid-算法" class="headerlink" title="适合分库分表的 uuid 算法"></a>适合分库分表的 uuid 算法</h5><p>我们可以参考雪花算法的实现，设计成下面这样。注意下面的每一位，<strong>都是十进制</strong>，而不是二进制。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%80%82%E5%90%88%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84uuid%E7%AE%97%E6%B3%95.d43rawio.png" alt="适合分库分表的uuid算法"></p><p>开头的<strong>12 位</strong>依然是时间，但并不是时间戳，雪花算法的时间戳精确到毫秒，我们用不上这么细，我们改为<code>yyMMddHHmmss</code>，注意开头的 yy 是两位，也就是这个方案能保证到 2099 年之前，id 都不会重复，能用到重复，那也是真·百年企业。同样由于最前面是时间，随着时间流逝，也能保证 id 趋势递增。</p><p>接下来的<strong>10 位</strong>，用<strong>十进制</strong>的方式表示工作机器的 ip，就可以把 12 位的 ip 转为 10 位的数字，它可以保证全局唯一，只要服务起来了，也就知道自己的 ip 是多少了，不需要像雪花算法那样从别的地方去读取 worker id 了，又是一个小细节。</p><p><img src="https://cdn.xiaobaidebug.top/0bec52deb6276987.jpeg"></p><p>在接下来的<strong>6 位</strong>，就用于生成序列号，它能支持每秒钟生成 100w 个 id。</p><p>最后的<strong>4 位</strong>，也是这个 id 算法最妙的部分。它<strong>前 2 位</strong>代表分库 id，<strong>后 2 位</strong>代表分表 id。也就是支持一共<code>100*100=1w</code>张分表。</p><br><p>举个例子，假设我只用了 1 个分库，当我一开始只有 3 张分表的情况下，那我可以通过配置，要求生成的 uuid 最后面的 2 位，取值只能是[0,1,2]，分别对应三个表。这样我生成出来的 id，就能非常均匀的落到三个分表中，这还<strong>顺带解决了单个分表热点写入的问题。</strong></p><p>如果随着业务不断发展，需要新加入两张新的表(3 和 4)，同时第 0 张表有点满了，不希望再被写了，那就将配置改为[1,2,3,4]，这样生成的 id 就不会再插入到对应的 0 表中。同时还可以加入生成 id 的<strong>概率和权重</strong>来调整哪个分表落更多数据。</p><p>有了这个新的 uuid 方案，我们<strong>既可以保证生成的数据趋势递增，同时也能非常方便扩展分表</strong>。非常 nice。</p><br><p>数据库有那么多种，mysql 只是其中一种，那其他数据库也是要求主键自增吗？</p><br><h4 id="tidb-的主键-id-不建议自增"><a href="#tidb-的主键-id-不建议自增" class="headerlink" title="tidb 的主键 id 不建议自增"></a>tidb 的主键 id 不建议自增</h4><p>tidb 是一款分布式数据库，作为 mysql 分库分表场景下的替代产品，可以更好的对数据进行分片。</p><p>它通过引入<strong>Range</strong>的概念进行数据表分片，比如第一个分片表的 id 在 0<del>2kw，第二个分片表的 id 在 2kw</del>4kw。这其实就是<strong>根据 id 范围进行数据库分表</strong>。</p><p>它的语法几乎跟 mysql 一致，用起来大部分时候是无感的。</p><p>但跟 mysql 有一点很不一样的就是，mysql 建议 id 自增，但<strong>tidb 却建议使用随机的 uuid</strong>。原因是如果 id 自增的话，根据范围分片的规则，一段时间内生成的 id 几乎都会落到同一个分片上，比如下图，从<code>3kw</code>开始的自增 uuid，几乎都落到<code>range 1</code>这个分片中，而其他表却几乎不会有写入，性能没有被利用起来。出现<strong>一表有难，多表围观</strong>的场面，这种情况又叫<strong>写热点</strong>问题。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%86%99%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98.drawio.png" alt="写热点问题"></p><p>所以为了充分的利用多个分表的写入能力，tidb 建议我们写入时使用<strong>随机 id</strong>，这样数据就能被均匀分散到多个分片中。</p><br><h4 id="用户-id-不建议用自增-id"><a href="#用户-id-不建议用自增-id" class="headerlink" title="用户 id 不建议用自增 id"></a>用户 id 不建议用自增 id</h4><p>前面提到的不建议使用自增 id 的场景，都是技术原因导致的，而下面介绍的这个，单纯是因为业务。</p><p>举个例子吧。</p><p>如果你能知道一个产品每个月，新增的用户数有多少，这个对你来说会是有用的信息吗？</p><p>对程序员来说，可能这个信息价值不大。</p><p>但如果你是做投资的呢，或者是分析竞争对手呢？</p><p>那反过来。</p><p>如果你发现你的竞争对手，总能非常清晰的知道你的产品每个月新进的注册用户是多少人，你会不会心里毛毛的？</p><p>如果真出现了这问题，先不要想是不是有内鬼，先检查下你的用户表主键是不是自增的。</p><img src="https://cdn.xiaobaidebug.top/%E6%9C%89%E5%86%85%E9%AC%BC.jpeg" alt="有内鬼" style="zoom:30%;" /><p><strong>如果用户 id 是自增的，那别人只要每个月都注册一个新用户，然后抓包得到这个用户的 user_id，然后跟上个月的值减一下，就知道这个月新进多少用户了。</strong></p><p>同样的场景有很多，有时候你去小店吃饭，发票上就写了你是今天的第几单，那大概就能估计今天店家做了多少单。你是店家，你心里也不舒服吧。</p><p>再比如说一些小 app 的商品订单 id，如果也做成自增的，那就很容易可以知道这个月成了多少单。</p><p>类似的事情有很多，这些场景都建议使用趋势递增的 uuid 作为主键。</p><p>当然，<strong>主键保持自增，但是不暴露给前端，那也行，那前面的话，你当我没说过</strong>。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>建表 sql 里主键边上的<code>AUTO_INCREMENT</code>，可以让主键自增，去掉它是可以的，但这就需要你在 insert 的时候自己设置主键的值。</p></li><li><p>建表 sql 里的 <code>PRIMARY KEY</code> 是用来声明主键的，如果去掉，那也能建表成功，但 mysql 内部会给你偷偷建一个 <code>ROW_ID</code>的隐藏列作为主键。</p></li><li><p>由于 mysql 使用<strong>B+树索引，叶子节点是从小到大排序的</strong>，如果使用自增 id 做主键，这样每次数据都加在 B+树的最后，比起每次加在 B+树中间的方式，加在最后可以有效<strong>减少页分裂的问题。</strong></p></li><li><p>在分库分表的场景下，我们可以通过 redis 等第三方组件来获得严格自增的主键 id。如果不想依赖 redis，可以参考雪花算法进行<strong>魔改</strong>，<strong>既能保证数据趋势递增，也能很好的满足分库分表的动态扩容。</strong></p></li><li><p>并不是所有数据库都建议使用自增 id 作为主键，比如<strong>tidb 就推荐使用随机 id</strong>，这样可以有效避免<strong>写热点</strong>的问题。而对于一些敏感数据，比如用户 id，订单 id 等，如果使用自增 id 作为主键的话，外部通过抓包，很容易可以知道新进用户量，成单量这些信息，所以需要<strong>谨慎考虑</strong>是否继续使用自增主键。</p></li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我比较记仇，最近有不少兄弟们在评论区叫我 diao 毛。</p><p><strong>我都记住了。</strong></p><p>但是，只要兄弟们还能给右下角的<strong>点赞和在看</strong>来上那么一下的话。</p><p>我觉得，<strong>这口气，也不是不能忍。</strong></p><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p><p>但我今天不想。</p><p>所以先这样。</p><p>我是小白，我们下期见。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何调用一个只支持batch_call的服务？</title>
      <link href="/2022/06/09/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F/"/>
      <url>/2022/06/09/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>我们先来说下标题是什么意思。</p><br><p>为了更好的理解我说的是啥，我们来举个例子。</p><p>假设你现在在做一个<strong>类似 B 站</strong>的系统，里面放了各种视频。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220529201338638.png"></p><p>用户每天在里头上传各种视频。</p><p>按理说每个视频都要去<strong>审查</strong>一下有没有搞颜色，但总不能人眼挨个看吧。</p><p>毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的<strong>算法服务</strong>去做检测。</p><p>但也不能上来就整个视频每一帧都拿去做审查吧，所以会在每个视频里根据<strong>时长</strong>和<strong>视频类型</strong>随机抽出好几张图片去做审查，比如视频标签是美女的，算法爱看，那多抽几张。标签是编程的，狗都不看，就少抽几张。</p><p>将这些抽出来的图片，送去审查。</p><br><p>为了实现这个功能，我们会以<strong>视频为维度</strong>去做审核，而每个视频里都会有 N 张<strong>数量不定的图片</strong>，下游服务是个使用<strong>GPU</strong>去检测图片的<strong>算法服务</strong>。</p><p><strong>现在问题来了</strong>，下游服务的算法开发告诉你，这些个下游服务，它<strong>不支持很高的并发</strong>，但请求传参里给你加了个数组，你可以<strong>批量（batch）传入</strong>一个比较大的图片数组，通过这个方式可以提升点图片处理量。</p><br><p>于是，我们的场景就变成。</p><p><strong>上游服务</strong>的<strong>入参</strong>是<strong>一个</strong>视频和它的 N 张图片，<strong>出参</strong>是这个视频是否审核通过。</p><p><strong>下游服务</strong>的<strong>入参</strong>是 N 张图片的，<strong>出参</strong>是这个视频是否审核通过。</p><p><img src="https://cdn.xiaobaidebug.top/batch_call%E4%B8%8A%E4%B8%8B%E6%B8%B8.drawio.png" alt="batch_call上下游"></p><br><p><strong>现在我们想要用上游服务接入下游服务。</strong>该怎么办？</p><p>看上去挺好办的，一把梭不就完事了吗？</p><p>当一个视频进来，就拿着视频的十多张图片作为一个 batch 去进行调用。</p><p><strong>有几个视频进来，就开几个这样的并发。</strong></p><p>这么做的结果就是，当并发大一点时，你会发现性能很差，并且性能非常不稳定，比如像下面的监控图一样一会 3qps，一会 15qps。处理的图片也只支持 20qps 左右。</p><p><strong>狗看了都得摇头。</strong></p><p><img src="https://cdn.xiaobaidebug.top/image-20220528224806387.png" alt="图1-直接调用时qps很低"></p><p><img src="https://cdn.xiaobaidebug.top/image-20220528225037987.png"></p><p>这可如何是好？</p><br><h3 id="为什么下游需要-batch-call"><a href="#为什么下游需要-batch-call" class="headerlink" title="为什么下游需要 batch call"></a>为什么下游需要 batch call</h3><p>本着<strong>先问是不是，再问为什么</strong>的精神，我们先看看为啥下游的要求会如此别致。</p><p>为什么同样都是处理多张图片，下游不搞成支持并发而要搞成批量调用（batch call）？</p><p>这个设定有点奇怪？</p><p>其实不奇怪，在算法服务中<strong>甚至很常见</strong>，举个例子你就明白了。</p><p>同样是处理多张图片，为了简单，我就假设是三张吧。如果是用<strong>单个 cpu</strong>去处理的话。那不管是并发还是 batch 进来，由于 cpu 内部的<strong>计算单元有限</strong>，所以你可以简单理解为，这三张图片，就是<strong>串行</strong>去计算的。</p><p><img src="https://cdn.xiaobaidebug.top/cpu%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B2.drawio.png" alt="cpu处理图片时的流程"></p><p>我计算第一张图片是否能审核通过，跟第二张图片是否能审核通过，这两者没有逻辑关联，因此按道理两张图片是可以<strong>并行</strong>计算。</p><p>奈何我 CPU 计算单元有限啊，做不到啊。</p><p>但是。</p><p><strong>如果我打破计算单元有限的这个条件，给 CPU 加入超多计算单元，并且弱化一些对于计算没啥用处的组件，比如 cache 和控制单元。</strong>那我们就有足够的算力可以让这些图片的计算<strong>并行</strong>起来了。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87.drawio.png" alt="并行处理图片"></p><p>是的，把 CPU 这么一整，它其实就变成了 GPU。</p><p><img src="https://cdn.xiaobaidebug.top/GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB2.drawio.png" alt="GPU和CPU的区别"></p><p>上面的讲解只是为了方便理解，实际上，gpu 会以更细的粒度去做并发计算，比如可以细到图片里的<strong>像素</strong>级别。</p><p>这也是为什么如果我们跑一些 3d 游戏的时候，需要用到显卡，因为它可以快速的并行计算画面里每个地方的光影，远近效果啥的，然后渲染出画面。</p><br><p><strong>回到为什么要搞成 batch call 的问题中。</strong></p><p>其实一次算法服务调用中，在数据真正进入 GPU 前，其实也使用了 CPU 做一些前置处理。</p><p>因此，我们可以简单的将一次调用的时间理解成做了下面这些事情。</p><p><img src="https://cdn.xiaobaidebug.top/GPU%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B.drawio.png" alt="GPU处理图片时的流程"></p><p>服务由 CPU 逻辑和 GPU 处理逻辑组成，调用进入服务后，会有一些前置逻辑，它需要 CPU 来完成，然后才使用 GPU 去进行并行计算，将结果返回后又有一些后置的 CPU 处理逻辑。中间的 GPU 部分，管是计算 1 张图，还是计算 100 张图，只要算力支持，那它们都是并行计算的，耗时都差不多。</p><p>如果把这多张图片拆开，<strong>并发去调用</strong>这个算法服务，那就有 N 组这样的 CPU+GPU 的消耗，而中间的并行计算，其实没有利用到位。</p><p>并且还会多了前置和后置的 CPU 逻辑部分，算法服务一般都是 python 服务，主流的一些 web 框架几乎都是以<strong>多进程</strong>，<strong>而不是多线程</strong>的方式去处理外部请求，这就有可能导致额外的<strong>进程间切换消耗</strong>。</p><p>当并发的请求多了，请求处理不过来，后边来的请求就需要等前边的处理完才能被处理，后面的请求耗时看起来就会变得特别大。这也是上面图 1 里，接口延时（latency）像过山车那样往上涨的原因。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220602225740411.png" alt="还是上面的图1的截图，一张图用两次哈哈"></p><p>按理说<strong>减少并发，增大每次调用时的图片数量</strong>，就可以解决这个问题。</p><p>这就是推荐 batch call 的原因。</p><p>但问题又来了。</p><p>每次调用，上游服务输入的是一个视频以及它的几张图片，调用下游时，batch 的数量按道理就只能是这几张图片的数量，<strong>怎么才能增大 batch 的数量呢？</strong></p><p>这里的调用，就需要分为<strong>同步调用和异步调用</strong>了。</p><br><h3 id="同步调用和异步调用的区别"><a href="#同步调用和异步调用的区别" class="headerlink" title="同步调用和异步调用的区别"></a>同步调用和异步调用的区别</h3><p>同步调用，意思是上游发起请求后，<strong>阻塞等待</strong>，下游处理逻辑后返回结果给上游。常见的形式就像我们平时做的 http 调用一样。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="同步调用"></p><p>异步调用，意思是上游发起请求后<strong>立马返回</strong>，下游收到消息后慢慢处理，处理完之后再通过某个形式通知上游。常见的形式是使用消息队列，也就是 mq。将消息发给 mq 后，下游消费 mq 消息，触发处理逻辑，然后再把处理结果发到 mq，上游消费 mq 的结果。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="异步调用"></p><br><h3 id="异步调用的形式接入"><a href="#异步调用的形式接入" class="headerlink" title="异步调用的形式接入"></a>异步调用的形式接入</h3><p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.drawio.png" alt="异步调用的实现方式"></p><p>回到我们文章开头提到的例子，当上游服务收到一个请求（一个视频和它对应的图片），这时候上游服务作为生产者将这个数据写入到 mq 中，请求返回。然后新造一个 C 服务，负责批量消费 mq 里的消息。这时候服务 C 就可以根据下游服务的性能控制自己的消费速度，比如一次性消费 10 条数据（视频），每个数据下面挂了 10 个图片，那我一次 batch 的图片数量就是 10*10=100 张，原来的 10 次请求就变为了 1 次请求。这对下游就相当的友好了。</p><p>下游返回结果后，服务 C 将结果写入到 mq 的另外一个 topic 下，由上游去做消费，这样就结束了整个调用流程。</p><br><p>当然上面的方案，如果你把 mq 换成数据库，一样是 ok 的，这时候服务 C 就可以不断的定时轮询数据库表，看下哪些请求没处理，把没处理的请求批量捞出来再 batch call 下游。不管是 mq 还是数据库，它们的作用无非就是<strong>作为中转，暂存数据，让服务 C 根据下游的消费能力，去消费这些数据。</strong></p><p>这样不管后续要加入多少个新服务，它们都可以在原来的基础上做扩展，如果是 mq，加 topic，如果是数据库，则加数据表，每个新服务都可以根据自己的消费能力去调整消费速度。</p><p><img src="https://cdn.xiaobaidebug.top/mq%E4%B8%B2%E8%81%94%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%8D%E5%8A%A1.drawio.png" alt="mq串联多个不同性能的服务"></p><p><strong>其实对于这种上下游服务处理性能不一致的场景，最适合用的就是异步调用。而且涉及到的服务性能差距越大，服务个数越多，这个方案的优势就越明显。</strong></p><br><h3 id="同步调用的方式接入"><a href="#同步调用的方式接入" class="headerlink" title="同步调用的方式接入"></a>同步调用的方式接入</h3><p>虽然异步调用在这种场景下的优势很明显，但也有个缺点，就是它需要最上游的调用方能接受用异步的方式去消费结果。其实涉及到算法的服务调用链，都是比较耗时的，用异步接口非常合理。但合理归合理，有些最上游他不一定听你的，就是不能接受异步调用。</p><p>这就需要采用同步调用的方案，但怎么才能把同步接口改造得更适合这种调用场景，这也是这篇文章的重点。</p><br><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>如果直接将请求打到下游算法服务，下游根本吃不消，因此首先需要做的就是给在上游调用下游的地方，加入一个速率限制（rate limit）。</p><p><strong>这样的组件一般也不需要你自己写，几乎任何一个语言里都会有现成的。</strong></p><p>比如 golang 里可以用<code>golang.org/x/time/rate</code>库，它其实是用令牌桶算法实现的限流器。如果不知道令牌桶是啥也没关系，不影响理解。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%99%90%E6%B5%81%E5%99%A8%E9%80%BB%E8%BE%91.png" alt="限流器逻辑"></p><p>当然，这个限制的是<strong>当前这个服务</strong>调用下游的 qps，也就是所谓的<strong>单节点限流</strong>。如果是多个服务的话，网上也有不少现成的<strong>分布式限流</strong>框架。但是，还是那句话，<strong>够用就好</strong>。</p><p>限流只能保证下游算法服务不被压垮，并不能提升单次调用 batch 的图片数量，有没有什么办法可以解决这个问题呢？</p><br><h4 id="参考-Nagle-算法的做法"><a href="#参考-Nagle-算法的做法" class="headerlink" title="参考 Nagle 算法的做法"></a>参考 Nagle 算法的做法</h4><p>我们熟悉的 TCP 协议里，有个算法叫 Nagle 算法，设计它的目的，就是为了避免一次传过少数据，提高数据包的有效数据负载。</p><p>当我们想要发送一些数据包时，数据包会被放入到一个缓冲区中，不立刻发送，那什么时候会发送呢？</p><p>数据包会在以下两个情况被发送：</p><ul><li>缓冲区的数据包长度达到某个长度（MSS）时。</li><li>或者等待超时（一般为<code>200ms</code>）。在超时之前，来的那么多个数据包，就是凑不齐 MSS 长度，现在超时了，不等了，立即发送。</li></ul><p>这个思路就非常值得我们参考。我们完全可以自己在代码层实现一波，实现也非常简单。</p><p>1.我们定义一个带锁的全局队列（链表）。</p><p>2.当上游服务输入一个视频和它对应的 N 张图片时，就加锁将这 N 张<strong>图片数据</strong>和一个<strong>用来存放返回结果的结构体</strong>放入到全局队列中。然后死循环读这个结构体，直到它有结果。就有点像阻塞等待了。</p><p>3.同时在服务启动时就起一个<strong>线程 A</strong>专门用于<strong>收集</strong>这个全局队列的图片数据。<strong>线程 A</strong>负责发起调用下游服务的请求，但只有在下面两个情况下会发起请求</p><ul><li><p>当收集的图片数量达到 xx 张的时候</p></li><li><p>距离上次发起请求过了 xx 毫秒（超时）</p><p>4.调用下游结束后，再根据一开始传入的数据，将调用结果拆开来，送回到刚刚提到的<strong>用于存放结果的结构体</strong>中。</p><p>5.第 2 步里的死循环因为<strong>存放返回结果的结构体</strong>，有值了，就可以跳出死循环，继续执行后面的逻辑。</p></li></ul><p><img src="https://cdn.xiaobaidebug.top/batch_call%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%E6%94%B9%E9%80%A0.drawio%20(1).png" alt="batch_call同步调用改造"></p><p>这就像公交车站一样，公交车站不可能每来一个顾客就发一辆公交车，当然是希望车里顾客越多越好。上游每来一个请求，就把请求里的图片，也就是乘客，塞到公交车里，公交车要么到点发车（向下游服务发起请求），要么车满了，也没必要等了，直接发车。这样就保证了每次发车的时候公交车里的顾客数量足够多，发车的次数尽量少。</p><br><p>大体思路就跟上面一样，如果是用 go 来实现的话，就会更加简单。</p><p>比如第 1 步里的<strong>加锁全局队列</strong>可以改成<strong>有缓冲长度的 channel</strong>。第 2 步里的”<strong>用来存放结果的结构体</strong>“，也可以改成<strong>另一个无缓冲 channel</strong>。执行 res := &lt;-ch， 就可以做到<strong>阻塞等待</strong>的效果。</p><p>而核心的仿 Nagle 的代码也大概长下面这样。当然<strong>不看也没关系，反正你已经知道思路了</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">size := <span class="number">100</span></span><br><span class="line"><span class="comment">// 这个数组用于收集视频里的图片，每个 IVideoInfo 下都有N张图片</span></span><br><span class="line">videoInfos := <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line"><span class="comment">// 设置一个200ms定时器</span></span><br><span class="line">tick := time.NewTicker(<span class="number">200</span> * time.Microsecond)</span><br><span class="line"><span class="keyword">defer</span> tick.Stop()</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="comment">// 由于定时器，每200ms，都会执行到这一行</span></span><br><span class="line"><span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(videoInfos) &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 200ms超时，去请求下游</span></span><br><span class="line">limitStartFunc(videoInfos, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 请求结束后把之前收集的数据清空，重新开始收集。</span></span><br><span class="line">videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AddChan就是所谓的全局队列</span></span><br><span class="line"><span class="keyword">case</span> videoInfo, ok := &lt;-AddChan:</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line"><span class="comment">// 通道关闭时，如果还有数据没有去发起请求，就请求一波下游服务</span></span><br><span class="line">limitStartFunc(videoInfos, <span class="literal">false</span>)</span><br><span class="line">videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">videoInfos = <span class="built_in">append</span>(videoInfos, videoInfo)</span><br><span class="line"><span class="keyword">if</span> videoInfos 内的图片满足xx数量 &#123;</span><br><span class="line">limitStartFunc(videoInfos, <span class="literal">false</span>)</span><br><span class="line">videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line"><span class="comment">// 重置定时器</span></span><br><span class="line">tick.Reset(<span class="number">200</span> * time.Microsecond)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><p>通过这一操作，上游每来一个请求，都会将视频里的图片收集起来，堆到一定张数的时候再统一请求，大大提升了每次 batch call 的图片数量，同时也减少了调用下游服务的次数。<strong>真·一举两得</strong>。</p><p>优化的效果也比较明显，上游服务支持的 qps 从原来不稳定的 3q~15q 变成稳定的 90q。下游的接口耗时也变得稳定多了，从原来的过山车似的飙到 15s 变成稳定的 500ms 左右。处理的图片的速度也从原来 20qps 提升到 350qps。</p><p>到这里就已经大大超过业务需求的预期（40qps）了，够用就好，多一个 qps 都是浪费。</p><p>可以了，下班吧。</p><p><img src="https://cdn.xiaobaidebug.top/image-20220528215806920.png"></p><p><img src="https://cdn.xiaobaidebug.top/image-20220529171810510.png"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>为了充分利用<strong>GPU</strong>并行计算的能力，不少算法服务会希望上游通过加大<strong>batch</strong>的同时减少并发的方式进行接口调用。</li><li>对于上下游性能差距明显的服务，建议配合<strong>mq</strong>采用<strong>异步调用</strong>的方式将服务串联起来。</li><li>如果非得使用<strong>同步调用</strong>的方式进行调用，建议模仿<strong>Nagle 算法</strong>的形式，攒一批数据再发起请求，这样既可以增大 batch，同时减少并发，真·一举两得，<strong>亲测有效</strong>。</li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>讲了那么多可以提升性能的方式，现在需求来了，如果你资源充足，但时间不充足，那还是直接同步调用一把梭吧。</p><p>性能不够？<strong>下游加机器，gpu 卡，买！</strong></p><p>然后下个季度再提起一个技术优化，<strong>性能提升 xx%，cpu，gpu 减少 xx%。</strong></p><p>有没有闻到？</p><p>这是 kpi 的味道。</p><p>又是一个小细节，学到了的兄弟们评论区打个【<strong>学到了</strong>】。</p><br><hr><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" /><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>啥？分库分表会带来读扩散问题？怎么解决？？？</title>
      <link href="/2022/05/25/%E5%9B%BE%E8%A7%A3mysql/%E5%95%A5%EF%BC%9F%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%B8%A6%E6%9D%A5%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%9F%EF%BC%9F/"/>
      <url>/2022/05/25/%E5%9B%BE%E8%A7%A3mysql/%E5%95%A5%EF%BC%9F%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E4%BC%9A%E5%B8%A6%E6%9D%A5%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F%EF%BC%9F%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>今天这篇文章，其实也是我曾经面试中遇到过的真题。</p><p><strong>分库分表</strong>大家可能听得多了，但<strong>读扩散</strong>问题大家了解吗？</p><p>这里涉及到几个问题。</p><p>分库分表是什么？</p><p>读扩散问题是什么？</p><p>分库分表为什么会引发读扩散问题？</p><p>怎么解决读扩散问题？</p><p>能不能不要在评论区叫我刁毛？</p><br><p><img src="https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif"></p><p>不好意思，失态了。</p><br><span id="more"></span>这些问题还是比较有意思的。<p>相信兄弟们也一定有机会遇到哈哈哈。</p><p>我们先从分库分表的话题聊起吧。</p><br><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p>我们平时做项目开发。一开始，通常都先用一张数据表，而一般来说数据表写到 2kw 条数据之后，底层 B+树的层级结构就可能会变高，不同层级的数据页一般都放在磁盘里不同的地方，换言之，磁盘 IO 就会增多，带来的便是查询性能变差。<strong>如果对上面这句话有疑惑的话，可以去看下我之前写的文章。</strong></p><p>于是，当我们单表需要管理的数据变得越来越多，就不得不考虑数据库<strong>分表</strong>。而这里的分表，分为<strong>水平分表和垂直分表</strong>。</p><p><strong>垂直分表</strong>的原理比较简单，一般就是把某几列拆成一个新表，这样单行数据就会变小，B+树里的单个数据页（固定 16kb）内能放入的行数就会变多，从而使单表能放入更多的数据。</p><p>垂直分表没有太多可以说的点。下面，我们重点说说最常见的<strong>水平分表</strong>。</p><p>水平分表有好几种做法，但不管是哪种，本质上都是将原来的 <code>user</code> 表，变成 <code>user_0, user1, user2 .... uerN</code>这样的 N 多张小表。</p><p>从读写一张 user<strong>大表</strong>，变成读写 user_1 … userN 这样的 N 张<strong>小表</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E5%88%86%E8%A1%A83.png" alt="分表"></p><p>每一张小表里，只保存一部分数据，但具体保存多少，这个自己定，一般就订个<strong>500w~2kw</strong>。</p><p><strong>那分表具体怎么做？</strong></p><br><h4 id="根据-id-范围分表"><a href="#根据-id-范围分表" class="headerlink" title="根据 id 范围分表"></a>根据 id 范围分表</h4><p>我认为最好用的，是根据 id 范围进行分表。</p><p>我们假设每张分表能放<code>2kw</code>行数据。那 user0 就放主键 id 为<code>1~2kw</code>的数据。user1 就放 id 为<code>2kw+1 ~ 4kw</code>，user2 就放 id 为<code>4kw+1 ~ 6kw</code>， userN 就放 <code>2N kw+1 ~ 2(N+1)kw</code>。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E8%8C%83%E5%9B%B4%E5%88%86%E8%A1%A8.png" alt="根据id范围分表"></p><p>假设现在有条数据，id=3kw，将这个<code>3kw除2kw = 1.5</code>，向下取整得到<code>1</code>，那就可以得到这条数据属于<code>user1表</code>。于是去读写 user1 表就行了。这就完成了数据的路由逻辑，我们把这部分逻辑封装起来，放在数据库和业务代码之间。</p><p>这样。<strong>对于业务代码来说</strong>，它只知道自己在读写一张 user 表，根本不知道底下还分了那么多张小表。</p><p><strong>对于数据库来说</strong>，它并不知道自己被分表了，它只知道有那么几张表，正好名字长得比较像而已。</p><p>这还只是在<strong>一个数据库</strong>里做分表，如果范围再搞大点，还能在<strong>多个数据库</strong>里做分表，这就是所谓的<strong>分库分表</strong>。</p><p>不管是单库分表还是分库分表，都可以通过这样一个中间层逻辑做路由。</p><p>还真的就应了那句话，没有什么是加中间层不能解决的。</p><p>如果有，就多加一层。</p><p>至于这个中间层的实现方式就更灵活了，它既可以像<strong>第三方 orm 库</strong>那样加在业务代码中。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%80%9A%E8%BF%87orm%E8%AF%BB%E5%86%99%E5%88%86%E8%A1%A8.drawio.png" alt="通过orm读写分表"></p><p>也可以在 mysql 和业务代码之间加个<strong>proxy 服务</strong>。</p><p>如果是通过第三方 orm 库的方式来做的话，那需要根据不同语言实现不同的代码库，所以不少厂都选择后者加个 proxy 的方式，这样就不需要关心上游服务用的是什么语言。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%80%9A%E8%BF%87proxy%E7%AE%A1%E7%90%86%E5%88%86%E8%A1%A8.drawio.png" alt="通过proxy管理分表"></p><br><h4 id="根据-id-取模分表"><a href="#根据-id-取模分表" class="headerlink" title="根据 id 取模分表"></a>根据 id 取模分表</h4><p>这时候就有兄弟要提出问题了，”我看很多方案都<strong>对 id 取模</strong>，你这个方案是不是不完整？”。</p><p>取模的方案也是很常见的。</p><p>比如一个 id=31 进来，我们一共分了 5 张表，分别是 user0 到 user4。对<code>31%5=1</code>，取模得<code>1</code>，于是就能知道应该读写<code>user1</code>表。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E5%8F%96%E6%A8%A1%E5%88%86%E8%A1%A8.drawio.png" alt="根据id取模分表"></p><p><strong>优点</strong>当然是比较简单。而且读写数据都可以很均匀的分摊到每个分表上。</p><p>但<strong>缺点</strong>也比较明显，如果想要扩展表的个数，比如从 5 张表变成 8 张表。那同样还是 id=31 的数据，<code>31%8 = 7</code>，就需要读写 user7 这张表。跟原来就对不上了。</p><p>这就需要考虑<strong>数据迁移</strong>的问题。很头秃。</p><p>为了避免后续扩展的问题，我见过一些业务一开始就将数据预估得很大，然后心一横，分成 100 张表，一张表如果存个 2kw 条，那也能存 20 亿数据了。</p><p>也不是说这样不行吧，就是这个业务直到最后放弃的时候，也就存了百万条数据，每次打开数据库表能看到茫茫多的 user_xx，就是不太舒服，专业点，叫增加了程序员的<strong>心智负担</strong>。</p><br><p>而上面一种方式，根据 id 范围去分表，就能很好的解决这些问题，数据少的时候，表也少，随着数据增多，表会慢慢变多。而且这样表还可以无限扩展。</p><p>那是不是说取模的做法就用不上了呢？</p><p>也不是。</p><br><h4 id="将上面两种方式结合起来"><a href="#将上面两种方式结合起来" class="headerlink" title="将上面两种方式结合起来"></a>将上面两种方式结合起来</h4><p>id 取模的做法，最大的好处是，新写入的数据都是实实在在的分散到了<strong>多张表</strong>上。</p><p>而根据 id 范围去做分表，因为 id 是递增的，那新写入的数据一般都会落到<strong>某一张表</strong>上，如果你的业务场景写数据特别频繁，那这张表就会出现<strong>写热点</strong>的问题。</p><p>这时候就可以将 id 取模和 id 范围分表的方式结合起来。</p><p>我们可以在某个 id 范围里，引入取模的功能。比如 以前 <code>2kw~4kw</code>是 user1 表，现在可以在这个范围<strong>再分成 5 个表</strong>，也就是引入 user1-0, user1-2 到 user1-4，在这 5 个表里取模。</p><p>举个例子，id=3kw，根据范围，会分到 user1 表，然后再进行取模 3kw % 5 = 0，也就是读写 user1-0 表。</p><p>这样就可以将写单表分摊为写多表。</p><p>这在分库的场景下优势会更明显，不同的库，可以把服务部署到不同的机器上，这样各个机器的性能都能被用起来。</p><p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E8%8C%83%E5%9B%B4%E5%88%86%E8%A1%A8%E5%90%8E%E5%86%8D%E5%8F%96%E6%A8%A1.drawio.png" alt="根据id范围分表后再取模"></p><br><h3 id="读扩散问题"><a href="#读扩散问题" class="headerlink" title="读扩散问题"></a>读扩散问题</h3><p>我们上面提到的好几种分表方式，都用了 id 这一列作为<strong>分表的依据</strong>，这其实就是所谓的<strong>分片键</strong>。</p><p>实际上我们一般也是用的<strong>数据库主键</strong>作为<strong>分片键</strong>。</p><p>这样，理想情况下我们已知一个 id，不管是根据哪种规则，我们都能很快定位到该读哪个分表。</p><p>但很多情况下，我们的查询又不是只查主键，如果我的数据库表有一列 name，并且加了个普通索引。</p><p>这样我执行下面的 sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> name <span class="operator">=</span> &quot;小白&quot;;</span><br></pre></td></tr></table></figure><p>由于 name 并不是分片键，我们没法定位到具体要到哪个分表上去执行 sql。</p><p>于是就会对<strong>所有分表</strong>都执行上面的 sql，当然不会是串行执行 sql，一般都是<strong>并发</strong>执行 sql 的。</p><p>如果我有 100 张表，就执行 100 次 sql。</p><p>如果我有 200 张表，就执行 200 次 sql。</p><p>随着我的表越来越多，次数会越来越多，这就是所谓的<strong>读扩散问题</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98.drawio.png" alt="读扩散问题"></p><p>这是个比较有趣的问题，它确实是个问题，但大部分的业务不会去处理它，读 100 次怎么了，数据增长之后读的次数会不断增加又怎么了？但架不住我的<strong>业务不赚钱</strong>啊，也根本<strong>长不了那么多数据</strong>啊。</p><br><p>话是这么说没错，但面试官问你的时候，你得知道怎么处理啊。</p><br><h4 id="引入新表来做分表"><a href="#引入新表来做分表" class="headerlink" title="引入新表来做分表"></a>引入新表来做分表</h4><p>问题的核心在于，主键是分片键，而普通索引列并不分片。</p><p>那好办，我们单独建个<strong>新的分片表</strong>，这个新表里的列就只有旧表的主键 id 和普通索引列，而这次换普通索引列来做分片键。</p><p><img src="https://cdn.xiaobaidebug.top/%E9%80%9A%E8%BF%87%E6%96%B0%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%A7%A3%E5%86%B3%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98.drawio.png" alt="通过新索引表解决读扩散问题"></p><p>这样当我们要查询普通索引列时，先到这个新的分片表里做一次查询，就能迅速定位到对应的主键 id，然后再拿主键 id 去旧的分片表里查一次数据。这样就从原来漫无目的的全表扩散查询，缩减为只查固定几个表了。</p><p>举个例子。比如我的表原本长下面这样，其中 id 列是主键，同时也是分片键，name 列是非主键索引。为了简化，假设三条数据一张表。</p><p>此时分表里 <code>id=1,4,6</code> 的都有<code>name=&quot;小白&quot;</code> 的数据。</p><p>当我们执行 <code>select * from user where name = &quot;小白&quot;;</code> 则需要并发查 3 张表，随着表变多，查询次数会变得更多。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%981.drawio.png" alt="举例说明读扩散问题"></p><p>但如果我们为 name 列<strong>建个新表(nameX)，以 name 为新的分片键</strong>。</p><p>这样我们可以先执行 <code>select id from nameX where name = &quot;小白&quot;;</code></p><p>再拿着结果里的 ids 去查询 <code>select * from user where id in (ids);</code> 这样就算表变多了，也可以迅速定位到某几张具体的表，减少了查询次数。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E9%80%9A%E8%BF%87%E6%96%B0%E7%B4%A2%E5%BC%95%E8%A1%A8%E8%A7%A3%E5%86%B3%E8%AF%BB%E6%89%A9%E6%95%A3%E9%97%AE%E9%A2%98.drawio.png" alt="举例说明通过新索引表解决读扩散问题"></p><p>但这个做法的缺点也比较明显，你需要维护两套表，并且普通索引列更新时，要两张表同时进行更改。</p><p>有一定的开发量</p><p>有没有更简单的方案？</p><br><h4 id="使用其他更合适的存储"><a href="#使用其他更合适的存储" class="headerlink" title="使用其他更合适的存储"></a>使用其他更合适的存储</h4><p>我们常规的查询是通过 id 主键去查询对应的 name 列。而像上面的方案，则通过引入一个新表，<strong>倒过来</strong>，先用 name 查到对应的 id，再拿 id 去获取具体的数据。这其实就像是建立了一个新的索引一样，像这种，通过 name 列反查原数据的思想，其实就很类似于<strong>倒排索引</strong>。</p><p><strong>相当于我们是利用了倒排索引的思路去解决分表下的数据查询问题。</strong></p><p>回想下，其实我们的<strong>原始需求</strong>无非就是在大量数据的场景下依然能提供普通索引列或其他更多维度的查询。</p><p>这种场合，更适合使用 es，es 天然分片，而且内部利用<strong>倒排索引</strong>的形式来加速数据查询。</p><p>哦？兄弟萌，又是它，<strong>倒排索引</strong>，又是个极小的细节，做好笔记。</p><p><img src="https://cdn.xiaobaidebug.top/006APoFYly8gqiccw4k14g308c05qq3b.gif"></p><p>举个例子，我同样是一行数据 id,name,age。在 mysql 里，你得根据 id 分片，如果要支持 name 和 age 的查询，为了防止读扩散，你得分别再建一个 name 的分片表和一个 age 的分片表。</p><p>而如果你用 es，它会在它内部以 id 分片键进行分片，同时还能建一个 name 到 id，和一个 age 到 id 的倒排索引。这是不是就跟上面做的事情没啥区别。</p><p>而且将 mysql 接入 es 也非常简单，我们可以通过开源工具 <code>canal</code> 监听 mysql 的<code>binlog</code>日志变更，再将数据解析后写入 es，这样 es 就能提供<strong>近实时</strong>的查询能力。</p><p><img src="https://cdn.xiaobaidebug.top/mysql%E5%90%8C%E6%AD%A5es.drawio.png" alt="mysql同步es"></p><p>觉得 es+mysql 还是繁琐？有没有其他更简洁的方案？</p><p>有。</p><p>别用 mysql 了，改用<strong>tidb</strong>吧，相信大家多少也听说过这个名称，这是个<strong>分布式数据库</strong>。</p><p>它通过引入<strong>Range</strong>的概念进行数据表分片，比如第一个分片表的 id 在 0<del>2kw，第二个分片表的 id 在 2kw</del>4kw。</p><p>哦？有没有很熟悉，这不就是文章开头提到的根据 id 范围进行数据库分表吗？</p><p>它支持普通索引，并且普通索引也是分片的，这是不是又跟上面提到的倒排索引方案很类似。</p><p>又是个极小的细节。</p><p><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F13563824367%2F1000&refer=http%3A%2F%2Finews.gtimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1655796068&t=e1cb280210d4e1526024b6c757e0b747"></p><p>并且 tidb 跟 mysql 的语法几乎一致，现在也有非常多现成的工具可以帮你把数据从 mysql 迁移到 tidb。所以开发成本并不高。</p><p><img src="https://cdn.xiaobaidebug.top/%E7%94%A8tidb%E6%9B%BF%E6%8D%A2mysql.drawio.png" alt="用tidb替换mysql"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>mysql 在单表数据过大时，查询性能会变差，因此当数据量变得巨大时，需要考虑水平分表。</li><li>水平分表需要选定一个分片键，一般选择主键，然后根据 id 进行取模，或者根据 id 的范围进行分表。</li><li>mysql 水平分表后，对于非分片键字段的查询会有读扩散的问题，可以用普通索引列作分片键建一个新表，先查新表拿到 id 后再回到原表再查一次原表。这本质上是借鉴了倒排索引的思路。</li><li>如果想要支持更多维度的查询，可以监听 mysql 的 binlog，将数据写入到 es，提供近实时的查询能力。</li><li>当然，用 tidb 替换 mysql 也是个思路。tidb 属实是个好东西，不少厂都拿它换个皮贴个标，做成自己的<strong>自研数据库</strong>，非常推荐大家学习一波。</li><li>不要做过早的优化，没事别上来就分 100 个表，很多时候真用不上。</li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《图解分库分表》 <a href="https://mp.weixin.qq.com/s/OI5y4HMTuEZR1hoz9aOMxg">https://mp.weixin.qq.com/s/OI5y4HMTuEZR1hoz9aOMxg</a></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>当年我还在某个游戏项目组里做开发的时候，从企鹅那边挖来的策划信誓旦旦的说，我们要做的这款游戏老少皆宜，肯定是爆款。要做成全球同服。上线至少<strong>过亿注册</strong>，<strong>十万人同时在线</strong>。要好好规划和设计。</p><br><p>我们算了下，信他能有个 1 亿注册。用了 id 范围的方式进行分片，分了<strong>4 张表</strong>。</p><p>搞得我热血沸腾。</p><p>那天晚上下班，夏蝉鸣泣，从赤道吹来的热风阵阵拂过我的手臂，我听着泽野弘之的歌，就算是开电瓶车，我都感觉自己像是在开高达。</p><br><p>一年后。</p><p>游戏上线前一天通知运维加机器，怕顶不住，要整夜关注。</p><p>后来上线了，全球最高在线人数<code>58</code>人。其中有<code>7</code>个是项目组成员。</p><br><p>还是夏天，还是同样的下班路，想哭，但我不能哭，因为骑电瓶车的时候擦眼泪不安全。</p><br><hr><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" /><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" /><p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql插入数据会失败，为什么？</title>
      <link href="/2022/05/18/%E5%9B%BE%E8%A7%A3mysql/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BC%9A%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/05/18/%E5%9B%BE%E8%A7%A3mysql/mysql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E4%BC%9A%E5%A4%B1%E8%B4%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>那天，我还在外面吃成都六姐的冒菜。</p><p>牛肉丸裹上麻酱后，狠狠嘬一口，都要入嘴了。</p><p>产品经理突然发来消息。</p><p><strong>“线上有些用户不能注册了”</strong></p><p>心想着”关我 x 事，又不是我做的模块”，放下手机。</p><p>不对，那老哥上礼拜刚离职了，想到这里，夹住毛肚的手<strong>微微颤抖</strong>。</p><p>对面继续发：**”还有些用户不能改名”**</p><p><img src="https://cdn.xiaobaidebug.top/image/a6a681ebgy1gpfzfr4ikdj20520523yf.jpg"></p><p>“如果用上<strong>表情符号</strong>的话，问题必现”</p><span id="more"></span><p>可以了，这下问题几乎直接定位了。</p><p>危，速归。</p><!-- more --><br><p>有经验的兄弟们很容易看出，这肯定是因为<strong>字符集</strong>的缘故。</p><br><h3 id="复现问题"><a href="#复现问题" class="headerlink" title="复现问题"></a>复现问题</h3><p>我们来简单复现下这个问题。</p><p>如果你有一张数据库表，建表 sql 就像下面一样。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%BB%BA%E8%A1%A8sql%E8%AF%AD%E5%8F%A5.png" alt="建表sql语句"></p><p>接下来如果你插入的数据是</p><p><img src="https://cdn.xiaobaidebug.top/image/insert%E6%88%90%E5%8A%9Fcase.png" alt="insert成功case"></p><p><strong>能成功</strong>。一切正常。</p><p>但如果你插入的是</p><p><img src="https://cdn.xiaobaidebug.top/image/insert%E5%A4%B1%E8%B4%A5case.png" alt="insert失败case"></p><p>就会<strong>报错</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Incorrect string <span class="keyword">value</span>: <span class="string">&#x27;\xF0\x9F\x98\x81&#x27;</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;name&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>区别在于后者多了个 emoji 表情。</strong></p><p>明明也是字符串，为什么字符串里含有<strong>emoji 表情</strong>，插入就会报错呢？</p><p>我们从<strong>字符集编码</strong>这个话题开始聊起。</p><br><h3 id="编码和字符集的关系"><a href="#编码和字符集的关系" class="headerlink" title="编码和字符集的关系"></a>编码和字符集的关系</h3><p>虽然我们平时可以在编辑器上输入各种中文英文字母，但这些都是给人读的，不是给计算机读的，其实计算机真正保存和传输数据都是以<strong>二进制</strong>0101 的格式进行的。</p><p>那么就需要有一个规则，把中文和英文字母转化为二进制，比如”debug”，计算机就需要把它转化为下图这样。</p><p><img src="https://cdn.xiaobaidebug.top/image/debug%E7%9A%84%E7%BC%96%E7%A0%81.drawio.png" alt="debug的编码"></p><p>其中 d 对应十六进制下的 64，它可以转换为 01 二进制的格式。</p><p>于是字母和数字就这样一一对应起来了，这就是<strong>ASCII 编码</strong>格式。</p><p>它用<strong>一个字节</strong>，也就是<code>8位</code>来标识字符，基础符号有 128 个，扩展符号也是 128 个。</p><p>也就只能表示下<strong>英文字母和数字</strong>。</p><p>这哪里够用。</p><p>塞牙缝都不够。</p><p>于是为了标识<strong>中文</strong>，出现了<strong>GB2312</strong>的编码格式。为了标识<strong>希腊语</strong>，出现了<strong>greek</strong>编码格式，为了标识<strong>俄语</strong>，整了<strong>cp866</strong>编码格式。</p><p>这百花齐放的场面，显然不是一个爱写<code>if else</code>的程序员想看到的。</p><p>为了统一它们，于是出现了<strong>Unicode 编码格式</strong>，它用了 2~4 个字节来表示字符，这样理论上所有符号都能被收录进去，并且完全兼容 ASCII 的编码，也就是说，同样是字母 d，在 ASCII 用 64 表示，在 Unicode 里还是用 64 来表示。</p><p>但<strong>不同的地方是 ASCII 编码用 1 个字节来表示，而 Unicode 用则两个字节来表示。</strong></p><p>比如下图，同样都是字母 d，unicode 比 ascii 多使用了一个字节。</p><p><img src="https://cdn.xiaobaidebug.top/image/unicode%E6%AF%94ascii%E5%A4%9A%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82.drawio.png" alt="unicode比ascii多使用一个字节"></p><p>我们可以注意到，上面的 unicode 编码，放在前面的都是 0，其实用不上，但还占了个字节，有点浪费，完全能隐藏掉。如果我们能做到该隐藏时隐藏，这样就能省下不少空间，按这个思路，就是就有了<strong>UTF-8 编码</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F3.png" alt="编码格式"></p><p>来总结下。</p><p>按照一定规则把符号和二进制码对应起来，这就是<strong>编码</strong>。而把 n 多这种已经编码的字符聚在一起，就是我们常说的<strong>字符集</strong>。</p><p>比如 utf-8 字符集就是所有 utf-8 编码格式的字符的合集。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%AD%97%E7%AC%A6%E5%92%8C%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9A%84%E5%85%B3%E7%B3%BB3.drawio.png" alt="字符和字符集的关系"></p><br><h3 id="mysql-的字符集"><a href="#mysql-的字符集" class="headerlink" title="mysql 的字符集"></a>mysql 的字符集</h3><p>想看下 mysql 支持哪些字符集。可以执行 <code>show charset;</code></p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%AD%97%E7%AC%A6%E9%9B%86.png" alt="数据库支持哪些字符集"></p><p>上面这么多字符集，我们只需要关注 utf8 和 utf8mb4 就够了。</p><br><h4 id="utf8-和-utf8mb4-的区别"><a href="#utf8-和-utf8mb4-的区别" class="headerlink" title="utf8 和 utf8mb4 的区别"></a>utf8 和 utf8mb4 的区别</h4><p>上面提到 utf-8 是在 unicode 的基础上做的优化，既然 unicode 有办法表示所有字符，那 utf-8 也一样可以表示所有字符，为了避免混淆，我在后面叫它<strong>大 utf8</strong>。</p><p>而从上面 mysql 支持的字符集的图里，我们看到了 utf8 和 utf8mb4。</p><p>先说<strong>utf8mb4</strong>编码，mb4 就是<strong>most bytes 4</strong>的意思，从上图最右边的<code>Maxlen</code>可以看到，它最大支持用<strong>4 个字节</strong>来表示字符，它几乎可以用来表示目前已知的所有的字符。</p><p>再说 mysql 字符集里的<strong>utf8</strong>，它是数据库的<strong>默认字符集</strong>。但注意，<strong>此 utf8 非彼 utf8</strong>，我们叫它<strong>小 utf8</strong>字符集。为什么这么说，因为从 Maxlen 可以看出，它最多支持用 3 个字节去表示字符，按 utf8mb4 的命名方式，准确点应该叫它<strong>utf8mb3</strong>。</p><p><strong>不好意思，有被严谨到的兄弟们，评论区扣个”严谨”。</strong></p><p>它就像是阉割版的 utf8mb4，只支持部分字符。比如 emoji 表情，它就不支持。</p><p><img src="https://cdn.xiaobaidebug.top/image/utf8mb3%E5%92%8Cutf8mb4%E7%9A%84%E5%85%B3%E7%B3%BB5.drawio.png" alt="utf8mb3和utf8mb4的关系"></p><br><p>而 mysql 支持的字符集里，第三列，<strong>collation</strong>，它是指<strong>字符集的比较规则</strong>。</p><p>比如，**”debug”和”Debug”**是同一个单词，但它们大小写不同，该不该判为同一个单词呢。</p><p>这时候就需要用到 collation 了。</p><p>通过<code>SHOW COLLATION WHERE Charset = &#39;utf8mb4&#39;;</code>可以查看到<code>utf8mb4</code>下支持什么比较规则。</p><p><img src="https://cdn.xiaobaidebug.top/image/utf8mb4%E5%AD%97%E7%AC%A6%E9%9B%86%E6%AF%94%E8%BE%83%E8%A7%84%E5%88%99-20220421210049625.png" alt="utf8mb4字符集比较规则"></p><p>如果<code>collation = utf8mb4_general_ci</code>，是指使用 utf8mb4 字符集前提下，<strong>挨个字符进行比较</strong>（<code>general</code>），并且不区分大小写（<code>_ci，case insensitice</code>）。</p><p>这种情况下，**”debug”和”Debug”是同一个单词**。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%AF%B9%E6%AF%94%E8%A7%84%E5%88%99-%E5%A4%A7%E5%B0%8F%E5%86%99%E4%B8%8D%E6%95%8F%E6%84%9F2.png" alt="对比规则-大小写不敏感"></p><p>如果改成<code>collation=utf8mb4_bin</code>，就是指<strong>挨个比较二进制位大小</strong>。</p><p>于是**”debug”和”Debug”就不是同一个单词。**</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%AF%B9%E6%AF%94%E8%A7%84%E5%88%99-%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F.png" alt="对比规则-大小写敏感"></p><br><h4 id="那-utf8mb4-对比-utf8mb3-有什么劣势吗？"><a href="#那-utf8mb4-对比-utf8mb3-有什么劣势吗？" class="headerlink" title="那 utf8mb4 对比 utf8mb3 有什么劣势吗？"></a>那 utf8mb4 对比 utf8mb3 有什么劣势吗？</h4><p>我们知道数据库表里，字段类型如果是 char(2)的话，里面的 2 是指<strong>字符个数</strong>，也就是说<strong>不管这张表用的是什么字符集</strong>，都能放上 2 个字符。</p><p>而 char 又是<strong>固定长度</strong>，为了能放下 2 个 utf8mb4 的字符，char 会默认保留<code>2*4（maxlen=4）= 8</code>个字节的空间。</p><p>如果是 utf8mb3，则会默认保留 2 * 3 (maxlen=3) = 6 个字节的空间。也就是说，在这种情况下，<strong>utf8mb4 会比 utf8mb3 多使用一些空间。</strong></p><p>但这真的无关紧要，如果我不用 char，用 varchar 就好了，varchar 不是固定长度，也就没有上面这些麻烦事了。</p><p>所以我<strong>个人认为，utf8mb4 比起 utf8mb3 几乎没有劣势。</strong></p><br><h4 id="如何查看数据库表的字符集"><a href="#如何查看数据库表的字符集" class="headerlink" title="如何查看数据库表的字符集"></a>如何查看数据库表的字符集</h4><p>如果我们不知道自己的表是用的哪种字符集，可以通过下面的方式进行查看。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%862.png" alt="查看数据库表的字符集"></p><br><h3 id="再看报错原因"><a href="#再看报错原因" class="headerlink" title="再看报错原因"></a>再看报错原因</h3><p>到这里，我们回到文章开头的问题。</p><p>因为数据库表在建表的时候使用 <code>DEFAULT CHARSET=utf8</code>， 相当于指定了<code>utf8mb3</code>字符集格式。</p><p>而在执行 insert 数据的时候，又不讲武德，加入了 emoji 表情这种<code>utf8mb4</code>才能支持的字符，mysql 识别到这是<code>utf8mb3</code>不支持的字符，于是忍痛报错。</p><p>要修复也很简单，执行下面的 sql 语句，就可以把数据库表的字符集改成<code>utf8mb4</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">CONVERT</span> <span class="keyword">TO</span> <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8mb4 <span class="keyword">COLLATE</span> utf8mb4_general_ci;</span><br></pre></td></tr></table></figure><p><strong>答应我，以后建表，我们都无脑选 utf8mb4。</strong></p><p>选 utf8 除了在 char 字段场景下会比 utf8mb4 稍微省一点空间外，几乎没任何好处。</p><p>这点空间省下来了能提高你的绩效吗？不能。</p><p>但如果因此炸雷了，那你号就没了。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>ASCII 编码支持数字和字母。大佬们为了支持中文引入了 GB2312 编码格式，其他国家的大佬们为了支持更多语言和符号，也引入了相应的编码格式。为了统一这些各种编码格式，大佬们又引入了 unicode 编码格式，而 utf-8 则在 unicode 的基础上做了优化，压缩了空间。</li><li>mysql 默认的 utf8 字符集，其实只是 utf8mb3，并不完整，当插入 emoji 表情等特殊字符时，会报错，导致插入、更新数据失败。改成 utf8mb4 就好了，它能支持更多字符。</li><li>mysql 建表时如果不知道该选什么字符集，无脑选 utf8mb4 就行了，你会感谢我的。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《从根儿上理解 mysql》</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>原本 A 同学设计这张表的时候非常简单，也有字符串类型的字段，但字段含义决定了肯定不会有奇奇怪怪的字符，用 utf8 很合理，还省空间。</p><p>后来交接给了 B 同学，B 同学在这基础上加过非常多的字段，离职前最后一个需求加的这个名称字段，所幸并没炸雷。最后到了我这里。</p><p>好一个<strong>击鼓传雷</strong>。</p><p>有点东西哦。</p><p><img src="https://cdn.xiaobaidebug.top/image/images.jpeg"></p><br><p>那么问题来了。</p><p>这样的一个事故，复盘会一开，会挂 P 几呢？</p><p><img src="https://cdn.xiaobaidebug.top/image/a6a681ebgy1gp1tujp12gj208c08cmxb.jpg"></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql查询 limit 1000,10 和limit 10 速度一样快吗？如果我要分页，我该怎么办？</title>
      <link href="/2022/05/06/%E5%9B%BE%E8%A7%A3mysql/mysql%E6%9F%A5%E8%AF%A2%20limit%201000,10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%88%91%E8%A6%81%E5%88%86%E9%A1%B5%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/"/>
      <url>/2022/05/06/%E5%9B%BE%E8%A7%A3mysql/mysql%E6%9F%A5%E8%AF%A2%20limit%201000,10%20%E5%92%8Climit%2010%20%E9%80%9F%E5%BA%A6%E4%B8%80%E6%A0%B7%E5%BF%AB%E5%90%97%EF%BC%9F%E5%A6%82%E6%9E%9C%E6%88%91%E8%A6%81%E5%88%86%E9%A1%B5%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>刷网站的时候，我们经常会遇到需要分页查询的场景。</p><p>比如下图红框里的翻页功能。</p><img src="https://cdn.xiaobaidebug.top/image-20220603221954745.png" style="zoom:50%;" /><span id="more"></span><br><p>我们很容易能联想到可以用 mysql 实现。</p><p>假设我们的建表 sql 是这样的</p><p><img src="https://cdn.xiaobaidebug.top/image/mysql%E5%BB%BA%E8%A1%A8sql5.png" alt="mysql建表sql"></p><br><p>建表 sql 大家也不用扣细节，只需要知道<strong>id 是主键，并且在 user_name 建了个非主键索引</strong>就够了，其他都不重要。</p><p>为了实现分页。</p><p>很容易联想到下面这样的 sql 语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="keyword">offset</span>, size;</span><br></pre></td></tr></table></figure><p>比如一页有 10 条数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%816.drawio.png" alt="user表数据库原始状态"></p><p>第一页就是下面这样的 sql 语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>第一百页就是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">990</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br><p>那么问题来了。</p><p>用这种方式，<strong>同样都是拿 10 条数据，查第一页和第一百页的查询速度是一样的吗？为什么？</strong></p><br><h3 id="两种-limit-的执行过程"><a href="#两种-limit-的执行过程" class="headerlink" title="两种 limit 的执行过程"></a>两种 limit 的执行过程</h3><p>上面的两种查询方式。对应 <code>limit offset, size</code> 和 <code>limit size</code> 两种方式。</p><p>而其实 <code>limit size</code> ，相当于 <code>limit 0, size</code>。也就是从 0 开始取 size 条数据。</p><p>也就是说，两种方式的<strong>区别在于 offset 是否为 0。</strong></p><p>我们先来看下 limit sql 的内部执行逻辑。</p><p><img src="https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio.png" alt="Mysql架构"></p><p>mysql 内部分为<strong>server 层</strong>和<strong>存储引擎层</strong>。一般情况下存储引擎都用 innodb。</p><p>server 层有很多模块，其中需要关注的是<strong>执行器</strong>是用于跟存储引擎打交道的组件。</p><p>执行器可以通过调用存储引擎提供的接口，将一行行数据取出，当这些数据完全符合要求（比如满足其他 where 条件），则会放到<strong>结果集</strong>中，最后返回给调用 mysql 的<strong>客户端（go、java 写的应用程序）</strong>。</p><br><p>我们可以对下面的 sql 先执行下 <code>explain</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>可以看到，explain 中提示 key 那里，执行的是<strong>PRIMARY</strong>，也就是走的<strong>主键索引</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2offset=0.png" alt="分页查询offset=0"></p><p>主键索引本质是一棵 B+树，它是放在 innodb 中的一个数据结构。</p><p>我们可以回忆下，B+树大概长这样。</p><p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%842d.png" alt="B+树结构"></p><p>在这个树状结构里，我们需要关注的是，最下面一层节点，也就是<strong>叶子结点</strong>。而这个叶子结点里放的信息会根据当前的索引是<strong>主键还是非主键</strong>有所不同。</p><ul><li>如果是<strong>主键索引</strong>，它的叶子节点会存放完整的行数据信息。</li><li>如果是<strong>非主键索引</strong>，那它的叶子节点则会存放主键，如果想获得行数据信息，则需要再跑到主键索引去拿一次数据，这叫<strong>回表</strong>。</li></ul><p>比如执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">where</span> user_name <span class="operator">=</span> &quot;小白10&quot;;</span><br></pre></td></tr></table></figure><p>会通过非主键索引去查询<strong>user_name</strong>为”<strong>小白 10</strong>“的数据，然后在叶子结点里找到”<strong>小白 10</strong>“的数据对应的<strong>主键为 10</strong>。</p><p>此时回表到<strong>主键索引</strong>中做查询，最后定位到<strong>主键为 10 的行数据</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%9B%9E%E8%A1%A8.drawio.png" alt="回表"></p><p>但不管是主键还是非主键索引，他们的叶子结点数据都是<strong>有序的</strong>。比如在主键索引中，这些数据是根据主键 id 的大小，从小到大，进行排序的。</p><br><h4 id="基于主键索引的-limit-执行过程"><a href="#基于主键索引的-limit-执行过程" class="headerlink" title="基于主键索引的 limit 执行过程"></a>基于主键索引的 limit 执行过程</h4><p>那么回到文章开头的问题里。</p><p>当我们去掉 explain，执行这条 sql。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上面 select 后面带的是<strong>星号*<strong>，也就是要求获得行数据的</strong>所有字段信息。</strong></p><p>server 层会调用 innodb 的接口，在 innodb 里的主键索引中获取到第 0 到 10 条<strong>完整行数据</strong>，依次返回给 server 层，并放到 server 层的结果集中，返回给客户端。</p><p>而当我们把 offset 搞离谱点，比如执行的是</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">6000000</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>server 层会调用 innodb 的接口，由于这次的 offset=6000000，会在 innodb 里的主键索引中获取到第 0 到（6000000 + 10）条<strong>完整行数据</strong>，<strong>返回给 server 层之后根据 offset 的值挨个抛弃，最后只留下最后面的 size 条</strong>，也就是 10 条数据，放到 server 层的结果集中，返回给客户端。</p><p>可以看出，当 offset 非 0 时，server 层会从引擎层获取到<strong>很多无用的数据</strong>，而获取的这些无用数据都是要耗时的。</p><p>因此，我们就知道了文章开头的问题的答案，<strong>mysql 查询中 limit 1000,10 会比 limit 10 更慢。原因是 limit 1000,10 会取出 1000+10 条数据，并抛弃前 1000 条，这部分耗时更大</strong></p><br><p><strong>那这种 case 有办法优化吗？</strong></p><p>可以看出，当 offset 非 0 时，server 层会从引擎层获取到很多无用的数据，而当 select 后面是*号时，就需要拷贝完整的行信息，<strong>拷贝完整数据</strong>跟<strong>只拷贝行数据里的其中一两个列字段</strong>耗时是不同的，这就让原本就耗时的操作变得更加离谱。</p><p>因为前面的 offset 条数据最后都是不要的，就算将完整字段都拷贝来了又有什么用呢，所以我们可以将 sql 语句修改成下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page  <span class="keyword">where</span> id <span class="operator">&gt;=</span>(<span class="keyword">select</span> id <span class="keyword">from</span> page  <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">6000000</span>, <span class="number">1</span>) <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上面这条 sql 语句，里面先执行子查询 <code>select id from page  order by id limit 6000000, 1</code>, 这个操作，其实也是将在 innodb 中的主键索引中获取到<code>6000000+1</code>条数据，然后 server 层会抛弃前 6000000 条，只保留最后一条数据的 id。</p><p>但不同的地方在于，在返回 server 层的过程中，只会拷贝数据行内的 id 这一列，而不会拷贝数据行的所有列，当数据量较大时，这部分的耗时还是比较明显的。</p><p>在拿到了上面的 id 之后，假设这个 id 正好等于 6000000，那 sql 就变成了</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page  <span class="keyword">where</span> id <span class="operator">&gt;=</span>(<span class="number">6000000</span>) <span class="keyword">order</span> <span class="keyword">by</span> id limit <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>这样 innodb 再走一次<strong>主键索引</strong>，通过 B+树快速定位到 id=6000000 的行数据，时间复杂度是 lg(n)，然后向后取 10 条数据。</p><p>这样性能确实是提升了，亲测能快一倍左右，属于那种耗时从 3s 变成 1.5s 的操作。</p><p>这······</p><p>属实有些杯水车薪，有点搓，属于没办法中的办法。</p><br><h4 id="基于非主键索引的-limit-执行过程"><a href="#基于非主键索引的-limit-执行过程" class="headerlink" title="基于非主键索引的 limit 执行过程"></a>基于非主键索引的 limit 执行过程</h4><p>上面提到的是主键索引的执行过程，我们再来看下基于<strong>非主键索引</strong>的 limit 执行过程。</p><p>比如下面的 sql 语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> user_name  limit <span class="number">0</span>, <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>server 层会调用 innodb 的接口，在 innodb 里的非主键索引中获取到第 0 条数据对应的主键 id 后，<strong>回表</strong>到主键索引中找到对应的完整行数据，然后返回给 server 层，server 层将其放到结果集中，返回给客户端。</p><p>而当 offset&gt;0 时，且 offset 的值较小时，逻辑也类似，区别在于，offset&gt;0 时会丢弃前面的 offset 条数据。</p><p>也就是说<strong>非主键索引的 limit 过程，比主键索引的 limit 过程，多了个回表的消耗。</strong></p><p>但当 offset 变得非常大时，比如 600 万，此时执行 explain。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%9D%9E%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95offset%E5%80%BC%E8%B6%85%E5%A4%A7%E6%97%B6%E8%B5%B0%E5%85%A8%E8%A1%A8%E6%89%AB%E6%8F%8F.png" alt="非主键索引offset值超大时走全表扫描"></p><p>可以看到 type 那一栏显示的是 ALL，也就是<strong>全表扫描</strong>。</p><p>这是因为 server 层的<strong>优化器</strong>，会在执行器执行 sql 语句前，判断下哪种执行计划的代价更小。</p><p>很明显，优化器在看到非主键索引的 600w 次回表之后，摇了摇头，还不如全表一条条记录去判断算了，于是选择了全表扫描。</p><p>因此，<strong>当 limit offset 过大时，非主键索引查询非常容易变成全表扫描。是真·性能杀手</strong>。</p><br><p>这种情况也能通过一些方式去优化。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page t1, (<span class="keyword">select</span> id <span class="keyword">from</span> page <span class="keyword">order</span> <span class="keyword">by</span> user_name limit <span class="number">6000000</span>, <span class="number">100</span>) t2  <span class="keyword">WHERE</span> t1.id <span class="operator">=</span> t2.id;</span><br></pre></td></tr></table></figure><p>通过<code>select id from page order by user_name limit 6000000, 100</code>。 先走 innodb 层的 user_name 非主键索引取出 id，因为只拿主键 id，<strong>不需要回表</strong>，所以这块性能会稍微快点，在返回 server 层之后，同样抛弃前 600w 条数据，保留最后的 100 个 id。然后再用这 100 个 id 去跟 t1 表做 id 匹配，此时走的是主键索引，将匹配到的 100 条行数据返回。这样就绕开了之前的 600w 条数据的回表。</p><p>当然，跟上面的 case 一样，还是没有解决要白拿 600w 条数据然后抛弃的问题，这也是非常挫的优化。</p><br><p>像这种，当 offset 变得超大时，比如到了百万千万的量级，问题就突然变得严肃了。</p><p>这里就产生了个专门的术语，叫<strong>深度分页</strong>。</p><br><h3 id="深度分页问题"><a href="#深度分页问题" class="headerlink" title="深度分页问题"></a>深度分页问题</h3><p>深度分页问题，是个很恶心的问题，恶心就恶心在，这个问题，它其实<strong>无解</strong>。</p><p>不管你是用 mysql 还是 es，你都只能通过一些手段去”减缓”问题的严重性。</p><p>遇到这个问题，我们就该回过头来想想。</p><p>为什么我们的代码会产生深度分页问题？</p><p><strong>它背后的原始需求是什么</strong>，我们可以根据这个做一些规避。</p><br><h4 id="如果你是想取出全表的数据"><a href="#如果你是想取出全表的数据" class="headerlink" title="如果你是想取出全表的数据"></a>如果你是想取出全表的数据</h4><p>有些需求是这样的，我们有一张数据库表，但我们希望将这个数据库表里的所有数据取出，异构到 es，或者 hive 里，这时候如果直接执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> page;</span><br></pre></td></tr></table></figure><p>这个 sql 一执行，狗看了都摇头。</p><p>因为数据量较大，mysql 根本没办法一次性获取到全部数据，妥妥<strong>超时报错</strong>。</p><p>于是不少 mysql 小白会通过<code>limit offset size</code>分页的形式去分批获取，刚开始都是好的，等慢慢地，哪天数据表变得奇大无比，就有可能出现前面提到的<strong>深度分页</strong>问题。</p><p>这种场景是最好解决的。</p><p>我们可以将所有的数据<strong>根据 id 主键进行排序</strong>，然后分批次取，将当前批次的最大 id 作为下次筛选的条件进行查询。</p><p>可以看下伪代码</p><p><img src="https://cdn.xiaobaidebug.top/image/batch%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.png" alt="batch获取数据"></p><p>这个操作，可以通过主键索引，每次定位到 id 在哪，然后往后遍历 100 个数据，这样不管是多少万的数据，查询性能都很稳定。</p><p><img src="https://cdn.xiaobaidebug.top/image/batch%E5%88%86%E6%89%B9%E8%8E%B7%E5%8F%96user%E8%A1%A8.drawio.png" alt="batch分批获取user表"></p><br><h4 id="如果是给用户做分页展示"><a href="#如果是给用户做分页展示" class="headerlink" title="如果是给用户做分页展示"></a>如果是给用户做分页展示</h4><p>如果深度分页背后的原始需求只是产品经理希望做一个展示页的功能，比如商品展示页，那么我们就应该好好跟产品经理 battle 一下了。</p><p>什么样的翻页，需要翻到 10 多万以后，这明显是不合理的需求。</p><p>是不是可以改一下需求，让它更接近用户的使用行为？</p><p>比如，我们在使用谷歌搜索时看到的翻页功能。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220502222159101.png"></p><p>一般来说，谷歌搜索基本上都在 20 页以内，作为一个用户，我就很少会翻到第 10 页之后。</p><p>作为参考。</p><p>如果我们要做搜索或筛选类的页面的话，就别用 mysql 了，用 es，并且也需要控制展示的结果数，比如一万以内，这样不至于让分页过深。</p><p>如果因为各种原因，必须使用 mysql。那同样，也需要控制下返回结果数量，比如数量 1k 以内。</p><p>这样就能勉强支持各种翻页，跳页（比如突然跳到第 6 页然后再跳到第 106 页）。</p><br><p>但如果能从产品的形式上就做成不支持跳页会更好，比如<strong>只支持上一页或下一页</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%8A%E4%B8%8B%E9%A1%B5%E7%9A%84%E5%BD%A2%E5%BC%8F.drawio.png" alt="上下页的形式"></p><p>这样我们就可以使用上面提到的 start_id 方式，采用分批获取，每批数据以 start_id 为起始位置。这个解法最大的好处是不管翻到多少页，查询速度永远稳定。</p><p>听起来很挫？</p><p>怎么会呢，把这个功能包装一下。</p><p>变成像抖音那样只能上划或下划，专业点，叫<strong>瀑布流</strong>。</p><p>是不是就不挫了？</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220503134616713.png"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>limit offset, size</code> 比 <code>limit size</code> 要慢，且 offset 的值越大，sql 的执行速度越慢。</p></li><li><p>当 offset 过大，会引发<strong>深度分页</strong>问题，目前不管是 mysql 还是 es 都没有很好的方法去解决这个问题。只能通过限制查询数量或分批获取的方式进行规避。</p></li><li><p>遇到深度分页的问题，多思考其原始需求，大部分时候是不应该出现深度分页的场景的，必要时多去影响产品经理。</p></li><li><p>如果数据量很少，比如 1k 的量级，且长期不太可能有巨大的增长，还是用<code>limit offset, size</code> 的方案吧，整挺好，能用就行。</p></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MySQL 的 Limit 子句底层原理你不可不知》<a href="https://blog.csdn.net/qq_34115899/article/details/120727513">https://blog.csdn.net/qq_34115899/article/details/120727513</a></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>关于深度分页，如果大家有更好的想法，欢迎评论区说出来。</p><p>这道题，是我无能！</p><p><strong>告辞！！</strong></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>都是同样条件的mysql select语句，为什么读到的内容却不一样？</title>
      <link href="/2022/04/26/%E5%9B%BE%E8%A7%A3mysql/%E9%83%BD%E6%98%AF%E5%90%8C%E6%A0%B7%E6%9D%A1%E4%BB%B6%E7%9A%84mysql%20select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E5%8D%B4%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F/"/>
      <url>/2022/04/26/%E5%9B%BE%E8%A7%A3mysql/%E9%83%BD%E6%98%AF%E5%90%8C%E6%A0%B7%E6%9D%A1%E4%BB%B6%E7%9A%84mysql%20select%E8%AF%AD%E5%8F%A5%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AF%BB%E5%88%B0%E7%9A%84%E5%86%85%E5%AE%B9%E5%8D%B4%E4%B8%8D%E4%B8%80%E6%A0%B7%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>假设当前数据库里有下面这张表。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%814.drawio.png" alt="user表数据库原始状态"></p><p>老规矩，以下内容还是默认发生在 innodb 引擎的<strong>可重复读隔离级别</strong>下。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%83%BD%E6%98%AFselect%E7%BB%93%E6%9E%9C%E5%8D%B4%E4%B8%8D%E5%90%8C1.drawio.png" alt="都是select结果却不同"></p><span id="more"></span><p>大家可以看到，<strong>线程 1</strong>，同样都是读 <code>age &gt;= 3</code> 的数据。第一次读到<strong>1 条数据</strong>，这个是原始状态。这之后线程 2 将 id=2 的 age 字段也改成了 3。</p><p>线程 1 此时再读两次，一次读到的结果还是原来的<strong>1 条</strong>，另一次读的结果却是<strong>2 条</strong>，<strong>区别在于加没加 for update。</strong></p><p>为什么同样条件下，都是读，读出来的数据却不一样呢？</p><p>可重复读不是要求每次读出来的内容要一样吗？</p><br><p>要回答这个问题。</p><p>我需要从盘古是怎么开天辟地这个话题开始聊起。</p><br><p>不好意思。</p><p>失态了。</p><p>那就从事务是怎么回滚的开始聊起吧。</p><br><h3 id="事务的回滚是怎么实现的"><a href="#事务的回滚是怎么实现的" class="headerlink" title="事务的回滚是怎么实现的"></a>事务的回滚是怎么实现的</h3><p>我们在执行事务的时候，一般都是下面这样的格式</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">操作<span class="number">1</span>;</span><br><span class="line">操作<span class="number">2</span>;</span><br><span class="line">操作<span class="number">3</span>;</span><br><span class="line">xxxxx</span><br><span class="line">....</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>在提交事务之前，会执行各种操作，里面可以包含各种逻辑。</p><p>只要是执行逻辑，那就<strong>有可能</strong>会报错。</p><p>回想下事务的<code>ACID</code>里有个<code>A</code>，<strong>原子性</strong>，整个事务就是个整体，要么一起成功，要么一起失败。</p><p><img src="https://cdn.xiaobaidebug.top/image/ACID.png" alt="ACID"></p><p>如果失败了的话，那就要让执行到一半的事务有能力回到没执行事务前的状态，这就是<strong>回滚</strong>。</p><p>执行事务的代码就类似写成下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">try:</span><br><span class="line">操作<span class="number">1</span>;</span><br><span class="line">  操作<span class="number">2</span>;</span><br><span class="line">  操作<span class="number">3</span>;</span><br><span class="line">  xxxxx</span><br><span class="line">  ....</span><br><span class="line">  <span class="keyword">commit</span>;</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line"><span class="keyword">rollback</span>;</span><br></pre></td></tr></table></figure><p>如果执行<code>rollback</code>能回到事务执行前的状态的话，那说明 mysql 需要知道某些行，执行事务前的数据长什么样子。</p><p>那数据库是怎么做到的呢？</p><p>这就要提到<strong>undo 日志</strong>了，它记录了某一行数据，在执行事务前是怎么样的。</p><p>比如<code>id=1</code>那行数据，<code>name</code>字段从**”小白”<strong>更新成了</strong>“小白 debug”**，那就会新增一个 undo 日志，用于记录之前的数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E4%BC%9A%E8%AE%B0%E5%BD%95%E4%B9%8B%E5%89%8D%E7%9A%84%E6%95%B0%E6%8D%AE.drawio.png" alt="undo日志会记录之前的数据"></p><p>由于同时并发执行的事务可以有很多，于是可能会有很多 undo 日志，日志里加入事务的 id（<code>trx_id</code>）字段，用于标明这是哪个事务下产生的 undo 日志。</p><p>同时将它们用<strong>链表的形式</strong>组织起来，在 undo 日志里加入一个指针（<code>roll_pointer</code>），指向上一个 undo 日志，于是就形成了一条<strong>版本链</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/undo%E6%97%A5%E5%BF%97%E7%89%88%E6%9C%AC%E9%93%BE.png" alt="undo日志版本链"></p><p>有了这个版本链，当某个事务执行到一半发现失败时，就直接回滚，这时候就可以顺着这个版本链，回到执行事务前的状态。</p><br><h3 id="当前读和快照读是什么"><a href="#当前读和快照读是什么" class="headerlink" title="当前读和快照读是什么"></a>当前读和快照读是什么</h3><p>有了上面的 undo 日志版本链之后，我们可以看到<strong>最新的数据在表头</strong>，在这之后的都是一个个旧的数据版本。不管是最新的，还是旧的数据版本，我们都叫它数据<strong>快照</strong>。</p><p><strong>当前读</strong>，读的就是版本链的表头，也就是<strong>最新的数据</strong>。</p><p><strong>快照读</strong>，读的就是版本链里的其中一个快照，当然如果这个快照正好就是表头，那此时快照读和当前读的结果一样。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%BD%93%E5%89%8D%E8%AF%BB%E5%92%8C%E5%BF%AB%E7%85%A7%E8%AF%BB.drawio.png" alt="当前读和快照读"></p><p>我们平时执行的普通 select 语句，比如下面这种，就是<strong>快照读</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from user where phone_no=2；</span><br></pre></td></tr></table></figure><p>而特殊的 select 语句，比如在<code>select</code>后面加上<code>lock in share mode</code>或<code>for update</code>，都属于<strong>当前读</strong>。</p><p>除此之外<code>insert，update，delete</code>操作都属于<strong>写操作</strong>，既然写，那必然是写最新的数据，所以都会引发当前读。</p><br><p>那么问题来了。</p><p><strong>当前读</strong>，读的是版本链的<strong>表头</strong>，那么执行当前读的时候，有没有可能恰好有其他事务，生成更加新的快照，替代当前表头，成为新的表头呢，<strong>那这时候岂不是读的不是最新数据了？</strong></p><p>答案是<strong>不会</strong>，不管是 select … for update 这些（特殊的）读操作，还是 insert、update 这些写操作，<strong>都会对这行数据加锁</strong>。而生成 undo 日志快照，也是在<strong>写操作</strong>的情况下生成的，执行写操作前<strong>也需要获得锁</strong>。所以写操作需要阻塞等待<strong>当前读</strong>完成后，获得锁后才能更新版本链。</p><br><h3 id="read-view"><a href="#read-view" class="headerlink" title="read view"></a>read view</h3><p>数据库里可以同时并发执行非常多的事务, <strong>每个事务都会被分配一个事务 ID, 这个 ID 是递增的，越新的事务，ID 越大。</strong></p><p>而数据表里某行数据的 undo 日志版本链，每个 undo 日志上面也有一个事务 id (<code>trx_id</code>)，它是创建这个 undo 日志的<strong>事务 id</strong>。</p><p>并不是所有事务都会生成 undo 日志，也就是说某行数据的 undo 日志版本链上只有<strong>部分</strong>事务的 id。但是，<strong>所有</strong>事务都有可能会访问这行数据对应的版本链。而且版本链上虽然有很多 undo 日志快照，但也不是所有 undo 日志都能被读，毕竟有些 undo 日志，创建它们的事务还没提交呢，人家随时可能失败并回滚。</p><p>现在的问题就成了，<strong>现在有一个事务，通过快照读的方式去读 undo 日志版本链，那它能读哪些快照？并且它应该读哪个快照？</strong></p><p>这里就要引入一个<strong>read view</strong>的概念。它就像是一个有上下边界的滑动窗口。</p><p>整个数据库里有那么多事务，这些事务分为已经提交（commit）的，和没提交的。没提交的，意味着这些事务还在进行中，也就是所谓的<strong>活跃事务</strong>。所有的活跃事务的 id，组成<strong>m_ids</strong>。而这其中最小的事务 id 就是 read view 的<strong>下边界，叫 min_trx_id。</strong></p><p>产生 read view 的那一刻，<strong>所有事务里最大的事务 id</strong>，加个 1，就是这个 read view 的<strong>上边界，叫 max_trx_id。</strong></p><p>概念太多，有点乱？没事的，继续往下看，后面会有例子的。</p><br><h4 id="事务能读哪些快照"><a href="#事务能读哪些快照" class="headerlink" title="事务能读哪些快照"></a>事务能读哪些快照</h4><p>有了这些基础信息之后，我们先看下事务在 read view 下，他<strong>能读哪些快照呢？</strong></p><p>记住一个大前提：<strong>事务只能读到自己产生的 undo 日志数据（事务提不提交都行），或者是其他事务已经提交完成的数据</strong>。</p><p>现在事务（假设就叫<strong>事务 A</strong>吧）有了 read view 之后，不管看哪个 undo 日志版本链，我们都可以把 read view 往版本链上一放。版本链就被分成了好几部分。</p><p><img src="https://cdn.xiaobaidebug.top/image/readview2.drawio.png" alt="readview"></p><ul><li><p><strong>版本链快照的 trx_id &lt; read view 的 min_trx_id</strong></p><p>从上面的描述中，我们可以知道 read view 的 m_ids 来源于数据库所有<strong>活跃事务的 id</strong>，而最小的 min_trx_id 就是 read view 的下边界，因为事务 id 是根据时间递增的，所以<strong>如果版本链快照的 trx_id 比 min_trx_id 还要小，那这些肯定都是非活跃（已经提交）的事务 id，这些快照都能被事务 A 读到。</strong></p></li><li><p><strong>版本链快照的 trx_id &gt;= read view 的 max_trx_id</strong></p><p>max_trx_id 是在<strong>事务 A 创建 read view 的那一刻产生的</strong>，它比<strong>那时候</strong>所有数据库已知的事务 id 都还要大。所以如果 undo 日志版本链上的某个快照上含有比 max_trx_id 还要大的 trx_id，那说明这个快照已经超出事务 A 的”理解范围了”，它不该被读到。</p></li><li><p><strong>read view 的 min_trx_id &lt;= 版本链快照的 trx_id &lt; read view 的 max_trx_id</strong></p><ul><li>如果版本链快照的 trx_id 正好就是事务 A 的 id，那正好是它自己生成的 undo 日志快照，那不管有没有提交，<strong>都能读</strong>。</li><li>如果版本链快照的 trx_id 正好在活跃事务 m_ids 中, 那这些事务数据都还没提交，所以事务 A 不能读到它们</li><li>除了上面两种情况外，剩下的都是<strong>已经提交</strong>的事务数据，可以放心读。</li></ul></li></ul><br><h4 id="事务会读哪个快照"><a href="#事务会读哪个快照" class="headerlink" title="事务会读哪个快照"></a>事务会读哪个快照</h4><p>上面提到，事务在 read view 的可见范围里，有机会能读到 N 多快照。但那么<strong>多快照版本，事务具体会读哪个快照呢？</strong></p><p>事务会<strong>从表头开始</strong>遍历这个 undo 日志版本链，它会拿每个 undo 日志里的 trx_id 去跟自己的 read view 的上下边界去做判断。<strong>第一个出现的小于 max_trx_id 的快照</strong>。</p><ul><li>如果快照是自己产生，那<strong>提不提交都行</strong>，就决定是读它了。</li><li>如果快照是别人产生的，且<strong>已经提交完成</strong>了，那也行，决定读它了。</li></ul><p>比如下图，<code>undo日志1</code>正好小于<code>max_trx_id</code>，且事务已经提交，那么就读它了。</p><p><img src="https://cdn.xiaobaidebug.top/image/readview%E4%B8%8Eundo%E7%89%88%E6%9C%AC%E9%93%BE3.drawio.png" alt="readview与undo版本链"></p><br><h4 id="MVCC-是什么"><a href="#MVCC-是什么" class="headerlink" title="MVCC 是什么"></a>MVCC 是什么</h4><p>像上面这种，维护一个多快照的<strong>undo 日志版本链</strong>，事务根据自己的<code>read view</code>去决定具体读那个 undo 日志<strong>快照</strong>，最理想的情况下是每个事务都读自己的一份快照，然后在这个快照上做自己的逻辑，只有在写数据的时候，才去操作最新的行数据，这样<strong>读和写就被分开了</strong>，比起单行数据没有快照的方式，它能更好的解决读写冲突，所以数据库并发性能也更好。其实这就是面试里常问的<strong>MVCC</strong>，全称<strong>M</strong>ulti-<strong>V</strong>ersion <strong>C</strong>oncurrency <strong>C</strong>ontrol，即<strong>多版本并发控制。</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/MVCC.png" alt="MVCC"></p><br><h3 id="四个隔离级别是怎么实现的"><a href="#四个隔离级别是怎么实现的" class="headerlink" title="四个隔离级别是怎么实现的"></a>四个隔离级别是怎么实现的</h3><p>之前的写的<a href="https://mp.weixin.qq.com/s/2UxF7GJrAW2nY8bB57ZogQ">一篇文章</a>最后留了个问题，四个隔离级别是怎么实现的。</p><p>知道了<strong>undo 日志版本链</strong>和<strong>MVCC</strong>之后，我们再回过头来看下这个问题。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%9B%9B%E5%B1%82%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="四层隔离级别"></p><p><strong>读未提交</strong>，每次读到的都是最新的数据，也不管数据行所在的事务是否提交。实现也很简单，只需要每次都读 undo 日志版本链的<strong>链表头</strong>（最新的快照）就行了。</p><p>与读未提交不同，<strong>读提交和可重复读隔离级别都是基于 MVCC 的 read view 实现的</strong>，反过来说, <strong>MVCC 也只会出现在这两个隔离级别里</strong>。</p><p><strong>读已提交</strong>隔离级别，<strong>每次执行普通 select，都会重新生成一个新的 read view</strong>，然后拿着这个<strong>最新的 read view</strong>到某行数据的版本链上挨个遍历，找到第一个合适的数据。这样就能做到每次都读到其他事务最新<strong>已提交</strong>的数据。</p><p><strong>可重复读</strong>隔离级别下的事务只会在<strong>第一次</strong>执行<strong>普通 select</strong>时生成<code>read view</code>，后续不管执行几次普通 select，都会<strong>复用</strong>这个 read view。这样就能保持每次读的时候都是在同一标准下进行读取，那读到的数据也会是一样的。</p><p><strong>串行化</strong>目的就是让并发事务看起来就像单线程执行一样，那实现也很简单，<strong>和读未提交隔离级别一样</strong>，串行化隔离界别下事务只读 undo 日志链的链表头，也就是<strong>最新版本的快照</strong>，并且就算是普通 select，也会在版本链的<strong>最新快照</strong>上加入<strong>读锁</strong>。这样其他事务想写，也得等这个读锁释放掉才行。所有对这行数据进行操作的事务，都老老实实地阻塞等待加锁，一个接一个进行处理，从效果上看就跟单线程处理一样。</p><br><h3 id="再看文章开头的例子"><a href="#再看文章开头的例子" class="headerlink" title="再看文章开头的例子"></a>再看文章开头的例子</h3><p>我们用上面提到的概念，重新回到文章开头的例子，梳理一遍。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%814.drawio.png" alt="user表数据库原始状态"></p><p>我们<strong>假设</strong>数据库一开始的三条数据，都是由<code>trx_id=1</code>的事务<code>insert</code>生成的。</p><p>于是数据表一开始长下面这样。每行数据只有一个快照。注意快照里，<code>trx_id</code>填的是创建它们的事务 id，也就是刚刚提到的事务<code>1</code>。<code>roll_pointer</code>原本应该指向 insert 产生的 undo 日志，为了简化，这里写为<code>null</code>（insert undo 日志在事务提交后可以被清理掉）。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8Btrx%E4%BF%A1%E6%81%AF.drawio.png" alt="user表数据库原始trx信息.drawio"></p><p>下面这个图，还是文章开头的图，这里放出来是为了方便大家，不用划回去看了。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%83%BD%E6%98%AFselect%E7%BB%93%E6%9E%9C%E5%8D%B4%E4%B8%8D%E5%90%8C1.drawio.png" alt="都是select结果却不同"></p><p>在<strong>线程 1</strong>启动事务，我们假设它的事务<code>trx_id=2</code>，<strong>第一次执行普通 select，是快照读</strong>，在<strong>可重复读</strong>隔离级别，会生成一个<code>read view</code>。当前这个数据库，活跃事务只有它一个，那<code>m_ids =[2]</code>。 m_ids 里最小的 id，也就是<code>min_trx_id=2</code>。max_trx_id 是当前最大数据库事务 id（只有它自己，所以也是 2），加个 1，也就是<code>max_trx_id=3</code></p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%8B%E5%8A%A11%E7%9A%84readview.drawio.png" alt="事务1的readview"></p><p>此时<strong>线程 1</strong>的事务，拿着这个 read view 去读数据库表。</p><p>因为这三条数据的 trx_id=1 都小于 min_trx_id=2，都属于可见范围，因此能读到这三条数据的所有快照，最后返回符合条件（age&gt;=3）的数据，有 1 条。</p><br><p>这时候事务 2，假设它的事务<code>trx_id=3</code>，执行更新操作，生成新的 undo 日志快照。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8A%A0%E5%85%A5undo%E6%97%A5%E5%BF%97.drawio.png" alt="user表数据库加入undo日志"></p><p>此时线程 1<strong>第二次执行普通 select</strong>，还是<strong>快照读</strong>，由于是可重复读，会复用之前的 read view，再执行一次读操作，这里重点关注 id=2 的那行数据，从版本链表头开始遍历，<strong>第一个快照 trx_id=3</strong> <code>&gt;=</code> <strong>read view 的 max_trx_id=3</strong>，因此不可读，遍历下一个快照<strong>trx_id=1</strong> <code>&lt;</code> <strong>min_trx_id=2</strong>，可读。于是 id=2 的那行数据，还是拿到 age=2，而不是更新后的 age=3，因此快照读结果还是只有<strong>1 条</strong>数据符合 age&gt;=3。</p><p>但是线程 1<strong>第三次读，执行 select for update</strong>，就成了<strong>当前读</strong>了，直接读 undo 日志版本链里<strong>最新的那行快照</strong>，于是能读到 id=2，age=3，所以最终结果返回<strong>符合 age&gt;=3 的数据有 2 条</strong>。</p><p>总的来说就是，由于快照读和当前读，读数据的规则不同，我们看到了不一样的结果。</p><br><p>看到这里，大家应该理解了，所谓的可重复读<strong>每次读</strong>都要读到一样的数据，这里头的**”读”<strong>，指的是</strong>快照读**。</p><p>如果下次面试官问你，<strong>可重复读隔离级别下每次读到的数据都是一样的吗？</strong></p><p>你该知道怎么回答了吧？</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>事务通过 undo 日志实现回滚的功能，从而实现事务的原子性（Atomicity）。</li><li>多个事务生成的 undo 日志构成一条版本链。<strong>快照读</strong>时事务根据 read view 来决定具体读哪个快照。<strong>当前读</strong>时事务直接读最新的快照版本。</li><li>mysql 的 innodb 引擎通过 MVCC 提升了读写并发。</li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql的索引为什么使用B+树而不使用跳表？</title>
      <link href="/2022/04/16/%E5%9B%BE%E8%A7%A3mysql/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9F/"/>
      <url>/2022/04/16/%E5%9B%BE%E8%A7%A3mysql/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="mysql-的索引为什么使用-B-树而不使用跳表？"><a href="#mysql-的索引为什么使用-B-树而不使用跳表？" class="headerlink" title="mysql 的索引为什么使用 B+树而不使用跳表？"></a>mysql 的索引为什么使用 B+树而不使用跳表？</h2><br><p>在我们的印象中，mysql 数据表里无非就是存储一行行的数据。跟个 excel 似的。</p><p>直接遍历这一行行数据，性能就是 O(n)，比较慢。为了加速查询，使用了<strong>B+树</strong>来做索引，将查询性能优化到了**O(lg(n))**。</p><p>但问题就来了，查询数据性能在 lg(n) 级别的数据结构有很多，比如 redis 的 zset 里用到的<strong>跳表</strong>，也是**lg(n)**，并且实现还贼简单。</p><p><strong>那为什么 mysql 的索引，不使用跳表呢？</strong></p><p>我们今天就来聊聊这个话题。</p><br><h3 id="B-树的结构"><a href="#B-树的结构" class="headerlink" title="B+树的结构"></a>B+树的结构</h3><p>之前的一篇<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>里，已经提到过<strong>B+树的结构</strong>了。文章不长，如果没看过，建议先看下。</p><p><strong>当然，不看也行。</strong></p><p>在这里，<del>为了混点字数</del>，我简单总结下 B+树的结构。</p><p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="B+树查询过程"><br>如上图，一般 B+树是由多个页组成的<strong>多层级</strong>结构，每个页<code>16Kb</code>，对于主键索引来说，最末级的<strong>叶子结点</strong>放行数据，<strong>非叶子结点</strong>放的则是索引信息（主键 id 和页号），用于加速查询。</p><p>比方说我们想要查找行数据 5。会先从顶层页的 record 们入手。<strong>record 里包含了主键 id 和页号（页地址）</strong>。关注黄色的箭头，向左最小 id 是 1，向右最小 id 是 7。那 id=5 的数据如果存在，那必定在左边箭头。于是顺着的 record 的页地址就到了<code>6号</code>数据页里，再判断 id=5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。</p><p>在<code>105号数据页</code>里，虽然有多行数据，但也<strong>不是挨个遍历的</strong>，数据页内还有个<strong>页目录</strong>的信息，它可以通过<strong>二分查找</strong>的方式加速查询行数据，于是找到 id=5 的数据行，完成查询。</p><p>从上面可以看出，B+树利用了<strong>空间换时间</strong>的方式（构造了一批非叶子结点用于存放索引信息），**将查询时间复杂度从 O(n)优化为 O(lg(n))**。</p><br><h3 id="跳表的结构"><a href="#跳表的结构" class="headerlink" title="跳表的结构"></a>跳表的结构</h3><p>看完 B+树，我们再来看下跳表是怎么来的。</p><p>同样的，还是为了存储一行行的数据。</p><p>我们可以将它们用<strong>链表</strong>串起来。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p><p>想要查询链表中的其中一个结点，时间复杂度是 O(n)，这谁顶得住，于是将<strong>部分</strong>链表结点提出来，再构建出一个新的链表。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%A4%E5%B1%82%E8%B7%B3%E8%A1%A8.png" alt="两层跳表"></p><p>这样当我想要查询一个数据的时候，我先查上层的链表，就很容易知道数据落在<strong>哪个范围</strong>，然后<strong>跳到下一个层级里进行查询。</strong>这样就把搜索范围一下子缩小了一大半。</p><p>比如查询 id=10 的数据，我们先在上层遍历，依次判断 1,6,12，很快就可以判断出 10 在 6 到 12 之间，然后往下一跳，就可以在遍历 6,7,8,9,10 之后，确定 id=10 的位置。直接将查询范围从原来的 1 到 10，变成现在的 1,6,7,8,9,10，算是砍半了。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%A4%E5%B1%82%E8%B7%B3%E8%A1%A8%E6%9F%A5%E6%89%BEid%E4%B8%BA10%E7%9A%84%E6%95%B0%E6%8D%AE.drawio.png" alt="两层跳表查找id为10的数据"></p><p>既然两层链表就直接将查询范围砍半了，那我<strong>多加几层</strong>，岂不妙哉？</p><p>于是跳表就这样变成了多层。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%89%E5%B1%82%E8%B7%B3%E8%A1%A8.png" alt="三层跳表"></p><p>如果还是查询 id=10 的数据，就只需要查询 1,6,9,10 就能找到，比两层的时候更快一些。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%89%E5%B1%82%E8%B7%B3%E8%A1%A8%E6%9F%A5%E8%AF%A2id%E4%B8%BA10%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="三层跳表查询id为10的数据"></p><p>可以看出，跳表也是通过<strong>牺牲空间换取时间</strong>的方式提升查询性能。**时间复杂度都是 lg(n)**。</p><br><h3 id="B-树和跳表的区别"><a href="#B-树和跳表的区别" class="headerlink" title="B+树和跳表的区别"></a>B+树和跳表的区别</h3><p>从上面可以看到，B+树和跳表的<strong>最下面一层，都包含了所有的数据</strong>，且都是<strong>顺序的，适合用于范围查询</strong>。往上的层级都是构建出来用于提升搜索性能的。这两者实在是太像了。但他们两者在<strong>新增和删除数据</strong>时，还是有些区别的。下面我们以新增数据为例聊一下。</p><br><h4 id="B-树新增数据会怎么样"><a href="#B-树新增数据会怎么样" class="headerlink" title="B+树新增数据会怎么样"></a>B+树新增数据会怎么样</h4><p>B+树本质上是一种多叉平衡二叉树。关键在于”<strong>平衡</strong>“这两个字，对于多叉树结构来说，它的含义是子树们的高度层级尽量一致（一般最多差一个层级），这样在搜索的时候，不管是到哪个子树分支，搜索次数都差不了太多。</p><p>当数据库表不断插入新的数据时，为了维持 B+树的平衡，B+树会不断分裂调整数据页。</p><p>我们知道 B+树分为<strong>叶子结点和非叶子结点</strong>。</p><p>当插入一条数据时，叶子结点和它上层的索引结点（非叶子结点）最大容量都是 16k，它们都有可能会满。</p><p>为了简化问题，我们<strong>假设</strong>一个数据页只能放三条行数据或索引。</p><p>加入一条数据，根据数据页会不会满，分为三种情况。</p><ul><li><strong>叶子结点和索引结点都没满</strong>。这种情况最简单，直接插入到叶子结点中就好了。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8F%B6%E5%AD%90%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E9%83%BD%E6%9C%AA%E6%BB%A1.png" alt="叶子和非叶子都未满"></p><ul><li><strong>叶子结点满了，但索引结点没满</strong>。此时需要拆分叶子结点，同时索引结点要增加新的索引信息。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8F%B6%E5%AD%90%E6%BB%A1%E4%BA%86%E4%BD%86%E9%9D%9E%E5%8F%B6%E5%AD%90%E6%9C%AA%E6%BB%A1.drawio.png" alt="叶子满了但非叶子未满.drawio"></p><ul><li><strong>叶子结点满了，且索引结点也满了</strong>。叶子和索引结点都要拆分，同时往上还要再<strong>加一层索引。</strong></li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8F%B6%E5%AD%90%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E9%83%BD%E6%BB%A1%E4%BA%86.png" alt="叶子和非叶子都满了"></p><p>从上面可以看到，只有在叶子和索引结点<strong>都满了</strong>的情况下，B+树才会考虑加入一层新的结点。</p><p>而从之前的<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>知道，要把三层 B+树塞满，那大概需要 2kw 左右的数据。</p><br><h4 id="跳表新增数据"><a href="#跳表新增数据" class="headerlink" title="跳表新增数据"></a>跳表新增数据</h4><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据。</p><p>此时，<strong>是否需要在上面的几层中加入数据做索引呢？</strong></p><p>这个就纯靠<strong>随机函数</strong>了。</p><p>理论上为了达到<strong>二分的效果</strong>，每一层的结点数需要是下一层结点数的二分之一。</p><p>也就是说现在有一个新的数据插入了，它有<code>50%</code>的概率需要在<code>第二层</code>加入索引，有<code>25%</code>的概率需要在<code>第三层</code>加个索引，以此类推，直到<code>最顶层</code>。</p><p>举个例子，如果跳表中插入数据 id=6，且随机函数返回第三层（有 25%的概率），那就需要在跳表的最底层到第三层都插入数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%B7%B3%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.drawio.png" alt="跳表插入数据"></p><p>如果这个随机函数设计成上面这样，当<strong>数据量样本足够大</strong>的时候，数据的分布就符合我们理想中的”二分”。</p><p>跟上面 B+树不一样，跳表是否新增层数，纯粹靠随机函数，根本不关心前后上下结点。</p><br><p>好了，基础科普也结束了，我们可以进入正题了。</p><br><h3 id="mysql-的索引为什么使用-B-树而不使用跳表？-1"><a href="#mysql-的索引为什么使用-B-树而不使用跳表？-1" class="headerlink" title="mysql 的索引为什么使用 B+树而不使用跳表？"></a>mysql 的索引为什么使用 B+树而不使用跳表？</h3><p><strong>B+树</strong>是多叉树结构，每个结点都是一个 16k 的数据页，能存放较多索引信息，所以<strong>扇出很高</strong>。<strong>三层</strong>左右就可以存储<code>2kw</code>左右的数据（知道结论就行，想知道原因可以看之前的<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>）。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询<strong>三次磁盘 IO</strong>。</p><br><p><strong>跳表</strong>是链表结构，一条数据一个结点，如果最底层要存放<code>2kw</code>数据，且每次查询都要能达到<strong>二分查找</strong>的效果，<code>2kw</code>大概在<code>2的24次方</code>左右，所以，跳表大概高度在<strong>24 层</strong>左右。最坏情况下，这 24 层数据会分散在不同的数据页里，也即是查一次数据会经历<strong>24 次磁盘 IO</strong>。</p><p>因此存放同样量级的数据，B+树的高度比跳表的要少，如果放在 mysql 数据库上来说，就是<strong>磁盘 IO 次数更少，因此 B+树查询更快</strong>。</p><p>而针对<strong>写操作</strong>，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比 B+树要好。</strong></p><p>其实，mysql 的<strong>存储引擎是可以换的</strong>，以前是<code>myisam</code>，后来才有的<code>innodb</code>，它们底层索引用的都是<strong>B+树</strong>。也就是说，你完全可以造一个索引为跳表的存储引擎装到 mysql 里。事实上，<code>facebook</code>造了个<code>rocksDB</code>的存储引擎，里面就用了<strong>跳表</strong>。直接说结论，它的<strong>写入性能</strong>确实是比 innodb 要好，但<strong>读性能</strong>确实比 innodb 要差不少。感兴趣的话，可以在文章最后面的<strong>参考资料</strong>里看到他们的性能对比数据。</p><br><h3 id="redis-为什么使用跳表而不使用-B-树或二叉树呢？"><a href="#redis-为什么使用跳表而不使用-B-树或二叉树呢？" class="headerlink" title="redis 为什么使用跳表而不使用 B+树或二叉树呢？"></a>redis 为什么使用跳表而不使用 B+树或二叉树呢？</h3><p>redis 支持多种数据结构，里面有个<strong>有序集合</strong>，也叫<strong>ZSET</strong>。内部实现就是<strong>跳表</strong>。那为什么要<strong>用跳表而不用 B+树等结构呢？</strong></p><p>这个几乎每次面试都要被问一下。</p><p>虽然已经很熟了，但每次都要装作之前没想过，现场思考一下才知道答案。</p><p>真的，很考验演技。</p><p>大家知道，redis 是纯纯的内存数据库。</p><p>进行读写数据都是操作内存，跟磁盘没啥关系，因此也<strong>不存在磁盘 IO</strong>了，所以层高就不再是跳表的劣势了。</p><p>并且前面也提到 B+树是有一系列合并拆分操作的，换成红黑树或者其他 AVL 树的话也是各种旋转，目的也是<strong>为了保持树的平衡</strong>。</p><p>而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就<strong>少了旋转平衡的开销</strong>。</p><p>因此，redis 选了跳表，而不是 B+树。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>B+树是多叉平衡搜索树，扇出高，只需要 3 层左右就能存放 2kw 左右的数据，同样情况下跳表则需要 24 层左右，假设层高对应<strong>磁盘 IO</strong>，那么 B+树的读性能会比跳表要好，因此 mysql 选了 B+树做索引。</li><li>redis 的读写全在内存里进行操作，不涉及磁盘 IO，同时跳表实现简单，相比 B+树、AVL 树、少了旋转树结构的开销，因此 redis 使用跳表来实现 ZSET，而不是树结构。</li><li>存储引擎 RocksDB 内部使用了跳表，对比使用 B+树的 innodb，虽然写性能更好，但读性能属实差了些。在读多写少的场景下，B+树依旧 YYDS。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MYSQL 内核：INNODB 存储引擎 卷 1》</p><p>《RocksDB 和 Innodb 引擎性能 PK 胜负难料？》</p><p><a href="https://cloud.tencent.com/developer/article/1813695">https://cloud.tencent.com/developer/article/1813695</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><br><p>最近在看《龙蛇演义》，剧情很一般，但我硬是一口气看到了最新一集，还很上头。</p><p>为啥？</p><p>点开它，看到女主角的时候你就理解我了。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220404094330264.png"></p><p>这么说吧，一个颜值出众，身材火辣的姐姐，还是个世界顶级的武术高手，穿着旗袍，踩着高跟，做着各种让牛顿棺材板都快要按不住的动作，只为手把手教会你武术基本功。</p><p>这时候，剧情还重要吗？</p><p>不得不说，当我看到姐姐穿成这样用木棍顶起 400 斤的汞球时。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220404094549469.png"></p><br><p>我可以肯定，导演根本不懂物理。</p><br><p>但是！</p><br><p>导演很懂男人!</p><br><p>这不得不让我陷入沉思，<strong>到底什么才是好的内容?</strong></p><p>难道现在有个大姐姐穿个黑丝高跟超短裙，教你变量的声明和定义这么基础的东西，你也会去看吗？</p><p>我不知道你们会不会。</p><br><p>反正我会。</p><p><img src="https://cdn.xiaobaidebug.top/image/006Xk4cbgy1gqzc3sofewj30c805st8u.jpg"></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么大家说mysql数据库单表最大两千万？依据是啥？</title>
      <link href="/2022/04/05/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F%E4%BE%9D%E6%8D%AE%E6%98%AF%E5%95%A5%EF%BC%9F/"/>
      <url>/2022/04/05/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F%E4%BE%9D%E6%8D%AE%E6%98%AF%E5%95%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>故事从好多年前说起。</p><p>想必大家也听说过数据库单表<strong>建议最大 2kw</strong>条数据这个说法。如果超过了，性能就会下降得比较厉害。</p><p>巧了。</p><p>我也听说过。</p><p><strong>但我不接受它的建议，硬是单表装了 1 亿条数据。</strong></p><p>这时候，我们组里新来的实习生看到了之后，天真无邪的问我：”单表不是建议最大两千万吗？为什么这个表都<strong>放了 1 个亿还不分库分表</strong>“？</p><p>我能说我是<strong>因为懒</strong>吗？我当初设计时哪里想到这表竟然能涨这么快。。。</p><p>我不能。</p><p>说了等于承认自己是<strong>开发组里的毒瘤</strong>，虽然我确实是，但我<strong>不能承认</strong>。</p><p>我如坐针毡，如芒刺背，如鲠在喉。</p><p>开始了一波骚操作。</p><p>“我这么做是有道理的”</p><p>“虽然这个表很大，但你有没有发现它查询其实还是很快”</p><p>“这个 2kw 是个建议值，我们要来看下这个 2kw 是怎么来的”</p><br><h3 id="数据库单表行数最大多大？"><a href="#数据库单表行数最大多大？" class="headerlink" title="数据库单表行数最大多大？"></a>数据库单表行数最大多大？</h3><p>我们先看下单表行数理论最大值是多少。</p><p>建表的 SQL 是这么写的，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">100037</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>其中 id 就是主键。主键本身唯一，也就是说主键的大小可以限制表的上限。</p><p>如果主键声明为<code>int</code>大小，也就是 32 位，那么能支持 2^32-1，也就是<strong>21 个亿</strong>左右。</p><p>如果是<code>bigint</code>，那就是 2^64-1，但这个<strong>数字太大</strong>，一般还没到这个限制之前，<strong>磁盘先受不了</strong>。</p><p>搞离谱点。</p><p>如果我把主键声明为 <code>tinyint</code>，一个字节，8 位，最大 2^8-1，也就是<code>255</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` tinyint(<span class="number">2</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>如果我想插入一个 id=256 的数据，那<strong>就会报错</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp` (`id`, `name`, `age`) <span class="keyword">VALUES</span> (<span class="number">256</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;id&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是说，<code>tinyint</code>主键限制表内最多 255 条数据。</p><p>那除了主键，还有哪些因素会影响行数？</p><br><h3 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h3><p>索引内部是用的 B+树，这个也是八股文老股了，大家估计也背得很熟了。</p><p>为了不让大家有过于强烈的审丑疲劳，今天我尝试从另外一个角度给大家讲讲这玩意。</p><br><h4 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h4><p>假设我们有这么一张 user 数据表。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png" alt="user表"></p><p>其中 id 是<strong>唯一主键</strong>。</p><p>这看起来的一行行数据，为了方便，我们后面就叫它们<strong>record</strong>吧。</p><p>这张表看起来就跟个 excel 表格一样。excel 的数据在硬盘上是一个 xx.excel 的文件。</p><p>而上面 user 表数据，在硬盘上其实也是类似，放在了 user.<strong>ibd</strong>文件下。含义是 user 表的 innodb data 文件，专业点，又叫<strong>表空间</strong>。</p><p>虽然在数据表里，它们看起来是挨在一起的。但实际上在 user.ibd 里他们被分成很多小份的<strong>数据页</strong>，每份大小 16k。</p><p>类似于下面这样。</p><p><img src="https://cdn.xiaobaidebug.top/image/ibd%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E9%A1%B5.png" alt="ibd文件内部有大量的页"></p><p>我们把视角聚焦一下，放到页上面。</p><p>整个页<code>16k</code>，不大，但 record 这么多，一页肯定放不下，所以会分开放到很多页里。并且这 16k，也不可能全用来放 record 对吧。</p><p>因为 record 们被分成好多份，放到好多页里了，为了唯一标识具体是哪一页，那就需要引入<strong>页号</strong>（其实是一个表空间的地址偏移量）。同时为了把这些数据页给关联起来，于是引入了<strong>前后指针</strong>，用于指向前后的页。这些都被加到了<strong>页头</strong>里。</p><p>页是需要读写的，16k 说小也不小，写一半电源线被拔了也是有可能发生的，所以为了保证数据页的正确性，还引入了校验码。这个被加到了<strong>页尾</strong>。</p><p>那剩下的空间，才是用来放我们的 record 的。而 record 如果行数特别多的话，进入到页内时挨个遍历，效率也不太行，所以为这些数据生成了一个<strong>页目录</strong>，具体实现细节不重要。只需要知道，它可以通过<strong>二分查找</strong>的方式将查找效率**从 O(n) 变成 O(lgn)**。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="页结构"><br></p><h4 id="从页到索引"><a href="#从页到索引" class="headerlink" title="从页到索引"></a>从页到索引</h4><p>如果想查一条 record，我们可以把表空间里每一页都捞出来，再把里面的 record 捞出来挨个判断是不是我们要找的。</p><p>行数量小的时候，这么操作也没啥问题。</p><p><strong>行数量大了，性能就慢了</strong>，于是为了加速搜索，我们可以在每个数据页里选出<strong>主键 id 最小</strong>的 record，而且只需要它们的<strong>主键 id 和所在页的页号</strong>。组成<strong>新的 record</strong>，放入到一个新生成的一个数据页中，这个<strong>新数据页跟之前的页结构没啥区别，而且大小还是 16k。</strong></p><p>但为了跟之前的数据页进行区分。数据页里加入了<strong>页层级（page level）</strong>的信息，从 0 开始往上算。于是页与页之间就有了<strong>上下层级</strong>的概念，就像下面这样。</p><p><img src="https://cdn.xiaobaidebug.top/%E4%B8%A4%E5%B1%82B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="两层B+树结构"></p><p>突然页跟页之间看起来就像是一棵倒过来的树了。也就是我们常说的<strong>B+树</strong>索引。</p><p>最下面那一层，<strong>page level 为 0</strong>，也就是所谓的<strong>叶子结点</strong>，其余都叫<strong>非叶子结点</strong>。</p><p>上面展示的是<strong>两层</strong>的树，如果数据变多了，我们还可以再通过类似的方法，再往上构建一层。就成了<strong>三层</strong>的树。</p><p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%847.drawio.png" alt="B加树结构7.drawio"></p><br><p>那现在我们就可以通过这样一棵 B+树加速查询。举个例子。</p><p>比方说我们想要查找行数据 5。会先从顶层页的 record 们入手。<strong>record 里包含了主键 id 和页号（页地址）</strong>。看下图黄色的箭头，向左最小 id 是 1，向右最小 id 是 7。那 id=5 的数据如果存在，那必定在左边箭头。于是顺着的 record 的页地址就到了<code>6号</code>数据页里，再判断 id=5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。在数据页里找到 id=5 的数据行，完成查询。</p><p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="B+树查询过程"></p><p>另外需要注意的是，上面的页的页号并不是连续的，它们在磁盘里也不一定是挨在一起的。</p><p>这个过程中查询了三个页，如果这三个页都在磁盘中（没有被提前加载到内存中），那么<strong>最多</strong>需要经历三次<strong>磁盘 IO 查询</strong>，它们才能被加载到内存中。</p><br><h3 id="B-树承载的记录数量"><a href="#B-树承载的记录数量" class="headerlink" title="B+树承载的记录数量"></a>B+树承载的记录数量</h3><p>从上面的结构里可以看出 B+树的<strong>最末级叶子结点</strong>里放了 record 数据。而<strong>非叶子结点</strong>里则放了用来加速查询的索引数据。</p><p>也就是说</p><p>同样一个 16k 的页，非叶子节点里每一条数据都指向一个新的页，而新的页有两种可能。</p><ul><li>如果是末级叶子节点的话，那么里面放的就是一行行 record 数据。</li><li>如果是非叶子节点，那么就会循环继续指向新的数据页。</li></ul><p>假设</p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的 record 数量为<code>y</code></li><li>B+树的层数为<code>z</code></li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E6%80%BB%E8%A1%8C%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="总行数的计算方法"></p><p>那这棵 B+树放的<strong>行数据总量</strong>等于 <code>(x ^ (z-1)) * y</code>。</p><br><h4 id="x-怎么算"><a href="#x-怎么算" class="headerlink" title="x 怎么算"></a>x 怎么算</h4><p>我们回去看数据页的结构。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="页结构"></p><p>非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。</p><p>主键假设是<code>bigint（8Byte）</code>，而页号在源码里叫<code>FIL_PAGE_OFFSET（4Byte）</code>，那么非叶子节点里的一条数据是<code>12Byte</code>左右。</p><p>整个数据页<code>16k</code>， 页头页尾那部分数据全加起来大概<code>128Byte</code>，加上页目录毛估占<code>1k</code>吧。那剩下的<strong>15k</strong>除以<code>12Byte</code>，等于<code>1280</code>，也就是可以指向<strong>x=1280 页</strong>。</p><p>我们常说的二叉树指的是一个结点可以发散出两个新的结点。m 叉树一个节点能指向 m 个新的结点。这个指向新节点的操作就叫<strong>扇出（fanout）</strong>。</p><p>而上面的 B+树，它能指向 1280 个新的节点，恐怖如斯，可以说<strong>扇出非常高</strong>了。</p><br><h4 id="y-的计算"><a href="#y-的计算" class="headerlink" title="y 的计算"></a>y 的计算</h4><p>叶子节点和非叶子节点的数据结构是一样的，所以也假设剩下<code>15kb</code>可以发挥。</p><p>叶子节点里放的是真正的行数据。假设一条行数据<code>1kb</code>，所以一页里能放<strong>y=15 行</strong>。</p><br><h4 id="行总数计算"><a href="#行总数计算" class="headerlink" title="行总数计算"></a>行总数计算</h4><p>回到 <code>(x ^ (z-1)) * y </code> 这个公式。</p><p>已知<code>x=1280</code>，<code>y=15</code>。</p><p>假设 B+树是<strong>两层</strong>，那<code>z=2</code>。则是<code>(1280 ^ (2-1)) * 15 ≈ 2w </code></p><p>假设 B+树是<strong>三层</strong>，那<code>z=3</code>。则是<code>(1280 ^ (3-1)) * 15 ≈ 2.5kw</code></p><p><strong>这个 2.5kw，就是我们常说的单表建议最大行数 2kw 的由来。</strong>毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘 IO，也比较合理。</p><br><h3 id="行数超一亿就慢了吗？"><a href="#行数超一亿就慢了吗？" class="headerlink" title="行数超一亿就慢了吗？"></a>行数超一亿就慢了吗？</h3><p>上面假设单行数据用了 1kb，所以一个数据页能放个 15 行数据。</p><p>如果我单行数据用不了这么多，比如只用了<code>250byte</code>。那么单个数据页能放 60 行数据。</p><p>那同样是三层 B+树，单表支持的行数就是 <code>(1280 ^ (3-1)) * 60 ≈ 1个亿</code>。</p><p>你看我一个亿的数据，其实也就三层 B+树，在这个 B+树里要查到某行数据，最多也是三次磁盘 IO。所以并不慢。</p><p>这就很好的解释了文章开头，为什么我单表 1 个亿，但查询性能没啥大毛病。</p><br><h3 id="B-树承载的记录数量-1"><a href="#B-树承载的记录数量-1" class="headerlink" title="B 树承载的记录数量"></a>B 树承载的记录数量</h3><p>既然都聊到这里了，我们就顺着这个话题多聊一些吧。</p><p>我们都知道，现在 mysql 的索引都是 B+树，而有一种树，跟 B+树很像，叫<strong>B 树，也叫 B-树</strong>。</p><p>它跟 B+树最大的区别在于，<strong>B+树只在末级叶子结点处放数据表行数据，而 B 树则会在叶子和非叶子结点上都放。</strong></p><p>于是，B 树的结构就类似这样</p><p><img src="https://cdn.xiaobaidebug.top/image/B%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="B树结构"></p><p>B 树将行数据都存在非叶子节点上，假设每个数据页还是 16kb，掐头去尾每页剩 15kb，并且一条数据表行数据还是占 1kb，就算不考虑各种页指针的情况下，也只能放个 15 条数据。<strong>数据页扇出明显变少了。</strong></p><p>计算可承载的总行数的公式也变成了一个<strong>等比数列</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 + 15^2 +15^3 + ... + 15^z</span><br></pre></td></tr></table></figure><p>其中<strong>z 还是层数</strong>的意思。</p><p>为了能放<code>2kw</code>左右的数据，需要<code>z&gt;=6</code>。也就是树需要有 6 层，查一次要访问 6 个页。假设这 6 个页并不连续，为了查询其中一条数据，最坏情况需要进行<strong>6 次磁盘 IO</strong>。</p><p>而 B+树同样情况下放 2kw 数据左右，查一次最多是<strong>3 次磁盘 IO。</strong></p><p>磁盘 IO 越多则越慢，这两者在性能上差距略大。</p><p>为此，<strong>B+树比 B 树更适合成为 mysql 的索引。</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>B+树叶子和非叶子结点的数据页都是 16k，且数据结构一致，区别在于叶子节点放的是真实的行数据，而非叶子结点放的是主键和下一个页的地址。</li><li>B+树一般有两到三层，由于其高扇出，三层就能支持 2kw 以上的数据，且一次查询最多 1~3 次磁盘 IO，性能也还行。</li><li>存储同样量级的数据，B 树比 B+树层级更高，因此磁盘 IO 也更多，所以 B+树更适合成为 mysql 索引。</li><li>索引结构不会影响单表最大行数，2kw 也只是推荐值，超过了这个值可能会导致 B+树层级更高，影响查询性能。</li><li>单表最大值还受主键大小和磁盘大小限制。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MYSQL 内核：INNODB 存储引擎 卷 1》</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><br><p>虽然我在单表里塞了 1 亿条数据，但这个操作的前提是，我很清楚这不会太影响性能。</p><p>这波解释，毫无破绽，无懈可击。</p><p>到这里，连我自己都被自己说服了。想必实习生也是。</p><p>可恶，这该死的毒瘤竟然有些”知识渊博”。</p><p><img src="https://cdn.xiaobaidebug.top/image/p34066865-20220327102515813.jpg"></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库查询好慢，除了索引，还能因为什么？</title>
      <link href="/2022/03/22/%E5%9B%BE%E8%A7%A3mysql/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A5%BD%E6%85%A2%EF%BC%8C%E9%99%A4%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%98%E8%83%BD%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/03/22/%E5%9B%BE%E8%A7%A3mysql/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A5%BD%E6%85%A2%EF%BC%8C%E9%99%A4%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%98%E8%83%BD%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>我熟练应用 ctrl c 和 ctrl v 开发 curd 代码好多年了。</p><p>mysql 查询为什么会慢，关于这个问题，在实际开发经常会遇到，而面试中，也是个高频题。</p><p>遇到这种问题，我们一般也会想到是因为索引。</p><p><strong>那除开索引之外，还有哪些因素会导致数据库查询变慢呢？</strong></p><p><strong>有哪些操作，可以提升 mysql 的查询能力呢？</strong></p><p>今天这篇文章，我们就来聊聊会导致数据库查询变慢的场景有哪些，并给出原因和解决方案。</p><br><h3 id="数据库查询流程"><a href="#数据库查询流程" class="headerlink" title="数据库查询流程"></a>数据库查询流程</h3><p>我们先来看下，一条查询语句下来，会经历哪些流程。</p><p>比如我们有一张数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `gender` <span class="type">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`),</span><br><span class="line">  KEY `idx_gender` (`gender`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>我们平常写的应用代码（go 或 C++之类的），这时候就叫<strong>客户端</strong>了。</p><p>客户端底层会带着账号密码，尝试向 mysql 建立一条 TCP 长链接。</p><p>mysql 的<strong>连接管理模块</strong>会对这条连接进行管理。</p><p>建立连接后，客户端执行一条查询 sql 语句。 比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>客户端会将 sql 语句通过网络连接给 mysql。</p><p>mysql 收到 sql 语句后，会在<strong>分析器</strong>中先判断下 SQL 语句有没有语法错误，比如 select，如果少打一个<code>l</code>，写成<code>slect</code>，则会报错<code>You have an error in your SQL syntax; </code>。这个报错对于我这样的手残党来说可以说是很熟悉了。</p><p>接下来是<strong>优化器</strong>，在这里会<strong>根据一定的规则选择该用什么索引</strong>。</p><p>之后，才是通过<strong>执行器</strong>去调用<strong>存储引擎</strong>的接口函数。</p><p><img src="https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio.png" alt="Mysql架构"></p><span id="more"></span><p><strong>存储引擎</strong>类似于一个个组件，它们才是 mysql 真正获取一行行数据并返回数据的地方，存储引擎是可以替换更改的，既可以用不支持事务的 MyISAM，也可以替换成支持事务的 Innodb。这个可以在建表的时候指定。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  ...</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>现在最常用的是<strong>InnoDB</strong>。</p><p>我们就重点说这个。</p><p>InnoDB 中，因为直接操作磁盘会比较慢，所以加了一层内存提提速，叫<strong>buffer pool</strong>，这里面，放了很多内存页，每一页 16KB，有些内存页放的是数据库表里看到的那种一行行的数据，有些则是放的索引信息。</p><p><img src="https://cdn.xiaobaidebug.top/image/bufferPool%E4%B8%8E%E7%A3%81%E7%9B%982.png" alt="bufferPool与磁盘"></p><p>查询 SQL 到了 InnoDB 中。会根据前面优化器里计算得到的索引，去<strong>查询相应的索引页</strong>，如果不在 buffer pool 里则从磁盘里加载索引页。<strong>再通过索引页加速查询，得到数据页</strong>的具体位置。如果这些数据页不在 buffer pool 中，则从磁盘里加载进来。</p><p>这样我们就得到了我们想要的一行行数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E7%B4%A2%E5%BC%95%E9%A1%B5%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A1%B5%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="索引页与磁盘页的关系"></p><p>最后将得到的数据结果返回给客户端。</p><br><h3 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h3><p>如果上面的流程比较慢的话，我们可以通过开启<code>profiling</code>看到流程慢在哪。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> profiling     <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>然后正常执行 sql 语句。</p><p>这些 SQL 语句的执行时间都会被记录下来，此时你想查看有哪些语句被记录下来了，可以执行 <code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.06811025</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">60</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00151375</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">80</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">0.00230425</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">60</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">0.00070400</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0.07797650</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">!=</span><span class="number">60</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>关注下上面的<code>query_id</code>，比如<code>select * from user where age&gt;=60 </code>对应的 query_id 是 1，如果你想查看这条 SQL 语句的具体耗时，那么可以执行以下的命令。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000074</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.000034</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000032</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000027</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000020</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000058</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.000018</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000013</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.067701</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000047</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000027</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>通过上面的各个项，大家就可以看到具体耗时在哪。比如从上面可以看出 Sending data 的耗时最大，这个是指<strong>执行器</strong>开始查询数据并将数据发送给客户端的耗时，因为我的这张表符合条件的数据有<strong>好几万条</strong>，所以这块耗时最大，也符合预期。</p><p>一般情况下，我们开发过程中，耗时大部分时候都在<code>Sending data</code>阶段，而这一阶段里如果慢的话，最容易想到的还是索引相关的原因。</p><br><h3 id="索引相关原因"><a href="#索引相关原因" class="headerlink" title="索引相关原因"></a>索引相关原因</h3><p>索引相关的问题，一般能用 explain 命令帮助分析。通过它能看到<strong>用了哪些索引</strong>，大概会<strong>扫描多少行</strong>之类的信息。</p><p>mysql 会在<strong>优化器阶段</strong>里看下选择哪个索引，查询速度会更快。</p><p>一般主要考虑几个因素，比如：</p><ul><li>选择这个索引大概要扫描<strong>多少行</strong>（rows）</li><li>为了把这些行取出来，需要读<strong>多少个 16kb 的页</strong></li><li>走普通索引需要回表，主键索引则不需要，<strong>回表成本</strong>大不大？</li></ul><br><p>回到 show profile 中提到的 sql 语句，我们使用<code>explain select * from user where age&gt;=60</code> 分析一下。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220319080215281.png" alt="explain sql"></p><p>上面的这条语句，使用的<code>type</code>为 ALL，意味着是<strong>全表扫描</strong>，<code>possible_keys</code>是指<strong>可能用得到的索引</strong>，这里可能使用到的索引是为 age 建的普通索引，但实际上数据库使用的索引是在<code>key</code>那一列，是<code>NULL</code>。也就是说<strong>这句 sql 不走索引，全表扫描</strong>。</p><p>这个是因为数据表里，符合条件的数据行数（<code>rows</code>）太多，如果使用 age 索引，那么需要将它们从 age 索引中读出来，并且 age 索引是<strong>普通索引</strong>，还需要<strong>回表</strong>找到对应的<strong>主键</strong>才能找到对应的<strong>数据页</strong>。算下来还不如直接走主键划算。于是最终选择了全表扫描。</p><p>当然上面只是举了个例子，实际上，mysql 执行 sql 时，<strong>不用索引或者用的索引不符合我们预期</strong>这件事经常发生，索引失效的场景有很多，比如用了<strong>不等号，隐式转换</strong>等，这个相信大家背八股文的时候也背过不少了，我也不再赘述。</p><p>聊两个生产中容易遇到的问题吧。</p><br><h4 id="索引不符合预期"><a href="#索引不符合预期" class="headerlink" title="索引不符合预期"></a>索引不符合预期</h4><p>实际开发中有些情况比较特殊，比如有些数据库表一开始数据量小，索引少，执行 sql 时，确实使用了符合你预期的索引。但随时时间边长，开发的人变多了，数据量也变大了，甚至还可能会加入一些其他重复多余的索引，就有可能出现用着用着，用到了不符合你预期的其他索引了。从而导致查询突然变慢。</p><p>这种问题，也好解决，可以通过<code>force index</code><strong>指定索引</strong>。比如</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220319093631814.png" alt="force index指定索引"></p><p>通过<code>explain</code>可以看出，加了 force index 之后，sql 就选用了 idx_age 这个索引了。</p><br><h4 id="走了索引还是很慢"><a href="#走了索引还是很慢" class="headerlink" title="走了索引还是很慢"></a>走了索引还是很慢</h4><p>有些 sql，用<code>explain</code>命令看，明明是走索引的，但还是很慢。一般是两种情况：</p><p>第一种是索引区分度太低，比如网页全路径的 url 链接，这拿来做索引，一眼看过去全都是同一个域名，如果<strong>前缀索引</strong>的长度建得不够长，那这走索引跟走<strong>全表扫描</strong>似的，正确姿势是尽量让索引的<strong>区分度</strong>更高，比如域名去掉，只拿后面 URI 部分去做索引。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E7%B4%A2%E5%BC%95%E5%89%8D%E7%BC%80%E5%8C%BA%E5%88%86%E5%BA%A6%E5%A4%AA%E4%BD%8E.drawio.png" alt="索引前缀区分度太低"></p><p>第二种是索引中匹配到的数据太大，这时候需要关注的是 explain 里的<strong>rows</strong>字段了。</p><p>它是用于<strong>预估</strong>这个查询语句需要查的行数的，它不一定完全准确，但可以体现个大概量级。</p><p>当它很大时，一般常见的是下面几种情况。</p><ul><li><p>如果这个字段具有<strong>唯一</strong>的属性，比如电话号码等，一般是不应该有大量重复的，那可能是你代码逻辑出现了<strong>大量重复插入</strong>的操作，你需要检查下代码逻辑，或者需要加个<strong>唯一索引</strong>限制下。</p></li><li><p>如果这个字段下的数据就是会很大，是否需要全部拿？如果不需要，加个<code>limit</code>限制下。如果确实要拿全部，那也不能一次性全拿，今天你数据量小，可能一次取一两万都没啥压力，万一哪天涨到了十万级别，那一次性取就有点吃不消了。你可能需要<strong>分批次取</strong>，具体操作是先用<code>order by id</code>排序一下，拿到一批数据后取<code>最大id</code>作为下次取数据的起始位置。</p></li></ul><br><h3 id="连接数过小"><a href="#连接数过小" class="headerlink" title="连接数过小"></a>连接数过小</h3><p>索引相关的原因我们聊完了，我们来聊聊，<strong>除了索引之外，还有哪些因素会限制我们的查询速度的。</strong></p><p>我们可以看到，mysql 的 server 层里有个<strong>连接管理</strong>，它的作用是管理客户端和 mysql 之间的长连接。</p><p>正常情况下，客户端与 server 层如果只有<strong>一条</strong>连接，那么在执行 sql 查询之后，只能阻塞等待结果返回，如果有大量查询同时并发请求，那么<strong>后面的请求都需要等待前面的请求执行完成</strong>后，才能开始执行。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%B0%91%E4%BC%9A%E5%AF%BC%E8%87%B4sql%E9%98%BB%E5%A1%9E.png" alt="连接过少会导致sql阻塞"></p><p>因此很多时候我们的应用程序，比如 go 或 java 这些，<strong>会打印出 sql 执行了几分钟的日志，但实际上你把这条语句单独拎出来执行，却又是毫秒级别的。</strong>这都是因为这些 sql 语句在<strong>等待</strong>前面的 sql 执行完成。</p><p>怎么解决呢？</p><p>如果我们能<strong>多建几条连接</strong>，那么请求就可以并发执行，后面的连接就不用等那么久了。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%A2%9E%E5%8A%A0%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BF%AB%E6%89%A7%E8%A1%8Csql.png" alt="增加连接可以加快执行sql"></p><p>而连接数过小的问题，<strong>受数据库和客户端两侧同时限制</strong>。</p><br><h4 id="数据库连接数过小"><a href="#数据库连接数过小" class="headerlink" title="数据库连接数过小"></a>数据库连接数过小</h4><p>Mysql 的最大连接数默认是<code>100</code>, 最大可以达到<code>16384</code>。</p><p>可以通过设置 mysql 的<code>max_connections</code>参数，更改数据库的最大连接数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> max_connections<span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> max_connections <span class="operator">|</span> <span class="number">500</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面的操作，就把最大连接数改成了 500。</p><br><h4 id="应用侧连接数过小"><a href="#应用侧连接数过小" class="headerlink" title="应用侧连接数过小"></a>应用侧连接数过小</h4><p>数据库连接大小是调整过了，但貌似问题还是没有变化？还是有很多 sql 执行达到了几分钟，甚至超时？</p><p>那有可能是因为你应用侧（go，java 写的应用，也就是 mysql 的客户端）的连接数也过小。</p><p>应用侧与 mysql 底层的连接，是<strong>基于 TCP 协议的长链接</strong>，而 TCP 协议，需要经过<strong>三次握手和四次挥手</strong>来实现建连和释放。如果我每次执行 sql 都重新建立一个新的连接的话，那就要不断握手和挥手，这很<strong>耗时</strong>。所以一般会建立一个<strong>长连接池</strong>，连接用完之后，塞到连接池里，下次要执行 sql 的时候，再从里面捞一条连接出来用，非常环保。</p><p><img src="https://cdn.xiaobaidebug.top/image/connection_pool.png" alt="连接池原理"></p><p>我们一般写代码的时候，都会通过第三方的<strong>orm 库</strong>来对数据库进行操作，而成熟的 orm 库，<strong>百分之一千万都会有个连接池。</strong></p><p>而这个连接池，一般会有个大小。这个大小就控制了你的连接数最大值，如果说你的连接池太小，都还没有数据库的大，那调了数据库的最大连接数也没啥作用。</p><p>一般情况下，可以翻下你使用的 orm 库的文档，看下怎么设置这个连接池的大小，就几行代码的事情，改改就好。比如 go 语言里的<code>gorm</code>里是这么设置的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(mysql.Open(conn), config)</span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">200</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="buffer-pool-太小"><a href="#buffer-pool-太小" class="headerlink" title="buffer pool 太小"></a>buffer pool 太小</h3><p>连接数是上去了，速度也提升了。</p><p>曾经遇到过面试官会追问，<strong>有没有其他办法可以让速度更快呢？</strong></p><p>那必须要眉头紧锁，假装思考，然后说：<strong>有的</strong>。</p><p>我们在前面的数据库查询流程里，提到了进了 innodb 之后，会有一层内存 buffer pool，用于将磁盘数据页加载到内存页中，只要查询到 buffer pool 里有，就可以直接返回，否则就要走磁盘 IO，那就慢了。</p><p>也就是说，<strong>如果我的 buffer pool 越大，那我们能放的数据页就越多，相应的，sql 查询时就更可能命中 buffer pool，那查询速度自然就更快了。</strong></p><p>可以通过下面的命令查询到 buffer pool 的大小，单位是<code>Byte</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">134217728</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>也就是<code>128Mb</code>。</p><p>如果想要调大一点。可以执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">536870912</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">536870912</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这样就把 buffer pool 增大到 512Mb 了。</p><p>但是吧，如果 buffer pool 大小正常，只是<strong>别的原因</strong>导致的查询变慢，那改 buffer pool 毫无意义。</p><p>但问题又来了。</p><br><h4 id="怎么知道-buffer-pool-是不是太小了？"><a href="#怎么知道-buffer-pool-是不是太小了？" class="headerlink" title="怎么知道 buffer pool 是不是太小了？"></a>怎么知道 buffer pool 是不是太小了？</h4><p>这个我们可以看<strong>buffer pool 的缓存命中率</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220319113917654.png" alt="查看buffer pool命中率"></p><p>通过 <code>show status like  &#39;Innodb_buffer_pool_%&#39;;</code>可以看到跟 buffer pool 有关的一些信息。</p><p><code>Innodb_buffer_pool_read_requests</code>表示读请求的次数。</p><p><code>Innodb_buffer_pool_reads</code> 表示从物理磁盘中读取数据的请求次数。</p><p>所以 buffer pool 的命中率就可以这样得到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer pool 命中率 <span class="operator">=</span> <span class="number">1</span> <span class="operator">-</span> (Innodb_buffer_pool_reads<span class="operator">/</span>Innodb_buffer_pool_read_requests) <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p>比如我上面截图里的就是，1 - (405/2278354) = 99.98%。可以说命中率非常高了。</p><p>一般情况下<strong>buffer pool 命中率</strong>都在<code>99%</code>以上，如果低于这个值，才需要考虑加大 innodb buffer pool 的大小。</p><p>当然，还可以把这个命中率做到<strong>监控</strong>里，这样半夜 sql 变慢了，早上上班还能定位到原因，就很舒服。</p><br><h3 id="还有哪些骚操作？"><a href="#还有哪些骚操作？" class="headerlink" title="还有哪些骚操作？"></a>还有哪些骚操作？</h3><p>前面提到的是在<strong>存储引擎层</strong>里加入了 buffer pool 用于缓存内存页，这样可以加速查询。</p><p>那同样的道理，<strong>server 层</strong>也可以加个缓存，直接将第一次查询的结果缓存下来，这样<strong>下次</strong>查询就能立刻返回，听着挺美的。</p><p>按道理，如果命中缓存的话，确实是能为查询加速的。但这个功能限制很大，其中最大的问题是只要数据库表被更新过，表里面的<strong>所有缓存都会失效</strong>，数据表频繁的更新，就会带来频繁的缓存失效。所以这个功能只适合用于那些<strong>不怎么更新的数据表。</strong></p><p>另外，这个功能在<code>8.0版本</code>之后，就被<strong>干掉</strong>了。所以这功能用来聊聊天可以，没必要真的在生产中使用啊。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%A2%AB%E5%88%A0%E9%99%A4.png" alt="查询缓存被删除"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数据查询过慢一般是索引问题，可能是因为选错索引，也可能是因为查询的行数太多。</li><li>客户端和数据库连接数过小，会限制 sql 的查询并发数，增大连接数可以提升速度。</li><li>innodb 里会有一层内存 buffer pool 用于提升查询速度，命中率一般&gt;99%，如果低于这个值，可以考虑增大 buffer pool 的大小，这样也可以提升速度。</li><li>查询缓存（query cache）确实能为查询提速，但一般不建议打开，因为限制比较大，并且 8.0 以后的 Mysql 里已经将这个功能干掉了。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个事务并发写，能保证数据唯一吗？</title>
      <link href="/2022/03/16/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%86%99%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E5%90%97%EF%BC%9F/"/>
      <url>/2022/03/16/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%86%99%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>哟，又是我小白。最近有点高产了。</p><p>连我自己都害怕了。</p><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly8grrdl7zawuj30af0afwiu.jpg"></p><span id="more"></span><p>直接进入正题吧。</p><br><h2 id="两个事务并发写，能保证数据唯一吗？"><a href="#两个事务并发写，能保证数据唯一吗？" class="headerlink" title="两个事务并发写，能保证数据唯一吗？"></a>两个事务并发写，能保证数据唯一吗？</h2><p>我先来解释下标题讲的是个啥。</p><br><p>我们假设有这么一个用户注册的场景。用户并发请求注册新用户。</p><p>你有一张数据库表，也就是下面的 user 表。</p><p><img src="https://cdn.xiaobaidebug.top/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="user表数据库原始状态"></p><p>产品经理要求用户和用户之间，电话号码不能重复，为了保证这一点。我们想到了先查一下数据库，再判断一下，如果存在，就退出，否则插入一条数据。类似下面这样的伪代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">where</span> phone_no <span class="operator">=</span><span class="number">2</span>;  <span class="operator">/</span><span class="operator">/</span> 查询<span class="keyword">sql</span></span><br><span class="line">if (<span class="keyword">user</span> 存在) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">user</span>;   <span class="operator">/</span><span class="operator">/</span> 插入<span class="keyword">sql</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这是两条 sql 语句，先执行查询 sql，判断后再决定要不要执行插入 sql。每次用户注册的时候都会执行这么一段逻辑。</p><p>那如果，此时有多个用户在做操作，就会<strong>并发</strong>执行这段逻辑。</p><p>如果都并发执行，第一条 sql 语句执行完之后，都会发现没有用户存在。此时都执行了插入，这样就出现了两条一样的数据才对。</p><p>所以，有人就想了，这<strong>两条 sql 语句逻辑应该是一个整体</strong>，不应该拆开，于是就想到了事务，通过事务把这两个 sql 作为<strong>一个整体</strong>，要么一起执行，要么都回滚。</p><p>这正是数据库 ACID 里的 A（Atomicity），原子性的完美体现啊。</p><p><img src="https://cdn.xiaobaidebug.top/image/ACID.png" alt="ACID"></p><p>伪代码类似下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">where</span> phone_no <span class="operator">=</span><span class="number">2</span>;  <span class="operator">/</span><span class="operator">/</span> 查询<span class="keyword">sql</span></span><br><span class="line">if (<span class="keyword">user</span> 存在) &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">user</span>;   <span class="operator">/</span><span class="operator">/</span> 插入<span class="keyword">sql</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>那么问题来了，<strong>这段逻辑，并发执行，能保证数据唯一？</strong></p><p><strong>当然是不能。</strong></p><p>事务內的多条 sql 语句，确实是原子的，要么一起成功，要么一起失败，这没错，但跟这个场景没什么太大关系。事务是并发执行的，第一个事务执行查询用户，并<strong>不会阻塞</strong>另一个事务查询用户，所以都有可能查到用户不存在，此时两个事务逻辑都判断为用户不存在，然后插入数据库。事务内两条 sql 都执行成功了，于是就插入了两条一样的数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%86%99%E5%85%A5%E4%B8%A4%E6%9D%A1%E6%95%B0%E6%8D%AE.drawio.png" alt="并发事务写入两条数据.drawio"></p><br><h2 id="怎么保证数据唯一？"><a href="#怎么保证数据唯一？" class="headerlink" title="怎么保证数据唯一？"></a>怎么保证数据唯一？</h2><p>那么我们接下来聊聊，怎么保证上面这种场景下，插入的数据是唯一的。方法有很多种，但我们今天只讨论 mysql 内部的做法，不考虑其他外部中间件（比如 redis 分布式锁这些）。</p><br><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>通过下面的命令，可以为数据库 user 表的 phone_no 字段加入唯一索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `user` ADD unique(`phone_no`);</span><br></pre></td></tr></table></figure><p>我们执行一条写操作时，比如下面这句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`user_name`, `phone_no`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>第一次会插入成功，第二次再执行插入，则会出现报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate entry <span class="string">&#x27;2&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;phone_no&#x27;</span></span><br></pre></td></tr></table></figure><p>含义是 phone_no 这个字段是唯一的，加两次 phone_no=2 会导致重复。</p><p>于是乎回到我们文章开头的场景里，就完美解决了重复插入的问题了。</p><br><p>那么问题来了。</p><br><h4 id="为什么唯一索引能保证数据唯一？"><a href="#为什么唯一索引能保证数据唯一？" class="headerlink" title="为什么唯一索引能保证数据唯一？"></a>为什么唯一索引能保证数据唯一？</h4><p>我们看看一句写操作，会经历什么。</p><p><img src="https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio.png" alt="Mysql架构"></p><p>首先，mysql 作为一个数据库，内部主要分为两层，一层是<strong>server 层</strong>，一层是<strong>存储引擎层</strong>（一般是<strong>innodb</strong>）。</p><p>server 层主要管的是数据库链接，权限校验，以及 sql 语句校验和优化之类的工作。请求打到存储引擎层，才是真正的查询和更新数据的操作。</p><p>大家都知道数据库是持久化存储，且最后都是把数据存到<strong>磁盘</strong>上的。</p><p><strong>那数据库读写是直接读写磁盘数据吗？</strong></p><p>不是，如果直接读写磁盘的话，那就太慢了，为了提升速度。</p><p>它在磁盘前面加了一层内存，叫<strong>buffer pool</strong>。它里面有很多细节，但最主要的就是个双向链表，里面放的是一个个数据页，每个数据页的大小默认是 16kb，数据页里面放的就是磁盘的数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/bufferPool%E4%B8%8E%E7%A3%81%E7%9B%98.png" alt="bufferPool与磁盘"></p><p>于是有了这层 buffer pool 内存，mysql 的读和写操作都可以先操作这部分内存，如果想要读写的数据页不在 buffer pool 里，再跑到磁盘里去捞。由于<strong>读写内存的速度比读写磁盘快得多</strong>。</p><p><strong>所以引擎读写都快多了。</strong></p><p>但这还不够，<strong>很多时候写操作，我的诉求就是把 xx 更新为 xx，或插入 xx，数据库光知道这一点就够了，我根本不需要知道数据页原来长什么样子。</strong></p><p>有点抽象？举个例子吧。</p><p>比方说我想要把 id=1 的这条数据的 phone_no 字段更新为 100，数据库知道这一点就够了，至于这条数据原来 phone_no 究竟是等于 20，还是 30，这根本不重要，反正最后都会变成我想要的 phone_no=100。</p><p>也就是说，如果有那么<strong>一块内存</strong>，记录下我准备把数据改成什么样子，然后后续异步慢慢更新到磁盘数据上。那我甚至到不需要在一开始就把这块数据从磁盘读到 buffer pool 中，按照这个思路，<strong>change buffer</strong>就来了。</p><p><img src="https://cdn.xiaobaidebug.top/image/changeBuffer%E5%9C%A8bufferPool%E5%86%852.png" alt="changeBuffer在bufferPool内"></p><p>于是乎，写加了<strong>普通索引</strong>的数据，它只要把想要写的内容写到 change buffer 上，就立马结束返回了。后面 innodb 引擎拿着这个 change buffer，再异步读入磁盘数据到内存，将 change buffer 的数据修改到数据页中，再写回磁盘，这速度就上来了，秒啊。</p><p>但这个 change buffer，放在<strong>唯一索引</strong>这里就不管用了，毕竟，它得保证数据真的只有一条，那就得去看下数据库里，是不是真的有这条数据。</p><p>所以，对于 insert 场景，普通索引把需求扔到 change buffer 就完事返回了，而唯一索引需要真的把数据从磁盘读到内存来，看下是不是有重复的，没重复的再插入数据。</p><p>这唯一索引，在性能上就输了一截了。</p><p>所以回到<strong>唯一索引为什么能保证数据唯一</strong>的问题上，一句话概括就是，<strong>唯一索引会绕过 change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>加唯一索引可以保证数据并发写入时数据唯一，而且最省事省心。</p></li><li><p>数据库通过引入一层 buffer pool 内存来提升读写速度，普通索引可以利用 change buffer 提高数据插入的性能。</p></li><li><p>唯一索引会绕过 change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</p></li></ul><br><p>给大家留个问题呗，前面也提到了，<strong>innodb 中，利用了 change buffer，为普通索引做了加速</strong>。<strong>有没有哪些场景下，change buffer 不仅不能给普通索引加速，还起到反作用的呢？</strong></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>大家也别笑，文章开头提到的通过开事务来保证数据唯一性的错误操作，其实很容易犯，而且我曾经也遇到过不止一次这样的事情。</p><p>做这个操作的人，还会信誓旦旦，言之凿凿的说出他的理解，在我解释了几遍发现无果之后，我选择低头假装思考，然后说：”你说的有点道理，我再回去好好想想”，然后默默的为数据表加上唯一索引……</p><p>我相信对方肯定已经理解了。那一刻，我感觉我写的不是代码，我写的是人情世故。</p><p><img src="https://cdn.xiaobaidebug.top/image/006ARE9vgy1fz5ahct0mhj30mk0m83zo.jpg"></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给32位系统装8g内存条能用吗？为什么？</title>
      <link href="/2022/03/09/%E5%9B%BE%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%9932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%A3%858g%E5%86%85%E5%AD%98%E6%9D%A1%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/03/09/%E5%9B%BE%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%9932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%A3%858g%E5%86%85%E5%AD%98%E6%9D%A1%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/421646663617_.pic_hd.jpg"></p><p>关于 32 位和 64 位，这个概念一直让人比较懵。</p><span id="more"></span><p>在买电脑的时候，我们看到过<strong>32 位和 64 位 CPU</strong>。</p><p>下软件的时候，我们也看到过<strong>32 位或 64 位的软件</strong>。</p><p>就连装虚拟机的时候，我们也看过<strong>32 位和 64 位的系统</strong>。</p><p>在写代码的时候，我们的数值，也可以定义为<strong>int32 或者 int64</strong>。</p><p>我们当然很清楚，装软件的时候，一般 64 位的系统就选 64 位的软件，肯定不出错，但是这又是为什么呢？既然 CPU，软件，操作系统，数值大小都有 32 位和 64 位，他们之间就可以随意组合成各种问题，比如 32 位的系统能装 64 位的软件吗？32 位的系统能计算 int64 的数值吗？他们之间到底有什么关系？这篇文章会尝试解释清楚。</p><br><h3 id="从代码到到可执行文件"><a href="#从代码到到可执行文件" class="headerlink" title="从代码到到可执行文件"></a>从代码到到可执行文件</h3><p>我们从熟悉的场景开始说起，比方说，我们写代码的时候，会在代码编辑器里写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i,j;</span><br><span class="line">         i = <span class="number">3</span>;</span><br><span class="line">         j = <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个代码是给人看的，机器可看不懂，于是这段代码，还会经过被编译器转成<strong>汇编码</strong>。</p><p>汇编码就是我们大学的时候学的头秃的这种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// gcc -S test.c</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset %rbp, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">movl$3, -8(%rbp)</span><br><span class="line">movl$2, -12(%rbp)</span><br><span class="line">movl-8(%rbp), %eax</span><br><span class="line">addl-12(%rbp), %eax</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>大家也别去看上面的内容，没必要。</p><p>而汇编，总归还是有各种 movl，pushq 这些符号，虽然确实不好看，但说到底<strong>还是给人看的</strong>，而机器 cpu 要的，说到底还是要 0101 这样的<strong>二进制编码</strong>，所以还需要使用汇编器将汇编转成二进制的<strong>机器码</strong>。我们可以看到下面内容分为 3 列，左边是指令地址， 右边是汇编码内容，中间的就是指令机器码，是 16 进制，可以转成二进制 01 串，这就是机器 cpu 能认识的内容了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// objdump -d test</span><br><span class="line">0000000000001125 &lt;main&gt;:</span><br><span class="line">    1125:55                   push   %rbp</span><br><span class="line">    1126:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1129:c7 45 fc 03 00 00 00 movl   $0x3,-0x4(%rbp)</span><br><span class="line">    1130:c7 45 f8 02 00 00 00 movl   $0x2,-0x8(%rbp)</span><br><span class="line">    1137:8b 55 fc             mov    -0x4(%rbp),%edx</span><br><span class="line">    113a:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">    113d:01 d0                add    %edx,%eax</span><br><span class="line">    113f:5d                   pop    %rbp</span><br><span class="line">    1140:c3                   retq</span><br><span class="line">    1141:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1148:00 00 00</span><br><span class="line">    114b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BB%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%88%B0%E6%9C%BA%E5%99%A8%E7%A0%81.drawio-20220419210021874.png" alt="从高级语言到机器码"></p><p>而机器码，最后会放在我们编译生成的<strong>可执行文件</strong>里。</p><p>也就是说我们平时写的代码，最后会变成一堆 01 机器码，放在可执行文件里，躺在磁盘上。</p><br><h3 id="从可执行文件到进程"><a href="#从可执行文件到进程" class="headerlink" title="从可执行文件到进程"></a>从可执行文件到进程</h3><p>一旦我们执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./可执行文件名</span><br></pre></td></tr></table></figure><p>这个可执行文件就会加载进<strong>内存</strong>中，成为一个<strong>进程</strong>，运行起来。</p><p>可执行文件里的机器码也会被加载到内存中，它就像是一张列满 todo list 的清单，而 CPU 就对照着这张清单，一行行的执行上面的机器码。从效果上来看，进程就动起来了。</p><p>对 CPU 来说，它执行到某个特定的编码数值，就会执行特定的操作。比如计算 2+3，其实就是通过<strong>总线</strong>把数据 2 和 3 从<strong>内存</strong>里读入，然后放到<strong>寄存器</strong>上，再用加法器相加这两个数值并将结果放入到寄存器里，最后将这个数值回写到内存中，以此循环往复，一行行执行机器码直到退出。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.drawio-20220419210036155.png" alt="进程内存与CPU的执行逻辑"></p><br><h4 id="CPU-位数的含义"><a href="#CPU-位数的含义" class="headerlink" title="CPU 位数的含义"></a>CPU 位数的含义</h4><p>上面这个流程里，最重要的几个关键词，分别是<strong>CPU 寄存器，总线，内存</strong>。</p><p>CPU 的寄存器，说白了就是个存放数值的小盒子，盒子的大小，叫<strong>位宽</strong>。32 位 CPU 能放入最大 2^32 的数值。64 位就是最大 2^64 的值。这里的 32 位位宽的 CPU 就是我们常说的 32 位 CPU，同理 64 位 CPU 也是一样。</p><p>而<strong>CPU 跟内存</strong>之间，是用<strong>总线</strong>来进行信号传输的，总线可以分为<strong>数据总线，控制总线，地址总线</strong>。功能如其名，举个例子说明下他们的作用吧。在一个进程的运行过程中，CPU 会根据进程的机器码一行行执行操作。</p><p>比如现在有一行是将 A 地址的数据与 B 地址的数据相加，那么 CPU 就会通过<strong>控制总线</strong>，发送信号给内存这个设备，告诉它，现在 CPU 要通过<strong>地址总线</strong>在内存中找到<strong>A 数据的地址</strong>，然后取得 A 数据的值，假设是 100，那么这个 100，就会通过<strong>数据总线</strong>回传到 CPU 的某个寄存器中。B 也一样，假设 B=200，放到另一个寄存器中，此时 A 和 B 相加后，结果是 300，然后控制 CPU 通过<strong>地址总线</strong>找到返回的参数地址，再把数据结果通过<strong>数据总线</strong>传回内存中。这一存一取，CPU 都是通过<strong>控制总线</strong>对内存发出指令的。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%89%E7%B1%BB%E6%80%BB%E7%BA%BF.png" alt="三类总线"></p><p>而<strong>总线，也可以理解为有个宽度</strong>，比如宽度是 32 位，那么一次可以传 32 个 0 或 1 的信号，那么这个宽度能表达的数值范围就是 0 到 2^32 这么多。</p><p>32 位 CPU 的总线宽度一般是 32 位，因为刚刚上面提到了，CPU 可以利用地址总线在<strong>内存</strong>中进行寻址操作，那么现在这根地址总线，最大能寻址的范围，也就到 2^32，其实就是 4G。</p><p>64 位 CPU，按理说总线宽度是 64 位，但实际上是 48 位（也有看到说是 40 位或 46 位的，没关系，你知道它很大就行了），所以寻址范围能到 2^48 次方，也就是 256T。</p><br><h4 id="系统和软件的位数的含义"><a href="#系统和软件的位数的含义" class="headerlink" title="系统和软件的位数的含义"></a>系统和软件的位数的含义</h4><p>上面提到了 32 位 CPU 和 64 位 CPU 的内存寻址范围，那么相应的操作系统，和软件（其实操作系统也能说是软件），也应该按 CPU 所能支持的范围去构建自己的寻址范围。</p><p>比方说下面这个图，在操作系统上运行一个用户态进程，会分为用户态和内核态，并设定一定的内存布局。操作系统和软件都需要以这个内存布局为基础运行程序。比如 32 位，内核态分配了 1 个 G，用户态分配了 3G，这种时候，你总不能将程序的运行内存边界设定在大于 10G 的地方。所以，系统和软件的位数，可以理解为，这个系统或软件内存寻址的范围位数。</p><p><img src="https://cdn.xiaobaidebug.top/image/32%E5%92%8C64%E4%BD%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%B7%AE%E5%BC%82.png" alt="32和64位的内存差异"></p><p>一般情况下，由于现在我们的 CPU 架构在设计上都是<strong>完全向前兼容</strong>的，别说 32 位了，16 位的都还兼容着，因此 64 位的 CPU 是能装上 32 位操作系统的。</p><p>同理，64 位的操作系统是兼容 32 位的软件的，所以 32 位软件能装在 64 位系统上。</p><p>但反过来，因为 32 位操作系统只支持 4g 的内存，而 64 位的软件在编译的时候就设定自己的内存边界不止 4 个 G，并且 64 位的 CPU 指令集内容比 32 位的要多，所以 32 位操作系统是肯定不能运行 64 位软件的。</p><p>同理，32 位 CPU 也不能装 64 位的操作系统的。</p><br><h4 id="程序数值-int32-和-int64-的含义"><a href="#程序数值-int32-和-int64-的含义" class="headerlink" title="程序数值 int32 和 int64 的含义"></a>程序数值 int32 和 int64 的含义</h4><p>这个我们平时写代码接触的最多，比较好理解了。int32 也就是用 4 个字节，32 位的内存去存储数据，int64 也就是用 8 个字节，64 位去存数据。这个数值就是刚刚 CPU 运行流程中放在<strong>内存里</strong>的数据。</p><br><p>那么问题又来了。</p><br><h4 id="32-位的-CPU-能进行-int64-位的数值计算吗？"><a href="#32-位的-CPU-能进行-int64-位的数值计算吗？" class="headerlink" title="32 位的 CPU 能进行 int64 位的数值计算吗？"></a>32 位的 CPU 能进行 int64 位的数值计算吗？</h4><p>先说结论，<strong>能</strong>。但比起 64 位的 CPU，<strong>性能会慢一些</strong>。</p><p>如果说我用的是 64 位的<strong>CPU</strong>，那么我在计算两个 int64 的<strong>数值</strong>相加时，我就能将数据通过 64 位的<strong>总线</strong>，一次性存入到 64 位的<strong>寄存器</strong>，并在进行计算后返回到内存中。整个过程一步到位，一气呵成。</p><p>但如果我现在用的是 32 位的 CPU，那就憋屈一点了，我虽然在代码里放了个 int64 的数值，但实际上 CPU 的寄存器根本放不下这么大的数据，因此最简单的方法是，将 int64 的数值，拆成前后两半，现在两个 int64 相加，就变成了 4 个 int32 的数值相加，并且后半部分加好了之后，拿到进位，才能去计算前面的部分，这里光是执行的指令数就比 64 位的 CPU 要多。所以理论上，会更慢些。</p><br><h3 id="系统位数会限制内存吗？"><a href="#系统位数会限制内存吗？" class="headerlink" title="系统位数会限制内存吗？"></a>系统位数会限制内存吗？</h3><p>上面提到了 CPU 位数，系统位数，软件位数，以及数值位数之间的区别与联系。</p><p>现在，我们回到标题里提到的问题。</p><br><h4 id="32-位-CPU-和系统插-8g-内存条，能用吗？"><a href="#32-位-CPU-和系统插-8g-内存条，能用吗？" class="headerlink" title="32 位 CPU 和系统插 8g 内存条，能用吗？"></a>32 位 CPU 和系统插 8g 内存条，能用吗？</h4><p>系统能正常工作，但<strong>一般用不到 8G</strong>，因为 32 位系统的总线寻址能力为 2 的 32 次方，也就是 4G，<strong>哪怕装了 8G 的内存，真正能被用到的其实只有 4g，多少有点浪费。</strong></p><p>注意上面提到的是<strong>一般</strong>，为什么这么说，因为这里有例外，32 位系统里，有些是可以支持超过 4G 内存的，比如<strong>Windows Server 2003</strong>就能最大支持 64G 的内存，它通过使用 <strong>PAE</strong> （Intel <strong>P</strong>hysical <strong>A</strong>ddress <strong>E</strong>xtension）技术向程序提供更多的物理内存，PAE 本质上是通过<strong>分页管理</strong>的方式将 32 位的总线寻址能力增加到 36 位。因此<strong>理论上</strong>寻址能力达到 2 的 36 次方，也就是 64G。</p><p><img src="https://cdn.xiaobaidebug.top/image/PAE%E8%83%BD%E8%AE%A932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%BE%97%E5%A4%A7%E4%BA%8E4G%E7%9A%84%E5%86%85%E5%AD%98.drawio.png" alt="PAE能让32位系统获得大于4G的内存"></p><p>至于实现细节大家也不用关心，现在用到这玩意的机器也该淘汰的差不多了，而且都是 windows server，注意<strong>Windows Server 2003</strong> 名字里带个<strong>server</strong>，是用来做服务器的，我们一般也用不到，知道这件事，除了能帮助我们更好的装 x 外，就没什么作用了。</p><p>所以，<strong>你当 32 位系统最大只能用到 4G 内存，那也没毛病。</strong></p><br><h4 id="64-位-CPU-装-32-位操作系统，再插上-8g-的内存条，寻址能力还是-4G-吗"><a href="#64-位-CPU-装-32-位操作系统，再插上-8g-的内存条，寻址能力还是-4G-吗" class="headerlink" title="64 位 CPU 装 32 位操作系统，再插上 8g 的内存条，寻址能力还是 4G 吗"></a>64 位 CPU 装 32 位操作系统，再插上 8g 的内存条，寻址能力还是 4G 吗</h4><p>上面提到 32 位 CPU 就算插上 8G 内存条，寻址能力也还是 4G，那如果说我现在换用 64 位的 CPU，但装了个 32 位的操作系统，这时候插入 8G 内存条，寻址能力能超过 4G 吗？</p><p>寻址能力，除了受到 cpu 的限制外，还受到操作系统的限制，如果操作系统就是按着 32 位的指令和寻址范围（4G）来编译的话，那么它就会缺少 64 位系统该有的指令，它在运行软件的时候就不能做到超过这个限制，因此<strong>寻址能力还会是 4G。</strong></p><br><p>最后留下一个问题吧。</p><p>上面提到，我们平时写的代码（也就是 C，go，java 这些），先转成汇编，再转成机器码。最后 CPU 执行的是机器码，那么问题来了。</p><p><strong>为什么我们平时写的代码不直接转成机器码，而要先转成汇编，这是不是多此一举？</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>CPU 位数主要指的是寄存器的位宽，</p></li><li><p>32 位 CPU 只能装 32 位的系统和软件，且能计算 int64，int32 的数值。内存寻址范围是 4G。</p></li><li><p>64 位 CPU，同时兼容 32 位和 64 位的系统和软件，并且进行 int64 数值计算的时候，性能比 32 位 CPU 更好，内存寻址范围可以达到 256T。</p></li><li><p>32 位 CPU 和操作系统，插入 8G 的内存，会有点浪费，因为总线寻址范围比较有限，它只能用上 4G 不到的内存。</p></li><li><p>64 位 CPU，如果装上 32 位的操作系统，就算插上 8G 的内存，效果也还是只能用上 4G 不到的内存。</p></li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>刚工作的时候一直觉得 int32，有 21 个亿，这么大的数值肯定够用了吧，结果现实好几次打脸。</p><p>以前做游戏的时候，血量一开始是定义为 int32，游戏设定是可以通过充钱，提升角色的属性，还能提升血量上限，谁也没想到，老板们通过氪金，硬是把血量给打到了 int32 最大值。于是策划提了个一句话需求：”血量要支持到 int64 大小”，这是我见过最简单的策划案，但也让人加班加的最凶。</p><p>那是我第一次感受到了钞能力。</p><img src="https://cdn.xiaobaidebug.top/image/1593863685553.jpg" width = "50%"   align=center /><br><p>这篇文章老早就想写了，但涉及的知识点有点多，一直很头疼，怎么样才能用最简单的方式把他们表述清楚，于是想着从大家最熟悉的场景开始说起。希望能给大家带来价值。</p><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？</title>
      <link href="/2022/03/02/%E5%9B%BE%E8%A7%A3mysql/mysql%E4%B8%BB%E5%BA%93%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%BA%86%EF%BC%8C%E4%B8%BB%E5%BA%93%E8%BF%98%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC%E5%90%97%EF%BC%9F/"/>
      <url>/2022/03/02/%E5%9B%BE%E8%A7%A3mysql/mysql%E4%B8%BB%E5%BA%93%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%BA%86%EF%BC%8C%E4%B8%BB%E5%BA%93%E8%BF%98%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>大家好，我是小白，好长时间没更新技术文了，相信大家看我写的水文也看烦了。</p><p><img src="https://cdn.xiaobaidebug.top/image/1539510639669-20220302001234401.jpg"></p><span id="more"></span><p>今天的文章，其实来自真实的面试题，而且还比较有趣，所以忍不住分享出来。</p><p>直接开始吧。</p><br><p>我们知道，mysql 数据库，为了得到更高性能，一般会<strong>读写分离</strong>，主库用于写操作，比如用于执行<code>insert，update</code>操作，从库用于读，也就是最常见的<code>select</code>操作。像下面这个图这样。</p><p><img src="https://cdn.xiaobaidebug.top/image/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB2.drawio-20220419205818771.png" alt="mysql读写分离"></p><p>虽然主库一般用于写操作，但也是<strong>能读</strong>的。那么今天的问题来了。</p><ul><li><p>主库更新后，<strong>主库</strong>都读到最新值了，<strong>从库</strong>还有可能读到旧值吗？</p></li><li><p>主库更新后，<strong>从库</strong>都读到最新值了，<strong>主库</strong>还有可能读到旧值吗？</p></li></ul><p>毕竟面试官都这么问了，那当然是有可能的，那至于是为啥，以及怎么做到的，今天我们来好好聊聊。</p><h3 id="正常的主从更新流程"><a href="#正常的主从更新流程" class="headerlink" title="正常的主从更新流程"></a>正常的主从更新流程</h3><p>比如我在主库和从库都有张 user 表，此时有以下两条数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="数据库原始状态"></p><p>正常情况下，我们往主库执行写操作，比如更新一条数据，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>虽然这是一个单条写操作，但本质上可以理解为单条语句的事务。等同于下面这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个事务如果执行成功了，数据会先写入到主库的 binlog 文件中，然后再刷入磁盘。</p><p><strong>binlog 文件</strong>是 mysql 的 server 层日志，记录了用户对数据库有哪些变更操作，比如建数据库表加字段，对某些行的增删改等。</p><p>它的位置可以通过下面的查询语句看到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%log_bin%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slave<span class="operator">-</span>bin       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slave<span class="operator">-</span>bin.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure><p>其中 binlog 在 <code>/var/lib/mysql/</code> 下，命名会类似<code>mysql-bin.00000x</code>。感兴趣的可以到这个目录下直接查看文件内容长什么样子。</p><br><p>如果两个 mysql 配置好了主从的关系，那么他们之间会建立一个<strong>tcp 长连接</strong>，主要用于传输同步数据。</p><p>除此之外，主库还会再起一个<strong>binlog dump 线程</strong>将 binlog 文件的变更发给从库。</p><p>可以在<strong>主库</strong>中通过 <code>show full processlist;</code> 查询到 binlog dump 线程的存在。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220301084729507.png" alt="主库的binlog dump线程"></p><p>以上，主库的工作就结束了，我们说说从库的。</p><p>从库在收到 binlog 后，会有一个<strong>io 线程</strong>负责把收到的数据写入到<strong>relay log（中继日志）</strong>中。</p><p>然后再有一个<strong>sql 线程</strong>，来读取 relay log 的内容，然后对从库执行 sql 语句操作，从结果上来看就是将主库执行过的写操作，在从库上也重放一遍，这样主从数据就一致了。</p><br><p>是不是感觉 relay log 有些多余？</p><br><p><strong>为什么要先写一遍 relay log 然后再写从库，直接将数据写入到从库不好吗？</strong></p><p>在这里 relay log 的作用就类似于一个<strong>中间层</strong>，<strong>主库是多线程并发写的，从库的 sql 线程是单线程串行执行的，所以这两边的生产和消费速度肯定不同。</strong>当主库发的 binlog 消息过多时，从库的 relay log 可以起到暂存主库数据的作用，接着从库的 sql 线程再慢慢消费这些 relay log 数据，这样既不会限制主库发消息的速度，也不会给从库造成过大压力。</p><p>可以通过在<strong>从库</strong>中执行 <code>show full processlist;</code> 确认 io 线程和 sql 线程的存在。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220301102221753.png" alt="io线程和sql线程"></p><p>因此总结起来，主从同步的步骤就是</p><p><strong>1.执行更新 sql 语句。</strong></p><p><strong>2.主库写成功时，binlog 会更新。</strong></p><p><strong>3.主库 binlog dump 线程将 binlog 的更新部分发给从库</strong></p><p><strong>4.从库 io 线程收到 binlog 更新部分，然后写入到 relay log 中</strong></p><p><strong>5.从库 sql 线程读取 relay log 内容，重放执行 sql，最后主从一致。</strong></p><p><img src="https://gitee.com/xiaobaiTech/image/raw/master/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="mysql主从同步"></p><p>到这里，我们可以开始回答文章开头的第一个问题。</p><br><h3 id="主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？"><a href="#主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？" class="headerlink" title="主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？"></a>主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？</h3><p>这是可能的，上面提到的主从同步的 5 个步骤里，第 3 到第 5 步骤，都需要时间去执行，而这些步骤的执行时间总和，就是我们常说的<strong>主从延迟</strong>。</p><p>当更新一行数据后，立马去读主库，主库的数据肯定是最新值，这点没什么好说的，但<strong>如果此时主从延迟过大，这时候读从库，同步可能还没完成，因此读到的就是旧值。</strong></p><p>在实际的开发当中，主从延迟也非常常见，当数据库压力稍微大点，主从延迟就能到 100ms 甚至 1s 以上。</p><p>具体的主从延迟时间可以在从库中执行 <code>show slave status \G;</code>来查看，其中里面的<code>Seconds_Behind_Master</code>则是主从延迟的时间，单位是秒。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">                  Master_Host: <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">                  Master_User: slave</span><br><span class="line">                Connect_Retry: <span class="number">30</span></span><br><span class="line">              Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">          Read_Master_Log_Pos: <span class="number">756</span></span><br><span class="line">               Relay_Log_File: edu<span class="operator">-</span>mysql<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000004</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">969</span></span><br><span class="line">        Relay_Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">        Seconds_Behind_Master: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以如果你有<strong>写数据后就立马要读数据</strong>的场景，要是此时读的是从库，很有可能会读到<strong>更新前</strong>的旧数据，如果你对数据一致性有较高要求，这种时候<strong>建议读主库</strong>。</p><br><h3 id="主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？"><a href="#主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？" class="headerlink" title="主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？"></a>主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？</h3><p>那另一个问题就来了，如果从库都读到最新值了，那说明<strong>主库肯定已经更新完成了</strong>，那此时读主库是不是只能读到最新值呢？</p><p><strong>还真不是的</strong>，待会我给大家复现下，但在这之前我们了解一些<strong>前置知识点</strong>。</p><br><h4 id="mysql-的四种隔离级别"><a href="#mysql-的四种隔离级别" class="headerlink" title="mysql 的四种隔离级别"></a>mysql 的四种隔离级别</h4><p>这个绝对是面试八股文老股了。mysql 有四种隔离级别，分别是<strong>读未提交（Read uncommitted），读提交（Read committed），可重复读（Repeatable read）和串行化（Serializable）</strong>。在不同的隔离级别下，并发读写效果会不太一样。</p><p>当前数据库处于什么隔离级别可以通过执行 <code>select @@tx_isolation;</code> 查看到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>也可以通过下面的语句去修改隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE<span class="operator">-</span>READ;</span><br></pre></td></tr></table></figure><p>下面用一个 case 来让大家直观点的理解这四个隔离级别的区别。</p><p>假设我们有两个线程同时对某行数据 A(A=1)进行以下操作。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%80%E4%B8%AAcase%E8%A7%A3%E9%87%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.2drawio.png" alt="一个case解释隔离级别"></p><p>我们执行事务都像上面这样，begin 可以开启事务，commit 会提交事务，上面两个线程，各执行一个事务，且此时是并发执行。</p><p>线程 1 会将某行的 A 这个字段从 1 更新为 2。</p><p>线程 2 啥也不干，就读 A。重点关注 2 线程的三次读 A 的行为，它们会根据隔离级别的不同，读到不同的值。</p><p><strong>第 1 次读 A：</strong></p><ul><li>如果是<strong>读未提交</strong>，那么会读到 2，顾名思义，就算线程 1 未提交，线程 2 也能读到最新的值。</li><li>如果是读提交或者可重复读，那读到的都是 1，<strong>读提交</strong>只认事务提交后的数据，而<strong>可重复读</strong>只要线程 2 的事务内没有执行对 A 的更新 sql 语句，那读 A 的数据就会一直不变。</li></ul><p><strong>第 2 次读 A：时机正好在线程 1 提交了事务之后</strong></p><ul><li>如果是读未提交，前面都读到 2 了，现在读到的还是 2，这个没啥好说的。</li><li>如果是<strong>读提交</strong>，那读到的都是 2 了，因为线程 1 的事务提交了，<strong>读提交</strong>只认提交后的数据，所以此时线程 2 能读到最新数据。</li><li>如果是可重复读那就还是 1，理由跟上面一样。</li></ul><p><strong>第 3 次读 A：时机正好在线程 2 提交了事务之后</strong></p><ul><li>如果是读未提交或读已经提交，结果跟前面一样，还是 2。</li><li>如果是<strong>可重复读</strong>，那就变成了 2，因为线程 2 前面的事务结束了，在<strong>同一个事务内 A 的值重复多次读都是一致的</strong>，但当事务结束了之后，新的查询不再需要受限于上一次开事务时的值。</li></ul><p>上面的情况没有将<strong>串行化</strong>纳入讨论范围，只讨论了<strong>读未提交，读提交和可重复读</strong>这三个隔离级别，因为在这三个隔离级别下都有可能出现两个事务<strong>并发执行</strong>的场景，而在<strong>串行化的隔离级别</strong>中则不会出现，多个事务只会一个挨着一个依次<strong>串行执行</strong>，比如线程 1 的事务执行完了之后，线程 2 的事务才执行，因此不会产生并发查询更新的问题。</p><br><p>有了这个知识背景之后，我们就可以回到第二个问题里了。</p><p>数据库原始状态如下，此时主从都一样。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81-20220419205854846.png" alt="数据库原始状态"></p><p>假设当前的数据库事务隔离级别是<strong>可重复读</strong>，现在主库有 A，B 两个线程，同时执行 begin，开启事务。</p><p>此时主库的线程 2，<strong>先读一次 id=1 的数据</strong>，发现 age=72，<strong>由于当前事务隔离级别是可重复读</strong>，那么只要线程 2 在事务内不做更新操作的话，那么<strong>不管重复读多少次，age 都是 72</strong>。在这之后主库的线程 1 将 age 更新为 100 且执行 commit 提交了事务。</p><p>主库线程 1 的事务提交成功之后 binlog 就会顺利产生，然后同步给从库。此时<strong>从库去查询就能查到最新值 age=100</strong>。回过头来，此时主库的线程 2 因为还没提交事务，所以一直读到的都是旧值 age=72。但如果这时候线程 2 执行 commit 提交了事务，那么再查询，就能拿到最新值 age=100 了。</p><p>所以从结论上来说，<strong>出现了从库都读到最新值了，主库却读到了旧值的情况。</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/2%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%B8%BB%E5%BA%93%E5%8D%B4%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC.drawio.png" alt="从库读到最新值主库却读到旧值"></p><br><p>好了这道题到这里就结束了。</p><p>意不意外？</p><p>这道面试题，通过一个问题，将主从同步，事务隔离级别等知识点都串起来了。</p><p>还是有点意思的。</p><p>那么问题又来了，这四个隔离级别是挺骚气的，那他们是怎么实现的呢？</p><p><img src="https://cdn.xiaobaidebug.top/image/1597215709606.gif"></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么张一鸣推崇延时满足。。。</title>
      <link href="/2022/01/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%A0%E4%B8%80%E9%B8%A3%E6%8E%A8%E5%B4%87%E5%BB%B6%E6%97%B6%E6%BB%A1%E8%B6%B3/"/>
      <url>/2022/01/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%A0%E4%B8%80%E9%B8%A3%E6%8E%A8%E5%B4%87%E5%BB%B6%E6%97%B6%E6%BB%A1%E8%B6%B3/</url>
      
        <content type="html"><![CDATA[<p>大家知道，字节的文化里，有一条叫”<strong>延迟满足</strong>“，意思是为了长远的、更大的利益，自愿延缓或者放弃目前的、较小的满足，有种<strong>先苦后甜</strong>的那个味道。</p><p>看到标题，感觉好像会是个口水文，可能会通过人物故事去剖析，然后讲一些没什么用的鸡汤。</p><p>我需要否定下，至少不是“好像”，这就是口水文。</p><p>我希望能从更底层的原理来聊聊这个话题，而不是光灌鸡汤。</p><br><p>大家高中的时候应该学过，人体具有调节平衡的机制。</p><p>举个例子，当你病毒性感冒时，人体会通过调节体内的白细胞，淋巴，噬菌体这些进行免疫抵抗，所以你会发烧。而打针，一般除了给你杀杀病毒细菌之外，还会通过盐水葡萄糖，让你的身体更快恢复平衡。</p><p>所以这就跟大学时候学的<strong>反馈调节系统</strong>，非常像。</p><p><img src="https://s3.bmp.ovh/imgs/2022/01/80d3a0ad9f620091.png" alt="反馈调节系统"></p><span id="more"></span><p>这个图上面，左边是输入，右边是输出，当被控对象受到干扰的时候，输出就会发生变化，此时比较器就会计算偏差，然后控制器会根据偏差作出调整。</p><p>举个例子，四旋翼无人机能正常飘在空中，这是符合预期的状态，当外界轻微碰了它一下，虽然无人机姿态发生了一些偏移，但此时系统会计算出当前状态和预期状态的差距，然后通过调整四个螺旋桨的转速来不断减少偏差，最终回到原来的状态。</p><p>这里面比较重要的是比较器和控制器。它们做的事情无非就是发现偏差，然后想办法让偏差变小。</p><p>这就是所谓的<strong>反馈调节</strong>。</p><p>从效果上看其实就像个<strong>天平</strong>，你在一端压了重物，天平就倾斜，为了使天平回到平衡，你需要在另外一边也压点东西。而压东西的过程，就是<strong>调节</strong>。</p><p>了解了这一点后，再来了解下<strong>多巴胺</strong>和<strong>内啡肽</strong>是什么。</p><p>多巴胺大家应该经常听到，它可以让人产生快乐，当我们在做一些新鲜好玩的事情时，比如打游戏、听音乐，都会产生这玩意。**”期待”这件事情，也会产生多巴胺<strong>。回想下抖音的</strong>feed 流<strong>，你永远不知道，下一个视频是啥，划了再说。如果你对一个东西更感兴趣，那你在面对这个东西的时候会比面对其他东西的时候，分泌更多的多巴胺，而</strong>推荐**机制，则将更多你可能感兴趣的东西推荐到你面前。抖音和头条在这双层机制的把持下，让人上头。</p><p>但如果多巴胺立马降下来了，会给人带来焦虑和空虚的感觉，这也是你进入贤者时间思考人生的重要原因。</p><p>比起多巴胺，可能<strong>内啡肽</strong>大家听得比较少。但<strong>吗啡</strong>大家应该在电视剧里多多少少听说过，一般用这个的人都是做了大手术躺在病床上的，它能止疼镇静还能让人产生愉悦的感觉，并且这种舒爽的感觉还会比较持久。而<strong>内啡肽效果就跟吗啡类似。</strong> 一般在经历了学习，健身，洗冷水澡这种比较痛苦的事情之后会产生。</p><br><p>以上两种，都是人体内的激素，都会对人体内的”天平”产生影响。当人体产生多巴胺之后，人是立刻爽了，但天平也倾斜了，为了使系统恢复平衡，人会产生难受的感觉，所以打完游戏你会一阵空虚。而内啡肽也类似，虽然学习健身让你很不爽，但因为天平也倾斜了，此时身体会通过分泌内啡肽让你重新爽回来，所以运动完会神清气爽。</p><p>总结来说多巴胺和内啡肽都是会让人快乐的东西，但区别点在于，多巴胺即刻满足，而内啡肽延迟满足。</p><p>我们再回过头来看张一鸣同学推崇的<strong>延迟满足</strong>，其实就有点内啡肽的那意思。 而抖音强调的则是即刻满足。<strong>一个推崇延迟满足的人做了一个能让每个人即刻满足的应用</strong>，不得不说，大佬总归是大佬，对人性，三个手指头拿捏得死死的。大佬之所以推崇延时满足，是因为在你真正得到满足之前，往往付出了大量的努力，不管是学习和健身都是反人性的，但是<strong>这些反人性的事情也确确实实对人的发展有益</strong>。</p><br><p>了解一些系统的实现原理，可以帮助我们更好的做系统调优。那么，现在我们明白了人体的设计原理，其实就可以更好的做人体这个系统的调优了。</p><p>有句话是这么说的。</p><p>“<strong>做人嘛，最重要是开心</strong>“。</p><p>古人诚不欺我。</p><p>“<strong>开心</strong>“，就是我们人体这个系统最重要的指标。</p><p>而想办法让自己”更开心”，就是所谓的”<strong>系统调优</strong>“。</p><p>比方说，如果你心情低落，你可以尝试立刻提升多巴胺，比如打开抖音。</p><p>你很清楚内啡肽可以给你带来较为持久的愉悦，那你可以尝试把让你痛苦的事情放在早上做，比如学习或健身都放在早上，这样下午和晚上你都会更加快乐。但如果反过来，早上打完游戏，多巴胺减少，人很难受，下午还要学习，就更难受了，多半真学不动，相信大家都有体会。</p><p>刚开始刷抖音，你会迅速分泌多巴胺，刷的时间长了，多巴胺的分泌带来的快乐则没有一开始那么明显，于是我们会慢慢出现”<strong>麻了</strong>“的感觉，需要更大的刺激才能保持这份快乐，于是出现越刷越上头，越刷也越无聊的情况。所以可以尝试降低刷抖音的时间，加完班回来，只刷前面的十几分钟，真的就够了。早点睡，小心猝死。</p><p>以前不少老哥总拿”学习使我快乐”当反话开玩笑，但其实学习确实会让你快乐，只不过不是当下快乐，而是学习之后你会分泌内啡肽，这其实也会让你快乐。如果你确实感觉不到快乐，那大概率是你学的时间不够长…..</p><br><p>人体不像计算机，我们也看不到人体的源码，否则我高低也给大家整上两行。</p><p>大家估计也清楚，基因这玩意，就是我们的源码。</p><p>我们写的系统没办法实现编码外的功能，而我们也没办法做到我们基因外的功能，比如基因规定了我们没翅膀，那我们就是不能飞。基因规定了我们喜欢看大长腿，那我没办法不去看啊。</p><p>我们能做的就是在理解系统原理的前提下，更好的去使用系统。</p><p>对了，最后补充一句，不管是多巴胺还是内啡肽，都具有成瘾性。</p><p>非要说哪个更好，作为成年人，我选择全都要！</p><p>文章到这里也写完了，我的内啡肽也马上要上来了！</p><p>如果此时我打开抖音。</p><p>那我的快乐，就是<strong>双倍！</strong></p><br><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>快过年了，各位老哥快关注我之前写过的文章，给自己搞点内啡肽。</p><p>如果文章对你有帮助，欢迎…..</p><p>算了。</p><br><p>别说了，一起在知识的海洋里呛水吧</p><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有趣的话题。就<strong>超！开！心！</strong> 快过年了，群里可能会有红包，懂？</p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" style="zoom:50%" /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学生毕业找工作，该选择哪个方向。</title>
      <link href="/2021/11/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%EF%BC%8C%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E6%96%B9%E5%90%91%E3%80%82/"/>
      <url>/2021/11/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%EF%BC%8C%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E6%96%B9%E5%90%91%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>兄弟们。</p><p>出来说骚话啊。</p><p>考虑到，读者里面，有不少是还未踏入社会的学生党。</p><p>今天在这里想简单介绍下行业的区别。</p><p>虽然都是写代码，虽然大家都叫程序员，但其实，分为很多种类。程序员大体上分为<strong>前端和后端</strong>。</p><p>因为我不懂前端，所以这里主要讲下<strong>后端</strong>吧。</p><p>而后端，可以从很多角度进行分类。</p><p>我们从大家最熟悉的大学专业开始展开吧。</p><br><h3 id="非计算机专业"><a href="#非计算机专业" class="headerlink" title="非计算机专业"></a>非计算机专业</h3><p>一般提到程序员，都会以为都是计算机专业的，但其实除了计算机专业外，还有一些专业，比如电气工程、自动化、通信工程等，都会有不少相关的对口程序员工种。</p><p>比如大学时候学的 51 单片，STM32 之类的相关，那个其实属于嵌入式软件开发的范畴，用的一般是 C 语言。</p><p>如果是画画 PCB 电路板之类的，那应该属于嵌入式硬件工程师的范畴。</p><p>跟这两块比较相近的，还有个工作自动控制系统相关的相关工作，叫 PLC 工程师。用的编程语言也比较特别，叫梯形图。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20211121223351338.png"></p><span id="more"></span><p>以上这几种类型工种，一般出现在较为传统的行业里，比如工业控制、车企、电机电梯等企业，没那么传统的，有共享单车、无人机等。</p><br><h3 id="计算机专业"><a href="#计算机专业" class="headerlink" title="计算机专业"></a>计算机专业</h3><p>这个就很好理解了，也是毕业后进入互联网行业的主力军。而这里面方向也很多，但一般从我了解到的就业情况来说，分为下面这几类。</p><br><h4 id="游戏方向"><a href="#游戏方向" class="headerlink" title="游戏方向"></a>游戏方向</h4><p>游戏方向也算是互联网行业里比较特殊的一个分支。我们常说的前端和后端，在这里一般是叫客户端和服务端。服务端用的一般是 C++，少数使用 golang，java 等，一般是根据游戏类型去区分，比如像的《率土之滨》之类的策略类游戏叫 SLG，《王者荣耀》这种叫 moba，《xx 传奇》叫 MMORPG，《地下城与勇士》这类叫 ARPG，这里面服务端的架构设计根据游戏类型会有一些不同，但开发之间用的技术栈大体差距不算太大。</p><p>客户端之间差距就有些大了，做 2d 游戏的一般用 cocos，3d 游戏前两年一般用 unity3D，现在都开始慢慢开始用 unreal。而微信小游戏，一般用的 laya 或者白鹭引擎。当然还有 flash 小游戏，这个就有些古老了。有一说一，游戏客户端用的技术差异比较大，隔两年换一个新东西学学，太难了。相比之下，游戏服务端用的技术倒是稳定多了。</p><br><h4 id="互联网应用方向"><a href="#互联网应用方向" class="headerlink" title="互联网应用方向"></a>互联网应用方向</h4><br><h5 id="业务开发"><a href="#业务开发" class="headerlink" title="业务开发"></a>业务开发</h5><p>是最常见的 curd boy，对于并不复杂的业务，很多时候就是写写数据库的插入（<strong>c</strong>reate），更新（<strong>u</strong>pdate），读取（<strong>r</strong>ead）、删除（<strong>d</strong>elete）等语句。</p><p>这里业务其实还细分为 to b 方向和 to c 方向，to b 的业务一般用户不多，正因为用户不多，所以他们提的每一个问题都有可能被重视并且转化为<strong>定制化的需求</strong>，因为需求只针对某部分特定人群，所以<strong>产品逻辑做的巨复杂，巨奇怪也很正常</strong>。to b 一般也比 to c 的产品逻辑更复杂，而产品的主要工作也是直接跟用户沟通，收集用户的痛点并且转化成各种奇怪的需求。用户也可以直接找到这个开发，并且反馈自己的疑问，所以很多时候开发也会沦为 oncall 工具人。</p><p>to c 业务<strong>一般</strong>会相对 to b 业务来说并发稍微高点，因为产品是面向普通用户，所以设计上也会尽量傻瓜式，这就可以反推背后的逻辑也会相对 to b 业务要简单一些。</p><br><h5 id="基础架构开发"><a href="#基础架构开发" class="headerlink" title="基础架构开发"></a>基础架构开发</h5><p>又名，高级 oncall 工程师。跟上面的业务开发不同，业务开发 oncall 的对象一般是没有编程背景的普通用户。基础架构 oncall 的主要对象还是开发，所以总的来说，沟通理解成本可能会稍微低一些。做基架，也会给人一种更专业的感觉，很多知识都偏向于计算机底层，且通用，比如做网关的或者 mesh 的，换个公司，做的事情一般还能差不多且能延续。但业务开发，比如做电商的，如果离职跑去做教育，那需要从零开始重新理解业务。</p><p>行业上很多大佬都是做基架出身的。业务开发上班时间搞本操作系统来看，还看什么内核源码，那多少有些”不务正业”，”天天摸鱼”的感觉，但如果是基架开发，整这个就非常合情合理了。</p><br><h4 id="安全方向"><a href="#安全方向" class="headerlink" title="安全方向"></a>安全方向</h4><p>这里面最特别的就是做信息安全的，就是是最接近电影里黑客的方向，就业方向对口的是安全行业，学的东西也跟其他方向的不太一样，这里面有着比较大的 gap。我至今不知道他们平时的工作内容是什么，但是经常能看到一个认识的老哥在网上找各种网站的漏洞然后提交官方后获得多少 w 刀的一个奖励。反正羡慕死我了。</p><br><h3 id="这么多种类怎么选"><a href="#这么多种类怎么选" class="headerlink" title="这么多种类怎么选"></a>这么多种类怎么选</h3><h4 id="行业怎么选"><a href="#行业怎么选" class="headerlink" title="行业怎么选"></a>行业怎么选</h4><p>我曾经也当过大学生，也理解大家毕业前面对着这些岗位一脸懵逼的痛点。</p><p>如果大家对研究通用化的技术特别感兴趣，并且自身硬实力也较强，可以考虑做基础架构相关的工作，这块学到的东西更通用化。但是这块有个缺点，一般情况下，做基架会离业务远一点。</p><p>既然当程序员，选了这么苦的路，除了少部分对技术有这极大热情的兄弟们，那我盲猜大部分兄弟可能跟我一样，是因为<strong>钱包比较瘦</strong>。</p><p>那既然这样，我们聊聊怎么样的岗位有机会赚更多。</p><p>大家得明白一个道理，<strong>代码不值钱，业务和数据才值钱</strong>。如果业务盈利很猛，那你离业务越近，你越有机会跟着吃肉喝汤。</p><p>在商业化社会，公司都是为了盈利的，而盈利的，一般是业务部门。当然，不是每个部门都有机会盈利，所以一旦不盈利，被裁得最快的也是业务开发。</p><p>那么问题来了，什么样的业务，离曼妮比较近呢。以我浅薄的认知水平，目前看下来，<strong>游戏、电商，金融</strong>这三个行业离曼妮是比较近的，越符合人性的业务功能越容易盈利，比如短视频，游戏这些，就很符合人性。而教育，运动这种，属于比较反人性的，可能就难一些。但凡事无绝对，神级产品经理可以无视一切常理。</p><p>所以，打工人，不要把路走窄了。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E7%A6%BB%E6%9B%BC%E5%A6%AE%E8%BF%91%E7%9A%84%E8%A1%8C%E4%B8%9A.png" alt="离钱更近的行业"></p><br><h4 id="语言怎么选"><a href="#语言怎么选" class="headerlink" title="语言怎么选"></a>语言怎么选</h4><p>虽然不管什么语言，都能实现相似的功能，但是从目前的行业情况来看，不同的语言在不同行业里会有一定的分化。</p><p>比如如果你做嵌入式软件开发，那你一般是用 C 语言。做电商一般也是 java，做游戏一般是 C++。而 golang，目前用的公司也越来越多了，有用它做游戏的，也有用于电商，网页后台。</p><p>为了不引起语言争论，如果大家不知道选什么语言，那可以考虑下 java 或 golang。java 这一块人多，竞争激烈些。选 C++，学习路线比较陡峭，过于博大精深。选 golang 的话，比较简单，同时没有太多历史包袱，唯一的缺点就是岗位相对少一些，但目前看下来比前两年更多，相信以后用的人越来越多。</p><p>如果你做游戏，又想转互联网应用方向，那么做 golang 挺好的，它可以在这两个方向里来回横跳。</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>当然，以上都是一些人生建议。而且不一定对，都是我认知范围内的一些信息。大家听不听都不重要，毕竟很多人知道很多道理，依然过不好这一生。</p><p>比如我，以前做游戏的时候，游戏版号就被封了好长时间，行业确实也没之前那么景气了。后来认为教育是风口，想成为那头在风口上起飞的猪，结果这今年双减，长期来看可能也不太乐观。</p><p>干啥都凉，我小白，还真的是行业瞑灯啊，害。。。</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！怎么让goroutine跑一半就退出？</title>
      <link href="/2021/11/15/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F/"/>
      <url>/2021/11/15/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/doutub_gif2.gif"></p><p>光看标题，大家可能不太理解我说的是啥。</p><span id="more"></span><p>我们平时创建一个协程，跑一段逻辑，代码大概长这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码，正常运行会有下面的结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">3</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>这上面”<strong>打印 2</strong>“是在<code>defer</code>中的，所以会在函数结束前打印。因此后置于”<strong>打印 3</strong>“。</p><p>那么今天的问题是，如何让<code>Foo()</code>函数<strong>跑一半就结束</strong>，比如说跑到<strong>打印 2</strong>，就退出协程。输出如下结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p>也不卖关子了，我这边直接说答案。</p><p>在”打印 2”后面插入一个 <code>runtime.Goexit()</code>， 协程就会直接结束。并且结束前还能执行到<code>defer</code>里的<strong>打印 2</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">runtime.Goexit() <span class="comment">// 加入这行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看到<strong>打印 3</strong>这一行没出现了，协程确实提前结束了。</p><p>其实面试题到这里就讲完了，这一波自问自答可还行？</p><p>但这不是今天的重点，我们需要搞搞清楚内部的逻辑。</p><h3 id="runtime-Goexit-是什么？"><a href="#runtime-Goexit-是什么？" class="headerlink" title="runtime.Goexit()是什么？"></a>runtime.Goexit()是什么？</h3><p>看一下内部实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 以下函数省略一些逻辑...</span></span><br><span class="line">gp := getg()</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 获取defer并执行</span></span><br><span class="line">d := gp._defer</span><br><span class="line">reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">&#125;</span><br><span class="line">goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，<code>runtime.Goexit()</code>会先执行一下<code>defer</code>里的方法，这里就解释了开头的代码里为什么<strong>在 defer 里的打印 2</strong>能正常输出。</p><p>然后代码再执行<code>goexit1</code>。本质就是对<code>goexit0</code>的简单封装。</p><p>我们可以把代码继续跟下去，看看<code>goexit0</code>做了什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前的 goroutine</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 将当前goroutine的状态置为 _Gdead</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">  <span class="comment">// 全局协程数减一</span></span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略各种清空逻辑...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把g从m上摘下来。</span></span><br><span class="line">  dropg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个g放回到p的本地协程队列里，放不下放全局协程队列。</span></span><br><span class="line">gfput(_g_.m.p.ptr(), gp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新调度，拿下一个可运行的协程出来跑</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码，信息密度比较大。</p><p>很多名词可能让人一脸懵。</p><p>简单描述下，Go 语言里有个<strong>GMP 模型</strong>的说法，<code>M</code>是内核线程，<code>G</code>也就是我们平时用的协程<code>goroutine</code>，<code>P</code>会在<code>G和M之间</code>做工具人，负责<strong>调度</strong><code>G</code>到<code>M</code>上运行。</p><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E5%9B%BE.png" alt="GMP图"></p><p>既然是<strong>调度</strong>，也就是说不是每个<code>G</code>都能一直处于运行状态，等 G 不能运行时，就把它存起来，再<strong>调度</strong>下一个能运行的 G 过来运行。</p><p>暂时不能运行的 G，P 上会有个<strong>本地队列</strong>去存放这些这些 G，P 的本地队列存不下的话，还有个全局队列，干的事情也类似。</p><p>了解这个背景后，再回到 <code>goexit0</code> 方法看看，做的事情就是将当前的协程 G 置为<code>_Gdead</code>状态，然后把它从 M 上摘下来，尝试放回到 P 的本地队列中。然后重新调度一波，获取另一个能跑的 G，拿出来跑。</p><p><img src="https://cdn.xiaobaidebug.top/image/goexit.gif" alt="goexit"></p><p>所以简单总结一下，<strong>只要执行 goexit 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</strong></p><p>看到这里，大家应该就能理解，开头的代码里，为什么<code>runtime.Goexit()</code>能让协程只执行一半就结束了。</p><h3 id="goexit-的用途"><a href="#goexit-的用途" class="headerlink" title="goexit 的用途"></a>goexit 的用途</h3><p>看是看懂了，但是会忍不住疑惑。<strong>面试这么问问，那只能说明你遇到了一个喜欢为难年轻人的面试官</strong>，但正经人谁会没事跑一半协程就结束呢？所以<code>goexit</code>的<strong>真实用途</strong>是啥？</p><p>有个<strong>小细节</strong>，不知道大家平时 debug 的时候有没有关注过。</p><p><img src="https://cdn.xiaobaidebug.top/image/0bec52deb6276987.jpeg"></p><p>为了说明问题，这里先给出一段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的代码，输出什么完全不重要。通过<code>go</code>关键字启动了一个<code>goroutine</code>执行<code>Foo()</code>，里面打印一下就结束，主协程<code>sleep</code>很长时间，只为<strong>死等</strong>。</p><p>这里我们新启动的协程里，在<code>Foo()</code>函数内随便打个断点。然后<code>debug</code>一下。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20211024150223114.png"></p><p>会发现，这个协程的堆栈底部是从<code>runtime.goexit()</code>里开始启动的。</p><p>如果大家平时有注意观察，会发现，<strong>其实所有的堆栈底部，都是从这个函数开始的</strong>。我们继续跟跟代码。</p><h3 id="goexit-是什么？"><a href="#goexit-是什么？" class="headerlink" title="goexit 是什么？"></a>goexit 是什么？</h3><p>从上面的<code>debug</code>堆栈里点进去会发现，这是个汇编函数，可以看出调用的是<code>runtime</code>包内的 <code>goexit1()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br><span class="line">CALLruntime·goexit1(SB)<span class="comment">// does not return</span></span><br><span class="line"><span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br></pre></td></tr></table></figure><p>于是跟到了<code>pruntime/proc.go</code>里的代码中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很熟悉，这不就是我们开头讲<code>runtime.Goexit()</code>里内部执行的<code>goexit0</code>吗。</p><h3 id="为什么每个堆栈底部都是这个方法？"><a href="#为什么每个堆栈底部都是这个方法？" class="headerlink" title="为什么每个堆栈底部都是这个方法？"></a>为什么每个堆栈底部都是这个方法？</h3><p>我们首先需要知道的是，函数栈的执行过程，是先进后出。</p><p>假设我们有以下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是 main 运行 B 函数，B 函数再运行 A 函数，代码执行时就跟下面的动图那样。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88.gif" alt="函数堆栈执行顺序"></p><p>这个是先进后出的过程，也就是我们常说的函数栈，执行完<strong>子函数 A()<strong>后，就会回到</strong>父函数 B()<strong>中，执行完</strong>B()后</strong>，最后就会回到<strong>main()<strong>。这里的栈底是<code>main()</code>，如果在</strong>栈底</strong>插入的是 <code>goexit</code> 的话，那么当程序执行结束的时候就都能跑到<code>goexit</code>里去。</p><p>结合前面讲过的内容，我们就能知道，此时栈底的<code>goexit</code>，会在协程内的业务代码跑完后被执行到，从而实现协程退出，并调度下一个<strong>可执行的 G</strong>来运行。</p><br><p>那么问题又来了，栈底插入<code>goexit</code>这件事是谁做的，什么时候做的？</p><p>直接说答案，这个在<code>runtime/proc.go</code>里有个<code>newproc1</code>方法，只要是<strong>创建协程</strong>都会用到这个方法。里面有个地方是这么写的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取当前g</span></span><br><span class="line">  _g_ := getg()</span><br><span class="line"><span class="comment">// 获取当前g所在的p</span></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// 创建一个新 goroutine</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底部插入goexit</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum</span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line"><span class="comment">// 把新创建的g放到p中</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的逻辑是获取当前协程 G 所在的调度器 P，然后创建一个新 G，并在栈底插入一个 goexit。</p><p>所以我们每次 debug 的时候，就都能看到函数栈底部有个 goexit 函数。</p><h3 id="main-函数也是个协程，栈底也是-goexit？"><a href="#main-函数也是个协程，栈底也是-goexit？" class="headerlink" title="main 函数也是个协程，栈底也是 goexit？"></a>main 函数也是个协程，栈底也是 goexit？</h3><p>关于 main 函数栈底是不是也有个<code>goexit</code>，我们对下面代码断点看下。直接得出结果。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20211025073255360.png"></p><p>main 函数栈底也是<code>goexit()</code>。</p><p>从 <code>asm_amd64.s</code>可以看到 Go 程序启动的流程，这里提到的 <code>runtime·mainPC</code> 其实就是 <code>runtime.main</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line">MOVQ$runtime·mainPC(SB), AX<span class="comment">// 也就是runtime.main</span></span><br><span class="line">PUSHQAX</span><br><span class="line">PUSHQ$<span class="number">0</span><span class="comment">// arg size</span></span><br><span class="line">CALLruntime·newproc(SB)</span><br></pre></td></tr></table></figure><p>通过<code>runtime·newproc</code>创建<code>runtime.main</code>协程，然后在<code>runtime.main</code>里会启动<code>main.main</code>函数，这个就是我们平时写的那个 main 函数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 省略大量代码</span></span><br><span class="line">fn := main_main <span class="comment">// 其实就是我们的main函数入口</span></span><br><span class="line">fn()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname main_main main.main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main_main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>结论是，<strong>其实 main 函数也是由 newproc 创建的，只要通过 newproc 创建的 goroutine，栈底就会有一个 goexit。</strong></p><h3 id="os-Exit-和-runtime-Goexit-有什么区别"><a href="#os-Exit-和-runtime-Goexit-有什么区别" class="headerlink" title="os.Exit()和 runtime.Goexit()有什么区别"></a>os.Exit()和 runtime.Goexit()有什么区别</h3><p>最后再回到开头的问题，实现一下首尾呼应。</p><p>开头的面试题，除了<code>runtime.Goexit()</code>，是不是还可以改为用<code>os.Exit()</code>？</p><p>同样都是带有”退出”的含义，两者退出的<strong>对象</strong>不同。<code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。</p><p>可想而知，改用<code>os.Exit()</code> 这种情况下，defer 里的内容就不会被执行到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>通过 <code>runtime.Goexit()</code>可以做到提前结束协程，且结束前还能执行到 defer 的内容</li><li><code>runtime.Goexit()</code>其实是对 goexit0 的封装，只要执行 goexit0 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</li><li>通过<code>newproc</code>可以创建出新的<code>goroutine</code>，它会在函数栈底部插入一个 goexit。</li><li><code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。两者含义有区别。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>无用的知识又增加了。</p><p>一般情况下，业务开发中，谁会没事执行这个函数呢？</p><p><strong>但是开发中不关心，不代表面试官不关心！</strong></p><p>下次面试官问你，<strong>如果想在 goroutine 执行一半就退出协程，该怎么办？</strong>你知道该怎么回答了吧？</p><br><p>好了，兄弟们，有没有发现这篇文章写的又水又短，真的是因为我变懒了吗？</p><p>不！</p><p>当然不！</p><p>我是为了兄弟们的身体健康考虑，保持蹲姿太久对身体不好，懂？</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>一起在知识的海洋里呛水吧</p><p>我是小白，我们下期见！</p><br><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有趣的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>饶大的《哪来里的 goexit？》- <a href="https://qcrao.com/2021/06/07/where-is-goexit-from/">https://qcrao.com/2021/06/07/where-is-goexit-from/</a></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！没有accept，能建立TCP连接吗？</title>
      <link href="/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%90%97/"/>
      <url>/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B3.gif" alt="握手建立连接流程"></p><p>上面这个动图，是我们平时客户端和服务端建立连接时的代码流程。</p><p>对应的是下面一段简化过的服务端伪代码。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Step 1: 创建服务器端监听socket描述符listen_fd*/</span></span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 2: bind绑定服务器端的IP和端口，所有客户端都向这个IP和端口发送和请求数据*/</span></span><br><span class="line">    bind(listen_fd, xxx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 3: 服务端开启监听*/</span></span><br><span class="line">    listen(listen_fd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 服务器等待客户端的链接，返回值cfd为客户端的socket描述符*/</span></span><br><span class="line">    cfd = accept(listen_fd, xxx);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*Step 5: 读取客户端发来的数据*/</span></span><br><span class="line">  n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>估计大家也是老熟悉这段伪代码了。</p><p>需要注意的是，在执行<code>listen()</code>方法之后还会执行一个<code>accept()</code>方法。</p><p><strong>一般情况</strong>下，如果启动服务器，会发现最后程序会<strong>阻塞在</strong><code>accept()</code>里。</p><p>此时服务端就算 ok 了，就等客户端了。</p><p>那么，再看下简化过的客户端伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Step 1: 创建客户端端socket描述符cfd*/</span></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 2: connect方法,对服务器端的IP和端口号发起连接*/</span></span><br><span class="line">    ret = connect(cfd, xxxx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 向服务器端写数据*/</span></span><br><span class="line">    write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端比较简单，创建好<code>socket</code>之后，直接就发起<code>connect</code>方法。</p><p>此时回到服务端，会发现<strong>之前一直阻塞的 accept 方法，返回结果了</strong>。</p><p>这就算两端成功建立好了一条连接。之后就可以愉快的进行读写操作了。</p><p>那么，我们今天的问题是，<strong>如果没有这个 accept 方法，TCP 连接还能建立起来吗？</strong></p><br><p>其实只要在执行<code>accept()</code> 之前执行一个 <code>sleep(20)</code>，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210917233531475.png" alt="不执行accept时抓包结果"></p><p>从抓包结果看来，<strong>就算不执行 accept()方法，三次握手照常进行，并顺利建立连接。</strong></p><p>更骚气的是，<strong>在服务端执行 accept()前，如果客户端发送消息给服务端，服务端是能够正常回复 ack 确认包的。</strong></p><p>并且，<code>sleep(20)</code>结束后，服务端正常执行<code>accept()</code>，客户端前面发送的消息，还是能正常收到的。</p><p>通过这个现象，我们可以多想想为什么。顺便好好了解下三次握手的细节。</p><br><h3 id="三次握手的细节分析"><a href="#三次握手的细节分析" class="headerlink" title="三次握手的细节分析"></a>三次握手的细节分析</h3><p>我们先看面试八股文的老股，三次握手。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BF%AE%E6%AD%A3%E7%89%882.png" alt="TCP三次握手"></p><p>服务端代码，对 socket 执行 bind 方法可以绑定监听端口，然后执行<code>listen方法</code>后，就会进入监听（<code>LISTEN</code>）状态。内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列，分别叫<strong>半连接队列和全连接队列</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%AF%8F%E4%B8%AAlistenSocket.png" alt="每个listen Socket都有一个全连接和半连接队列"></p><br><h4 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h4><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%973.png" alt="半连接队列和全连接队列"></p><ul><li><p><strong>半连接队列（SYN 队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</p></li><li><p><strong>全连接队列（ACCEPT 队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行 accept()后被取出了。</strong></p></li></ul><p>看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要<code>accept()</code> 参与， <strong>执行 accept()只是为了从全连接队列里取出一条连接。</strong></p><p>我们把话题再重新回到这两个队列上。</p><p>虽然都叫<strong>队列</strong>，但其实<strong>全连接队列（icsk_accept_queue）是个链表</strong>，而<strong>半连接队列（syn_table）是个哈希表</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="半连接全连接队列的内部结构"></p><br><h4 id="为什么半连接队列要设计成哈希表"><a href="#为什么半连接队列要设计成哈希表" class="headerlink" title="为什么半连接队列要设计成哈希表"></a>为什么半连接队列要设计成哈希表</h4><p>先对比下<strong>全连接里队列</strong>，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为<code>O(1)</code>。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应 IP 端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是 O(n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到<code>O(1)</code>了。</p><p>因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><br><h4 id="怎么观察两个队列的大小"><a href="#怎么观察两个队列的大小" class="headerlink" title="怎么观察两个队列的大小"></a>怎么观察两个队列的大小</h4><h5 id="查看全连接队列"><a href="#查看全连接队列" class="headerlink" title="查看全连接队列"></a>查看全连接队列</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ss -lnt</span></span><br><span class="line">State      Recv-Q Send-Q     Local Address:Port           Peer Address:Port</span><br><span class="line">LISTEN     0      128        127.0.0.1:46269              *:*</span><br></pre></td></tr></table></figure><p>通过<code>ss -lnt</code>命令，可以看到全连接队列的大小，其中<code>Send-Q</code>是指全连接队列的最大值，可以看到我这上面的最大值是<code>128</code>；<code>Recv-Q</code>是指当前的全连接队列的使用值，我这边用了<code>0</code>个，也就是全连接队列里为空，连接都被取出来了。</p><p>当上面<code>Send-Q</code>和<code>Recv-Q</code>数值很接近的时候，那么全连接队列可能已经满了。可以通过下面的命令查看是否发生过队列<strong>溢出</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -s | grep overflowed</span></span><br><span class="line">    4343 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><p>上面说明发生过<code>4343次</code>全连接队列溢出的情况。这个查看到的是<strong>历史发生过的次数</strong>。</p><p>如果配合使用<code>watch -d</code> 命令，可以自动每<code>2s</code>间隔执行相同命令，还能高亮显示变化的数字部分，如果溢出的数字不断变多，说明<strong>正在发生</strong>溢出的行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># watch -d &#x27;netstat -s | grep overflowed&#x27;</span></span><br><span class="line">Every 2.0s: netstat -s | grep overflowed                                Fri Sep 17 09:00:45 2021</span><br><span class="line"></span><br><span class="line">    4343 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><br><h5 id="查看半连接队列"><a href="#查看半连接队列" class="headerlink" title="查看半连接队列"></a>查看半连接队列</h5><p>半连接队列没有命令可以直接查看到，但因为半连接队列里，放的都是<code>SYN_RECV</code> 状态的连接，那可以通过统计处于这个状态的连接的数量，间接获得半连接队列的长度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep -i &#x27;127.0.0.1:8080&#x27; | grep -i &#x27;SYN_RECV&#x27; | wc -l</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意半连接队列和全连接队列都是挂在某个<code>Listen socket</code>上的，我这里用的是<code>127.0.0.1:8080</code>，大家可以替换成自己想要查看的<strong>IP 端口</strong>。</p><p>可以看到我的机器上的半连接队列长度为<code>0</code>，这个很正常，<strong>正经连接谁会没事老待在半连接队列里。</strong></p><p>当队列里的半连接不断增多，最终也是会发生溢出，可以通过下面的命令查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;</span></span><br><span class="line">    26395 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure><p>可以看到，我的机器上一共发生了<code>26395</code>次半连接队列溢出。同样建议配合<code>watch -d</code> 命令使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># watch -d &#x27;netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;&#x27;</span></span><br><span class="line">Every 2.0s: netstat -s | grep -i <span class="string">&quot;SYNs to LISTEN sockets dropped&quot;</span>       Fri Sep 17 08:36:38 2021</span><br><span class="line"></span><br><span class="line">    26395 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure><br><h4 id="全连接队列满了会怎么样？"><a href="#全连接队列满了会怎么样？" class="headerlink" title="全连接队列满了会怎么样？"></a>全连接队列满了会怎么样？</h4><p>如果队列满了，服务端还收到客户端的第三次握手 ACK，默认当然会丢弃这个 ACK。</p><p>但除了丢弃之外，还有一些附带行为，这会受 <code>tcp_abort_on_overflow</code> 参数的影响。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li><code>tcp_abort_on_overflow</code>设置为 0，全连接队列满了之后，会丢弃这个第三次握手 ACK 包，并且开启定时器，重传第二次握手的 SYN+ACK，如果重传超过一定限制次数，还会把对应的<strong>半连接队列里的连接</strong>给删掉。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/tcp_abort_on_overflow%E4%B8%BA0.png" alt="tcp_abort_on_overflow为0"></p><ul><li><code>tcp_abort_on_overflow</code>设置为 1，全连接队列满了之后，就直接发 RST 给客户端，效果上看就是连接断了。</li></ul><p>这个现象是不是很熟悉，服务端<strong>端口未监听</strong>时，客户端尝试去连接，服务端也会回一个 RST。这两个情况长一样，所以客户端这时候收到 RST 之后，其实无法区分到底是<strong>端口未监听</strong>，还是<strong>全连接队列满了</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp_abort_on_overflow%E4%B8%BA1.png" alt="tcp_abort_on_overflow为1"></p><br><h4 id="半连接队列要是满了会怎么样"><a href="#半连接队列要是满了会怎么样" class="headerlink" title="半连接队列要是满了会怎么样"></a>半连接队列要是满了会怎么样</h4><p><strong>一般是丢弃</strong>，但这个行为可以通过 <code>tcp_syncookies</code> 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。</p><p>首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了<strong>SYN Flood 攻击</strong>。</p><p>所谓<strong>SYN Flood 攻击</strong>，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。</p><p><img src="https://cdn.xiaobaidebug.top/image/syn%E6%94%BB%E5%87%BB.png" alt="syn攻击"></p><p>那这种情况怎么处理？有没有一种方法可以<strong>绕过半连接队列</strong>？</p><p>有，上面提到的<code>tcp_syncookies</code>派上用场了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_syncookies</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>当它被设置为 1 的时候，客户端发来<strong>第一次握手</strong>SYN 时，服务端<strong>不会将其放入半连接队列中</strong>，而是直接生成一个<code>cookies</code>，这个<code>cookies</code>会跟着<strong>第二次握手</strong>，发回客户端。客户端在发<strong>第三次握手</strong>的时候带上这个<code>cookies</code>，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%BC%80%E5%90%AFtcp_syncookies.drawio.png" alt="tcp_syncookies=1"></p><br><h5 id="会有一个-cookies-队列吗"><a href="#会有一个-cookies-队列吗" class="headerlink" title="会有一个 cookies 队列吗"></a>会有一个 cookies 队列吗</h5><p>生成是<code>cookies</code>，保存在哪呢？<strong>是不是会有一个队列保存这些 cookies？</strong></p><p>我们可以反过来想一下，如果有<code>cookies</code>队列，那它会跟半连接队列一样，到头来，还是会被<strong>SYN Flood 攻击</strong>打满。</p><p>实际上<code>cookies</code>并不会有一个专门的队列保存，它是通过<strong>通信双方的 IP 地址端口、时间戳、MSS</strong>等信息进行<strong>实时计算</strong>的，保存在<strong>TCP 报头</strong>的<code>seq</code>里。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B4_seq%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="tcp报头_seq的位置"></p><p>当服务端收到客户端发来的第三次握手包时，会通过 seq 还原出<strong>通信双方的 IP 地址端口、时间戳、MSS</strong>，验证通过则建立连接。</p><br><h5 id="cookies-方案为什么不直接取代半连接队列？"><a href="#cookies-方案为什么不直接取代半连接队列？" class="headerlink" title="cookies 方案为什么不直接取代半连接队列？"></a>cookies 方案为什么不直接取代半连接队列？</h5><p>目前看下来<code>syn cookies</code>方案省下了半连接队列所需要的队列内存，还能解决 <strong>SYN Flood 攻击</strong>，那为什么不直接取代半连接队列？</p><p>凡事皆有利弊，<code>cookies</code>方案虽然能防 <strong>SYN Flood 攻击</strong>，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p><p>另外，编码解码<code>cookies</code>，都是比较<strong>耗 CPU</strong>的，利用这一点，如果此时攻击者构造大量的<strong>第三次握手包（ACK 包）</strong>，同时带上各种瞎编的<code>cookies</code>信息，服务端收到<code>ACK包</code>后<strong>以为是正经 cookies</strong>，憨憨地跑去解码（<strong>耗 CPU</strong>），最后发现不是正经数据包后才丢弃。</p><p>这种通过构造大量<code>ACK包</code>去消耗服务端资源的攻击，叫<strong>ACK 攻击</strong>，受到攻击的服务器可能会因为<strong>CPU 资源耗尽</strong>导致没能响应正经请求。</p><p><img src="https://cdn.xiaobaidebug.top/image/ack%E6%94%BB%E5%87%BB2.gif" alt="ack攻击"></p><br><h4 id="没有-listen，为什么还能建立连接"><a href="#没有-listen，为什么还能建立连接" class="headerlink" title="没有 listen，为什么还能建立连接"></a>没有 listen，为什么还能建立连接</h4><p>那既然没有<code>accept</code>方法能建立连接，那是不是没有<code>listen</code>方法，也能建立连接？是的，之前写的一篇文章提到过客户端是可以自己连自己的形成连接（<strong>TCP 自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP 同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有 listen，就能建立连接。</strong></p><p>当时文章最后也留了个疑问，<strong>没有 listen，为什么还能建立连接？</strong></p><p>我们知道执行<code>listen</code>方法时，会创建半连接队列和全连接队列。</p><p>三次握手的过程中会在这两个队列中暂存连接信息。</p><p>所以形成连接，前提是你得<strong>有个地方存放着</strong>，方便握手的时候能根据 IP 端口等信息找到 socket 信息。</p><br><p><strong>那么客户端会有半连接队列吗？</strong></p><p><strong>显然没有</strong>，因为客户端没有执行<code>listen</code>，因为半连接队列和全连接队列都是在执行<code>listen</code>方法时，内核自动创建的。</p><p>但内核还有个<strong>全局 hash 表</strong>，可以用于存放<code>sock</code>连接的信息。这个全局<code>hash</code>表其实还细分为<code>ehash，bhash和listen_hash</code>等，但因为过于细节，大家理解成有一个<strong>全局 hash</strong>就够了，</p><p>在 TCP 自连接的情况中，客户端在<code>connect</code>方法时，最后会将自己的连接信息放入到这个<strong>全局 hash 表</strong>中，然后将信息发出，消息在经过回环地址重新回到 TCP 传输层的时候，就会根据 IP 端口信息，再一次从这个<strong>全局 hash</strong>中取出信息。于是握手包一来一回，最后成功建立连接。</p><p>TCP 同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>每一个</strong><code>socket</code>执行<code>listen</code>时，内核都会自动创建一个半连接队列和全连接队列。</p></li><li><p>第三次握手前，TCP 连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。</p></li><li><p><code>accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。</p></li><li><p>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。</p></li><li><p>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</p></li><li><p>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</p></li><li><p>客户端没有半连接队列和全连接队列，但有一个<strong>全局 hash</strong>，可以通过它实现自连接或 TCP 同时打开。</p></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>小林图解网络 – 推荐大家关注《小林 coding》</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>活久见！TCP两次挥手，你见过吗？那四次握手呢？</title>
      <link href="/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F/"/>
      <url>/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，TCP 是个<strong>面向连接的、可靠的、基于字节流的传输层</strong>通信协议。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%98%AF%E4%BB%80%E4%B9%882.png" alt="TCP是什么"></p><p>那这里面提到的”<strong>面向连接</strong>“，意味着需要 建立连接，使用连接，释放连接。</p><p><strong>建立连接</strong>是指我们熟知的<strong>TCP 三次握手</strong>。</p><p>而<strong>使用连接</strong>，则是通过一发送、一确认的形式，进行<strong>数据传输</strong>。</p><p>还有就是<strong>释放连接</strong>，也就是我们常见的<strong>TCP 四次挥手</strong>。</p><p><strong>TCP 四次挥手</strong>大家应该比较了解了，但大家见过<strong>三次挥手</strong>吗？还有<strong>两次挥手</strong>呢？</p><p>都见过？ 那<strong>四次握手</strong>呢？</p><p>今天这个话题，不想只是猎奇，也不想搞冷知识。</p><p>我们从四次挥手开始说起，搞点实用的知识点。</p><span id="more"></span><br><h2 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h2><p>简单回顾下 TCP 四次挥手。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B7.png" alt="TCP四次挥手"></p><p>正常情况下。只要数据传输完了，<strong>不管是客户端还是服务端，都可以主动发起四次挥手</strong>，释放连接。</p><p>就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是<strong>主动方</strong>。服务器是被动接收客户端的挥手请求的，叫<strong>被动方</strong>。</p><p>客户端和服务器，一开始，都是处于<code>ESTABLISHED</code>状态。</p><p><strong>第一次挥手</strong>：一般情况下，主动方执行<code>close()</code>或 <code>shutdown()</code>方法，会发个<code>FIN报文</code>出来，表示”<strong>我不再发送数据了</strong>“。</p><p><strong>第二次挥手</strong>：在收到主动方的<code>FIN</code>报文后，被动方立马回应一个<code>ACK</code>，意思是”我收到你的 FIN 了，也知道你不再发数据了”。</p><p>上面提到的是<strong>主动方</strong>不再发送数据了。但如果这时候，<strong>被动方</strong>还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。</p><p><strong>第三次挥手</strong>：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 <code>close()</code>, 这时候就会发出第三次挥手的 <code>FIN-ACK</code>。</p><p><strong>第四次挥手</strong>：主动方回一个<code>ACK</code>，意思是收到了。</p><p>其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用<code>close()</code>方法），也就是我们平时写代码需要关注的地方。</p><p>第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。</p><p>另外不管是主动还是被动，每方发出了一个 <code>FIN</code> 和一个<code>ACK</code> 。也收到了一个 <code>FIN</code> 和一个<code>ACK</code> 。<strong>这一点大家关注下，待会还会提到。</strong></p><h3 id="FIN-一定要程序执行-close-或-shutdown-才能发出吗？"><a href="#FIN-一定要程序执行-close-或-shutdown-才能发出吗？" class="headerlink" title="FIN 一定要程序执行 close()或 shutdown()才能发出吗？"></a>FIN 一定要程序执行 close()或 shutdown()才能发出吗？</h3><p><strong>不一定</strong>。一般情况下，通过对<code>socket</code>执行 <code>close()</code> 或 <code>shutdown()</code> 方法会发出<code>FIN</code>。但实际上，只要应用程序退出，不管是<strong>主动</strong>退出，还是<strong>被动</strong>退出（因为一些莫名其妙的原因被<code>kill</code>了）, <strong>都会</strong>发出 <code>FIN</code>。</p><blockquote><p>FIN 是指”我不再发送数据”，因此<code>shutdown()</code> 关闭读不会给对方发 FIN, 关闭写才会发 FIN。</p></blockquote><br><h3 id="如果机器上-FIN-WAIT-2-状态特别多，是为什么"><a href="#如果机器上-FIN-WAIT-2-状态特别多，是为什么" class="headerlink" title="如果机器上 FIN-WAIT-2 状态特别多，是为什么"></a>如果机器上 FIN-WAIT-2 状态特别多，是为什么</h3><p>根据上面的四次挥手图，可以看出，<code>FIN-WAIT-2</code>是<strong>主动方</strong>那边的状态。</p><p>处于这个状态的程序，一直在等<strong>第三次挥手</strong>的<code>FIN</code>。而第三次挥手需要由被动方在代码里执行<code>close()</code> 发出。</p><p>因此当机器上<code>FIN-WAIT-2</code>状态特别多，那一般来说，另外一台机器上会有大量的 <code>CLOSE_WAIT</code>。需要检查有大量的 <code>CLOSE_WAIT</code>的那台机器，为什么迟迟不愿调用<code>close()</code>关闭连接。</p><p>所以，如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p><p><img src="https://cdn.xiaobaidebug.top/image/FIN-WAIT-2%E7%89%B9%E5%88%AB%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0.png" alt="FIN-WAIT-2特别多的原因"></p><br><h3 id="主动方在-close-之后收到的数据，会怎么处理"><a href="#主动方在-close-之后收到的数据，会怎么处理" class="headerlink" title="主动方在 close 之后收到的数据，会怎么处理"></a>主动方在 close 之后收到的数据，会怎么处理</h3><p>之前写的一篇文章《代码执行 send 成功后，数据就发出去了吗？》中，从源码的角度提到了，<strong>一般情况下</strong>，程序主动执行<code>close()</code>的时候；</p><ul><li>如果当前连接对应的<code>socket</code>的<strong>接收缓冲区</strong>有数据，会发<code>RST</code>。</li><li>如果<strong>发送缓冲区</strong>有数据，那会等待发送完，再发第一次挥手的<code>FIN</code>。</li></ul><p>大家知道，TCP 是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>也就是说，虽然<strong>理论上</strong>，第二次和第三次挥手之间，被动方是可以传数据给主动方的。</p><p>但如果 主动方的四次挥手是通过 <code>close()</code> 触发的，那主动方是不会去收这个消息的。而且还会回一个 <code>RST</code>。直接结束掉这次连接。</p><p><img src="https://cdn.xiaobaidebug.top/image/close()%E8%A7%A6%E5%8F%91TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B5.png" alt="close()触发TCP四次挥手"></p><br><h3 id="第二第三次挥手之间，不能传输数据吗？"><a href="#第二第三次挥手之间，不能传输数据吗？" class="headerlink" title="第二第三次挥手之间，不能传输数据吗？"></a>第二第三次挥手之间，不能传输数据吗？</h3><p>也不是。前面提到<code>Close()</code>的含义是，要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>那如果能做到<strong>只关闭发送消息</strong>，<strong>不关闭接收消息</strong>的功能，那就能继续收消息了。这种 <code>half-close</code> 的功能，通过调用<code>shutdown()</code> 方法就能做到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>其中 howto 为断开方式。有以下取值：</p><ul><li>SHUT_RD：关闭读。这时应用层不应该再尝试接收数据，内核协议栈中就算接收缓冲区收到数据也会被丢弃。</li><li>SHUT_WR：关闭写。如果发送缓冲区中还有数据没发，会将将数据传递到目标主机。</li><li>SHUT_RDWR：关闭读和写。相当于<code>close()</code>了。</li></ul></blockquote><p><img src="https://cdn.xiaobaidebug.top/image/shutdown%E8%A7%A6%E5%8F%91%E7%9A%84TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="shutdown触发的TCP四次挥手"></p><br><h3 id="怎么知道对端-socket-执行了-close-还是-shutdown"><a href="#怎么知道对端-socket-执行了-close-还是-shutdown" class="headerlink" title="怎么知道对端 socket 执行了 close 还是 shutdown"></a>怎么知道对端 socket 执行了 close 还是 shutdown</h3><p>不管<strong>主动</strong>关闭方调用的是<code>close()</code>还是<code>shutdown()</code>，对于被动方来说，收到的就只有一个<code>FIN</code>。</p><p><strong>被动</strong>关闭方<strong>就懵了</strong>，”我怎么知道对方让不让我继续发数据？”</p><p><img src="https://cdn.xiaobaidebug.top/image/e18d20c94006dfe0-feec70b0eb485633-f0e01cf6d9cce2bccba34029f1ca10e0-20210808141929988.jpg"></p><p>其实，大可不必纠结，该发就发。</p><p>第二次挥手和第三次挥手之间，如果<strong>被动</strong>关闭方想发数据，那么在代码层面上，就是执行了 <code>send()</code> 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">( SOCKET s,<span class="keyword">const</span> <span class="keyword">char</span>* buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><code>send()</code> 会把数据拷贝到本机的<strong>发送缓冲区</strong>。如果发送缓冲区没出问题，都能拷贝进去，所以正常情况下，<code>send()</code><strong>一般</strong>都会返回成功。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp_sendmsg%E9%80%BB%E8%BE%912.png" alt="tcp_sendmsg逻辑"></p><p>然后<strong>被动方</strong>内核协议栈会把数据发给<strong>主动</strong>关闭方。</p><ul><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>shutdown(socket_fd, SHUT_WR)</code>。那此时，<strong>主动关闭方</strong>不再发送消息，但能接收<strong>被动方</strong>的消息，一切如常，皆大欢喜。</p></li><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>close()</code>。那<strong>主动方</strong>在收到<strong>被动方</strong>的数据后会直接<strong>丢弃</strong>，然后回一个<code>RST</code>。</p></li></ul><p>针对第二种情况。</p><p>被动方<strong>内核协议栈</strong>收到了<code>RST</code>，会把连接关闭。但内核连接关闭了，应用层也不知道（除非被通知）。</p><p>此时被动方<strong>应用层</strong>接下来的操作，无非就是<strong>读或写</strong>。</p><ul><li><p>如果是读，则会返回<code>RST</code>的报错，也就是我们常见的<code>Connection reset by peer</code>。</p></li><li><p>如果是写，那么程序会产生<code>SIGPIPE</code>信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p></li></ul><br><p><strong>总结一下</strong>，当被动关闭方 <code>recv()</code> 返回<code>EOF</code>时，说明主动方通过 <code>close()</code>或 <code>shutdown(fd, SHUT_WR)</code> 发起了第一次挥手。</p><p>如果此时被动方执行<strong>两次</strong> <code>send()</code>。</p><ul><li><p>第一次<code>send()</code>, 一般会成功返回。</p></li><li><p>第二次<code>send()</code>时。如果主动方是通过 <code>shutdown(fd, SHUT_WR)</code> 发起的第一次挥手，那此时<code>send()</code>还是会成功。如果主动方通过 <code>close()</code>发起的第一次挥手，那此时会产生<code>SIGPIPE</code>信号，进程默认会终止，异常退出。不想异常退出的话，记得捕获处理这个信号。</p></li></ul><br><h3 id="如果被动方一直不发第三次挥手，会怎么样"><a href="#如果被动方一直不发第三次挥手，会怎么样" class="headerlink" title="如果被动方一直不发第三次挥手，会怎么样"></a>如果被动方一直不发第三次挥手，会怎么样</h3><p>第三次挥手，是由<strong>被动方</strong>主动触发的，比如调用<code>close()</code>。</p><p>如果由于代码错误或者其他一些原因，被动方就是不执行第三次挥手。</p><p>这时候，主动方会根据自身第一次挥手的时候用的是 <code>close()</code> 还是 <code>shutdown(fd, SHUT_WR)</code> ，有不同的行为表现。</p><ul><li><p>如果是 <code>shutdown(fd, SHUT_WR)</code> ，说明主动方其实只关闭了写，但还可以读，此时会一直处于 <code>FIN-WAIT-2</code>， 死等被动方的第三次挥手。</p></li><li><p>如果是 <code>close()</code>， 说明主动方读写都关闭了，这时候会处于 <code>FIN-WAIT-2</code>一段时间，这个时间由 <code>net.ipv4.tcp_fin_timeout</code> 控制，一般是 <code>60s</code>，这个值正好跟<code>2MSL</code>一样 。<strong>超过这段时间之后，状态不会变成 <code>TIME-WAIT</code>，而是直接变成<code>CLOSED</code>。</strong></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_fin_timeout</span></span><br><span class="line">60</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%80%E7%9B%B4%E4%B8%8D%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%83%85%E5%86%B53.png" alt="一直不发第三次挥手的情况"></p><br><h2 id="TCP-三次挥手"><a href="#TCP-三次挥手" class="headerlink" title="TCP 三次挥手"></a>TCP 三次挥手</h2><p>四次挥手聊完了，那有没有可能出现三次挥手？</p><p><strong>是可能的。</strong></p><p>我们知道，TCP 四次挥手里，第二次和第三次挥手之间，是有可能有数据传输的。第三次挥手的目的是为了告诉主动方，”被动方没有数据要发了”。</p><p>所以，在第一次挥手之后，如果被动方没有数据要发给主动方。第二和第三次挥手是<strong>有可能</strong>合并传输的。这样就出现了三次挥手。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP三次挥手"></p><br><h3 id="如果有数据要发，就不能是三次挥手了吗"><a href="#如果有数据要发，就不能是三次挥手了吗" class="headerlink" title="如果有数据要发，就不能是三次挥手了吗"></a>如果有数据要发，就不能是三次挥手了吗</h3><p>上面提到的是<strong>没有数据要发</strong>的情况，如果第二、第三次挥手之间<strong>有数据</strong>要发，就不可能变成三次挥手了吗？</p><p><strong>并不是</strong>。TCP 中还有个特性叫<strong>延迟确认</strong>。可以简单理解为：<strong>接收方收到数据以后不需要立刻马上回复 ACK 确认包。</strong></p><p>在此基础上，<strong>不是每一次发送数据包都能对应收到一个 <code>ACK</code> 确认包，因为接收方可以合并确认。</strong></p><p>而这个合并确认，放在四次挥手里，可以把第二次挥手、第三次挥手，以及他们之间的数据传输都合并在一起发送。因此也就出现了三次挥手。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4.png" alt="TCP三次挥手延迟确认"></p><br><h2 id="TCP-两次挥手"><a href="#TCP-两次挥手" class="headerlink" title="TCP 两次挥手"></a>TCP 两次挥手</h2><p>前面在四次挥手中提到，关闭的时候双方都<strong>发出了一个 FIN 和收到了一个 ACK</strong>。</p><p>正常情况下 TCP 连接的两端，是不同<strong>IP+端口</strong>的进程。</p><p>但如果 TCP 连接的两端，<strong>IP+端口</strong>是一样的情况下，那么在关闭连接的时候，也同样做到了<strong>一端发出了一个 FIN，也收到了一个 ACK</strong>，只不过正好这两端其实是<code>同一个socket</code> 。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B2.png" alt="TCP两次挥手"></p><p>而这种两端<strong>IP+端口</strong>都一样的连接，叫<strong>TCP 自连接</strong>。</p><p>是的，你没看错，我也没打错别字。<strong>同一个 socket 确实可以自己连自己，形成一个连接。</strong></p><br><h3 id="一个-socket-能建立连接？"><a href="#一个-socket-能建立连接？" class="headerlink" title="一个 socket 能建立连接？"></a>一个 socket 能建立连接？</h3><p>上面提到了，同一个客户端 socket，自己对自己发起连接请求。是可以成功建立连接的。这样的连接，叫<strong>TCP 自连接</strong>。</p><p>下面我们尝试下复现。</p><p>注意我是在以下系统进行的实验。在<code>mac</code>上多半无法复现。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br></pre></td></tr></table></figure><p>通过<code>nc</code>命令可以很简单的创建一个<strong>TCP 自连接</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nc -p 6666 127.0.0.1 6666</span></span><br></pre></td></tr></table></figure><p>上面的 <code>-p</code> 可以指定源端口号。也就是指定了一个端口号为<code>6666</code>的客户端去连接 <code>127.0.0.1:6666</code> 。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep 6666</span></span><br><span class="line">tcp        0      0 127.0.0.1:6666          127.0.0.1:6666          ESTABLISHED</span><br></pre></td></tr></table></figure><p><strong>整个过程中，都没有服务端参与</strong>。可以抓个包看下。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210810093309117.png" alt="image-20210810093309117"></p><p>可以看到，<strong>相同的 socket，自己连自己的时候，握手是三次的。挥手是两次的。</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E8%87%AA%E8%BF%9E%E6%8E%A52.png" alt="TCP自连接"></p><p>上面这张图里，左右都是同一个客户端，把它画成两个是为了方便大家理解状态的迁移。</p><p>我们可以拿自连接的握手状态<strong>对比下</strong>正常情况下的 TCP 三次握手。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="正常情况下的TCP三次握手"></p><p>看了自连接的状态图，再看看下面几个问题。</p><br><h4 id="一端发出第一次握手后，如果又收到了第一次握手的-SYN-包，TCP-连接状态会怎么变化？"><a href="#一端发出第一次握手后，如果又收到了第一次握手的-SYN-包，TCP-连接状态会怎么变化？" class="headerlink" title="一端发出第一次握手后，如果又收到了第一次握手的 SYN 包，TCP 连接状态会怎么变化？"></a>一端发出第一次握手后，如果又收到了第一次握手的 SYN 包，TCP 连接状态会怎么变化？</h4><p>第一次握手过后，连接状态就变成了<code>SYN_SENT</code>状态。如果此时又收到了第一次握手的 SYN 包，那么连接状态就会从<code>SYN_SENT</code>状态变成<code>SYN_RCVD</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_rcv_synsent_state_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// SYN_SENT状态下，收到SYN包</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">        <span class="comment">// 状态置为 SYN_RCVD</span></span><br><span class="line">tcp_set_state(sk, TCP_SYN_RECV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h4 id="一端发出第二次握手后，如果又收到第二次握手的-SYN-ACK-包，TCP-连接状态会怎么变化？"><a href="#一端发出第二次握手后，如果又收到第二次握手的-SYN-ACK-包，TCP-连接状态会怎么变化？" class="headerlink" title="一端发出第二次握手后，如果又收到第二次握手的 SYN+ACK 包，TCP 连接状态会怎么变化？"></a>一端发出第二次握手后，如果又收到第二次握手的 SYN+ACK 包，TCP 连接状态会怎么变化？</h4><p>第二握手过后，连接状态就变为<code>SYN_RCVD</code>了，此时如果再收到第二次握手的<code>SYN+ACK</code>包。连接状态会变为<code>ESTABLISHED</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前面省略很多逻辑，能走到这就认为肯定有ACK</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断下这个ack是否合法</span></span><br><span class="line"><span class="keyword">int</span> acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"><span class="keyword">if</span> (acceptable) &#123;</span><br><span class="line">        <span class="comment">// 状态从 SYN_RCVD 转为 ESTABLISHED</span></span><br><span class="line">tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="一端第一次挥手后，又收到第一次挥手的包，TCP-连接状态会怎么变化？"><a href="#一端第一次挥手后，又收到第一次挥手的包，TCP-连接状态会怎么变化？" class="headerlink" title="一端第一次挥手后，又收到第一次挥手的包，TCP 连接状态会怎么变化？"></a>一端第一次挥手后，又收到第一次挥手的包，TCP 连接状态会怎么变化？</h4><p>第一次挥手过后，一端状态就会变成 <code>FIN-WAIT-1</code>。正常情况下，是要等待第二次挥手的<code>ACK</code>。但实际上却等来了 一个第一次挥手的 <code>FIN</code>包， 这时候连接状态就会变为<code>CLOSING</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">tcp_send_ack(sk);</span><br><span class="line">    <span class="comment">// FIN-WAIT-1状态下，收到了FIN，转为 CLOSING</span></span><br><span class="line">tcp_set_state(sk, TCP_CLOSING);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以说是<strong>隐藏剧情</strong>了。</p><p><code>CLOSING</code> 很少见，除了出现在<strong>自连接关闭</strong>外，一般还会出现在 TCP 两端<strong>同时关闭</strong>连接的情况下。</p><p>处于<code>CLOSING</code>状态下时，只要再收到一个<code>ACK</code>，就能进入 <code>TIME-WAIT</code> 状态，然后等个<code>2MSL</code>，连接就彻底断开了。这跟正常的四次挥手还是有些差别的。大家可以滑到文章开头的 TCP 四次挥手再对比下。</p><br><h4 id="代码复现自连接"><a href="#代码复现自连接" class="headerlink" title="代码复现自连接"></a>代码复现自连接</h4><p>可能大家会产生怀疑，这是不是<code>nc</code>这个软件本身的<code>bug</code>。</p><p>那我们可以尝试下用<code>strace</code>看看它内部都做了啥。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strace nc -p 6666 127.0.0.1 6666</span></span><br><span class="line">// ...</span><br><span class="line">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3</span><br><span class="line">fcntl(3, F_GETFL)                       = 0x2 (flags O_RDWR)</span><br><span class="line">fcntl(3, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0</span><br><span class="line"><span class="built_in">bind</span>(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>)&#125;, 16) = 0</span><br><span class="line">connect(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, 16) = -1 EINPROGRESS (Operation now <span class="keyword">in</span> progress)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>无非就是以创建了一个客户端<code>socket</code>句柄，然后对这个句柄执行 <code>bind</code>, 绑定它的端口号是<code>6666</code>，然后再向 <code>127.0.0.1:6666</code>发起<code>connect</code>方法。</p><p>我们可以尝试用<code>C语言</code>去复现一遍。</p><p><strong>下面的代码，只用于复现问题。直接跳过也完全不影响阅读。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">0</span>, ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a client \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 1: 创建客户端端socket描述符cfd*/</span></span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>,len=<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span>( setsockopt(cfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, len) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    clie_addr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>, &amp;clie_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 2: 客户端使用bind绑定客户端的IP和端口*/</span></span><br><span class="line">    ret = bind(cfd, (struct sockaddr* )&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 3: connect链接服务器端的IP和端口号*/</span></span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    ret = connect(cfd,(struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 向服务器端写数据*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, n);<span class="comment">//写到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Step 5: 关闭socket描述符*/</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存为 <code>client.c</code> 文件，然后执行下面命令，会发现连接成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc client.c -o client &amp;&amp; ./client</span></span><br><span class="line">This is a client</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep 6666</span></span><br><span class="line">tcp        0      0 127.0.0.1:6666          127.0.0.1:6666          ESTABLISHED</span><br></pre></td></tr></table></figure><p>说明，这不是 nc 的 bug。事实上，这也是内核允许的一种情况。</p><br><h4 id="自连接的解决方案"><a href="#自连接的解决方案" class="headerlink" title="自连接的解决方案"></a>自连接的解决方案</h4><p>自连接一般不太常见，但遇到了也不难解决。</p><p>解决方案比较简单，只要能保证客户端和服务端的端口不一致就行。</p><p>事实上，我们写代码的时候一般不会去指定客户端的端口，系统会随机给客户端分配某个范围内的端口。而这个范围，可以通过下面的命令进行查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/ip_local_port_range</span></span><br><span class="line">32768   60999</span><br></pre></td></tr></table></figure><p>也就是只要我们的服务器端口不在<code>32768-60999</code>这个范围内，比如设置为<code>8888</code>。就可以规避掉这个问题。</p><p>另外一个解决方案，可以参考<code>golang</code>标准网络库的实现，在连接建立完成之后判断下 IP 和端口是否一致，如果遇到自连接，则断开重试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialTCP</span><span class="params">(net <span class="keyword">string</span>, laddr, raddr *TCPAddr, deadline time.Time)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是自连接，这里会重试</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(net, laddr, raddr, deadline, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">&quot;dial&quot;</span>, sockaddrToTCP)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selfConnect</span><span class="params">(fd *netFD, err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是否端口、IP一致</span></span><br><span class="line"><span class="keyword">return</span> l.Port == r.Port &amp;&amp; l.IP.Equal(r.IP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p>前面提到的<code>TCP</code>自连接是一个客户端自己连自己的场景。那不同客户端之间是否可以互联？</p><p>答案是<strong>可以的</strong>，有一种情况叫<strong>TCP 同时打开</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%802.png" alt="TCP同时打开"></p><p>大家可以对比下，<strong>TCP 同时打开</strong>在握手时的状态变化，跟 TCP 自连接是非常的像。</p><p>比如<code>SYN_SENT</code>状态下，又收到了一个<code>SYN</code>，其实就相当于自连接里，在发出了第一次握手后，又收到了第一次握手的请求。结果都是变成 <code>SYN_RCVD</code>。</p><p>在 <code>SYN_RCVD</code> 状态下收到了 <code>SYN+ACK</code>，就相当于自连接里，在发出第二次握手后，又收到第二次握手的请求，结果都是变成 <code>ESTABLISHED</code>。<strong>他们的源码其实都是同一块逻辑。</strong></p><br><h4 id="复现-TCP-同时打开"><a href="#复现-TCP-同时打开" class="headerlink" title="复现 TCP 同时打开"></a>复现 TCP 同时打开</h4><p>分别在<strong>两个控制台</strong>下，分别执行下面两行命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> nc -p 2224 127.0.0.1 2223 -v;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> nc -p 2223 127.0.0.1 2224 -v;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面两个命令的含义也比较简单，两个客户端互相请求连接对方的端口号，如果失败了则不停重试。</p><p>执行后看到的现象是，一开始会疯狂失败，重试。一段时间后，连接建立完成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -an | grep  2223</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 127.0.0.1:2224          127.0.0.1:2223          ESTABLISHED</span><br><span class="line">tcp        0      0 127.0.0.1:2223          127.0.0.1:2224          ESTABLISHED</span><br></pre></td></tr></table></figure><p>期间抓包获得下面的结果。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210815090301418.png"></p><p>可以看到，这里面建立连接用了四次交互。因此可以说这是通过**”四次握手”**建立的连接。</p><p>而且更重要的是，这里面只涉及两个客户端，<strong>没有服务端</strong>。</p><p>看到这里，不知道大家有没有跟我一样，被刷新了一波认知，对<code>socket</code>有了重新的认识。</p><p>在以前的观念里，建立连接，必须要有一个客户端和一个服务端，并且服务端还要执行一个<code>listen()</code>和一个<code>accept()</code>。而实际上，这些都不是必须的。</p><p>那么下次，面试官问你**”没有<code>listen()</code>， TCP 能建立连接吗？”**， 我想大家应该知道该怎么回答了。</p><p>但问题又来了，只有两个客户端，没有<code>listen()</code> ，为什么能建立<code>TCP</code>连接？</p><p>如果大家感兴趣，我们以后有机会再填上这个坑。</p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>四次挥手</strong>中，不管是程序主动执行<code>close()</code>，还是进程被杀，都有可能发出第一次挥手<code>FIN</code>包。如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p></li><li><p><code>Close()</code>会<strong>同时关闭</strong>发送和接收消息的功能。<code>shutdown()</code> 能<strong>单独关闭</strong>发送或接受消息。</p></li><li><p>第二、第三次挥手，是有可能合在一起的。于是四次挥手就变成<strong>三次挥手</strong>了。</p></li><li><p>同一个 socket 自己连自己，会产生<strong>TCP 自连接</strong>，自连接的挥手是<strong>两次挥手</strong>。</p></li><li><p>没有<code>listen</code>，两个客户端之间也能建立连接。这种情况叫<strong>TCP 同时打开</strong>，它由<strong>四次握手</strong>产生。</p></li></ul><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天提到的，不管是<strong>两次挥手</strong>，还是<strong>自连接</strong>，或是<strong>TCP 同时打开</strong>什么的。</p><p>咋一看，可能对日常搬砖没什么用，实际上也确实没什么用。</p><p>并且在面试上大概率也不会被问到。</p><p><strong>毕竟一般面试官也不在意茴字有几种写法。</strong></p><p>这篇文章的目的，主要是想从另外一个角度让大家重新认识下<code>socket</code>。原来<code>TCP</code>是可以自己连自己的，甚至两个客户端之间，不用服务端也能连起来。</p><p>这实在是，太出乎意料了。</p><br><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！收到RST，就一定会断开TCP连接吗？</title>
      <link href="/2021/09/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F/"/>
      <url>/2021/09/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>想必大家已经知道我的 niao 性，搞个标题，就是不喜欢立马回答。</p><p>就是要搞一大堆<strong>原理性</strong>的东西，再回答标题的问题。</p><p>说这个是因为我这次会把问题的答案就放到开头吗？</p><p>不！</p><p><strong>我就不！</strong></p><span id="more"></span><p>但是大家可以直接根据目录看自己感兴趣的部分。</p><p>之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，<strong>这样有利于建立知识体系</strong>。多一点上下文，少一点<code>gap</code>。</p><p>好了，进入正题。</p><p>下面是这篇文章的目录。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%94%B6%E5%88%B0RST%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%971.png" alt="收到RST就一定会断开连接吗"></p><br><h3 id="什么是-RST"><a href="#什么是-RST" class="headerlink" title="什么是 RST"></a>什么是 RST</h3><p>我们都知道 TCP 正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它是一个 TCP 包头中的<strong>标志位</strong>。</p><p><strong>正常情况下</strong>，不管是<strong>发出</strong>，还是<strong>收到</strong>置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是 TCP 连接被关闭了。</p><p>而接收到 RST 的一方，一般会看到一个 <code>connection reset</code> 或 <code>connection refused</code> 的报错。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B4RST%E4%BD%8D.png" alt="TCP报头RST位"></p><br><h3 id="怎么知道收到-RST-了？"><a href="#怎么知道收到-RST-了？" class="headerlink" title="怎么知道收到 RST 了？"></a>怎么知道收到 RST 了？</h3><p>我们知道<strong>内核</strong>跟<strong>应用层</strong>是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层<strong>只能</strong>通过 <code>send/recv</code> 与内核交互，才能感知到内核是不是收到了<code>RST</code>。</p><p>当本端收到远端发来的<code>RST</code>后，<strong>内核</strong>已经认为此链接已经关闭。</p><p>此时如果本端<strong>应用层</strong>尝试去执行 <strong>读数据</strong>操作，比如<code>recv</code>，应用层就会收到 <strong>Connection reset by peer</strong> 的报错，意思是<strong>远端已经关闭连接</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/resetByPeer1.gif" alt="ResetByPeer"></p><p>如果本端<strong>应用层</strong>尝试去执行<strong>写数据</strong>操作，比如<code>send</code>，那么应用层就会收到 <strong>Broken pipe</strong> 的报错，意思是发送通道已经坏了。</p><p><img src="https://cdn.xiaobaidebug.top/image/brokenPipe1.gif" alt="BrokenPipe"></p><p>这两个是开发过程中很经常遇到的报错，感觉大家可以<strong>把这篇文章放进收藏夹吃灰</strong>了，等遇到这个问题了，再打开来擦擦灰，说不定对你会有帮助。</p><br><h3 id="出现-RST-的场景有哪些"><a href="#出现-RST-的场景有哪些" class="headerlink" title="出现 RST 的场景有哪些"></a>出现 RST 的场景有哪些</h3><p><strong>RST</strong>一般出现于异常情况，归类为 <strong>对端的端口不可用</strong> 和 <strong>socket 提前关闭</strong>。</p><br><h4 id="端口不可用"><a href="#端口不可用" class="headerlink" title="端口不可用"></a>端口不可用</h4><p>端口不可用分为两种情况。要么是这个端口从来就没有”可用”过，比如根本就没监听<strong>（listen）</strong>过；要么就是曾经”可用”，但现在”不可用”了，比如服务<strong>突然崩</strong>了。</p><h5 id="端口未监听"><a href="#端口未监听" class="headerlink" title="端口未监听"></a>端口未监听</h5><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E8%BF%9E%E6%8E%A5%E6%9C%AA%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3.png" alt="TCP连接未监听的端口"></p><p>服务端<code>listen</code> 方法会创建一个<code>sock</code>放入到全局的<code>哈希表</code>中。</p><p>此时客户端发起一个<code>connect</code>请求到服务端。服务端在收到数据包之后，第一时间会根据 IP 和端口从哈希表里去获取<code>sock</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%85%A8%E5%B1%80hash%E8%A1%A8.png" alt="全局hash表"></p><p>如果服务端执行过<code>listen</code>，就能从<code>全局哈希表</code>里拿到<code>sock</code>。</p><p>但如果服务端没有执行过<code>listen</code>，那<code>哈希表</code>里也就不会有对应的<code>sock</code>，结果当然是拿不到。此时，<strong>正常情况下</strong>服务端会发<code>RST</code>给客户端。</p><br><h6 id="端口未监听就一定会发-RST-吗？"><a href="#端口未监听就一定会发-RST-吗？" class="headerlink" title="端口未监听就一定会发 RST 吗？"></a>端口未监听就一定会发 RST 吗？</h6><p><strong>不一定</strong>。上面提到，发 RST 的前提是<strong>正常情况下</strong>，我们看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_ipv4.c</span></span><br><span class="line"><span class="comment">// 代码经过删减</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据ip、端口等信息 获取sock。</span></span><br><span class="line">sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">no_tcp_socket:</span><br><span class="line">    <span class="comment">// 检查数据包有没有出错</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; <span class="number">2</span>) || tcp_checksum_complete(skb)) &#123;</span><br><span class="line">        <span class="comment">// 错误记录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送RST</span></span><br><span class="line">tcp_v4_send_reset(<span class="literal">NULL</span>, skb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是<strong>TCP 还是 UDP</strong>走不一样的函数方法。可以简单认为，<strong>TCP</strong>数据包都会走到 <code>tcp_v4_rcv()</code>。 这个方法会从<code>全局哈希表</code>里获取 <code>sock</code>，如果此时服务端没有<code>listen()</code>过 , 那肯定获取不了<code>sock</code>，会跳转到<code>no_tcp_socket</code>的逻辑。</p><p>注意这里会先走一个 <code>tcp_checksum_complete()</code>，目的是看看数据包的**校验和(Checksum)**是否合法。</p><br><blockquote><p><strong>校验和</strong>可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的 TCP 首部和 TCP 数据。</p></blockquote><br><p>如果在发送端到接收端传输过程中，数据发生<strong>任何改动</strong>，比如被第三方篡改，那么接收方能检测到校验和有差错，此时 TCP 段会被直接丢弃。如果校验和没问题，那才会发 RST。</p><p>所以，<strong>只有在数据包没问题的情况下，比如校验和没问题，才会发 RST 包给对端。</strong></p><br><h6 id="为什么数据包异常的情况下，不发-RST？"><a href="#为什么数据包异常的情况下，不发-RST？" class="headerlink" title="为什么数据包异常的情况下，不发 RST？"></a>为什么数据包异常的情况下，不发 RST？</h6><p>一个数据包连校验都不能通过，那这个包，<strong>多半有问题</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/006cSBLKly1gl6b731molj306405q74a.jpg"></p><p>有可能是在发送的过程中被篡改了，又或者，可能只是一个<strong>胡乱伪造</strong>的数据包。</p><p><strong>五层网络，不管是哪一层</strong>，只要遇到了这种数据，<strong>推荐的做法都是默默扔掉</strong>，<strong>而不是</strong>去回复一个消息告诉对方数据有问题。</p><p>如果对方用的是 TCP，是可靠传输协议，发现很久没有<code>ACK</code>响应，自己就会重传。</p><p>如果对方用的是 UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。</p><p>因此，数据包异常的情况下，默默扔掉，不发<code>RST</code>，非常合理。</p><br><p><img src="https://cdn.xiaobaidebug.top/image/006i487Uly1fgqbcncf3gj30b40b43z0-20210908211826494.jpg"></p><p>还是不能理解？那我<strong>再举个例子</strong>。</p><p>正常人喷你，他说话<strong>条理清晰，主谓宾分明</strong>。此时你喷回去，那你是个充满热情，正直，富有判断力的好人。</p><p>而此时一个憨憨也想喷你，但他<strong>思维混乱，连话都说不清楚，一直阿巴阿巴</strong>的，你虽然听不懂，但<strong>大受震撼</strong>，此时你会？</p><ul><li><p>A：跟他激情互喷</p></li><li><p>B：不跟他一般见识，就当没听过</p></li></ul><p>一般来说<strong>最优选择是 B</strong>，毕竟你理他，他反而来劲。</p><p>这下，应该就懂了。</p><p><img src="https://cdn.xiaobaidebug.top/image/006m97Kgly1fxtp35bi77j315o15o4qp.jpg"></p><br><h5 id="程序启动了但是崩了"><a href="#程序启动了但是崩了" class="headerlink" title="程序启动了但是崩了"></a>程序启动了但是崩了</h5><p>端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的<strong>应用程序突然崩了</strong>，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会<strong>回一个 RST</strong>。在开发过程中，<strong>这种情况是最常见的</strong>。</p><p>比如你的服务端应用程序里，弄了个<strong>空指针</strong>，或者<strong>数组越界</strong>啥的，程序立马就崩了。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E7%9B%91%E5%90%AC%E4%BA%86%E4%BD%86%E5%B4%A9%E4%BA%863.png" alt="TCP监听了但崩了"></p><p>这种情况跟<strong>端口未监听</strong>本质上类似，在服务端的应用程序<strong>崩溃后</strong>，原来监听的端口资源就被释放了，从效果上来看，类似于处于<code>CLOSED</code>状态。</p><p>此时服务端又收到了客户端发来的消息，内核协议栈会根据<strong>IP 端口</strong>，从全局哈希表里查找<code>sock</code>，结果当然是拿不到对应的<code>sock</code>数据，于是走了跟上面**”端口未监听”<strong>时一样的逻辑，回了个<code>RST</code>。客户端在收到 RST 后也</strong>释放了 sock 资源<strong>，从效果上来看，就是</strong>连接断了**。</p><h6 id="RST-和-502-的关系"><a href="#RST-和-502-的关系" class="headerlink" title="RST 和 502 的关系"></a>RST 和 502 的关系</h6><p>上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现<code>RST</code>。但如果在客户端和服务端中间再加一个<code>nginx</code>，就像下图一样。</p><p><img src="https://cdn.xiaobaidebug.top/image/RST%E4%B8%8E5021.png" alt="RST与502"></p><p><code>nginx</code>会作为客户端和服务端之间的”中间人角色”，负责<strong>转发</strong>请求和响应结果。但当服务端程序<strong>崩溃</strong>，比如出现<strong>野指针或者 OOM</strong>的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个<code>RST</code>给<code>nginx</code>。<code>nginx</code>在收到这个<code>RST</code>后会断开与服务端的连接，同时返回客户端一个<code>502</code>错误码。</p><p>所以，出现 502 问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了 OOM 或者日志是否有空指针等报错信息。</p><br><h4 id="socket-提前关闭"><a href="#socket-提前关闭" class="headerlink" title="socket 提前关闭"></a>socket 提前关闭</h4><p>这种情况分为<strong>本端</strong>提前关闭，和<strong>远端</strong>提前关闭。</p><h5 id="本端提前关闭"><a href="#本端提前关闭" class="headerlink" title="本端提前关闭"></a>本端提前关闭</h5><p>如果本端<code>socket</code>接收缓冲区<strong>还有数据未读</strong>，此时<strong>提前<code>close()</code> socket</strong>。那么本端会先把接收缓冲区的数据清空，然后给远端发一个 RST。</p><p><img src="https://cdn.xiaobaidebug.top/image/recvbuf%E9%9D%9E%E7%A9%BA.gif" alt="recvbuf非空"></p><br><h5 id="远端提前关闭"><a href="#远端提前关闭" class="headerlink" title="远端提前关闭"></a>远端提前关闭</h5><p>远端已经<code>close()</code>了<code>socket</code>，此时本端还尝试发数据给远端。那么远端就会回一个 RST。</p><p><img src="https://cdn.xiaobaidebug.top/image/close()%E8%A7%A6%E5%8F%91TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B5-20210828083457512.png" alt="close()触发TCP四次挥手"></p><p>大家知道，TCP 是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>客户端执行<code>close()</code>， 正常情况下，会发出<strong>第一次</strong>挥手 FIN，然后服务端回<strong>第二次</strong>挥手 ACK。如果在<strong>第二次和第三次挥手之间</strong>，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个 RST 消息到服务端。直接结束掉这次连接。</p><br><h3 id="对方没收到-RST，会怎么样？"><a href="#对方没收到-RST，会怎么样？" class="headerlink" title="对方没收到 RST，会怎么样？"></a>对方没收到 RST，会怎么样？</h3><p>我们知道 TCP 是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个<code>ACK</code>，意思是”我收到这个包了”。</p><p><strong>而 RST，不需要 ACK 确认包</strong>。</p><p>因为<code>RST</code>本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个<code>ACK</code>吗？<strong>可以幻想，不要妄想。</strong></p><p>但<strong>问题又来了</strong>，网络环境这么复杂，丢包也是分分钟的事情，既然 RST 包不需要 ACK 来确认，那万一对方就是没收到 RST，会怎么样？</p><p><img src="https://cdn.xiaobaidebug.top/image/RST%E4%B8%A2%E5%A4%B13.png" alt="RST丢失"></p><p>RST 丢了，问题不大。比方说上图服务端，发了 RST 之后，服务端就认为连接不可用了。</p><p>如果客户端之前<strong>发送了数据</strong>，一直没等到这个数据的确认 ACK，就会重发，重发的时候，自然就会触发一个新的 RST 包。</p><p>而如果客户端之前<strong>没有发数据</strong>，但服务端的 RST 丢了，TCP 有个 keepalive 机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个 RST。</p><p><img src="https://cdn.xiaobaidebug.top/image/RST%E4%B8%A2%E5%A4%B1%E5%90%8Ekeepalive2.png" alt="RST丢失后keepalive"></p><br><h3 id="收到-RST-就一定会断开连接吗"><a href="#收到-RST-就一定会断开连接吗" class="headerlink" title="收到 RST 就一定会断开连接吗?"></a>收到 RST 就一定会断开连接吗?</h3><p>先说结论，<strong>不一定会断开</strong>。我们看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_validate_incoming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取sock</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1：先判断seq是否合法（是否在合法接收窗口范围内）</span></span><br><span class="line"><span class="keyword">if</span> (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123;</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2：执行收到 RST 后该干的事情</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line"><span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)</span><br><span class="line">tcp_reset(sk);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tcp_send_challenge_ack(sk);</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到 RST 包，第一步会通过<code>tcp_sequence</code>先看下这个 seq 是否合法，其实主要是看下这个 seq 是否在合法<strong>接收窗口</strong>范围内。<strong>如果不在范围内，这个 RST 包就会被丢弃。</strong></p><p>至于接收窗口是个啥，我们先看下面这个图。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png" alt="接收窗口"></p><p>这里<strong>黄色的部分</strong>，就是指接收窗口，只要 RST 包的 seq 不在这个窗口范围内，那就会被丢弃。</p><br><h4 id="为什么要校验是否在窗口范围内"><a href="#为什么要校验是否在窗口范围内" class="headerlink" title="为什么要校验是否在窗口范围内"></a>为什么要校验是否在窗口范围内</h4><p>正常情况下客户端服务端双方可以通过 RST 来断开连接。假设不做 seq 校验，如果这时候有不怀好意的第三方介入，构造了一个 RST 包，且在 TCP 和 IP 等报头都填上客户端的信息，发到服务端，那么服务端就会断开这个连接。同理也可以伪造服务端的包发给客户端。这就叫<strong>RST 攻击</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/RST%E6%94%BB%E5%87%BB.png" alt="RST攻击"></p><p>受到 RST 攻击时，从现象上看，客户端老感觉服务端崩了，这非常影响用户体验。</p><p>如果这是个游戏，我相信多崩几次，第二天大家就不来玩了。</p><p>实际消息发送过程中，接收窗口是不断移动的，seq 也是在飞快的变动中，此时第三方是<strong>比较难</strong>构造出合法 seq 的 RST 包的，那么通过这个 seq 校验，就可以拦下了很多不合法的消息。</p><br><h4 id="加了窗口校验就不能用-RST-攻击了吗"><a href="#加了窗口校验就不能用-RST-攻击了吗" class="headerlink" title="加了窗口校验就不能用 RST 攻击了吗"></a>加了窗口校验就不能用 RST 攻击了吗</h4><p><strong>不是，只是增加了攻击的成本。</strong>但如果想搞，还是可搞的。</p><p>以下是<strong>面向监狱编程</strong>的环节。</p><p>希望大家只<strong>了解原理</strong>就好了，<strong>不建议使用</strong>。</p><p>相信大家都不喜欢穿着蓝白条纹的衣服，拍<strong>纯狱风</strong>的照片。</p><p>从上面可以知道，不是每一个 RST 包都会导致连接重置的，要求是这个 RST 包的 seq 要在窗口范围内，所以，问题就变成了，<strong>我们怎么样才能构造出合法的 seq</strong>。</p><br><h5 id="盲猜-seq"><a href="#盲猜-seq" class="headerlink" title="盲猜 seq"></a>盲猜 seq</h5><p>窗口数值 seq 本质上只是个 uint32 类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> &#123;</span></span><br><span class="line">__u32seq;<span class="comment">/* Starting sequence number*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在这个范围内疯狂猜测 seq 数值，并构造对应的包，发到目的机器，虽然概率低，但是总是能被试出来，从而实现<strong>RST 攻击</strong>。这种乱棍打死老师傅的方式，就是所谓的<strong>合法窗口盲打（blind in-window attacks）</strong>。</p><p>觉得这种方式比较<strong>笨</strong>？那有没有聪明点的方式，还真有，但是在这之前需要先看下面的这个问题。</p><br><h5 id="已连接状态下收到第一次握手包会怎么样？"><a href="#已连接状态下收到第一次握手包会怎么样？" class="headerlink" title="已连接状态下收到第一次握手包会怎么样？"></a>已连接状态下收到第一次握手包会怎么样？</h5><p>我们需要了解一个问题，比如服务端在已连接（<code>ESTABLISHED</code>）状态下，如果收到客户端发来的第一次握手包（<code>SYN</code>），会怎么样？</p><p>以前我以为<strong>服务单会认为客户端憨憨了，直接 RST 连接。</strong></p><p><strong>但实际，并不是</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_validate_incoming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断seq是否在合法窗口内 */</span></span><br><span class="line"><span class="keyword">if</span> (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line"><span class="comment">// 收到一个不在合法窗口内的SYN包</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn)</span><br><span class="line"><span class="keyword">goto</span> syn_challenge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * RFC 5691 4.2 : 发送 challenge ack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">syn_challenge:</span><br><span class="line">tcp_send_challenge_ack(sk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端发出一个不在合法窗口内的 SYN 包的时候，服务端会发一个带有正确的 seq 数据 ACK 包出来，这个 ACK 包叫 <code>challenge ack</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210901085509641.png" alt="challenge ack抓包"></p><p>上图是抓包的结果，用<code>scapy</code>随便伪造一个<code>seq=5</code>的包发到服务端（<code>端口9090</code>），服务端回复一个带有正确 seq 值的<code>challenge ack</code>包给客户端（<code>端口8888</code>）。</p><br><h5 id="利用-challenge-ack-获取-seq"><a href="#利用-challenge-ack-获取-seq" class="headerlink" title="利用 challenge ack 获取 seq"></a>利用 challenge ack 获取 seq</h5><p>上面提到的<strong>这个 challenge ack ，仿佛为盲猜 seq 的老哥们打开了一个新世界。</strong></p><p>在获得这个<code>challenge ack</code>后，攻击程序就可以以 ack 值为基础，在一定范围内设置 seq，这样造成 RST 攻击的几率就大大增加了。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%88%A9%E7%94%A8ChallengeACK%E7%9A%84RST%E6%94%BB%E5%87%BB.png" alt="利用ChallengeACK的RST攻击"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>RST 其实是 TCP 包头里的一个标志位，目的是为了在<strong>异常情况</strong>下关闭连接。</li><li>内核收到 RST 后，应用层只能通过调用读/写操作来感知，此时会对应获得 <strong>Connection reset by peer</strong> 和<strong>Broken pipe</strong> 报错。</li><li>发出 RST 后不需要得到对方的 ACK 确认包，因此 RST 丢失后对方不能立刻感知，但是通过下一次<strong>重传</strong>数据或 keepalive<strong>心跳包</strong>可以导致 RST 重传。</li><li><strong>收到 RST 包，不一定会断开连接，seq 不在合法窗口范围内的数据包会被默默丢弃。</strong>通过构造合法窗口范围内 seq，可以造成 RST 攻击，<strong>这一点大家了解就好，千万别学！</strong></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>TCP 旁路攻击分析与重现 - <a href="https://www.cxyzjd.com/article/qq_27446553/52416369">https://www.cxyzjd.com/article/qq_27446553/52416369</a></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近想用<code>vscode</code>写小说了，故事梗概都想好了。</p><blockquote><p>十年前，他是大厂最年轻 CTO，闭眼刷 leetcode，敲代码 0 error ，0 warning， 却被诬陷删库跑路，锒铛入狱，众叛亲离……十年后，他重新归来！却看到自己的女儿在仇人公司里修 bug！</p><p>“我要你付出代价！”</p><p>一声令下，十万 <code>p7，p8</code> 应声前来…….</p></blockquote><p><strong>爽否？</strong></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！代码执行send成功后，数据就发出去了吗？</title>
      <link href="/2021/08/10/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Csend%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%B0%B1%E5%8F%91%E5%87%BA%E5%8E%BB%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2021/08/10/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Csend%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%B0%B1%E5%8F%91%E5%87%BA%E5%8E%BB%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>今天又是被倾盆的需求淹没的一天。</p><p><img src="https://cdn.xiaobaidebug.top/image/8e7e47794e20a373.jpeg"></p><p>有没有人知道，那种“<strong>我用 3 句话，就让产品为我砍了 18 个需求</strong>”的鸡汤课在哪报名，想报。</p><span id="more"></span><p>“<strong>听懂掌声</strong>“的那种课就算了，太费手了。</p><p><img src="https://cdn.xiaobaidebug.top/image/2b1dc921fecd27e1.gif"></p><p>扯远了，回到我们今天的正题，我们了解下这篇文的目录。</p><p><img src="https://cdn.xiaobaidebug.top/image/send%E7%9B%AE%E5%BD%95.png" alt="目录"></p><p>代码执行 send 成功后，数据就发出去了吗？</p><p>回答这个问题之前，需要了解什么是<strong>Socket 缓冲区</strong>。</p><br><h2 id="Socket-缓冲区"><a href="#Socket-缓冲区" class="headerlink" title="Socket 缓冲区"></a>Socket 缓冲区</h2><h3 id="什么是-socket-缓冲区"><a href="#什么是-socket-缓冲区" class="headerlink" title="什么是 socket 缓冲区"></a>什么是 socket 缓冲区</h3><p>编程的时候，如果要跟某个 IP 建立连接，我们需要调用操作系统提供的 <code>socket API</code>。</p><p><strong>socket</strong> 在操作系统层面，可以理解为一个<strong>文件</strong>。</p><p>我们可以对这个文件进行一些<strong>方法操作</strong>。</p><p>用<code>listen</code>方法，可以让程序作为服务器<strong>监听</strong>其他客户端的连接。</p><p>用<code>connect</code>，可以作为客户端<strong>连接</strong>服务器。</p><p>用<code>send</code>或<code>write</code>可以<strong>发送</strong>数据，<code>recv</code>或<code>read</code>可以<strong>接收</strong>数据。</p><p>在建立好连接之后，这个 <strong>socket</strong> 文件就像是远端机器的 <strong>“代理人”</strong> 一样。比如，如果我们想给远端服务发点什么东西，那就只需要对这个文件执行写操作就行了。</p><p><img src="https://cdn.xiaobaidebug.top/image/socket_api.png" alt="socket_api"></p><p>那写到了这个文件之后，剩下的发送工作自然就是由操作系统<strong>内核</strong>来完成了。</p><p>既然是写给操作系统，那操作系统就需要<strong>提供一个地方给用户写</strong>。同理，接收消息也是一样。</p><p>这个地方就是 <strong>socket 缓冲区</strong>。</p><p>用户<strong>发送</strong>消息的时候写给 send buffer（发送缓冲区）。</p><p>用户<strong>接收</strong>消息的时候，是从 recv buffer（接收缓冲区）中读取数据。</p><p>也就是说<strong>一个 socket ，会带有两个缓冲区</strong>，一个用于发送，一个用于接收。因为这是个先进先出的结构，有时候也叫它们<strong>发送、接收队列</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%80%E4%B8%AAsocket%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="一个socket有两个缓冲区"></p><br><h4 id="怎么观察-socket-缓冲区"><a href="#怎么观察-socket-缓冲区" class="headerlink" title="怎么观察 socket 缓冲区"></a>怎么观察 socket 缓冲区</h4><p>如果想要查看 socket 缓冲区，可以在 linux 环境下执行 <code>netstat -nt</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0     60 172.22.66.69:22         122.14.220.252:59889    ESTABLISHED</span><br></pre></td></tr></table></figure><p>这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的 IP 信息，状态（State）是已连接。</p><p>还有<strong>Send-Q 是发送缓冲区</strong>，下面的数字 60 是指，当前还有 60 Byte 在发送缓冲区中未发送。而 <strong>Recv-Q 代表接收缓冲区</strong>， 此时是空的，数据都被应用进程接收干净了。</p><br><h2 id="TCP-部分"><a href="#TCP-部分" class="headerlink" title="TCP 部分"></a>TCP 部分</h2><p>我们在使用 TCP 建立连接之后，一般会使用 send 发送数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    sockfd=socket(AF_INET,SOCK_STREAM, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 建立连接</span></span><br><span class="line">    connect(sockfd, 服务器ip信息, <span class="keyword">sizeof</span>(server))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行 send 发送消息</span></span><br><span class="line">    send(sockfd,str,<span class="keyword">sizeof</span>(str),<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 socket</span></span><br><span class="line">    close(sockfd);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一段伪代码，仅用于展示大概逻辑，我们在建立好连接后，一般会在代码中执行 <code>send</code> 方法。那么此时，消息就会被立刻发到对端机器吗？</p><br><h3 id="执行-send-发送的字节，会立马发送吗？"><a href="#执行-send-发送的字节，会立马发送吗？" class="headerlink" title="执行 send 发送的字节，会立马发送吗？"></a>执行 send 发送的字节，会立马发送吗？</h3><p>答案是不确定！执行 send 之后，数据只是拷贝到了 socket 缓冲区。至于什么时候会发数据，发多少数据，<strong>全听操作系统安排</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp_sendmsg%E9%80%BB%E8%BE%913.png" alt="tcp_sendmsg逻辑"></p><p>在用户进程中，程序通过操作 socket 会从用户态进入内核态，而 send 方法会将数据一路传到传输层。在识别到是 TCP 协议后，会调用 tcp_sendmsg 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp.c</span></span><br><span class="line"><span class="comment">// 以下省略了大量逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果还有可以放数据的空间</span></span><br><span class="line">  <span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试拷贝待发送数据到发送缓冲区</span></span><br><span class="line">    err = skb_add_data_nocache(sk, skb, from, copy);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面是尝试发送的逻辑代码,先省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。</p><br><h3 id="如果缓冲区满了会怎么办"><a href="#如果缓冲区满了会怎么办" class="headerlink" title="如果缓冲区满了会怎么办"></a>如果缓冲区满了会怎么办</h3><p>前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。</p><h4 id="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"><a href="#如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？" class="headerlink" title="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"></a>如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？</h4><p>这里分两种情况。</p><p>首先，socket 在创建的时候，是可以设置是<strong>阻塞</strong>的还是<strong>非阻塞</strong>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><p>比如通过上面的代码，就可以将 <code>socket</code> 设置为<strong>非阻塞</strong> （<code>SOCK_NONBLOCK</code>）。</p><p>当发送缓冲区<strong>满了</strong>，如果还向 socket 执行 send</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等、死等</strong>，直到释放出新的缓存空间，就继续把数据拷进去，然后<strong>返回</strong>。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/send%E9%98%BB%E5%A1%9E.gif" alt="send阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是 <code>Try again</code> , 现在缓冲区满了，你也别等了，待会再试一次。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/send%E9%9D%9E%E9%98%BB%E5%A1%9E.gif" alt="send非阻塞"></p><p>我们可以简单看下源码是怎么实现的。还是回到刚才的 <code>tcp_sendmsg</code> 发送方法中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ..如果有足够缓冲区就执行balabla</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果发送缓冲区没空间了，那就等到有空间，至于等的方式，分阻塞和非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> ((err = sk_stream_wait_memory(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面提到的 <code>sk_stream_wait_memory</code> 会根据<code>socket</code>是否阻塞，来决定是<strong>一直等</strong>，还是<strong>等一会就返回</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sk_stream_wait_memory</span><span class="params">(struct sock *sk, <span class="keyword">long</span> *timeo_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞模式时，会等到超时返回 EAGAIN</span></span><br><span class="line"><span class="keyword">if</span> (等待超时))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;</span><br><span class="line">     <span class="comment">// 阻塞等待时，会等到发送缓冲区有足够的空间了，才跳出</span></span><br><span class="line"><span class="keyword">if</span> (sk_stream_memory_free(sk) &amp;&amp; !vm_wait)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="如果接收缓冲区为空，执行-recv-会怎么样？"><a href="#如果接收缓冲区为空，执行-recv-会怎么样？" class="headerlink" title="如果接收缓冲区为空，执行 recv 会怎么样？"></a>如果接收缓冲区为空，执行 recv 会怎么样？</h4><p>接收缓冲区也是类似的情况。</p><p>当接收缓冲区<strong>为空</strong>，如果还向 socket 执行 recv</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等</strong>，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后<strong>返回</strong>。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/recv%E9%98%BB%E5%A1%9E.gif" alt="recv阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/recv%E9%9D%9E%E9%98%BB%E5%A1%9E2.gif" alt="recv非阻塞"></p><p>下面用一张图汇总一下，方便大家保存面试的时候用哈哈哈。</p><p><img src="https://cdn.xiaobaidebug.top/image/socket.png" alt="socket读写缓冲区满了的情况汇总"></p><br><h3 id="如果-socket-缓冲区还有数据，执行-close-了，会怎么样？"><a href="#如果-socket-缓冲区还有数据，执行-close-了，会怎么样？" class="headerlink" title="如果 socket 缓冲区还有数据，执行 close 了，会怎么样？"></a>如果 socket 缓冲区还有数据，执行 close 了，会怎么样？</h3><p>首先我们要知道，<strong>一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。</strong></p><p>如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。</p><p>正常情况下，如果 <code>socket</code> 缓冲区<strong>为空</strong>，执行 <code>close</code>。就会触发四次挥手。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B4.png" alt="TCP四次挥手"></p><p>这个也是面试老八股文内容了，<strong>这里我们只需要关注第一次挥手，发的是 <code>FIN</code> 就够了</strong>。</p><br><h4 id="如果接收缓冲区有数据时，执行-close-了，会怎么样？"><a href="#如果接收缓冲区有数据时，执行-close-了，会怎么样？" class="headerlink" title="如果接收缓冲区有数据时，执行 close 了，会怎么样？"></a>如果接收缓冲区有数据时，执行 close 了，会怎么样？</h4><p><code>socket close</code> 时，主要的逻辑在 <code>tcp_close()</code> 里实现。</p><p>先说结论，关闭过程主要有两种情况：</p><ul><li>如果接收缓冲区<strong>还有数据未读</strong>，会先把接收缓冲区的数据清空，然后给对端发一个 RST。</li><li>如果接收缓冲区是<strong>空的</strong>，那么就调用 <code>tcp_send_fin()</code> 开始进行四次挥手过程的第一次挥手。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果接收缓冲区有数据，那么清空数据</span></span><br><span class="line"><span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq -</span><br><span class="line">  tcp_hdr(skb)-&gt;fin;</span><br><span class="line">data_was_unread += len;</span><br><span class="line">__kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">    <span class="comment">// 如果接收缓冲区的数据被清空了，发 RST</span></span><br><span class="line">tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">    <span class="comment">// 正常四次挥手， 发 FIN</span></span><br><span class="line">tcp_send_fin(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待关闭</span></span><br><span class="line">sk_stream_wait_close(sk, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/recvbuf%E9%9D%9E%E7%A9%BA.gif" alt="recvbuf非空"></p><br><h4 id="如果发送缓冲区有数据时，执行-close-了，会怎么样？"><a href="#如果发送缓冲区有数据时，执行-close-了，会怎么样？" class="headerlink" title="如果发送缓冲区有数据时，执行 close 了，会怎么样？"></a>如果发送缓冲区有数据时，执行 close 了，会怎么样？</h4><p>以前以为，这种情况下，内核会把发送缓冲区数据清空，然后四次挥手。</p><p>但是发现源码<strong>并不是这样的</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获得发送缓冲区的最后一块数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tskb</span> =</span> tcp_write_queue_tail(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果发送缓冲区还有数据</span></span><br><span class="line"><span class="keyword">if</span> (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) &#123;</span><br><span class="line">TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN; <span class="comment">// 把最后一块数据值为 FIN</span></span><br><span class="line">TCP_SKB_CB(tskb)-&gt;end_seq++;</span><br><span class="line">tp-&gt;write_seq++;</span><br><span class="line">&#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发送缓冲区没有数据，就造一个FIN包</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。</p><p><code>socket</code> 缓冲区是个<strong>先进先出</strong>的队列，这种情况是指，内核会等待 TCP 层安静地把发送缓冲区数据都<strong>发完</strong>，最后再执行 四次挥手的第一次挥手（FIN 包）。</p><p>有一点需要注意的是，只有在<strong>接收缓冲区为空的前提下</strong>，我们才有可能走到 <code>tcp_send_fin()</code> 。而只有在进入了这个方法之后，我们才有可能考虑<strong>发送缓冲区是否为空</strong>的场景。</p><p><img src="https://cdn.xiaobaidebug.top/image/sendbuf%E9%9D%9E%E7%A9%BA.gif" alt="sendbuf非空"></p><br><h2 id="UDP-部分"><a href="#UDP-部分" class="headerlink" title="UDP 部分"></a>UDP 部分</h2><h3 id="UDP-也有缓冲区吗"><a href="#UDP-也有缓冲区吗" class="headerlink" title="UDP 也有缓冲区吗"></a>UDP 也有缓冲区吗</h3><p>说完 TCP 了，我们聊聊 UDP。这对好基友，同时都是传输层里的重要协议。既然前面提到 TCP 有发送、接收缓冲区，那 UDP 有吗？</p><p>以前我以为。</p><blockquote><p>“每个 UDP socket 都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，正因为不需要缓冲数据，所以也不需要发送缓冲区。”</p></blockquote><p>后来我发现我错了。</p><p>UDP socket 也是 socket，一个 socket 就是会有收和发两个缓冲区。<strong>跟用什么协议关系不大</strong>。</p><p>有没有是一回事，用不用又是另外一回事。</p><br><h3 id="UDP-不用发送缓冲区？"><a href="#UDP-不用发送缓冲区？" class="headerlink" title="UDP 不用发送缓冲区？"></a>UDP 不用发送缓冲区？</h3><p>事实上，UDP 不仅<code>有</code>发送缓冲区，也<code>用</code>发送缓冲区。</p><p>一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。</p><p>还有一种情况，是在发送数据的时候，设置一个 <code>MSG_MORE</code> 的标记。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// flag 置为 MSG_MORE</span></span><br></pre></td></tr></table></figure><p>大概的意思是告诉内核，待会还有其他<strong>更多消息</strong>要一起发，先别着急发出去。此时内核就会把这份数据先用<strong>发送缓冲区</strong>缓存起来，待会应用层说 ok 了，再一起发。</p><p>我们可以看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// corkreq 为 true 表示是 MSG_MORE 的方式，仅仅组织报文，不发送；</span></span><br><span class="line"><span class="keyword">int</span> corkreq = up-&gt;corkflag || msg-&gt;msg_flags&amp;MSG_MORE；</span><br><span class="line"></span><br><span class="line"><span class="comment">//  将要发送的数据，按照MTU大小分割，每个片段一个skb；并且这些</span></span><br><span class="line"><span class="comment">//  skb会放入到套接字的发送缓冲区中；该函数只是组织数据包，并不执行发送动作。</span></span><br><span class="line">err = ip_append_data(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">     <span class="keyword">sizeof</span>(struct udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">     corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有启用 MSG_MORE 特性，那么直接将发送队列中的数据发送给IP。</span></span><br><span class="line">    <span class="keyword">if</span> (!corkreq)</span><br><span class="line">err = udp_push_pending_frames(sk);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不管是不是 <code>MSG_MORE</code>， IP 都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。</p><p>而我们大部分情况下，都不会用 <code>MSG_MORE</code>，也就是来一个数据包就直接发一个数据包。从这个行为上来说，<strong>虽然 UDP 用上了发送缓冲区，但实际上并没有起到”缓冲”的作用。</strong></p><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章，我也就写了 20 个小时吧。画图也就画吐了<strong>而已</strong>，每天早上 7 点钟爬起来写一个多小时再去上班。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是心口不一的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连接一个 IP 不存在的主机时，握手过程是怎样的？</title>
      <link href="/2021/07/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AAIP%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%97%B6%EF%BC%8C%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
      <url>/2021/07/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AAIP%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%97%B6%EF%BC%8C%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>鸽了好长时间了，最近<strong>很忙</strong>。以前工作忙完，就抽空写文章。</p><p>现在忙完工作，还要一三五学驾照，二四六看家具。有同感的老铁们不要举手，拉到右下角**点个”在看”**就好了。</p><p>真的，全怪某音。</p><span id="more"></span><p><img src="https://cdn.xiaobaidebug.top/image/12021625633784_.pic.jpg"></p><p>扯远了，回到今天的主题。</p><p>方兄最近写了篇很赞的文章 <a href="https://mp.weixin.qq.com/s/SxaNLfGwM4dyzvBUvLAHvA">写给想去字节写 Go 的你</a> ，里面提到了两个问题。</p><p>连接一个 <strong>IP 不存在</strong>的主机时，握手过程是怎样的？</p><p>连接一个 <strong>IP 地址存在但端口号不存在</strong>的主机时，握手过程又是怎样的呢？</p><p>让我回想起曾经也被面试官也问过类似的问题，意识到应该很多朋友会对这个问题感兴趣。</p><p>所以来给大家唠唠。</p><p>这两个问题可以延伸出非常多的点。</p><p>看完了，说不定能加分！</p><p><img src="https://cdn.xiaobaidebug.top/image/12011625633784_.pic.jpg"></p><br><h2 id="正常情况的握手过程是怎么样的"><a href="#正常情况的握手过程是怎么样的" class="headerlink" title="正常情况的握手过程是怎么样的"></a>正常情况的握手过程是怎么样的</h2><p>上面提到的问题，其实是指<strong>TCP 的三次握手流程</strong>。这绝对是面试八股文里的老股了。</p><p>我们<strong>简单回顾</strong>下基础知识点。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt="正常情况下的TCP三次握手"></p><p>在<strong>服务端</strong>启动好后会调用 <code>listen()</code> 方法，进入到 <code>LISTEN</code> 状态，然后静静等待<strong>客户端</strong>的连接请求到来。</p><p>而此时客户端主动调用 <code>connect(IP地址)</code> ，就会向某个 IP 地址发起<strong>第一次握手</strong>，发送<code>SYN</code> 到目的服务器。</p><p>服务器在收到第一次握手后就会响应客户端，这是<strong>第二次握手</strong>。</p><p>客户端在收到第二次握手的消息后，响应服务的一个<code>ACK</code>，这算<strong>第三次</strong>握手，此时客户端 就会进入 <code>ESTABLISHED</code>状态，认为连接已经建立完成。</p><p>通过抓包可以直观看出三次握手的流程。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210626164202297.png" alt="正常三次握手抓包"></p><br><h2 id="连一个-IP-不存在的主机时，握手过程是怎样的"><a href="#连一个-IP-不存在的主机时，握手过程是怎样的" class="headerlink" title="连一个 IP 不存在的主机时，握手过程是怎样的"></a>连一个 IP 不存在的主机时，握手过程是怎样的</h2><p>那不存在的 IP，分两种，<strong>局域网内和局域网外</strong>的。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%81%94.png" alt="家用路由器局域网互联"></p><p>我以我家里的情况举例。</p><p>家里有一台<strong>家用路由器</strong>。本质上它的功能已经集成了我们常说的<strong>路由器，交换机和无线接入点</strong>的功能了。</p><p>其中<strong>路由器和交换机</strong>在之前写过的 《<a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a>》里已经详细介绍过了，就不再说一遍了。<strong>无线接入点</strong>基本可以认为就是个放出 wifi 信号的组件。</p><p>家用路由器下，连着我的 N 台设备，包括手机和电脑，他们的 IP 都有个<strong>共同点</strong>。都是 <code>192.168.31.xx</code> 形式的。其中，我的电脑的 IP 是<code>192.168.31.6</code> ，这个可以通过 <code>ifconfig</code>查到。</p><p>符合这个形式的这些个设备，本质上就是通过各种设备（wifi 或交换机等）接入到<strong>上图路由器的 e2 端口</strong>，他们共同构成一个<strong>局域网</strong>。</p><p>因此，在我家，我们可以<strong>粗暴点</strong>认为只要是 <code>192.168.31.xx</code> 形式的 IP，就是<strong>局域网内的 IP</strong>。否则就是<strong>局域网外的 IP</strong>，比如 <code>192.0.2.2</code> 。</p><br><h3 id="目的-IP-在局域网内"><a href="#目的-IP-在局域网内" class="headerlink" title="目的 IP 在局域网内"></a>目的 IP 在局域网内</h3><p>因为通过 ifconfig 可以查到我的局域网内 IP 是<code>192.168.31.6</code> ，这里<strong>盲猜</strong>末尾+1 是不存在的 IP 。试了下，<code>192.168.31.7</code> 还真不存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 192.168.31.7</span></span><br><span class="line">PING 192.168.31.7 (192.168.31.7): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br><span class="line">Request timeout for icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- 192.168.31.7 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>于是写个程序尝试连这个 IP 。下面的代码是 <code>golang</code> 写的，<strong>大家不看代码也没关系，放出来只是方便大家自己复现的时候用的。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp客户端</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">client, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.31.7:8081&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := os.Stdin.Read(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;input err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">client.Write([]<span class="keyword">byte</span>(input[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := client.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;read err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后尝试抓包。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210619112642833.png" alt="连一个不存在的IP(局域网内)抓包"></p><p>可以发现根本没有三次握手的包，只有一些 ARP 包，在询问“谁是 <code>192.168.31.7</code>，告诉一下 <code>192.168.31.6</code>” 。</p><p>这里有三个问题</p><ul><li>为什么会发 ARP 请求？</li><li>为什么没有 TCP 握手包？</li><li>ARP 本身是没有重试机制的，为什么 ARP 请求会发那么多遍？</li></ul><p>首先我们看下正常情况下执行<code>connect</code>，也就是第一次握手 的流程。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%AD%A3%E5%B8%B8connect%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="正常connect的流程"></p><p>应用层执行<code>connect</code>过后，会通过 socket 层，操作系统接口，进程会从<strong>用户态进入到内核态</strong>，此时进入 <strong>传输层</strong>，因为是<strong>TCP 第一次握手</strong>，会加入<strong>TCP 头</strong>，且置<strong>SYN</strong>标志。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B4%E7%9A%84SYN.png" alt="tcp报头的SYN"></p><p>然后进入<strong>网络层</strong>，我想要连的是 <code>192.168.31.7</code> ，虽然它是我瞎编的，但<strong>IP 头</strong>还是得老老实实把它加进去。</p><p>此时需要重点介绍的是<strong>邻居子系统</strong>，它在<strong>网络层和数据链路层之间</strong>。可以通过<strong>ARP 协议将目的 IP 转为对应的 MAC 地址</strong>，然后<strong>数据链路层</strong>就可以用这个 MAC 地址组装<strong>帧头</strong>。</p><p>我们看下那么<strong>ARP 协议的流程</strong>是</p><p><img src="https://cdn.xiaobaidebug.top/image/ARP%E6%B5%81%E7%A8%8B3.png" alt="ARP流程"></p><p>1.先到本地 ARP 表查一下有没有 <code>192.168.31.7</code> 对应的 <strong>mac 地址</strong>，有的话就返回，这里显然是不可能会有的。</p><blockquote><p>可以通过 arp -a 命令查看本机的 arp 表都记录了哪些信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> arp -a</span></span><br><span class="line">? (192.168.31.1) at 88:c1:97:59:d1:c3 on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:4e:0:1:fb on en0 ifscope permanent [ethernet]</span><br><span class="line">? (239.255.255.250) at 1:0:3e:7f:ff:fb on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure><p>2.看下 <code>192.168.31.7</code> 跟本机 IP <code>192.168.31.6 </code>在不在一个局域网下。如果在的话，就在局域网内发一个 arp 广播，内容就是 前面提到的 “谁是 <code>192.168.31.7</code>，告诉一下 <code>192.168.31.6</code>”。</p><p>3.如果目的 IP 跟本机 IP 不在同一个局域网下，那么会去获取<strong>默认网关的 MAC 地址</strong>，这里就是指获取<strong>家用路由器的 MAC 地址</strong>。然后把消息发给家用路由器，让路由器发到互联网，找到下一跳路由器，一跳一跳的发送数据，<strong>直到把消息发到目的 IP 上，又或者找不到目的地最终被丢弃。</strong></p><p>4.第 2 和第 3 点都是本地没有查到 ARP 缓存记录的情况，这时候会<strong>把 SYN 报文放进一个队列（叫 unresolved_queue）里暂存起来</strong>，然后发起 ARP 请求；等 ARP 层收到 ARP 回应报文之后，会再从缓存中取出 SYN 报文，组装 MAC 帧头，完成刚刚没完成的发送流程。</p><p>如果经过 ARP 流程能正常返回 MAC 地址，那皆大欢喜，直接给<strong>数据链路层</strong>，经过 <code>ring buffer</code> 后传到网卡，发出去。</p><p>但因为现在这个 IP 是瞎编的，因此不可能得到目的地址 MAC ，所以消息也一直没法到数据链路层。<strong>整个流程卡在了 ARP 流程中。</strong></p><p>而<strong>抓包是在数据链路层之后进行的</strong>，因此 TCP 第一次握手的包一直没能抓到，只能抓到为了获得 <code>192.168.31.7</code> 的 MAC 地址的 ARP 请求。</p><blockquote><p>发送数据时，是在经过数据链路层之后的 dev_queue_xmit_nit 方法执行抓包操作的，这是属于网卡驱动层的方法了。</p><p>顺带一提，接收端抓包是在 __netif_receive_skb_core 方法里执行的，也属于网卡驱动层。感兴趣的朋友们可以以这个为关键词搜索相关知识点哈</p></blockquote><p>此时 因为 TCP 协议是可靠的协议，对于 TCP 层来说，第一次握手的消息，已经发出去了，但是一直没有收到 ACK。也不知道消息是出去后是遇到什么事了。为了保证可靠性，它会不断重发。</p><p>而每一次重发，都会因为同样的原因（没有目的 MAC 地址）而尬在了 ARP 那个流程里。因此，才看到好几次重复的 ARP 消息。</p><p>那回到刚刚的三个问题</p><ul><li><p>为什么会发 ARP 请求？</p><p>因为目的地址是瞎编的，本地 ARP 表没有目的机器的 MAC 地址，因此发出 ARP 消息。</p></li><li><p>为什么没有 TCP 握手包？</p><p>因为协议栈的数据到了网络层后，在数据链路层前，就因为没有目的 MAC 地址，没法发出。因此抓包软件抓不到相关数据。</p></li><li><p>为什么 ARP 请求会发那么多遍？</p><p>因为 TCP 协议的可靠性，会重发第一次握手的消息，但每一次都因为没有目的 MAC 地址而失败，每次都会发出 ARP 请求。</p></li></ul><br><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>连一个 IP 不存在的主机时，如果<strong>目的 IP 在局域网内</strong>，则第一次握手会失败，接着不断尝试重发握手的请求。同时，本机会不断发出 ARP 请求，企图获得目的机器的 MAC 地址。并且，因为没能获得目的 MAC 地址，这些 TCP 握手请求最终都发不出去，</p><br><h3 id="目的-IP-在局域网外"><a href="#目的-IP-在局域网外" class="headerlink" title="目的 IP 在局域网外"></a>目的 IP 在局域网外</h3><p>上面提到的是，目的 IP 在<strong>局域网内</strong>的情况，下面讨论目的 IP 在<strong>局域网外</strong>的情况。</p><p>瞎编一个不是 <code>192.168.31.xx</code> 形式的 IP 作为这次要用的局域网外 IP， 比如 <code>10.225.31.11</code>。</p><p>先抓包看一下。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210619111302173.png" alt="连一个不存在的IP(局域网外)抓包"></p><p>这次的现象是能发出 TCP 第一次握手的 <code>SYN包</code>。</p><p>这里有两个问题</p><ul><li>为什么连局域网外的 IP 现象跟连局域网内不一致？</li><li>TCP 第一次握手的重试规律好像不太对？</li></ul><br><h4 id="为什么连局域网外的-IP-现象跟连局域网内不一致？"><a href="#为什么连局域网外的-IP-现象跟连局域网内不一致？" class="headerlink" title="为什么连局域网外的 IP 现象跟连局域网内不一致？"></a>为什么连局域网外的 IP 现象跟连局域网内不一致？</h4><p>这个问题的答案其实在上面 <strong>ARP 的流程</strong>里已经提到过了，如果目的 IP 跟本机 IP 不在同一个局域网下，那么会去获取<strong>默认网关的 MAC 地址</strong>，这里就是指获取<strong>家用路由器的 MAC 地址</strong>。</p><p>此时 ARP 流程成功返回<strong>家用路由器的 MAC 地址</strong>，数据链路层加入帧头，消息通过网卡发到了<strong>家用路由器上</strong>。</p><p>消息会通过互联网一直传递到某个局域网为 <code>10.225.31.xx</code> 的路由器上，那个路由器 发出 ARP 请求，询问他们局域网内的机器有没有叫 <code>10.225.31.11</code>的 （结果当然没有）。</p><p>最终没能发送成功，发送端也就迟迟收不到目的机的第二次握手响应。</p><p>因此触发 TCP 重传。</p><br><h4 id="TCP-第一次握手的重试规律好像不太对？"><a href="#TCP-第一次握手的重试规律好像不太对？" class="headerlink" title="TCP 第一次握手的重试规律好像不太对？"></a>TCP 第一次握手的重试规律好像不太对？</h4><p>在 Linux 中，第一次握手的 <code>SYN</code> 重传次数，是通过 <code>tcp_syn_retries</code> 参数控制的。可以通过下面的方式查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /proc/sys/net/ipv4/tcp_syn_retries</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这里的含义是指 <code>syn重传</code> 会发生 6 次。</p><p>而每次重试都会间隔一定的时间，这里的间隔一般是 1s，2s，4s，8s, 16s, 32s .</p><p><img src="https://cdn.xiaobaidebug.top/image/SYN%E9%87%8D%E4%BC%A0.png" alt="SYN重传"></p><p>而事实上，看我的截图，是先重试 4 次，每次都是 1s，之后才是 1s，2s，4s，8s, 16s, 32s 的重试。</p><p>这跟我们知道的不太一样。</p><p>这个是因为<strong>我用的是 macOS 抓的包，跟 linux 就不是一个系统</strong>，各自的 TCP 协议栈在 sync 重传方面的实现都可能会有一定的差异。</p><p>我还听说 <code>oppo</code> 和 <code>vivo</code> 的 syn 重传 是 0.5s 起步的。而 <code>windows</code> 的 syn 重传 还有自己的专利。</p><p>这些冷知识大家可以不用在意。面试的时候知道 linux 的就够了，剩下的可以用来装逼。毕竟面试官不在意”茴”字到底有几种写法。</p><br><h2 id="连-IP-地址存在但端口号不存在的主机的握手过程"><a href="#连-IP-地址存在但端口号不存在的主机的握手过程" class="headerlink" title="连 IP 地址存在但端口号不存在的主机的握手过程"></a>连 IP 地址存在但端口号不存在的主机的握手过程</h2><p>前面提到的是 IP 地址压根就不存在的情况。假如<strong>IP 地址存在但端口号是瞎编的</strong>呢？</p><h3 id="目的-IP-是回环地址"><a href="#目的-IP-是回环地址" class="headerlink" title="目的 IP 是回环地址"></a>目的 IP 是回环地址</h3><p><img src="https://cdn.xiaobaidebug.top/image/image-20210627090037348.png" alt="连回环地址，端口不存在抓包"></p><p>现象也比较简单，已经 IP 地址是存在的，也就是在互联网中这个机器是存在的。</p><p>那么我们可以正常发消息到目的 IP，因为对应的 MAC 地址和 IP 都是正确的，所以，数据从数据链路层到网络层都很 OK。</p><p>直到传输层，TCP 协议在识别到这个端口号对应的进程根本不存在时，就会把数据丢弃，响应一个 RST 消息给发送端。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%BF%9E%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E6%97%B6%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="连回环地址时端口不存在"></p><br><h4 id="RST-是什么？"><a href="#RST-是什么？" class="headerlink" title="RST 是什么？"></a>RST 是什么？</h4><p>我们都是到 TCP 正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它在 TCP 包头中，在收到置了这个标志位的数据包后，连接就会被关闭，此时接收到 RST 的一方，一般会看到一个 <code>connection reset</code> 或 <code>connection refused</code> 的报错。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B4RST%E4%BD%8D.png" alt="TCP报头RST位"></p><br><h3 id="目的-IP-在局域网内-1"><a href="#目的-IP-在局域网内-1" class="headerlink" title="目的 IP 在局域网内"></a>目的 IP 在局域网内</h3><p>刚刚提到我的本机 IP 是 <code>192.168.31.6</code> ，局域网内有台 <code>192.168.31.1</code> 。同样尝试连一个不存在的端口。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210619113503022.png" alt="连存在的局域网内IP，端口不存在抓包"></p><p>此时现象跟前者一致。</p><p>唯一不同的是，前者是回环地址，RST 数据是从本机的传输层返回的。而这次的情况，RST 数据是从目的机器的传输层返回的。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%BF%9E%E5%A4%96%E7%BD%91%E5%9C%B0%E5%9D%80%E6%97%B6%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="连外网地址时端口不存在"></p><br><h3 id="目的-IP-在局域网外-1"><a href="#目的-IP-在局域网外-1" class="headerlink" title="目的 IP 在局域网外"></a>目的 IP 在局域网外</h3><p>找一个存在的外网 ip，这里我拿了<strong>最近刚白嫖的阿里云服务器</strong>地址 <code> 47.102.221.141</code> 。（炫耀）</p><p>进行连接连接，发现与前面两种情况是一致的，目的机器在收到我的请求后，立马就通过 <strong>RST 标志位</strong> 断开了这次的连接。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210619182034584.png" alt="连存在的局域网外IP，端口不存在抓包"></p><p>这一点跟前面两种情况一致。</p><p>熟悉小白的朋友们都知道，每次搞事情做测试，都会用 <code>baidu.com</code> 。</p><p>这次也不例外，ping 一下 <code>baidu.com</code> ,获得它的 <code>IP: 220.181.38.148</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping baidu.com</span></span><br><span class="line">PING baidu.com (220.181.38.148): 56 data bytes</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=0 ttl=48 time=35.728 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=1 ttl=48 time=38.052 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=2 ttl=48 time=37.845 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=3 ttl=48 time=37.210 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=4 ttl=48 time=38.402 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=5 ttl=48 time=37.692 ms</span><br><span class="line">^C</span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">6 packets transmitted, 6 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 35.728/37.488/38.402/0.866 ms</span><br></pre></td></tr></table></figure><p>发消息到给百度域名背后的 IP，且瞎随机指定一个端口 <strong>8080</strong>， 抓包。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210619084158238.png" alt="连baidu，端口不存在抓包"></p><p>现象却不一致。没有 <code>RST</code> 。而且触发了第一次握手的重试消息。这是为什么？</p><p>这是因为 baidu 的机器，作为线上生产的机器，会设置一系列安全策略，比如只对外暴露某些端口，除此之外的端口，都一律拒绝。</p><p>所以很多发到 8080 端口的消息都<strong>在防火墙这一层就被拒绝掉了</strong>，根本到不了目的主机里，而<strong>RST 是在目的主机的 TCP/IP 协议栈里发出</strong>的，都还没到这一层，就更不可能发 RST 了。因此发送端发现消息没有回应（因为被防火墙丢了），就会重传。所以才会出现上述抓包里的现象。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5.png" alt="防火墙安全策略"></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连一个 IP 不存在的主机时</p><ul><li><p>如果 IP 在局域网内，会发送 N 次 ARP 请求获得目的主机的 MAC 地址，同时不能发出 TCP 握手消息。</p></li><li><p>如果 IP 在局域网外，会将消息通过路由器发出，但因为最终找不到目的地，触发 TCP 重试流程。</p></li></ul><p>连 IP 地址存在但端口号不存在的主机时</p><ul><li><p>不管目的 IP 是回环地址还是局域网内外的 IP 地址，目的主机的传输层都会在收到握手消息后，发现端口不正确，发出 RST 消息断开连接。</p></li><li><p>当然如果目的机器设置了防火墙策略，限制他人将消息发到不对外暴露的端口，那么这种情况，发送端就会不断重试第一次握手。</p></li></ul><p>最后留个问题，连一个 <strong>不存在的局域网外 IP</strong>的主机时，我们可以看到 TCP 的重发规律是：开始时，每隔 1s 重发五次 <code>TCP SYN</code>消息，接着 2s,4s,8s,16s,32s 都重发一次；</p><p>对比连一个 <strong>不存在的局域网内 IP</strong>的主机时，却是每隔 1s 重发了 4 次<code>ARP请求</code>，接着过了 32s 后才再发出一次 ARP 请求。已知 ARP 请求是没有重传机制的，它的重试就是 TCP 重试触发的，但两者规律不一致，是为什么？</p><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（**<del>卑微</del>疯狂暗示，拜托拜托，这对我真的很重要！**）</p><p><img src="https://cdn.xiaobaidebug.top/image/12051625633785_.pic.jpg"></p><p>我是小白，我们下期见。</p><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？</title>
      <link href="/2021/06/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%96%AD%E7%BD%91%E4%BA%86%EF%BC%8C%E8%BF%98%E8%83%BDping%E9%80%9A%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
      <url>/2021/06/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%96%AD%E7%BD%91%E4%BA%86%EF%BC%8C%E8%BF%98%E8%83%BDping%E9%80%9A%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>首发于个人公众号：小白 debug<br>原文地址：<a href="https://mp.weixin.qq.com/s/XsZYiLxZ0AXjVMBgWCnmzw">硬核图解！断网了，还能 ping 通 127.0.0.1 吗？为什么？</a></p><p>你<strong>女神爱不爱你</strong>，你问她，她可能不会告诉你。</p><p>但<strong>网通不通</strong>，你 <code>ping</code> 一下就知道了。</p><span id="more"></span><p>可能看到标题，你就知道答案了，但是你了解背后的原因吗？那如果把 <code>127.0.0.1</code> 换成 <code>0.0.0.0</code> 或 <code>localhost</code> 会怎么样呢？ 你知道这几个<code>IP</code>有什么区别吗？</p><p>以前面试的时候就遇到过这个问题，大家看个动图了解下面试官和我当时的场景，求当时小白的心里阴影面积。</p><p><img src="https://cdn.xiaobaidebug.top/image/cache_1623425479_3538.gif"></p><p>话不多说，我们直接开车。</p><p>拔掉网线，断网。</p><p><img src="https://cdn.xiaobaidebug.top/image/006WD51tly1fxvyqnfervj308c08c3yo.jpg"></p><p>然后在控制台输入<code> ping 127.0.0.1</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 127.0.0.1</span></span><br><span class="line">PING 127.0.0.1 (127.0.0.1): 56 data bytes</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.079 ms</span><br><span class="line">^C</span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.074/0.081/0.093/0.006 ms</span><br></pre></td></tr></table></figure><p>说明，拔了网线，<code>ping 127.0.0.1</code> 是<strong>能 ping 通的</strong>。</p><p>其实这篇文章看到这里，标题前半个问题已经被回答了。但是我们可以再想深一点。</p><p>为什么断网了还能 <code>ping</code> 通 <code> 127.0.0.1</code> 呢？</p><p><strong>这能说明你不用交网费就能上网吗？</strong></p><p><strong>不能。</strong></p><p>首先我们需要进入基础科普环节。</p><p>不懂的同学看了就懂了，懂的看了就当查漏补缺吧。</p><h3 id="什么是-127-0-0-1"><a href="#什么是-127-0-0-1" class="headerlink" title="什么是 127.0.0.1"></a>什么是 127.0.0.1</h3><p>首先，这是个 <code>IPV4</code> 地址。</p><p><code>IPV4</code> 地址有 <code>32</code> 位，一个字节有 <code>8</code> 位，共 <code>4</code> 个字节。</p><p>其中<strong>127 开头的都属于回环地址</strong>，也是 <code>IPV4</code> 的特殊地址，没什么道理，就是人为规定的。</p><p>而<code>127.0.0.1</code>是<strong>众多</strong>回环地址中的一个。之所以不是 <code>127.0.0.2</code> ，而是 <code>127.0.0.1</code>，是因为源码里就是这么定义的，也没什么道理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Address to loopback in software to local host.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>INADDR_LOOPBACK0x7f000001<span class="comment">/* 127.0.0.1   */</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="回环地址"></p><p><code>IPv4</code> 的地址是 <code>32</code> 位的，2 的 32 次方，大概是<code>40+亿</code>。地球光人口就 76 亿了，40 亿 IP 这点量，<strong>塞牙缝都不够</strong>，实际上<strong>IP 也确实用完</strong>了。</p><p>所以就有了<code>IPV6</code>， <code>IPv6</code> 的地址是 <code>128</code> 位的，大概是 2 的 128 次方 ≈<strong>10 的 38 次方</strong>。据说地球的沙子数量大概是 <strong>10 的 23 次方</strong>，所以 IPV6 的 IP 可以认为用不完。</p><p>IPV4 以 8 位一组，每组之间用 <strong>.</strong> 号隔开。</p><p>IPV6 就以 16 位为一组，每组之间用 <strong>:</strong> 号隔开。如果全是 0，那么可以省略不写。</p><p><img src="https://cdn.xiaobaidebug.top/image/ipv6%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="ipv6回环地址"></p><p>在 IPV4 下的回环地址是 <code>127.0.0.1</code>，在<code>IPV6</code>下，表达为 <code>::1</code> 。中间把<strong>连续的 0</strong>给省略了，之所以不是<strong>7 个 冒号</strong>，而是<strong>2 个冒号:</strong> ， 是因为一个 IPV6 地址中<strong>只允许出现⼀次两个连续的冒号</strong>。</p><blockquote><p>多说一句： 在 IPV4 下用的是 <strong>ping 127.0.0.1</strong> 命令。 在 IPV6 下用的是 <strong>ping6 ::1</strong> 命令。</p></blockquote><h3 id="什么是-ping"><a href="#什么是-ping" class="headerlink" title="什么是 ping"></a>什么是 ping</h3><p>ping 是应用层命令，可以理解为它跟游戏或者聊天软件属于同一层。只不过聊天软件可以收发消息，还能点个赞什么的，有很多复杂的功能。而 ping 作为一个小软件，它的功能比较简单，就是<strong>尝试</strong>发送一个小小的消息到目标机器上，判断目的机器是否<strong>可达</strong>，其实也就是判断目标机器网络是否能连通。</p><p>ping 应用的底层，用的是网络层的<strong>ICMP 协议</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/IP%E5%92%8CICMP%E5%92%8CPing%E6%89%80%E5%9C%A8%E5%88%86%E5%B1%82.png" alt="IP和ICMP和Ping所在分层"></p><p>虽然 ICMP 协议和 IP 协议<strong>都属于网络层协议</strong>，但其实<strong>ICMP 也是利用了 IP 协议进行消息的传输</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/ip%E5%92%8Cicmp%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="ip和icmp的关系"></p><p>所以，大家在这里完全可以简单的理解为 ping 某个 IP 就是往某个 IP 地址发个消息。</p><h3 id="TCP-发数据和-ping-的区别"><a href="#TCP-发数据和-ping-的区别" class="headerlink" title="TCP 发数据和 ping 的区别"></a>TCP 发数据和 ping 的区别</h3><p>一般情况下，我们会使用 TCP 进行网络数据传输，那么我们可以看下它和 ping 的区别。</p><p><img src="https://cdn.xiaobaidebug.top/image/ping%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%B3%E7%B3%BB2.png" alt="ping和普通发消息的关系"></p><p>ping 和其他应用层软件都属于<strong>应用层</strong>。</p><p>那么我们横向对比一下，比方说聊天软件，如果用的是 TCP 的方式去发送消息。</p><p>为了发送消息，那就得先知道往哪发。linux 里万物皆文件，那你要发消息的目的地，也是个文件，这里就引出了 socket 的概念。</p><p>要使用 <code>socket</code> , 那么首先需要创建它。</p><p>在 TCP 传输中创建的方式是 <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 <strong>host:port</strong> 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，<strong>工作在传输层</strong>。</p><p>创建好了 <code>socket</code> 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从<strong>用户态进入到内核态</strong>，最后会调用到 <code>sock_sendmsg</code> 方法。</p><p>然后进入传输层，带上<code>TCP</code>头。网络层带上<code>IP</code>头，数据链路层带上 <code>MAC</code>头等一系列操作后。进入网卡的<strong>发送队列 ring buffer</strong> ，顺着网卡就发出去了。</p><p>回到 <code>ping</code> ， 整个过程也基本跟 <code>TCP</code> 发数据类似，差异的地方主要在于，创建 <code>socket</code> 的时候用的是 <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，<strong>工作在网络层</strong>， 所以构建<code>ICMP</code>（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的 <code>sock_sendmsg</code> 方法，进入到网络层后加上<strong>ICMP 和 IP 头</strong>后，数据链路层加上<strong>MAC 头</strong>，也是顺着网卡发出。因此 本质上 ping 跟 普通应用发消息 在程序流程上没太大差别。</p><p>这也解释了<strong>为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能 ping 通吗？</strong>因为可以简单理解为 ping 就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。</p><h3 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h3><p>前面提到，有网的情况下，ping 最后是<strong>通过网卡</strong>将数据发送出去的。</p><p>那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。</p><p><img src="https://cdn.xiaobaidebug.top/image/ping%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="ping回环地址"></p><p>从应用层到传输层再到网络层。这段路径跟 ping 外网的时候是几乎是一样的。到了网络层，系统会根据目的 IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现<strong>目标 IP 是外网 IP</strong>时，会从”真网卡”发出。</p><p>当发现<strong>目标 IP 是回环地址</strong>时，就会选择<strong>本地网卡</strong>。</p><p>本地网卡，其实就是个**”假网卡”<strong>，它不像”真网卡”那样有个<code>ring buffer</code>什么的，”假网卡”会把数据推到一个叫 <code> input_pkt_queue</code> 的 <strong>链表</strong> 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个</strong>软中断**。</p><p>专门处理软中断的工具人**”ksoftirqd”** （这是个<strong>内核线程</strong>），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%B7%A5%E5%85%B7%E4%BA%BAksoftirqd.png" alt="工具人ksoftirqd"></p><p>ping 回环地址和<strong>通过 TCP 等各种协议发送数据到回环地址</strong>都是走这条路径。整条路径从发到收，都没有经过”真网卡”。<strong>之所以 127.0.0.1 叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，在本机打个转就又回来了。</strong>所以断网，依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><h3 id="ping-回环地址和-ping-本机地址有什么区别"><a href="#ping-回环地址和-ping-本机地址有什么区别" class="headerlink" title="ping 回环地址和 ping 本机地址有什么区别"></a>ping 回环地址和 ping 本机地址有什么区别</h3><p>我们在 mac 里执行 <code>ifconfig</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">inet 127.0.0.1 netmask 0xff000000</span><br><span class="line">...</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">inet 192.168.31.6 netmask 0xffffff00 broadcast 192.168.31.255</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>能看到 <strong>lo0</strong>，表示本地回环接口，对应的地址，就是我们前面提到的 <strong>127.0.0.1</strong> ，也就是<strong>回环地址</strong>。</p><p>和 <strong>eth0</strong>，表示本机第一块网卡，对应的 IP 地址是<strong>192.168.31.6</strong>，管它叫<strong>本机 IP</strong>。</p><p>之前一直认为 ping 本机 IP 的话会通过”真网卡”出去，然后遇到第一个路由器，再发回来到本机。</p><p>为了验证这个说法，可以进行抓包，但结果跟上面的说法并不相同。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210611225434437.png" alt="ping 127.0.0.1"></p><br><p><img src="https://cdn.xiaobaidebug.top/image/image-20210611225140197.png" alt="ping 本机地址"></p><p>可以看到 ping 本机 IP 跟 ping 回环地址一样，相关的网络数据，都是走的 <strong>lo0</strong>，本地回环接口，也就是前面提到的**”假网卡”**。</p><p>只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping 回环地址和 ping 本机地址没有区别</strong>。</p><h3 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h3><p>回到文章开头动图里的提问，算是面试八股文里的老常客了。</p><p>以前第一次用 <code>nginx</code> 的时候，发现用这几个 <code>IP</code>，都能正常访问到 <code>nginx</code> 的欢迎网页。一度认为这几个 <code>IP</code> 都是一样的。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210530190253656.png" alt="访问127.0.0.1:80"></p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210530190335350.png" alt="访问localhost:80"></p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210530190410662.png" alt="访问0.0.0.0:80"></p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210530191958500.png" alt="访问本机的IP地址"></p><p>但本质上还是有些区别的。</p><p>首先 <code>localhost</code> 就不叫 <code>IP</code>，它是一个域名，就跟 <code>&quot;baidu.com&quot;</code>,是一个形式的东西，只不过默认会把它解析为 <code>127.0.0.1</code> ，当然这可以在 <code>/etc/hosts</code> 文件下进行修改。</p><p>所以默认情况下，使用 <code>localhost</code> 跟使用 <code>127.0.0.1</code> 确实是没区别的。</p><p>其次就是 <code>0.0.0.0</code>，执行 ping 0.0.0.0 ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 0.0.0.0</span></span><br><span class="line">PING 0.0.0.0 (0.0.0.0): 56 data bytes</span><br><span class="line">ping: sendto: No route to host</span><br><span class="line">ping: sendto: No route to host</span><br></pre></td></tr></table></figure><p>但它还是很有用处的，回想下，我们启动服务器的时候，一般会 <code>listen</code> 一个 IP 和端口，等待客户端的连接。</p><p>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> , 那么它表示本机上的<strong>所有 IPV4 地址</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Address to accept any incoming messages. */</span><br><span class="line"><span class="meta">#</span><span class="bash">defineINADDR_ANY((unsigned long int) 0x00000000) /* 0.0.0.0   */</span></span><br></pre></td></tr></table></figure><p>举个例子。刚刚提到的 <code>127.0.0.1</code> 和 <code>192.168.31.6</code> ，都是本机的 IPV4 地址，如果监听 <code>0.0.0.0</code> ，那么用上面两个地址，都能访问到这个服务器。</p><p>当然， 客户端 <code>connect</code> 时，不能使用 <code>0.0.0.0</code> 。必须指明要连接哪个服务器 IP。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</p></li><li><p><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</p></li><li><p>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近工作上的事情太忙，本来就黑的黑眼圈，就更黑了，鸽了大家这么久实在不好意思哈。</p><p>这篇文章里，有几张大图本来都是动图，但是发现动起来之后发现字太小，点开来放大之后图又不会动了。有些影响体验，我就先改成静态图吧。</p><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《127.0.0.1 之本机网络通信过程知多少 ?！》—— 推荐关注飞哥的《开发内功修炼》</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/VLHCu6b5Anx8HEj_gQZfOg">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！GMP模型里为什么要有P？背后的原因让人暖心</title>
      <link href="/2021/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P/"/>
      <url>/2021/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><h3 id="GM-模型是什么"><a href="#GM-模型是什么" class="headerlink" title="GM 模型是什么"></a>GM 模型是什么</h3><p><img src="https://cdn.xiaobaidebug.top/image/GM%E5%9B%BE.png" alt="GM图"></p><p>在 <code>Go 1.1</code>版本之前，其实用的就是<code>GM</code>模型。</p><span id="more"></span><ul><li><p><strong>G</strong>，协程。通常在代码里用 <code>go</code> 关键字执行一个方法，那么就等于起了一个<code>G</code>。</p></li><li><p><strong>M</strong>，<strong>内核</strong>线程，操作系统内核其实看不见<code>G</code>和<code>P</code>，只知道自己在执行一个线程。<code>G</code>和<code>P</code>都是在<strong>用户层</strong>上的实现。</p></li></ul><p>除了<code>G</code>和<code>M</code>以外，还有一个<strong>全局协程队列</strong>，这个全局队列里放的是多个处于<strong>可运行状态</strong>的<code>G</code>。<code>M</code>如果想要获取<code>G</code>，就需要访问一个<strong>全局队列</strong>。同时，内核线程<code>M</code>是可以同时存在多个的，因此访问时还需要考虑<strong>并发</strong>安全问题。因此这个全局队列有一把<strong>全局的大锁</strong>，每次访问都需要去获取这把大锁。</p><p>并发量小的时候还好，当并发量大了，这把大锁，就成为了<strong>性能瓶颈</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/GM%E6%A8%A1%E5%9E%8B.gif" alt="GM模型"></p><h3 id="GMP-模型是什么"><a href="#GMP-模型是什么" class="headerlink" title="GMP 模型是什么"></a>GMP 模型是什么</h3><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E5%9B%BE.png" alt="GMP图"></p><p>基于<strong>没有什么是加一个中间层不能解决的</strong>思路，<code>golang</code>在原有的<code>GM</code>模型的基础上加入了一个调度器<code>P</code>，可以简单理解为是在<code>G</code>和<code>M</code>中间加了个中间层。</p><p>于是就有了现在的<code>GMP</code>模型里。</p><ul><li><p><code>P</code> 的加入，还带来了一个<strong>本地协程队列</strong>，跟前面提到的<strong>全局队列</strong>类似，也是用于存放<code>G</code>，想要获取等待运行的<code>G</code>，会<strong>优先</strong>从本地队列里拿，访问本地队列无需加锁。而全局协程队列依然是存在的，但是功能被弱化，不到<strong>万不得已</strong>是不会去全局队列里拿<code>G</code>的。</p></li><li><p><code>GM</code>模型里 M 想要运行<code>G</code>，直接去全局队列里拿就行了；<code>GMP</code>模型里，<code>M</code>想要运行<code>G</code>，就得先获取<code>P</code>，然后从 <code>P</code> 的本地队列获取 <code>G</code>。</p></li></ul><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E6%A8%A1%E5%9E%8B1.gif" alt="GMP模型"></p><ul><li><p>新建 <code>G</code> 时，新<code>G</code>会优先加入到 <code>P</code> 的本地队列；如果本地队列满了，则会把本地队列中一半的 <code>G</code> 移动到全局队列。</p></li><li><p><code>P</code> 的本地队列为空时，就从全局队列里去取。</p></li></ul><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E6%A8%A1%E5%9E%8B-%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E5%8D%8F%E7%A8%8B%E9%98%9F%E5%88%97.gif" alt="GMP模型-获取全局协程队列"></p><ul><li>如果全局队列为空时，<code>M</code> 会从其他 <code>P</code> 的本地队列<strong>偷（stealing）一半 G</strong>放到自己 <code>P</code> 的本地队列。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E6%A8%A1%E5%9E%8B-stealing2.gif" alt="GMP模型-stealing"></p><ul><li><code>M</code> 运行 <code>G</code>，<code>G</code> 执行之后，<code>M</code> 会从 <code>P</code> 获取下一个 <code>G</code>，不断重复下去。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/GMP%E6%A8%A1%E5%9E%8B4.gif" alt="GMP模型-循环执行"></p><h3 id="为什么-P-的逻辑不直接加在-M-上"><a href="#为什么-P-的逻辑不直接加在-M-上" class="headerlink" title="为什么 P 的逻辑不直接加在 M 上"></a>为什么 P 的逻辑不直接加在 M 上</h3><p>主要还是因为<code>M</code>其实是<strong>内核</strong>线程，内核只知道自己在跑线程，而<code>golang</code>的运行时（包括调度，垃圾回收等）其实都是<strong>用户空间</strong>里的逻辑。操作系统内核哪里还知道，也不需要知道用户空间的 golang 应用原来还有那么多花花肠子。这一切逻辑交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适啊。</p><blockquote><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p></blockquote><p>我是小白，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]《Golang 调度器 GMP 原理与调度全分析》 ——Aceld :<a href="https://learnku.com/articles/41728">https://learnku.com/articles/41728</a></p><p>[2]《GMP 模型为什么要有 P》 ——煎鱼 :<a href="https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw">https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw</a></p><p>[3]《深度解密 Go 语言之 Scheduler》 ——qcrao :<a href="https://qcrao.com/2019/09/02/dive-into-go-scheduler/#%E4%BB%80%E4%B9%88%E6%98%AF-scheduler">https://qcrao.com/2019/09/02/dive-into-go-scheduler/#%E4%BB%80%E4%B9%88%E6%98%AF-scheduler</a></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></li><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></li></ul><h6 id="别说了，关注公众号-【小白-debug】，一起在知识的海洋里呛水吧"><a href="#别说了，关注公众号-【小白-debug】，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，关注公众号:【小白 debug】，一起在知识的海洋里呛水吧"></a>别说了，关注公众号:【小白 debug】，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我感觉，我可能要拿图灵奖了。。。</title>
      <link href="/2021/06/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%88%91%E6%84%9F%E8%A7%89%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8B%BF%E5%9B%BE%E7%81%B5%E5%A5%96%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/"/>
      <url>/2021/06/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%88%91%E6%84%9F%E8%A7%89%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8B%BF%E5%9B%BE%E7%81%B5%E5%A5%96%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>是的，这个是<strong>标题党</strong>。</p><p>事情是这样的，最近在<code>zhihu</code>上回答了一个问题。一夜之间拿到了<code>900+</code>赞，让我相当震惊。</p><span id="more"></span><p><img src="https://cdn.xiaobaidebug.top/image/image-20210413074107762.png"></p><p>实话说，就是个抖机灵的回答。不知道是不是命中了什么推荐规则。没想到打开手机突然发现<code>99+</code>的信息，一时之间有些蒙圈。</p><p>打开评论，也是相当有趣哈哈哈。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210413074228059.png"></p><p>在知乎划水这么久，第一次遇到这种场面，纪念下。</p><p>但说说心里话。</p><p>既开心又难过。</p><p>开心是因为能获得那么多赞，刷新一下手机就立马十多个赞，太爽太快乐了。</p><p>难过是因为<strong>之前辛辛苦苦花了好长时间写的文章，加一起点赞都不及随便抖机灵的答案。</strong>果然大家还是比较喜欢轻松快乐的东西，学习是反人性的。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210412132121144.png"></p><p>那么多赞还发牢骚，这大概就是所谓的得了便宜还卖乖吧哈哈哈哈。</p><p>对，说的就是我这种情况。</p><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1go727k3ckzj30dw0dw41u.jpg"></p><p>一码归一码，虽然几乎没有涨粉，但能得到这么大的流量，总的来说还是很开心的。</p><p>另外想问下，有大佬知道知乎是什么样一个推荐规则吗？我还想看到<code>99+</code>小红点。。。</p><p>还有有什么可以从<code>zhihu</code>回答引流到<code>【g】【zong】【hao】</code> 的小技巧吗？感觉自己这个门外汉白瞎了这波流量。。。。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210413073559386.png"></p><p>最近看了巨人的漫画大结局，很难受，追了8年了，以前每个月等更新，现在突然感觉生活少了点盼头。巨人的结局影响了我写文的速度，但是，下一篇已经在路上了。。。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210413072037873.png"></p><blockquote><p>首发于个人公众号：小白debug<br>原文地址：<a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA</a></p></blockquote><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>读者提问：你听说过pip协议吗？该不该签？</title>
      <link href="/2021/05/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BD%A0%E5%81%9A%E7%9A%84%E8%BF%99%E4%B8%AA%E4%BA%8B%E6%83%85%EF%BC%8C%E4%B8%9A%E5%8A%A1%E4%BB%B7%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2021/05/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BD%A0%E5%81%9A%E7%9A%84%E8%BF%99%E4%B8%AA%E4%BA%8B%E6%83%85%EF%BC%8C%E4%B8%9A%E5%8A%A1%E4%BB%B7%E5%80%BC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif"></p><br><p>我们先来聊聊你这大半年都做了哪些事情吧。</p><br><p>你做的这个事情，业务价值是什么？</p><br><p>那你了解这个事情对业务的收益是什么吗？</p><br><p>你了解后续业务规划是怎么样的吗？</p><br><p>你对业务的规划有什么自己的想法吗？</p><br><p>ok，看得出来你对业务的收益和规划都比较清晰，所以你完成了这些需求，也取得了不少结果。</p><p>但这是业务需求本身的价值，<strong>你正好分到了一个容易取得结果的需求</strong>，但这是业务属性决定的，你不能说 A 需求业务价值比 B 需求更容易拿到结果，其他同事碰巧拿到了 B 需求，而你拿到了 A 需求，<strong>大家一样努力，就否定 B 同事的付出，对吧？</strong></p><p>所以我就想问你，<strong>除了业务本身的价值以外，你还为业务提供了哪些额外的价值？</strong></p><br><p>嗯嗯，这其实也是为了完成业务需求做的事情，还有其他例子可以举证的吗？</p><br><p>那这些事情有落地吗？取得什么成果了吗？<strong>我比较关注有哪些结果落地了</strong>。</p><br><p>另外，你在这段时间里，<strong>你有没有觉得自己哪些事情做的不够好的？</strong></p><br><p><strong>那还有其他觉得做的不好的点吗？</strong></p><br><p>我看了一下，我发现你的<strong>bug 比较多</strong>。这一点你有意识到吗？</p><br><p>嗯嗯，我知道，你确实没有造成过任何一次线上事故，所有的 bug 都是提测期间出现的。</p><p>我理解这其实是你的代码提测质量比较差？</p><br><p>嗯嗯，我明白，分配给你的需求确实不少，从产出上来看确实也不错。<strong>但我们在分配活的时候，都是根据每个人的能力模型来进行分配的，我们分配给你这么多活，说明我们是认为你的能力可以 cover 住的</strong>。如果你觉得吃力，我觉得你应该及早提醒我们，让我们降低对你的预期和调整你的工作安排，如果你需要支持但却没有主动来沟通，我理解这是<strong>沟通能力不足的表现</strong>。</p><br><p>Ok，那我可以认为你是认可自己的能力可以胜任这些工作的，所以我们是拉平了这条<strong>比较的线</strong>的。所以对每一个同事其实都是公平的。但有些同事，比如 xxx，就在完成了业务开发的同时，还做了 xxx 的事情。而你在完成需求以外，我看不到为业务和团队提供更多的价值，并且提测质量也不太理想，<strong>这一点不太符合预期</strong>。</p><br><p>另外，你是否了解组内其他开发目前做的事情吗？</p><br><p>嗯那你了解他们做的业务会对你做的事情带来什么收益吗？</p><br><p>ok，看来你对整个项目组做的事情了解的并不是很全面啊，你可能需要提升一下大局观，你可以尝试一下，跳上一个台阶去看下我们下一步的规划，而<strong>不是只盯着自己在做的事情</strong>。</p><br><p>而且从你对自己接下来的做的事情的规划上来看，你打算深钻这个领域，这点我觉得 ROI 可能有点低了，这说句不好听，其实叫<strong>钻牛角尖</strong>，我觉得你如果完成手上的业务需求，可以把时间投入到组里其他项目中，去拿到更多的结果。</p><br><p>所以综合以上这些考虑，我这次给你的绩效是 xxx，我知道这可能让你有些意外，但我这边结合上面说的事情给你列出几个点，希望能引起你的反思。balabala。我想问问你是否认可。</p><br><p>不不不，你不要闷着，也不需要情绪化，你如果有什么想法，完全可以说出来，我们坦诚的交流。</p><br><p>一个人最可贵的品质其实是他能虚心的接受他人的意见，我举一些身边的例子。balablabala。所以你现在再对齐到你自己的情况上，你是否有做到？</p><br><p>没错，你确实可能做到了这些点，但是我们在招你进来的时候，我们对你有更高的期望，我希望你不仅仅只是做到上面这些点。</p><p>而且我个人也非常关注你，我发现你是个有着 xxx 优秀品质的人，我甚至在你身上看到了以前的自己。<strong>但是</strong>我现在重新审视过去的自己，就会发现，自己有 xxx 的不足，你想一下，你是不是也跟曾经的我一样，犯了这些错误？</p><br><p>嗯嗯，我能走到今天这个位置，那当然说明我在这方面比你有经验，至少是个前辈。所以<strong>我希望能帮助你变得更好</strong>。我也有信心有能力能帮助到你。</p><p>我也知道你非常关注自己的技术能力成长，这起码说明你是个很上进的人，我也知道你其实是个很有想法的人，我想听听你的想法。</p><br><p><strong>看来你已经意识到自己的问题了，你对自己的问题有复盘过吗？你有没有总结出什么方法论吗？是不是可以将这些事情落地为一套 SOP？</strong></p><p><strong>那你告诉我，接下来你将怎么做，做哪些事情，怎么样才能避免下一次还犯这样的错误？</strong></p><br><p>我给你立个标杆吧，你身边有的同事 xxx，他 balablabala，最后取得了 balabla 的结果，所以说你也应该向他一样。你希望能变成和他一样的人吗？</p><br><p>好的，接下来为了让你变得更好，我会跟你一起制定一套改进方案 pip (performance improve plan) ，针对你的问题和痛点，给出解决方法，并且帮助你在一定的时间内能变得更好。我其实一直很相信你的能力，我相信只要你认真执行，一定可以变得更好，如果你还能在这个过程中<strong>沉淀出一套方案论</strong>，并且将这个方法论带给身边的同事，让身边的同事也变得更好，这就是大大超出预期的成果，那下次一定能拿到好的绩效。你认可吗？</p><p><img src="https://cdn.xiaobaidebug.top/pip%E5%8D%8F%E8%AE%AE.png" alt="pip协议"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>以上内容，均来自于一些读者的想象，我只负责整理。并不是读者的亲身经历。完全不是。现实中也完全不可能会有这样的人。</strong></p><p>如有雷同……不，不可能有雷同。</p><p>很多读者可能没听说过 pip，它其实是一份协议，也<strong>有人说过</strong>这是<strong>认罪/劝退协议书</strong>，原则上它会规定你在一定的时间内完成某些任务，如果你签了，就相当于承认自己有问题，如果你最后未能达到要求，就会以能力不足为由被辞退。</p><p>那个人还说过：”N+1？没有的啊，你忘了你自己承认自己不能胜任工作了吗。”</p><p>当然，<strong>说这个话的人，肯定是瞎说，大家不要信。</strong>我不信，狗也不信。</p><p>就我知道的情况来看，很多工作了三五年的老哥，做了几年才发现原来他们能力不足，需要做 pip 计划，也不知道为啥，虽然他们表面看起来能力出色，工作也做的很好，但可能是他们都是在演戏吧。<strong>我谴责他们没有好好工作。</strong></p><p>让你签 pip 的人<strong>怎么可能</strong>只是想找个理由裁员呢，他当然只是希望你变得更好而已。<strong>请大家不要恶意揣测任何人。</strong></p><br><p>但不得不说，从对话里你可以看出，这里面其实涉及到非常多的谈判技巧，既有<strong>推</strong>也有<strong>拉</strong>，俗称<strong>打一巴掌给颗糖，再打巴掌再给糖</strong>。你能在里面看到几个这样的小技巧？你又能在这样的对话下抗住几个回合？</p><p><strong>如果你还遇到过什么有意思的犬话，我们评论区见啊。</strong></p><p>如果你遇到了 pip，那你加我微信，我有一个<strong>不成熟的小建议</strong>。</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我本是某科技公司 ceo<br>权力被架空<br>股份被清空<br>现在<br>我只想夺回我的公司<br>现在只差一个 <strong>你的点赞和在看</strong><br>我就能东山再起<br><strong>点击关注《小白 debug》</strong> ，我有一套详细的复仇计划等待实施</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！既然IP层会分片，为什么TCP层也还要分段？</title>
      <link href="/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/"/>
      <url>/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/%E7%9B%AE%E5%BD%95.png"></p><h3 id="什么是-TCP-分段和-IP-分片"><a href="#什么是-TCP-分段和-IP-分片" class="headerlink" title="什么是 TCP 分段和 IP 分片"></a>什么是 TCP 分段和 IP 分片</h3><p>我们知道网络就像一根管子，而管子吧，就会有粗细。</p><p>一个数据包想从管子的一端到另一端，得过这个管子。<del>（废话）</del></p><p>但数据包的量<strong>有大有小</strong>，想过管子，数据包不能大于这根管子的粗细。</p><p>问题来了，数据包过大时怎么办？</p><span id="more"></span><p>答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%872.png" alt="数据分片"></p><p>回去看下网络分层协议，数据先过传输层，再到网络层。</p><p>这个行为在<strong>传输层和网络层</strong>都有可能发生。</p><p>在传输层（<code>TCP</code>协议）里，叫<strong>分段</strong>。</p><p>在网络层（<code>IP</code>层），叫<strong>分片</strong>。（注意以下提到的 IP 没有特殊说明的情况下，都是指<strong>IPV4</strong>）</p><p>那么不管是分片还是分段，肯定需要<strong>按照一定的长度</strong>切分。</p><p>在<code>TCP</code>里，这个长度是<code>MSS</code>。</p><p>在<code>IP</code>层里，这个长度是<code>MTU</code>。</p><p>那<strong>MSS 和 MTU 是什么关系</strong>呢？这个在<a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">之前的文章</a>里简单提到过。这里单独拿出来。</p><h3 id="MSS-是什么"><a href="#MSS-是什么" class="headerlink" title="MSS 是什么"></a>MSS 是什么</h3><p><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p><p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%88%86%E5%8C%85.gif" alt="MSS分包"></p><h4 id="如何查看-MSS？"><a href="#如何查看-MSS？" class="headerlink" title="如何查看 MSS？"></a>如何查看 MSS？</h4><p>我们都知道 TCP 三次握手，而<code>MSS</code>会在三次握手的过程中传递给对方，用于通知对端本地最大可以接收的 TCP 报文数据大小（不包含 TCP 和 IP 报文首部）。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%8A%93%E5%8C%85mss.png" alt="抓包mss"></p><p>比如上图中，B 将自己的 MSS 发送给 A，建议 A 在发数据给 B 的时候，采用<code>MSS=1420</code>进行分段。而 B 在发数据给 A 的时候，同样会带上<code>MSS=1372</code>。两者在对比后，会采用<strong>小的</strong>那个值（1372）作为通信的<code>MSS值</code>，这个过程叫<code>MSS协商</code>。</p><blockquote><p>另外，一般情况下 MSS + 20（TCP 头）+ 20（IP 头）= MTU，上面抓包的图里对应的 MTU 分别是 1372+40 和 1420+40。 同一个路径上，<strong>MTU 不一定是对称的</strong>，也就是说 A 到 B 和 B 到 A，两条路径上的 MTU 可以是不同的，对应的 MSS 也一样。</p></blockquote><h4 id="三次握手中协商了-MSS-就不会改变了吗？"><a href="#三次握手中协商了-MSS-就不会改变了吗？" class="headerlink" title="三次握手中协商了 MSS 就不会改变了吗？"></a>三次握手中协商了 MSS 就不会改变了吗？</h4><p>当然不是，每次执行 TCP 发送消息的函数时，会重新计算一次 MSS，再进行分段操作。</p><h4 id="对端不传-MSS-会怎么样？"><a href="#对端不传-MSS-会怎么样？" class="headerlink" title="对端不传 MSS 会怎么样？"></a>对端不传 MSS 会怎么样？</h4><p>我们再看 TCP 的报头。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B45.png" alt="TCP报头"></p><p>其实 MSS 是作为可选项引入的，只不过一般情况下 MSS 都会传，但是万一遇到了哪台机器的实现上比较调皮，<strong>不传 MSS</strong>这个可选项。那对端该怎么办？</p><p><strong>如果没有接收到对端 TCP 的 MSS，本端 TCP 默认采用 MSS=536Byte</strong>。</p><p>那为什么会是<code>536</code>？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">536（data） + 20（tcp头）+20（ip头）= 576Byte</span><br></pre></td></tr></table></figure><p>前面提到了 IP 会切片，那会切片，也就会重组，而这个 576 正好是 IP 最小重组缓冲区的大小。</p><h3 id="MTU-是什么"><a href="#MTU-是什么" class="headerlink" title="MTU 是什么"></a>MTU 是什么</h3><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 其实这个是由<strong>数据链路层</strong>提供，为了告诉上层 IP 层，自己的传输能力是多大。IP 层就会根据它进行数据包切分。一般 MTU=<strong>1500 Byte</strong>。<br>假设 IP 层有 &lt;= <code>1500</code> byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有 &gt; <code>1500</code> byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的 IP 包里加上各种信息。比如这个分片在原来的 IP 包里的偏移 offset。</p><p><img src="https://cdn.xiaobaidebug.top/image/mtu%E5%88%86%E5%8C%85.gif" alt="MTU分包"></p><h4 id="如何查看-MTU"><a href="#如何查看-MTU" class="headerlink" title="如何查看 MTU"></a>如何查看 MTU</h4><p>在<code>mac</code>控制台输入 <code>ifconfig</code>命令，可以看到 MTU 的值为多大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipconfig</span></span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">...</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">...</span><br><span class="line">p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这上面有好几个<strong>MTU</strong>，可以简单理解为每个网卡的处理能力不同，所以对应的 MTU 也不同。当然这个值是可以修改的，但不在今天的讨论范畴内，不再展开。</p><p>在一台机器的应用层到这台机器的网卡，<strong>这条链路上</strong>，基本上可以保证，<code>MSS &lt; MTU</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="MSS和MTU的区别"></p><h4 id="为什么-MTU-一般是-1500"><a href="#为什么-MTU-一般是-1500" class="headerlink" title="为什么 MTU 一般是 1500"></a>为什么 MTU 一般是 1500</h4><p>这其实是由传输效率决定的。首先，虽然我们平时用的网络感觉挺稳定的，但其实这是因为 TCP 在背地里做了各种重传等保证了传输的可靠，其实背地里线路是动不动就丢包的，而越大的包，发生丢包的概率就越大。</p><p>那是不是包越小就越好？也不是</p><p>但是如果选择一个比较小的长度，假设选择<code>MTU</code>为<code>300Byte</code>，<code>TCP payload = 300 - IP Header - TCP Header = 300 - 20 - 20 = 260 byte</code>。那有效传输效率<code>= 260 / 300 = 86%</code></p><p>而如果以太网长度为 1500，那有效传输效率<code>= 1460 / 1500 = 96%</code> ，显然比 <code>86%</code> 高多了。</p><p>所以，包越小越不容易丢包，包越大，传输效率又越高，因此权衡之下，选了<code>1500</code>。</p><h3 id="为什么-IP-层会分片，TCP-还要分段"><a href="#为什么-IP-层会分片，TCP-还要分段" class="headerlink" title="为什么 IP 层会分片，TCP 还要分段"></a>为什么 IP 层会分片，TCP 还要分段</h3><p>由于本身 IP 层就会做分片这件事情。<strong>就算 TCP 不分段</strong>，到了 IP 层，数据包也会被分片，数据也能<strong>正常传输</strong>。</p><p>既然网络层就会分片了，那么 TCP 为什么还要分段？是不是有些多此一举？</p><p>假设有一份数据，较大，且在 TCP 层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP 会发生重传，那么重传的就是这一大份数据（虽然 IP 层会把数据切分为 MTU 长度的 N 多个小包，但是 TCP 重传的单位却是那一大份数据）。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E5%88%86%E7%89%871.gif" alt="假设TCP不分段"></p><p>如果 TCP 把这份数据，分段为 N 个小于等于 MSS 长度的数据包，到了 IP 层后加上 IP 头和 TCP 头，还是小于 MTU，那么 IP 层也不会再进行分包。此时在传输路上发生了丢包，那么 TCP 重传的时候也只是重传那一小部分的 MSS 段。效率会比 TCP 不分段时更高。</p><p><img src="https://cdn.xiaobaidebug.top/image/TCP%E5%88%86%E6%AE%B5.gif" alt="假设TCP分段"></p><p>类似的，传输层除了 TCP 外，还有 UDP 协议，但 UDP 本身不会分段，所以当数据量较大时，只能交给 IP 层去分片，然后传到底层进行发送。</p><p>也就是说，正常情况下，在一台机器的传输层到网络层<strong>这条链路上</strong>，如果传输层对数据做了分段，那么 IP 层就不会再分片。如果传输层没分段，那么 IP 层就可能会进行分片。</p><p>说白了，<strong>数据在 TCP 分段，就是为了在 IP 层不需要分片，同时发生重传的时候只重传分段后的小份数据</strong>。</p><h3 id="TCP-分段了，IP-层就一定不会分片了吗"><a href="#TCP-分段了，IP-层就一定不会分片了吗" class="headerlink" title="TCP 分段了，IP 层就一定不会分片了吗"></a>TCP 分段了，IP 层就一定不会分片了吗</h3><p>上面提到了，在发送端，TCP 分段后，IP 层就不会再分片了。</p><p>但是整个传输链路中，可能还会有其他网络层设备，而这些设备的 MTU 可能小于发送端的 MTU。此时虽然数据包在发送端已经<strong>分段</strong>过了，但是在 IP 层就还会再分片一次。</p><p>如果链路上还有设备有<strong>更小的 MTU</strong>，那么还会再分片，最后所有的分片都会在<strong>接收端</strong>处进行组装。</p><p><img src="https://cdn.xiaobaidebug.top/image/IP%E5%88%86%E7%89%87%E5%86%8D%E5%88%86%E7%89%87.gif" alt="IP分片再分片"></p><p>因此，就算 TCP 分段过后，在链路上的其他节点的 IP 层也是有可能再分片的，而且哪怕数据被第一次 IP 分片过了，也是有可能被其他机器的 IP 层进行二次、三次、四次….分片的。</p><h3 id="IP-层怎么做到不分片"><a href="#IP-层怎么做到不分片" class="headerlink" title="IP 层怎么做到不分片"></a>IP 层怎么做到不分片</h3><p>上面提到的 IP 层在传输过程中<strong>因为各个节点间 MTU</strong>可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。那么 IP 层是否可以做到不分片？</p><p>如果有办法知道整个链路上，最小的 MTU 是多少，并且以最小 MTU 长度发送数据，那么不管数据传到哪个节点，都不会发生分片。</p><p>整个链路上，<strong>最小的 MTU，就叫 PMTU</strong>（path MTU）。</p><p>有一个<strong>获得这个 PMTU 的方法，叫 Path MTU Discovery</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/ip_no_pmtu_disc</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>默认为<code>0</code>，意思是开启 PMTU 发现的功能。现在一般机器上都是开启的状态。</p><p>原理比较简单，首先我们先回去看下 IP 的数据报头。</p><p><img src="https://cdn.xiaobaidebug.top/image/ip%E6%8A%A5%E5%A4%B4DF1.png" alt="IP报头DF"></p><p>这里有个标红的标志位<code>DF</code>（Don’t Fragment），当它置为 1，意味着这个 IP 报文不分片。</p><p>当链路上某个路由器，收到了这个报文，当 IP 报文长度大于路由器的 MTU 时，路由器会看下这个 IP 报文的<code>DF</code></p><ul><li>如果为<code>0</code>（允许分片），就会分片并把分片后的数据传到下一个路由器</li><li>如果为<code>1</code>，就会把数据丢弃，同时返回一个 ICMP 包给发送端，并告诉它 <del>“达咩!”</del> 数据不可达，需要分片，同时带上当前机器的 MTU</li></ul><p>理解了上面的原理后，我们再看下 PMTU 发现是怎么实现的。</p><ul><li>应用通过 TCP 正常发送消息，传输层<strong>TCP 分段</strong>后，到<strong>网络层</strong>加上 IP 头，<strong>DF 置为 1</strong>，消息再到更底层执行发送</li><li>此时链路上有台<strong>路由器</strong>由于各种原因<strong>MTU 变小了</strong></li><li>IP 消息到这台路由器了，路由器发现消息长度大于自己的 MTU，且消息自带 DF 不让分片。就把消息丢弃。同时返回一个<code>ICMP</code>错误给发送端，同时带上自己的<code>MTU</code>。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E8%8E%B7%E5%BE%97pmtu.gif" alt="获得pmtu"></p><ul><li>发送端收到这个 ICMP 消息，会更新自己的 MTU，同时记录到一个<strong>PMTU 表</strong>中。</li><li>因为 TCP 的可靠性，会尝试重传这个消息，同时以这个新 MTU 值计算出 MSS 进行分段，此时新的 IP 包就可以顺利被刚才的路由器转发。</li><li>如果路径上还有更小的 MTU 的路由器，那上面发生的事情还会再发生一次。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E8%8E%B7%E5%BE%97pmtu%E5%90%8E%E7%9A%84TCP%E9%87%8D%E4%BC%A0.gif" alt="获得pmtu后的TCP重传"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>数据在 TCP 分段，在 IP 层就不需要分片，同时发生重传的时候只重传分段后的小份数据</p></li><li><p>TCP 分段时使用 MSS，IP 分片时使用 MTU</p></li><li><p>MSS 是通过 MTU 计算得到，在三次握手和发送消息时都有可能产生变化。</p></li><li><p>IP 分片是<strong>不得已</strong>的行为，尽量不在 IP 层分片，尤其是链路上中间设备的 IP 分片。因此，在 IPv6 中已经禁止中间节点设备对 IP 报文进行分片，分片只能在链路的最开头和最末尾两端进行。</p></li><li><p>建立连接后，路径上节点的 MTU 值改变时，可以通过 PMTU 发现更新发送端 MTU 的值。这种情况下，PMTU 发现通过浪费 N 次发送机会来换取的 PMTU，TCP 因为有重传可以保证可靠性，在 UDP 就相当于消息直接丢了。</p></li></ul><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP 模型里为什么要有 P？背后的原因让人暖心</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个 net/http 包的坑</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>画动图，太难了。。。看完求个赞，下次图会动得更凶。</p><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210513085507280.png"></p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>i/o timeout ， 希望你不要踩到这个net/http包的坑</title>
      <link href="/2021/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/io_timeout%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E4%B8%8D%E8%A6%81%E8%B8%A9%E5%88%B0%E8%BF%99%E4%B8%AAhttp%E5%8C%85%E7%9A%84%E5%9D%91/"/>
      <url>/2021/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/io_timeout%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E4%B8%8D%E8%A6%81%E8%B8%A9%E5%88%B0%E8%BF%99%E4%B8%AAhttp%E5%8C%85%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们来看一段日常代码。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">body := bytes.NewReader(data)</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">Transport: tr,</span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>做的事情，比较简单，就是循环去请求 <code>http://www.baidu.com/</code> , 然后等待响应。</p><p><strong>看上去貌似没啥问题吧。</strong></p><p>代码跑起来，也<strong>确实能正常收发消息</strong>。</p><p>但是这段代码跑<strong>一段时间</strong>，就会出现 <code>i/o timeout</code> 的报错。</p><br><p>这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，我这边对代码做了简化。</p><p>实际生产中发生的<strong>现象</strong>是，<code>golang</code>服务在发起<code>http</code>调用时，虽然<code>http.Transport</code>设置了<code>3s</code>超时，会偶发出现<code>i/o timeout</code>的报错。</p><p>但是查看下游服务的时候，发现下游服务其实 <code>100ms</code> 就已经返回了。</p><br><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90.png" alt="五层网络协议对应的消息体变化分析"></p><p>就很奇怪了，明明服务端显示处理耗时才<code>100ms</code>，且客户端超时设的是<code>3s</code>, 怎么就出现超时报错 <code>i/o timeout</code> 呢？</p><br><p>这里推测有两个可能。</p><ul><li><p>因为服务端打印的日志其实只是<strong>服务端应用层</strong>打印的日志。但客户端应用层发出数据后，中间还经过<strong>客户端的传输层，网络层，数据链路层和物理层</strong>，再经过<strong>服务端的物理层，数据链路层，网络层，传输层到服务端的应用层</strong>。服务端应用层处耗时<strong>100ms</strong>，再原路返回。那剩下的<code>3s-100ms</code><strong>可能是</strong>耗在了整个流程里的各个层上。比如网络不好的情况下，传输层 TCP 使劲丢包重传之类的原因。</p></li><li><p>网络没问题，客户端到服务端链路整个收发流程大概耗时就是<code>100ms</code>左右。客户端处理逻辑问题导致超时。</p><br></li></ul><p><strong>一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了</strong>，不死心就抓个包看下。</p><p><img src="https://cdn.xiaobaidebug.top/image/wiresharkcp2.png" alt="抓包结果"></p><p>分析下，从刚开始三次握手（<strong>画了红框的地方</strong>）。</p><p>到最后出现超时报错 <code>i/o timeout</code> （<strong>画了蓝框的地方</strong>）。</p><p>从<code>time</code>那一列从<code>7</code>到<code>10</code>，确实间隔<code>3s</code>。而且看<strong>右下角</strong>的蓝框，是<code>51169</code>端口发到<code>80</code>端口的一次<code>Reset</code>连接。</p><p><code>80</code>端口是服务端的端口。换句话说就是客户端<code>3s</code>超时<strong>主动</strong>断开链接的。</p><p>但是再仔细看下<strong>第一行</strong>三次握手到<strong>最后</strong>客户端超时主动断开连接的中间，其实有<strong>非常多次 HTTP 请求</strong>。</p><p>回去看代码设置超时的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，这里的<code>3s</code>超时，其实是在<strong>建立连接之后</strong>开始算的，而不是<strong>单次调用开始算的</strong>超时。</p><p>看注释里写的是</p><blockquote><p>SetDeadline sets the read and write deadlines associated with the <strong>connection</strong>.</p></blockquote><br><br><h3 id="超时原因"><a href="#超时原因" class="headerlink" title="超时原因"></a>超时原因</h3><p>大家知道<code>HTTP</code>是应用层协议，传输层用的是<code>TCP</code>协议。</p><p>HTTP 协议从<code>1.0</code>以前，默认用的是<code>短连接</code>，每次发起请求都会建立 TCP 连接。收发数据。然后断开连接。</p><p>TCP 连接每次都是三次握手。每次断开都要四次挥手。</p><p>其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。</p><p>于是乎，HTTP 协议从<code>1.1</code>之后就默认使用<code>长连接</code>。具体相关信息可以看之前的 <a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">这篇文章</a>。</p><p>那么<code>golang标准库</code>里也兼容这种实现。</p><p>通过建立一个连接池，针对<code>每个域名</code>建立一个 TCP 长连接，比如<code>http://baidu.com</code>和<code>http://golang.com</code> 就是两个不同的域名。</p><p>第一次访问<code>http://baidu.com</code> 域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问<code>http://baidu.com</code> 的时候会重新从连接池里把这个连接捞出来<code>复用</code>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%A4%8D%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="复用长连接"></p><br><blockquote><p>插个题外话：这也解释了之前<a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">这篇文章</a>里最后的疑问，为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应<strong>一个读 goroutine 和一个写 goroutine</strong>。正因为是同一个域名，所以最后才会泄漏<code>3</code>个 goroutine，如果不同域名的话，那就会泄漏 <code>1+2*N</code> 个协程，<code>N</code>就是域名数。</p></blockquote><br><p>假设第一次请求要<code>100ms</code>，每次请求完<code>http://baidu.com</code> 后都<strong>放入</strong>连接池中，下次继续复用，重复<code>29</code>次，耗时<code>2900ms</code>。</p><p>第<code>30</code>次请求的时候，连接从建立开始到服务返回前就已经用了<code>3000ms</code>，刚好到设置的<strong>3s</strong>超时阈值，那么此时客户端就会报超时 <code>i/o timeout</code> 。</p><p>虽然这时候服务端其实才花了<code>100ms</code>，但耐不住前面<code>29次</code>加起来的耗时已经很长。</p><p>也就是说只要通过 <code>http.Transport</code> 设置了 <code>err = conn.SetDeadline(time.Now().Add(time.Second * 3)) </code>，并且你用了<strong>长连接</strong>，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，你的程序会报超时错误。</p><h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。</p><p>另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。</p><p>基于这两点，改一下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line"><span class="comment">// 下面的代码被干掉了</span></span><br><span class="line"><span class="comment">//Dial: func(netw, addr string) (net.Conn, error) &#123;</span></span><br><span class="line"><span class="comment">//conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return nil, err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return nil, err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return conn, nil</span></span><br><span class="line"><span class="comment">//&#125;,</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">body := bytes.NewReader(data)</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">Transport: tr,</span><br><span class="line">Timeout: <span class="number">3</span>*time.Second,  <span class="comment">// 超时加在这里，是每次调用的超时</span></span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看注释会发现，改动的点有两个</p><ul><li><p><code>http.Transport</code>里的建立连接时的一些超时设置干掉了。</p></li><li><p>在发起 http 请求的时候会场景<code>http.Client</code>，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释</p><blockquote><p>Timeout specifies a time limit for <strong>requests</strong> made by this Client.</p></blockquote></li></ul><p>到这里，代码就改好了，实际生产中问题也就解决了。</p><p>实例代码里，如果拿去跑的话，其实还会下面的错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get http:<span class="comment">//www.baidu.com/: EOF</span></span><br></pre></td></tr></table></figure><p>这个是因为调用得太猛了，<code>http://www.baidu.com</code> 那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，<strong>毕竟每个人都像这么搞，服务器是会炸的</strong>。。。</p><p>解决方案很简单，每次 HTTP 调用中间加个<code>sleep</code>间隔时间就好。</p><br><p>到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。对读源码不感兴趣的朋友们可以不用接着往下看，直接拉到文章底部<strong>右下角</strong>，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>用的 go 版本是 1.12.7</strong>。</p><p>从发起一个网络请求开始跟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">resp, err = rt.RoundTrip(req)</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里进入 RoundTrip 逻辑</span></span><br><span class="line">/src/net/http/roundtrip.<span class="keyword">go</span>: <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 尝试去获取一个空闲连接，用于发起 http 连接</span></span><br><span class="line">  pconn, err := t.getConn(treq, cm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点关注这个函数，返回是一个长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略了大量逻辑，只关注下面两点</span></span><br><span class="line"><span class="comment">// 有空闲连接就返回</span></span><br><span class="line">pc := &lt;-t.getIdleConnCh(cm)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有创建连接</span></span><br><span class="line">  pc, err := t.dialConn(ctx, cm)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。</p><p>最后一个上面的代码里有个 <code>getConn</code> 方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。</p><ul><li><p>如果有空闲连接，就拿空闲连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">810</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getIdleConnCh</span><span class="params">(cm connectMethod)</span> <span class="title">chan</span> *<span class="title">persistConn</span></span> &#123;</span><br><span class="line">   <span class="comment">// 返回放空闲连接的chan</span></span><br><span class="line">   ch, ok := t.idleConnCh[key]</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有空闲连接，就创建长连接。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">1357</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">  <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<strong>第一次</strong>发起一个 http 请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个<strong>读 goroutine 和一个写 goroutine</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%AF%BB%E5%86%99%E5%8D%8F%E7%A8%8B.png" alt="读写协程"></p><p>注意上面代码里的<code>t.dial(ctx, &quot;tcp&quot;, cm.addr())</code>，如果像文章开头那样设置了 <code>http.Transport</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">   conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么这里就会在下面的<code>dial</code>里被执行到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dial</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  c, err := t.Dial(network, addr)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面调用的设置超时，会执行到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/src/net/net.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">SetDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">c.fd.SetDeadline(t)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDeadlineImpl</span><span class="params">(fd *FD, t time.Time, mode <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="keyword">int64</span>, mode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 设置一个定时器事件</span></span><br><span class="line">  rtf = netpollDeadline</span><br><span class="line"><span class="comment">// 并将事件注册到定时器里</span></span><br><span class="line">  modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个<strong>定时器事件</strong>，假设时间设了<code>3s</code>，那么这个事件会在<code>3s</code>后发生，然后执行注册事件的逻辑。而这个注册事件就是<code>netpollDeadline</code>。 <strong>注意这个<code>netpollDeadline</code>，待会会提到。</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%AF%BB%E5%86%99%E5%8D%8F%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6.png" alt="读写协程定时器事件"></p><p>设置了超时事件，且超时事件是 3s 后之后，发生。再次期间正常收发数据。一切如常。</p><p>直到<code>3s</code>过后，这时候看<code>读goroutine</code>，会等待网络数据返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">1642</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span> alive &#123;</span><br><span class="line">_, err := pc.br.Peek(<span class="number">1</span>)  <span class="comment">// 阻塞读取服务端返回的数据</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是一直跟代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">src/bufio/bufio.<span class="keyword">go</span>: <span class="number">129</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   b.fill()</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">fill</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err := b.rd.Read(b.buf[b.w:])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/net/http/transport.<span class="keyword">go</span>: <span class="number">1517</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err = pc.conn.Read(p)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /src/net/net.go: 173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err := c.fd.Read(b)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">n, err = fd.pfd.Read(p)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/internal/poll/fd_unix.<span class="keyword">go</span>:</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">waitRead</span><span class="params">(isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">wait</span><span class="params">(mode <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line"><span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直到跟到 <strong>runtime_pollWait</strong>，这个可以简单认为是<strong>等待服务端数据返回</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.如果网络正常返回数据就跳出</span></span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果有出错情况也跳出</span></span><br><span class="line">err = netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line"><span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整条链路跟下来，就是会一直等待数据，等待的结果只有两个</p><ul><li>有可以读的数据</li><li>出现报错</li></ul><p>这里面的<strong>报错</strong>，又有那么两种</p><ul><li>连接关闭</li><li>超时</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pd.closing &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> <span class="comment">// errClosing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中提到的<code>超时</code>，就是指这里面返回的<code>数字2</code>，会通过下面的函数，转化为 <code>ErrTimeout</code>， 而 <code>ErrTimeout.Error()</code> 其实就是 <code>i/o timeout</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertErr</span><span class="params">(res <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> res &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> errClosing(isFile)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> ErrTimeout <span class="comment">// ErrTimeout.Error() 就是 &quot;i/o timeout&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;unreachable: &quot;</span>, res)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了。上面返回的超时错误，也就是<strong>返回 2 的时候的条件是怎么满足的</strong>？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得刚刚提到的 <code>netpollDeadline</code>吗？</p><p>这里面放了定时器<code>3s</code>到点时执行的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line"><span class="comment">// 计时器到设定时间点了，触发之前注册函数</span></span><br><span class="line">f(arg, seq) <span class="comment">// 之前注册的是 netpollDeadline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/runtime/netpoll.<span class="keyword">go</span>: <span class="number">428</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="keyword">uintptr</span>, read, write <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> read &#123;</span><br><span class="line">pd.rd = <span class="number">-1</span></span><br><span class="line">rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会设置<code>pd.rd=-1</code>，是指 <code>poller descriptor.read deadline</code> ，含义<strong>网络轮询器文件描述符</strong>的<strong>读超时时间</strong>， 我们知道在 linux 里万物皆文件，这里的文件其实是指这次网络通讯中使用到的<strong>socket</strong>。</p><p>这时候再回去看<strong>发生超时的条件</strong>就是<code>if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0) </code>。</p><p>至此。我们的代码里就收到了 <code>io timeout</code> 的报错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>不要在 <code>http.Transport</code>中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名 <code>io timeout</code>报错。</p></li><li><p>请求的超时在创建<code>client</code>里设置。</p></li></ul><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a></li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:<strong>【小白 debug】</strong><br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>妙啊！程序猿的第一本互联网黑话指南</title>
      <link href="/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A6%99%E5%95%8A%EF%BC%81%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D%E6%8C%87%E5%8D%97/"/>
      <url>/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A6%99%E5%95%8A%EF%BC%81%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61617799367126.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><br><p>很烦，小侄子最近不给我打电话了。</p><p>放下作为叔叔的面子，拨通电话。</p><span id="more"></span><p><img src="https://cdn.xiaobaidebug.top/image/3f5e9f7e95a2cc21.jpeg" alt="打电话"></p><p>他说，他最近很烦。</p><p>我以为他长大了，谈恋爱了。</p><p>他说，最近他们学校，换了个校长。</p><p>喜欢在早上升国旗之后发表演讲。</p><p>“发表演讲挺好的啊，德智体美。”</p><p>他说他听不懂。比如校长今天早上提到说：</p><p>“我们需要大力推进新型教育<strong>场景</strong>，尝试建立一些新的教学<strong>模型</strong>，用心打磨<strong>细节</strong>。</p><p>并重点关注其他教育形式的<strong>可能性</strong>。利用传统教育形式去<strong>驱动</strong>新型教育形式，打通<strong>底层逻辑</strong>，形成<strong>闭环</strong>。用传统教育理念<strong>赋能</strong>新型教育场景。让传统和新型教育形式作为一整套<strong>组合拳</strong>，加速学生更好更快的<strong>发展</strong>。”</p><p><img src="https://cdn.xiaobaidebug.top/image/89254ec8063c5fc9.jpeg"></p><p>好家伙，这么长的一句话，<strong>信息量竟然为 0</strong>。</p><p>再仔细一想。</p><p>心里一惊，原来是同行啊，这老哥，一定是互联网出来的。</p><p>光听到<strong>赋能</strong>这个词，我就知道是哪个厂出来的了。</p><p>我劝小侄子，这个想听懂，得有<strong>一定的互联网阅历</strong>才行啊。</p><p>小侄子却表示：“叔叔，你不是在互联网公司上班吗？你教教我吧”</p><p>不行，这对于年幼的他，还太早了。</p><p>直到他告诉我，“我们班长现在已经学会这种超酷的说话方式了，现在班里的女生都超爱听他说话”</p><p>这？？？</p><p>不，这能忍？就算是这样的我，也有想要守护的东西。我必须教会。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210404153251619.png"></p><p>那晚我打了 3 小时视频电话，畅快淋漓，让我差点忘了手机还欠费 47 块这件事。</p><br><p>三天后，侄子跟我说，好是挺好的，就是有点废纸，现在班里的女同学都喜欢找他要签名。</p><p>嗯，不是很环保。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210404153859729.png"></p><p>考虑到身边还有很多连互联网黑话都不会说的胖友们，在这里简单写一份程序员必知必会的<strong>互联网黑话指南</strong>。赠与有缘人。</p><p>诚实质朴如你，实在无法低下高傲的头颅的话，希望你也能听懂别人在不讲人话的时候，到底背后是几层意思。</p><p>我不允许我的胖友们听不懂！更不允许你们被蒙在鼓里！</p><br><br><p>领导开口闭口都是商业模式，闭环？整个会听下来，就记住了<strong>赋能，抓住，推进，深入</strong>这些词？</p><p>产品让你跟她<strong>对齐</strong>一下？</p><p>其他部门同事说再不马上处理某个问题，她就要<strong>上升</strong>了，而这时候你以为她是要<strong>上天</strong>？</p><p>hr 跟你说公司扁平化管理，一年有两次加薪机会的时候，你只听到了<strong>加薪</strong>，却听漏了这只是<strong>机会</strong>？</p><br><p>看完下面，你会对上面的场景有不一样的认识。</p><br><p>首先对于<strong>国内互联网大厂</strong>，我们盘一下常说的一些话。</p><p>比如<strong>抓手</strong>，是指手可以抓得到的地方，一般是指项目的<strong>切入点</strong>。</p><p>当提到项目需要努力<strong>寻找抓手</strong>的时候，说明项目现在比较<strong>蒙圈</strong>，还没有好的切入点，还在各种试错。</p><p>划重点了，项目怎么做都没想清楚，建议各位老哥 <code>LeetCode</code> 刷起来吧。</p><br><p>当你在职级答辩的时候，也可能被问到某件事情的<strong>抓手</strong>是什么。</p><p>一般是问你这个问题的切入点在哪，从哪里开始解决，</p><p>一般是要你说下从现象到本质的判断过程。</p><p>比如，机器内存暴涨导致报警，这时候现象切入点是某个进程，再定位代码更新部分，最后定位问题。</p><br><p>而一般项目的<strong>抓手</strong>都是从某个<strong>垂直领域</strong>里的<strong>细分领域</strong>里发力，</p><p>垂直领域和细分领域的<strong>区别</strong>大概可以理解为编程和用<code>golang</code>编程之间的区别。</p><br><p>领域不够垂直，不够细分，大概就是说，啥都干了点，不够专，不够精。</p><br><p><strong>赋能</strong>是个啥，第一次接触这个词的时候，我还去搜了一下定义</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210407121032572.png" alt="赋能的定义"></p><p>好家伙，竟然拿<strong>一堆</strong>别人看不懂的词去解释<strong>一个</strong>别人看不懂的词，<strong>属实让人意外了</strong>。</p><p>后来搞明白了。说白了，别人没有某个东西，而你有，你<strong>主动</strong>找他跟你合作。重点在于<strong>主动</strong>这个词，有<strong>忽悠</strong>内味了。</p><br><p>还有，如果运营产品们喜欢探讨项目的<strong>盈利模式</strong>，你就要知道，他们其实心里也没底这玩意到底能不能赚钱。如果赚钱了，就会找出<strong>各种理由</strong>解释“这个项目为什么能赚钱”，这就是所谓的各种<strong>方法论</strong>了。</p><p>当然，如果项目赚钱了，又不给你发钱，就可以说是<strong>延迟满足感</strong>。</p><br><p>类似的不讲人话的词还有很多。</p><p>开个会，叫<strong>对齐</strong>一下。</p><p>找你领导，叫<strong>上升</strong>。</p><p>最容易<code>pian</code>到投资的领域，叫<strong>风口</strong>。</p><p>同时用多种方法去搞钱，就叫<strong>组合拳</strong>。</p><p>跟别的公司产生了合作，那就出现了<strong>生态</strong>，合作的公司多了，就叫<strong>生态链</strong>。</p><p>生态链产生<strong>闭环</strong>，这里就划重点了，意思是<strong>开始赚钱</strong>了。</p><p>还有另外一个需要<strong>敲黑板，划重点</strong>的考点。</p><p>当老板提到要向社会<strong>输送人才</strong>，就是要开始解雇咸鱼了。。不管读多少遍，我还是觉得说这话的人是真的厉害，这才是语！言！艺！术！请各位老哥<strong>把牛皮打在公屏上</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/9150e4e5ly1flnjufq3eaj204w05cjra.jpg"></p><p>作为不讲人话的高发场地，面试那张方寸小桌，经常会出现一些让人觉得高深莫测的词语。</p><p>比如当你听到<code>hr</code>介绍公司<strong>弹性工作制</strong>，不打卡，也就是指下班时间不定，也没有加班这一说。</p><p><strong>扁平化管理</strong>，在公司层面可能有各种积极意义。但对你<strong>个人而言</strong>，基本上约等于<strong>一般没有晋升</strong>。</p><p><strong>能独立完成工作任务</strong>，当然就是产品的开发全都你一个人干。</p><br><p>很多时候 hr 会看着招聘简介上的信息问你问题。</p><p>问你有没有做过<strong>高并发</strong>相关，如果你给机器扩容过，大胆说有。</p><p>用了主备机器，就说是<strong>高可用</strong>。</p><p>用了缓存，那就是<strong>高性能</strong>了。</p><p>用了 <code>Mysql</code>，妥了，<strong>持久化</strong>。</p><p>虽然我很普通，但我很自信。</p><p><img src="https://cdn.xiaobaidebug.top/image/415f82b9ly1fy7bddcac0j20c80c90tp.jpg"></p><p>这时候你可能就会产生疑问了，这是不是<strong>国内互联网大厂</strong>才有的通病？</p><p>我去<strong>外企</strong>是不是就好了？</p><br><br><p>那欢迎来到<strong>快乐星球</strong>了。</p><p>上班等电梯的时候，你会听到旁边的 <code>Lucy</code> 端着她的<strong>美式卡布奇诺</strong>很惊讶的对 <code>Emily</code> 说</p><p>“<code>Emiliy</code> 你知道吗？我跟你说，昨天，<code>Alice</code> 他的手机在 <code>meeting</code> 的时候摔得粉粉碎，真的粉粉碎哦”</p><p>“哇哦，<code>what a pity</code>“</p><p>早上，老板会让大家开个 <code>daily meeting</code>。说一下大家今天的 <code>todo list</code>。还有 <code>project</code> 的进展。</p><p>可能这个 <code>project</code> 的 <code>schedule</code> 有些问题，尤其是<code>buffer</code>不多。另外，<code>cost</code>也偏高。</p><p>项目组没法 <code>confirm</code> 手上的 <code>resource</code> 能完全 <code>take</code> 得了。</p><p><code>anyway</code>，我们可以先 <code>argue</code> 一下，再 <code>follow up</code> 最终的 <code>output</code>，先 <code>run</code> 起来，看<code>work</code> 不 <code>work</code>。</p><p><code>more importantly</code> ，我们要尝试 <code>cover</code> 掉所有的 <code>difficulty</code>。</p><p>瞧瞧，瞬间觉得抓手闭环<strong>亲切了许多</strong>。</p><p>在这里我要<strong>正能量</strong>一波，否则对不起我这全日制本科的学历。</p><p>本来一些类似<code>hr</code>，<code>kindle</code>专有名词用英语，可以提升沟通效率，但是大量在不必要的场景下用这些中英文混杂的话，真的让人难受。</p><p>沟通，最 <code>important</code> 的是 <code>efficiency</code>，<code>understand</code>？</p><p><img src="https://cdn.xiaobaidebug.top/image/CUKEOz4pHnNw4KZUEH9P0-P1JVVY9Atf1pUFZcdI1EdPGrlfX02981wq2nhcibqbIMlzBL6FVIRpw4lKrJkz_WOPa7t6ivga2L75aav9VwWyh6Pdeq2CsP_nGth8xjSv6ggZ7vFYU-r-ZtZgog52dryw.jpeg"></p><p>以前在网上看到过一个话题叫<strong>我想一巴掌扇 si 那个中英夹杂讲话的朋友！</strong></p><p>当初年轻，高低也想说上那么两句。</p><p>现在成熟了，只会努力克制不要拿<strong>百宝袋</strong>里的<strong>四次元大嘴巴子</strong>扇人。</p><p>让更不成熟的年轻人去扇吧，<strong>要带响的</strong>哦。</p><p><img src="https://cdn.xiaobaidebug.top/image/a9cf8ef6ly1fm3yy1ks5bj205e05iaad.jpg"></p><br><br><p><strong>国内的大厂和外企</strong>都不爱讲人话？</p><p>那我去<strong>小厂</strong>，总归可以了吧？</p><br><br><p><strong>小了，</strong></p><p><strong>格局小了。</strong></p><br><br><br><br><br><p>你忘了大厂给社会<strong>输送的人才</strong>了吗？</p><p>你猜他们都去哪了？</p><br><br><p>还是没学会怎么说黑话？</p><p>那就用数量堆叠的方式，让人在无数莫名其妙的<strong>动词名词形容词</strong>下沦陷。</p><p>让他一时之间眼花缭乱，抓不住任何重点。</p><p>反正，某厂周报，就是这么干的。</p><br><br><p>会说话就多说点吧。</p><p>我是小白，我们下期见。</p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30 张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>聊聊我的大学是怎么过的</title>
      <link href="/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%81%8A%E8%81%8A%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%87%E7%9A%84/"/>
      <url>/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E8%81%8A%E8%81%8A%E6%88%91%E7%9A%84%E5%A4%A7%E5%AD%A6%E6%98%AF%E6%80%8E%E4%B9%88%E8%BF%87%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>今天收拾房间把大学时候的旧电脑翻了出来。</p><p>毕业之后我就很少碰它了。</p><p>正好可以试试还能不能开机。</p><p>打开电脑，小风扇一阵咔咔咔转起来。</p><p>桌面也不知道从什么时候开始多了很多【传奇霸主，沙城争霸，复古奇迹之类的】的网页快捷方式。</p><p>当然，还有<strong>2345 浏览器</strong>。。。</p><p>磁盘使用率也总是能轻而易举的到<code>98%</code>。</p><br><p>可能是当了<strong>肉鸡</strong>，也可能该进行一波<strong>磁盘碎片整理</strong>。</p><p>但想想还是算了。没必要。</p><br><p>翻文件夹的时候发现了很多陈年老照片和老资料。</p><p>很多回忆瞬间涌入，我才想起好多旧事情。</p><span id="more"></span><p><strong>回忆的小风扇也突然温情了起来。</strong></p><p>刚上大学的时候选专业，那时候”<strong>码农</strong>“这个词很火，当时我身边的人都在说这个行业已经饱和了，等我毕业的时候肯定就不行了，而且码农还很辛苦，不要选计算机专业，我表示很认可。</p><p>于是，我大学时候选了电气工程及其自动化，如果非要说专业对口的工作的话，那应该是<strong>电气工程师</strong>。</p><p>如果运气好的话，能进某<strong>电网</strong>当个工程师，又或者会进到某个<strong>变电站</strong>里调调设备啥的。我已经能想象到我能像刘慈欣那样在变电站里一边划水一边写下一部《三体》的画面了。</p><p>为了不让自己以后成为码农，但凡是跟计算机沾边的选修课，我是能不选就不选。</p><p>这其中就包括<strong>数据结构</strong>，后来流的泪，确实是当初脑子进的水。</p><br><p>像每一个普普通通的大学生一样，我大学的时候也不知道未来会做什么，只能好好学习，课是一门都没翘过。</p><p>每天下课后身边的同学都在打当时很火的英雄联盟，成群结队开黑，而我当时，也沉迷电影动漫。</p><p>但凡有点目标，也不至于这样。</p><p><strong>那个年纪，谁都迷茫。</strong></p><br><p>这样的日子持续了好长时间，为了寻求改变，于是尝试参加各种校园活动。</p><p>学校里有很多标榜着”领导力”，”组织力”，”策划力”的社团和组织。</p><p>那个年纪的年轻人大都血气方刚，谁不想做管理者呢？看着学生会会长在讲台上慷慨激昂的演讲，相信台下的每个人多多少少也想象过自己会不会也有这么一天。</p><p>但我很清楚，我不会有这么一天，毕竟我那时候连普通话都说不标准，<strong>带着广东味的普通话，怎么听都不普通。</strong></p><p>于是我早早就接受了自己”<strong>工具人</strong>“的定位，学<strong>PS 画海报，做 PPT，录视频剪视频</strong>。</p><p>学会了这些技能，课程小组作业里，总有人喜欢找我组队。学生会宣传部里，也总能有我一份苦差事。</p><p>甚至有个老哥，让我为他和他女朋友做了一个相恋周年视频集锦。</p><p>这么多年过去了，他们现在已经各自有了自己的家庭，而这部视频，还躺在我的硬盘上。</p><p>这感觉，大概就叫<strong>唏嘘</strong>。</p><p><strong>而这些技能，打死你，我也想不到现在能在做公众号的时候用上</strong>。。</p><br><p>后来，遭遇了好几次海报改了五六版的事情之后，我也开始觉得没意思了。</p><br><p>这一晃时间也到了大二下学期。</p><p>我也通过各种渠道，参加到了学校的一些所谓的科创小团体中。像什么 PLC 自控相关的项目，飞思卡尔啥的我是一个没落下。</p><p>全都去水了一把。后来听说有家公司搞了个四旋翼无人机的科创项目，听说报销额度高达 1k。</p><p>这我哪懂无人机啊，但有便宜不占王八蛋啊。</p><p>我本想水一下完事的，但这玩意接触下来确实有点意思。</p><br><p>于是我的大学生活开始正式进入正轨。</p><p>我开始自己尝试画 PCB 电路板，看网上的源码。当时看不懂源码，就用的最笨的方法，一行一行的照着敲。</p><p>一边敲一边就有新的理解。</p><p><strong>抛开效率不谈，只要你花时间，任何事情的熬不住你一遍一遍的磨。</strong></p><p>大概过了两三个月吧。</p><p>小飞机的第一个模块才终于跑起来了。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220514154131344.png"></p><p>对那时候的我来说，做这玩意，挺费钱的，电机电池都是钱。</p><p>举个例子。立在最上头的那个诡异的芯片。叫 MPU6050，是个 6 轴陀螺仪，用来计算偏移反馈控制电机，可以让小飞机保持平衡。就这玩意，要 60，穷学生看了都流泪。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20220514160134592.png"></p><p>于是，我通过各种渠道参加了一些兼职，大二结束的那个夏天，还去上海游泳馆当了一个暑假的苦力。</p><p>那个时候，早上 5 点起床，7 点上班，下午 3 点下班。</p><p>不知道你们有没有干过这种<strong>没有成长的纯苦力工作</strong>，每次做完这种工作，脑子里只会有一种想法：”我以后绝对不能继续做这种工作”。</p><p>于是回到学校 4 点半，我就开始调代码。只有吃学习的苦，才能不吃生活的苦，那段时间效率高的飞起。</p><p>这时候肯定有读者跳出来骂小白了，游泳馆不好吗？穿着泳装的姐姐们难道你不爱看？</p><p><strong>嘿嘿，别问了，贼爱看。</strong></p><br><p>后来小飞机也做出来了。</p><p>我拿着它去参加了各种比赛。</p><p>然后到了大三夏天，凭着这份经历，进了一家车企实习。这时候，我做的是嵌入式软件开发。</p><p>我以为我会一直这样下去。</p><p>直到某一天我在图书馆，看到科创实验室里的研究生大佬，桌子上放了一本《HTML 从入门到精通》。</p><p>我开始有些动摇，”为什么连我们实验室的科创大佬都开始学这个，难道它比嵌入式开发要好”？</p><p>好不好我不知道。</p><p>但当时我还打开过拉勾网溜了一遍，发现互联网应届毕业生的工资确实要高不少。</p><p><img src="https://cdn.xiaobaidebug.top/image/u=2250987786,1718046519&fm=253&fmt=auto&app=138&f=JPEG.jpeg"></p><p>于是我又开始了新的探索。</p><p>我不是计算机系的学生，并且只会 C 语言和简单的数据结构。如果我想进入互联网行业，有哪些是适合我的呢？</p><p>当时我发现了不少游戏行业的服务端是用 C/C++的，于是尝试了往这个方面去学习和做准备。</p><p>很幸运，秋招结束前，拿到了一家游戏公司的 offer。</p><p>后面的事情，就是跟大部分人一样，在实习中等待着毕业。</p><p>可以了，我的大学生活就聊到这里吧。</p><br><p>之前面试的时候，终面面试官问了我一个问题。</p><p><strong>“如果你有一天，物质和经济条件都自由了，你会做什么？”</strong></p><p>在技术面试里被问这样一个问题，我有点意外。但我心里很快有了答案。</p><p>我之所以能走到今天，单纯是因为当时的那家公司提供了小飞机这样的科创机会，我从这样一个小小的项目开始，人生开始慢慢发生了改变，如果有一天我能有机会，我也希望能像当初别人帮助我那样，去帮助更多跟曾经的我一样的年轻人，去改变他们的人生。</p><br><p>满分满分。我自己都信了。虽然我并没有实现啥啥自由，也不知道自己能为现在的年轻人做点什么，但给个小建议还是可以的。</p><p>就只有一个建议。</p><p>去打一次工吧，打一次毫无技术含量的苦力工。在这之后，你就会明白，比起吃生活的苦，学习的苦都算甜的。</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我本是某科技公司 ceo<br>权力被架空<br>股份被清空<br>现在<br>我只想夺回我的公司<br>现在只差一个 <strong>你的点赞和再看</strong><br>我就能东山再起<br><strong>点击关注《小白 debug》</strong> ，我有一套详细的复仇计划等待实施</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center /><p><img src="https://cdn.xiaobaidebug.top/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP 粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然 IP 层会分片，为什么 TCP 层也还要分段？</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核！阿里面试就是不一样！30张图带你搞懂路由器，集线器，交换机，网桥，光猫有啥区别？</title>
      <link href="/2021/04/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%8130%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%EF%BC%81%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E7%BD%91%E6%A1%A5%EF%BC%8C%E5%85%89%E7%8C%AB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2021/04/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%8130%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%EF%BC%81%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E7%BD%91%E6%A1%A5%EF%BC%8C%E5%85%89%E7%8C%AB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/image-20210404152601935.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>故事就从一个车轱辘说起吧。先来看一个车轱辘。</p><span id="more"></span><p><img src="https://cdn.xiaobaidebug.top/image/%E8%BD%A6%E8%BD%AE.jpeg"></p><p>辐条从车轱辘边缘，一直汇聚到 中心的轴，这个轴在英文里叫<strong>hub</strong>。</p><p>而我们今天要讲到的<strong>集线器</strong>，英文里也叫<strong>hub</strong>。</p><p>都叫<strong>hub</strong>，多少有点关系，看下这面这个图大概能明白，其实两者有点像。</p><p><img src="https://cdn.xiaobaidebug.top/image/hub%E7%9A%84%E7%94%B1%E6%9D%A52.png" alt="hub的由来"></p><p>大概想表达的意思是，它是汇聚网线的中心，因此就叫<strong>集线器</strong>。</p><p>所以可以理解，大家常逛的 <strong>Github，Docker Hub, 还有 P**hub</strong> ，都是为了表达它们是<strong>某类资源的中心</strong>了吧。</p><p><img src="https://cdn.xiaobaidebug.top/image/9e02d8ba2ebbd4a5.jpeg"></p><p>那么<strong>集线器是什么</strong>呢？那就要从<strong>电脑是怎么互联的</strong>这个话题说起。</p><p>小学的时候，有一种网吧，它其实是不能上外网的。也就是不能打开度娘，不能搜索资料。</p><p>不能上网的网吧还能叫网吧？</p><p><img src="https://cdn.xiaobaidebug.top/image/e18d20c94006dfe0-7524faeb6c8ff751-a0be6febc4215ebabfd22cf9ea5b4be8.jpg"></p><p><strong>能</strong>。虽然不能上外网，但网吧老板可以把很多台机子连起来，实现网吧内互联，形成一个<strong>局域网</strong>（<strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork，简称<strong>LAN</strong>）。</p><p>网吧内互联之后，就可以放上各种游戏，比如 CS，实现网吧内对线。</p><p>这种网吧有种好处，<strong>没有那么多键盘侠</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/5c93b203960156ee.jpeg"></p><p>毕竟你不知道什么时候键着键着，对方就<del>顺着网线</del><strong>找过来了</strong>。</p><p>对战直接<strong>从线上转移到线下</strong>了。</p><p>因此大家打游戏都很和谐，客气，场面十分感人就是了。</p><p><img src="https://cdn.xiaobaidebug.top/image/7be71adb6ffe357e.jpeg"></p><p>那么网吧内的电脑是怎么互联呢？</p><h3 id="一根网线互联电脑"><a href="#一根网线互联电脑" class="headerlink" title="一根网线互联电脑"></a>一根网线互联电脑</h3><p>从最简单的场景说起，假设网吧内只有<strong>两台</strong>电脑</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%A4%E5%8F%B0%E7%94%B5%E8%84%91%E4%BA%92%E8%81%94.png" alt="两台电脑互联"></p><p>随便连根网线就能实现互联吗？</p><p><strong>当然不是。</strong></p><p>还记得网络分层吗?</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96.png" alt="网络分层"></p><p>数据如果要进行传输，会从 A 电脑经过这些网络分层把消息组装好，再到 B 电脑层层解包。</p><p>网线，只是代替了上面的<strong>灰色部分</strong>，实现<strong>物理层</strong>上互联。</p><p>如果想要两台电脑互联成功，还需要确保每一层所需要的步骤都要做到位，这样数据才能确保正确投送并返回。</p><p>我们自顶向下，从细节开始说一下实现互联需要做什么。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>该层的网络功能由应用本身保证。</p><p>假设两台电脑是打算用游戏进行联网，那么该应用层的功能由游戏程序保证。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>绝大部分游戏用的传输层协议都是 TCP，我们可以看下<strong>TCP 报头</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B43.png" alt="TCP报头"></p><p>这里面我们需要关注的是<strong>源和目的端口</strong>，这个可以定位到这台电脑上哪个进程在收发数据。</p><p>这两个端口信息一般是游戏内部已经填好。</p><p>AB 两台电脑，其中一台作为服务端启动，比如 A，起了个<strong>服务器</strong>进程。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210330070559257.png" alt="建立服务器"></p><p>服务器会开放一个<strong>固定的端口</strong>，比如 27015。这就是<strong>目的端口</strong>。</p><p>这时候 A 和 B 都可以搜索到这个服务器。启动一个<strong>客户端</strong>进程，连接进入 A 的<strong>服务器</strong>进程。</p><p>而源端口，则由 A 和 B 自己生成。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210330071609786.png"></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>上图除了端口，我们还看到一个<code>192.168.0.105</code>，这个就是 A 的<strong>IP 地址</strong>。</p><p>我们看一下 IP 层的报文头。</p><p><img src="https://cdn.xiaobaidebug.top/image/ip%E6%8A%A5%E5%A4%B43.png" alt="IP报头"></p><p>这里面需要关注是<strong>源和目的 IP 地址</strong>。</p><p>如果两台电脑想通过一根网线进行消息通信，那么他们需要在一个<strong>局域网</strong>内。</p><p>这意味着，他们的子网掩码需要一致。局域网内，假设子网掩码是 <code>225.225.225.0</code>，会认为 <code>192.168.0.x</code> 这些 IP 都属于一个局域网。所以当 A 的 IP 地址是<code>192.168.0.105</code> 时，那么 B 的 IP 地址可以配成<code>192.168.0.106</code> 。</p><p>关于 IP 这一块是啥，后面会细讲，大家如果没明白我说的是啥，不要急。</p><p>组装好网络层报头后，数据包传入到数据链路据层。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>以上解决了网络层的互联，而在数据链路层，数据包里需要拼接上<strong>MAC 报头</strong>。先看下 MAC 报头长什么样子。</p><p><img src="https://cdn.xiaobaidebug.top/image/mac%E6%8A%A5%E5%A4%B41.png" alt="MAC报头"></p><p>其中需要关心的是标红的<strong>源和目的 MAC 地址</strong>。MAC 地址可以粗略理解是这台电脑网卡的唯一标识。大概长这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28:f9:d3:62:7d:31</span><br></pre></td></tr></table></figure><p>源和目的地址，在发送消息的时候就会被填上。</p><p>但是 A 只知道自己的 MAC 地址，怎么才能知道 B 的 MAC 地址呢？</p><p>这时候需要 ARP 协议。</p><p><strong>ARP</strong>（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocal），即地址解析协议。用于将 IP 地址解析为以太网的 MAC 地址的协议。</p><p>在局域网中，当主机 A 有数据要发送给主机 B 时，A 必须知道 B 的 IP 地址。</p><p>但是仅仅有 IP 地址还是不够的，因为 IP 数据报文还需要在<strong>数据链路层</strong>封装成<strong>帧</strong>才能通过物理网络发送。因为发送端还必须有接收端的 MAC 地址，所以需要一个从 IP 地址到 MAC 地址的映射。ARP 就是干这事情的协议。</p><p><img src="https://cdn.xiaobaidebug.top/image/ARP%E6%B5%81%E7%A8%8B1.png" alt="ARP流程"></p><ul><li><p>A 查本地 ARP 表发现 B 的 IP 和 MAC 映射关系不存在</p></li><li><p>A 通过 ARP 广播的形式向局域网发出消息，询问某 IP 对应的 MAC 地址是多少。比如 A 此时知道 B 的 IP，但并不知道 B 的 MAC 地址是多少，就会尝试在局域网内发起 ARP 广播，询问局域网下所有机器，哪个机器的 IP 与 B 的 IP 一致。</p></li><li><p>B 收到这个 ARP 消息，发现 A 要问的 IP 与自己的 IP 一致，就会把自己的 MAC 地址作为应答返回给 A。</p></li><li><p>此时 A 就知道了 B 的 MAC 地址，顺便把消息记录到本地 ARP 表里，下次直接用表里的关系就行，不需要每次都去问。</p></li></ul><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>从数据链路层到物理层，数据会被转为<strong>01 比特流</strong>。</p><p>此时需要把比特流传到另一台电脑。</p><p>通过一根网线，两段水晶头插入网口，把两台电脑连起来。</p><p>但对网线有一些要求。</p><p>这根网线两端的水晶头需要采用<strong>交叉互联法</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%A4%E5%8F%89%E4%BA%92%E8%81%94%E6%B3%951.png" alt="交叉互联法"></p><p>水晶头里有 8 根线，<strong>注意上图里的颜色</strong>，是有顺序的。第 1、2 根线起着收信号的作用，而第 3、6 脚发信号的作用。将一端的 1 号和 3 号线、2 号和 6 号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到。</p><p>当然，现在有些网卡有<strong>自适应</strong>的功能，就算是<strong>直连互联法</strong>的线，也能有<strong>交叉互联法</strong>的效果。如果你用的是这种网卡，就<strong>当我物理层这块什么都没说吧</strong>。</p><h4 id="互联"><a href="#互联" class="headerlink" title="互联"></a>互联</h4><p>此时，在确保<strong>关闭防火墙</strong>的前提下，可以尝试从 A 电脑中 ping 一下 B，再从 B 电脑中 ping 一下 A。如无意外，都能 ping 通。</p><p>A 给 B 发个消息，从应用层到数据链路层，会分别加上 A 和 B 的各种’’身份信息”。比如在传输层会加上 A 和 B 的应用端口号，在网络层加上源和目的 IP，在数据链路层会加上源和目的网卡的 MAC 头部信息。</p><p>B 收到消息后逐层解包，验证，最后顺利到达应用层。实现 AB 两台机器消息互通。</p><p>至此游戏就能正常联机对线，两台电脑互联成功！</p><p><img src="https://cdn.xiaobaidebug.top/image/2ffcf90e51d0ab39.jpeg"></p><h3 id="什么是集线器"><a href="#什么是集线器" class="headerlink" title="什么是集线器"></a>什么是集线器</h3><p>两个人打 cs，总会觉得无聊，但是每台电脑又只有一个网线口。</p><p>想要邀请更多的人一起玩，怎么办？</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%89%E5%8F%B0%E7%94%B5%E8%84%91%E4%BA%92%E8%81%94.png" alt="三台电脑互联"></p><p>那就要回到文章开头提到的<strong>集线器（hub）</strong>了。</p><p>这是个工作在<strong>物理层</strong>的设备。</p><p>有<strong>多个网口</strong>，很好的解决了电脑上只有一个网口的问题，可以做到多台电脑的网线都插入到集线器上。</p><p>同时工作原理也非常简单，会把某个端口收到的数据，输入到<strong>中继电路</strong>。</p><p>中继电路的基本功能是将输入的信号广播到集线器的所有端口上。</p><p>简单来说就是无脑复制 N 份到其余 N 个端口上。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BA%92%E8%81%94.png" alt="集线器互联"></p><p>数据复制到 N 个端口后。对应转发到 N 台机器里。</p><h4 id="集线器内部结构"><a href="#集线器内部结构" class="headerlink" title="集线器内部结构"></a>集线器内部结构</h4><p>说到这里，已经对集线器有个大概认识了。</p><p>接下来，我们看下集线器的内部结构。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="集线器内部结构"></p><p>从 A 网口进入集线器的消息，此时还是电信号。这里经过一个 PHY 模块。</p><blockquote><p>要理解 PHY 模块的作用，首先要先了解每个网口，都可能接着网线（<del>废话</del>），而每根网线的传输的格式都是有可能不同的。而 PHY 的作用，就是把这些格式转化为一个通用的格式。</p><p>举个例子。PHY 就好比一个翻译器，有的人说英文，有的人说日文。但是 PHY，会把它统一转为普通话，给内部电路处理。内部电路处理完之后，再经过 PHY 模块，转为英语，或日文从对应网口里输出。</p></blockquote><p>经过 PHY 的处理后，以电信号的形式输入到中继电路，被无脑广播，再次经过 PHY 模块后变成 BCD 网口的格式输出。</p><p>这里面的电信号，是会受噪声干扰，导致信号形变出错的。</p><p>但就算是错了，也还是会<strong>原封不动</strong>的广播出去，这就是上面提到<strong>无脑</strong>的精髓所在。</p><p><img src="https://cdn.xiaobaidebug.top/image/f650357e0bdd3258.jpeg"></p><p>那信号如果出错了怎么办？</p><p>只能让接收方收到消息后进行校验。</p><p>还记得上文里提到的数据链路层的 MAC 报头里最末尾有个<strong>FCS</strong>吗？</p><p>FCS 里存放的是发送方通过循环冗余校验 CRC 计算得到的值。</p><p><strong>接收方</strong>用收到的数据算一次 CRC，与 FCS 里的值进行对比。</p><p>如果一致，那证明数据没问题。如果出错，则<strong>直接丢弃</strong>。</p><blockquote><p>当然，丢弃包并不会影响数据的传输， 因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包， 并对该包进行重传。</p></blockquote><p>如果消息没出错，但是因为无脑广播，C 也能收到 A 发给 B 的数据包。</p><p>此时 C 会在接受到数据包后一层层的”剥开”。</p><p>正常情况下，在数据链路层时，识别到目的 MAC 地址跟 C 的不一致时，也会把<strong>数据丢弃</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BA%92%E8%81%94%E6%97%B6%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF.png" alt="集线器互联时广播消息"></p><h3 id="什么是交换机"><a href="#什么是交换机" class="headerlink" title="什么是交换机"></a>什么是交换机</h3><p>目前只有 ABC 三台机器，每次都是广播发消息倒还好。</p><p>如果机器越来越多，每台机器发一条消息，都会被广播，就有点顶不住了。</p><p>举个例子。</p><p>假设 N 台机器，其中两台机器 A 和 B，A 发到 B 和 B 发给 A，共两条消息。</p><p>如果这 N 台机器，用的是集线器。还是 AB 之间互发消息，每条消息都是广播的话，就是(N-1)+(N-1)条消息，差距有些大，对网络资源浪费就有些严重了。</p><p>那么，有没有可能做到，A 发给 B 的消息，就不要转发给 C 呢？</p><p>可以的，把集线器换成交换机。</p><p><strong>交换机</strong>，又叫<strong>switch</strong>，跟集线器长得很像。</p><p>但是功能更强一些，从网络分层上来说，属于<strong>数据链路层</strong>，比集线器所在的<strong>物理层</strong>还要高一层。</p><p>所有发到交换机的数据，都会先进入交换机的缓存区。接着消息再被<strong>转发</strong>到对应机器上。</p><p>注意这里用的是<strong>转发</strong>，而不是<strong>集线器的广播</strong>，交换机是怎么做到转发的呢？</p><h4 id="MAC-地址表"><a href="#MAC-地址表" class="headerlink" title="MAC 地址表"></a>MAC 地址表</h4><p>交换机内部维护了一张<strong>MAC 地址表</strong>。</p><p>记录了 端口号和 MAC 地址的对应关系。</p><p>这个表的数据是交换机<strong>不断学习</strong>的结果。</p><p>当 A 发消息到交换机时，交换机发现消息是从 1 号端口进来的，则会在 MAC 地址表上，记录 A 的 MAC 地址对应 1 号端口。</p><p>如果 A 没有很长时间没发消息到这个 1 号端口，那这条记录就会<strong>过期并被删除</strong>。</p><p>那么，当时间足够长，ABC 都发过消息给交换机后，地址表就会有完整的关系信息。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%92%E8%81%94%E6%97%B6%E8%BD%AC%E5%8F%91%E6%B6%88%E6%81%AF1.png" alt="交换机互联时转发消息1"></p><ul><li>A 准备发送消息给 B，此时 A 会把 B 的 MAC 地址，放入要发送的数据里。数据顺着网线发出。</li><li>交换机从端口收到数据，会把数据里的源和目的 MAC 地址提出来，跟 MAC 地址表进行对比。</li><li>发现<strong>B 的 MAC 地址正好在 2 号端口</strong>，那么就把数据转发给 2 号端口。</li><li>此时 B 电脑从网线收到来自交换机 2 号端口的数据。</li></ul><h4 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h4><p>正常流程很清楚了，看两个<strong>特殊情况</strong>：</p><ol><li>交换机查询地址表时，发现目的 MAC 地址的目标端口和这个包的源端口，是同一个端口，怎么办？</li></ol><p>先说结论，<strong>会直接丢弃这个包</strong>。</p><p>我们看下，假设它不丢弃，会发生什么情况。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%80%E8%87%B4%E6%97%B6.png" alt="交换机源和目的端口一致时"></p><ul><li>A 发了个消息给 B，中间经过一个<strong>集线器</strong>，此时消息会被<strong>广播</strong>到 B 和交换机。</li><li>此时 B 收到<strong>第一条</strong>A 发给它的消息</li><li>交换机从 1 号端口收到 A 的消息后，解包，获得目的 MAC 地址是 BB-BB-BB-BB-BB-BB。查 MAC 地址表，发现要发到 1 号端口。此时，源和目的端口都是同一个，<strong>如果交换机不丢弃这个消息</strong>，B 会收到<strong>第二条</strong>A 发给它的消息。</li></ul><p>A 只发了<strong>一次</strong>消息，B 却收到<strong>两条</strong>消息，明显不对。</p><p>因此，当交换机查询地址表时，发现目标端口和源端口，是同一个端口时，会丢弃这个包。</p><ol start="2"><li>MAC 地址表里找不到对应的 MAC 地址，怎么办？</li></ol><p>这可能是因为具有该地址的设备，还没有向交换机发送过包，或者这个设备一段时间没有工作，导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上，都能收到这个包。</p><p>此时，交换机就会跟集线器一样进行<strong>广播</strong>。</p><p>发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入地址表，下次也就不需要把包 发到所有端口了。</p><h4 id="交换机内部结构"><a href="#交换机内部结构" class="headerlink" title="交换机内部结构"></a>交换机内部结构</h4><p>再看下交换机内部结构。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="交换机内部结构"></p><p>其实对比可以发现，交换机和集线器内部结构很像。</p><p>重点需要提到的是 MAC 模块。消息以<strong>电信号</strong>的形式从网口进入，到了 PHY 会被转成<strong>通用格式</strong>的电信号。而 MAC 模块的作用是把这个电信号转为<strong>数字信号</strong>，这样就能提取出 MAC 包头，并通过 MAC 数据帧末尾的<strong>FCS 校验</strong>这个包有没有问题，如果没问题，则把数据放到<strong>内存缓冲区</strong>里，否则直接丢弃。</p><p>另外，这个 MAC 模块，虽然这么叫。但其实<strong>交换机 MAC 模块不具有 MAC 地址</strong>。因此交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p><p>放入到内存缓冲区后，还会把 MAC 地址和端口号记录到 MAC 地址表中。同时检查<strong>目的 MAC 地址</strong>在不在 MAC 地址表中，在的话则会<strong>转发</strong>到对应端口。否则<strong>广播</strong>。</p><h4 id="交换机与网桥的区别"><a href="#交换机与网桥的区别" class="headerlink" title="交换机与网桥的区别"></a>交换机与网桥的区别</h4><p>网桥，本质上可以理解为<strong>两个网线口的交换机</strong>，正好可以把两台电脑给连起来，也叫<strong>桥接</strong>。而交换机，则是<strong>多网线口的网桥</strong>，可以把多台电脑给连（桥接）起来。</p><p>其他功能方面，大差不差，不必太过纠结。</p><h4 id="交换机和二层交换机和三层交换机有什么区别"><a href="#交换机和二层交换机和三层交换机有什么区别" class="headerlink" title="交换机和二层交换机和三层交换机有什么区别"></a>交换机和二层交换机和三层交换机有什么区别</h4><p>这一部分提到的<strong>交换机</strong>，其实就是<strong>二层交换机</strong>，也就是工作在第二层（<strong>数据链路层</strong>）的交换机，二者<strong>没区别</strong>。</p><p>而<strong>三层交换机</strong>，是工作在第三层（<strong>网络层</strong>）的交换机，其实就是接下来要提到的<strong>路由器</strong>。</p><h3 id="什么是路由器"><a href="#什么是路由器" class="headerlink" title="什么是路由器"></a>什么是路由器</h3><p>有了交换机之后，小网吧里的电脑就都可以被连起来了。交换机网口不够？那就再接个交换机。</p><p>但世界上电脑这么多，交换机里的 MAC 地址表难道全都要记住吗?</p><p>显然做不到。为了解决这个问题。</p><p>于是就有了<strong>路由器</strong>，工作在<strong>网络层</strong>，比数据链路层更高一层。</p><p>网络层引入了 IP 的概念。</p><h4 id="什么是-IP"><a href="#什么是-IP" class="headerlink" title="什么是 IP"></a>什么是 IP</h4><p>比如前面提到的 <code>192.168.0.105</code> 就是一个 IP，同一个<strong>局域网</strong>内还可能会有一个 IP 是<code>192.168.0.106</code>。有没有发现，它们都是<code>192.168.0.xxx</code>。</p><p>像极了 <code>上海市.黄浦区.南京东路.105号</code>，这样的地址。现实生活中，我们可以通过一个地址定位到要去哪。到了 <code>上海市.黄浦区.南京东路.105号</code>楼里，我们就可以再去找某个叫身份证为<code>xiaobaixxxxx</code>的人。</p><p>那互联网世界里，我们也就可以通过 IP 地址，定位到某个广域网段，再通过广域网内部的局域网的 MAC 地址定位到具体某个电脑。</p><p><code>上海市.黄浦区.南京东路.105号</code>可以帮助我们定位到在南京东路上的第 105 号楼的位置。但还有些路，比如南京西路，可能不止 105 号，可能要到 257 号。</p><p>实际上一个 IP 由网络号和主机号组成，共 32 位组成。如果拿了前面 24 位做网络号，那主机号就剩 8 位了，2 的 8 次方=256，最多表示表示 256 号楼。因此为了多表示几个楼，可以向网络号多挪几位过来作为主机号。</p><p>那么具体多少位作为网络号呢？可以在 IP 后面加一个数字，用来表明这一点。</p><p>于是就有了 <code>192.168.0.105/24</code>这种表示方法，表明前 24 位<code>192.168.0.0</code>是网络号，105 是主机号。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7.png" alt="网络号和主机号"></p><p><strong>有了网段，就可以一次性表示一大批地址。就不需要像交换机那样苦哈哈的一条一条 MAC 地址记录在表里。</strong></p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由器的作用，可以帮助我们在互联网世界里转发消息到对应的 IP。</p><p>对比一下。</p><p>交换机，是通过 MAC 头部中，接收方 MAC 地址，来判断转发目标的。</p><p>路由器，则是根据 IP 头部中， IP 地址来判断的。</p><p>由于使用的地址不同，记录转发信息的表也会不同。</p><p>类似交换机的 MAC 地址表，路由器也维护了一张<strong>路由表</strong>。</p><p>而路由表，是用于告诉路由器，什么样的消息该转发到什么端口。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E8%B7%AF%E7%94%B1%E4%BA%92%E8%81%94%E6%97%B6.png" alt="路由互联时"></p><p>假设 A 要发消息到 D。也就是<code>192.168.0.105/24</code>要发消息到<code>192.168.1.11/24</code>。</p><p>那么 A 会把消息经过交换机发到路由器。</p><p>路由器通过<code>192.168.0.105/24</code>获得其网络号是 <code>192.168.0.0</code> ，而目的地的网络号是<code>192.168.1.0</code>，二者网络号不同，处于不同局域网。</p><p>查<strong>路由表</strong>，发现<code>192.168.1.0</code>,在 e2 端口，那么就会把消息从 e2 端口发出，到达交换机，交换机发现 MAC 地址是它局域网下的 D 机器，就把消息打过去。</p><p>当然，如果路由表里找不到，那就打到默认<strong>网关</strong>吧，也就是从 e1 口发出，发到 IP<code>192.0.2.1</code>。<strong>这个路由器的路由表不知道该去哪，说不定其他路由器知道</strong>。</p><h4 id="路由器的内部结构"><a href="#路由器的内部结构" class="headerlink" title="路由器的内部结构"></a>路由器的内部结构</h4><p><img src="https://cdn.xiaobaidebug.top/image/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%841.png" alt="路由器内部结构"></p><p>路由器内部，分为<strong>控制平面和数据平面</strong>，说白了就是对应<strong>软件部分和硬件部分</strong>。</p><p>硬件部分跟交换机很像。数据从 A<strong>网口</strong>进入，此时数据还是网线上格式的电信号，会被<strong>PHY 模块</strong>转为通用信号格式，再被<strong>MAC 模块</strong>转为数字信号，通过 FCS 进行错误校验，同时<strong>校验 MAC 地址是否是自己</strong>，通过校验则进入<strong>内存</strong>缓冲区，否则丢弃。</p><p>再进入<strong>软件部分</strong>，由路由选择处理器，通过一定规则（软件逻辑），查询<strong>路由表</strong>判断转发目标和对应<strong>转发口</strong>，再经由<strong>硬件部分</strong>的<strong>交换结构</strong>转发出去。</p><p>如果路由表中<strong>无法找到</strong>匹配记录，路由器会丢弃这个包，并通过<strong>ICMP</strong>消息告知发送方。</p><h4 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h4><h5 id="MAC-模块的区别"><a href="#MAC-模块的区别" class="headerlink" title="MAC 模块的区别"></a>MAC 模块的区别</h5><p>路由器和交换机不同点在于，它的<strong>每个网口下，都有一个 MAC 地址和 IP 地址</strong>。</p><p>正因为路由器具有 MAC 地址，因此它能够成为数据链路层的的<strong>发送方和接收方</strong>。</p><p>怎么理解这句话？</p><p>前面提到交换机，是不具备 MAC 地址的，而<strong>MAC 报头</strong>是需要填上目的 MAC 地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到<strong>目的地</strong>。</p><p>但路由器，是有 MAC 地址的，因此 MAC 报头就可以写上，下一站目的地就是 xx 路由。</p><p>到了路由器后，路由器可以再次组装下一站的目的 MAC 地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p><p>而同时因为交换机不具有 MAC 地址，因此也不会校验收到的数据帧的 MAC 地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的 MAC 报头里的目的 MAC 地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p><h5 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h5><p>如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP 消息告知发送方。</p><p>而交换机在<strong>MAC 地址表</strong>里找不到转发端口时会选择广播。</p><p>这里的处理方式两者是不同的，原因在于网络规模的大小。</p><p>交换机连接的网络最多也就是几千台设备的规模，这个规模并 不大。如果只有几千台设备，遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上，虽然这个方法很简单粗暴，但不会引发什么 问题。</p><p>但路由器工作的网络环境就是互联网，全世界所有的设备都连接在互联网上，规模非常大，并且这个规模还在持续扩大中。如果此时它的操作跟交换机一样，将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞。因此，路由器遇到不知道该转发到哪里的包， 就会直接丢弃。</p><h4 id="路由器和光猫有什么区别"><a href="#路由器和光猫有什么区别" class="headerlink" title="路由器和光猫有什么区别"></a>路由器和光猫有什么区别</h4><p>不管是交换机还是路由器，前面都是提到网口输入的是<strong>电信号</strong>。但现在流行的是<strong>光纤传输</strong>，传输的是<strong>光信号</strong>。</p><p>而<strong>光猫</strong>（modem），是一种调制解调器，其实就是用于<strong>光电信号转换</strong>的设备。</p><p>接收数据时，可以将光纤里的<strong>光信号转化为电信号</strong>，发给路由器，路由器内部再转成数字信号，并在此基础上做各种处理。</p><p>相反，也会把路由器传来的<strong>电信号转为光信号</strong>，发到光纤，并进入互联网。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%85%89%E7%8C%AB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="光猫和路由器的区别2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>两台电脑可以通过一根网线直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（物理层）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产 MAC 地址表，知道消息发到哪，那就<strong>不需要广播</strong>啦</li><li>互联网电脑这么多，交换机 MAC 地址表总不能全放下吧。改用<strong>路由器</strong>（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录 MAC 地址啦。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。</li><li>现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以前整个班的同学家里都不见得有一台电脑，都喜欢偷偷跑去网吧玩电脑。改革开放的春风，把电脑吹进了每家每户，也把网吧给吹成了网咖。</p><p>从前的我晚上偷偷上网，现在的我，接到报警，也能在大半夜爬起来网上冲浪。</p><p>没想到我以这种方式保持了当初最纯粹的质朴。</p><p><img src="https://cdn.xiaobaidebug.top/image/2602a035ddaa4d72.jpeg"></p><p>我是小白，<strong>看下右下角，你懂我意思的</strong>。</p><p>夏天快来了，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>网络是怎么连接的 - 户根勤</p><p>趣谈网络协议- 极客时间</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">硬核图解，TCP 粘包是什么？为什么 UDP 不粘包？</a></p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP粘包  数据包：我只是犯了每个数据包都会犯的错 |硬核图解</title>
      <link href="/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/"/>
      <url>/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61616129034230.png" alt="默认文件1616129034230"></p><p>事情从一个健身教练说起吧。</p><span id="more"></span><p><img src="https://cdn.xiaobaidebug.top/image/0073Cjx6ly1gkbnt17cilj30j60jxgmz.jpg"></p><p>李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件<strong>琛琛</strong>上发布广告。</p><p>键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！</p><p><img src="https://cdn.xiaobaidebug.top/image/9150e4e5jw1fcfryt6ztqg205k041wey.gif"></p><p>还记得<strong>四层网络协议</strong>长什么样子吗？</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE1.png" alt="四层网络协议"></p><p>四层网络模型每层各司其职，消息在进入每一层时都会多加一个<strong>报头</strong>，每多一个报头可以理解为<strong>数据报多戴一顶帽子</strong>。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，**<code>mac头部</code>记录的是硬件的唯一地址，<code>IP头</code>记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程**。</p><p>在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96.png" alt="四层网络协议 (1)"></p><h3 id="为什么要将数据切片"><a href="#为什么要将数据切片" class="headerlink" title="为什么要将数据切片"></a>为什么要将数据切片</h3><p>软件<strong>琛琛</strong>是属于<strong>应用层</strong>上的。</p><p>而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是<strong>传输层上的 TCP 协议</strong>。消息在进入<strong>传输层（TCP）</strong>时会被切片为一个个数据包。这个数据包的长度是<code>MSS</code>。</p><p>可以把网络比喻为一个水管，是有一定的<strong>粗细</strong>的，这个粗细由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>，一般认为是的<code>MTU</code>（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%871.png" alt="数据分片"></p><h3 id="MTU-和-MSS-有什么区别"><a href="#MTU-和-MSS-有什么区别" class="headerlink" title="MTU 和 MSS 有什么区别"></a>MTU 和 MSS 有什么区别</h3><p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="MSS和MTU的区别"></p><ul><li><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU=<strong>1500 Byte</strong>。<br>假设 IP 层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</p></li><li><p><strong>MSS：Maximum Segment Size</strong> 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p></li></ul><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h3><p>那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0%E7%BD%91%E7%BB%9C1.jpg" alt="发送消息到网络"></p><p>网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的<strong>字节流（stream）</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%B6%88%E6%81%AF%E4%BB%8E%E7%BD%91%E7%BB%9C%E6%8E%A5%E6%94%B6.png" alt="消息从网络接收"></p><p>但由于聊天软件<strong>琛琛</strong>是新开发的，而且开发者叫<strong>小白</strong>，完了，是个<strong>臭名昭著的造 bug 工程师</strong>。经过他的代码，在处理<strong>字节流</strong>的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的<strong>粘包</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/testcolour-20210319081110880.png" alt="消息对比"></p><p>一个号称<strong>健康终结者</strong>的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>那就要从 TCP 是啥说起。</p><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="TCP是什么"></p><p>其中跟<strong>粘包</strong>关系最大的就是<strong>基于字节流</strong>这个特点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间<strong>没有任何边界</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.png" alt="二进制字节流"></p><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p><h3 id="为什么要组装发送的数据"><a href="#为什么要组装发送的数据" class="headerlink" title="为什么要组装发送的数据"></a>为什么要组装发送的数据</h3><p>上面提到 TCP <strong>切割</strong>数据包是为了能顺利通过网络这根水管。相反，还有一个<strong>组装</strong>的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较<strong>浪费</strong>网络 io 。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%AD%A3%E5%B8%B8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%852.png" alt="正常发送数据包"></p><p>比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。</p><p>优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先<strong>等待</strong>，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。</p><p>上面说的其实就是<code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/negle2.png" alt="Nagle2"></p><ul><li>由于启动了<strong>Nagle 算法</strong>， msg1 小于 mss ，此时等待<code>200ms</code>内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为<code>MSS</code>。此时发送出去。</li><li>剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。</li><li>剩余的 msg3(2) 长度不足<code>mss</code>，同时在<code>200ms</code>内没有等到下一个包，等待超时，直接发送。</li><li>此时三个包虽然在图里<strong>颜色不同</strong>，但是实际场景中，他们都是<strong>一整个 01 串</strong>，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就<strong>像是两个包粘在一起</strong>，就会导致<strong>粘包问题</strong>。</li></ul><h3 id="关掉-Nagle-算法就不会粘包了吗？"><a href="#关掉-Nagle-算法就不会粘包了吗？" class="headerlink" title="关掉 Nagle 算法就不会粘包了吗？"></a>关掉 Nagle 算法就不会粘包了吗？</h3><p><strong>Nagle</strong> 算法其实是个<strong>有些年代</strong>的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。</p><p>但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。</p><p>所以现在<strong>一般也会把它关掉</strong>。</p><p>看起来，Nagle 算法的优化作用貌似不大，还会导致**粘包”问题”<strong>。那么是不是关掉这个算法就可以解决掉这个</strong>粘包”问题”**呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP_NODELAY = 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/%E5%85%B3%E9%97%ADnegle%E5%B0%B1%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85%E4%BA%86%E5%90%97.png" alt="关闭Nagle就不会粘包了吗"></p><ul><li>接受端应用层在收到 <strong>msg1</strong> 时立马就取走了，那此时 <strong>msg1</strong> 没粘包问题</li><li>**msg2 **到了后，应用层在忙，没来得及取走，就呆在 <strong>TCP Recv Buffer</strong> 中了</li><li>**msg3 **此时也到了，跟 <strong>msg2</strong> 和 <strong>msg3</strong> 一起放在了 <strong>TCP Recv Buffer</strong> 中</li><li>这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中<strong>都是 01 串</strong>，此时一起取走，发现还是粘包。</li></ul><p>因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。</p><p><img src="https://cdn.xiaobaidebug.top/image/image-20210319125906894.png"></p><h3 id="怎么处理粘包"><a href="#怎么处理粘包" class="headerlink" title="怎么处理粘包"></a>怎么处理粘包</h3><p>粘包出现的根本原因是不确定<strong>消息的边界</strong>。接收端在面对**”无边无际”的二进制流<strong>的时候，根本不知道收了多少 01 才算</strong>一个消息<strong>。一不小心拿多了就说是</strong>粘包**。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong>，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。</p><p>常见的方法有</p><ul><li><p>加入特殊标志</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E5%A4%B4%E5%B0%BE%E6%A0%87%E5%BF%97.png" alt="消息边界头尾标志"></p><p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p></li><li><p>加入消息长度信息</p></li></ul><p><img src="https://cdn.xiaobaidebug.top/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%97.png" alt="消息边界长度标志"></p><p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时，关于这一点<a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">上一篇文章</a>里有更详细的说明。</p><p><img src="https://cdn.xiaobaidebug.top/image/006mowZngy1fu63g3y5g1j309q09g3yu.jpg"></p><p>可能这时候会有朋友会问，采用<code>0xfffffe</code>标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？</p><p><img src="https://cdn.xiaobaidebug.top/image/69db3af78753efb7.gif"></p><p>是的，<strong>怕</strong>，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（<code>校验和</code>或者对整段完整数据进行 <code>CRC</code> 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E5%A4%B4%E5%B0%BE%E5%8A%A0%E6%A0%A1%E9%AA%8C%E6%A0%87%E5%BF%97.png" alt="消息边界头尾加校验标志"></p><h3 id="UDP-会粘包吗"><a href="#UDP-会粘包吗" class="headerlink" title="UDP 会粘包吗"></a>UDP 会粘包吗</h3><p>跟 <code>TCP</code> 同为传输层的另一个协议，<strong>UDP，User Datagram Protocol</strong>。用户数据包协议，是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议。</p><p><img src="https://cdn.xiaobaidebug.top/image/udp%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="UDP是什么"></p><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是 IP 层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p>我们先看下<strong>IP 报头</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/ip%E6%8A%A5%E5%A4%B42.png" alt="ip报头"></p><p>注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 <strong>UDP 的报头</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/udp%E6%8A%A5%E5%A4%B44.png" alt="UDP报头"></p><p>在报头中有<code>16bit</code>用于指示 <strong>UDP 数据报文的长度</strong>，假设这个长度是 n ，以此作为<strong>数据边界</strong>。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个<strong>完整的</strong>数据报，从而避免粘包和拆包的问题。</p><p>当然，就算没有这个位（<strong>16 位 UDP 长度</strong>），因为 IP 的头部已经包含了数据的<strong>总长度</strong>信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个<strong>总长度</strong>其实就包含了 UDP 的头部和 UDP 的数据。</p><p>因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了<code>数据和选项</code>以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。</p><p><img src="https://cdn.xiaobaidebug.top/image/UDP%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6-20210319074710451.png" alt="UDP数据长度"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/cb8849427e15334b.jpeg"></p><p>可以再来看下 <strong>TCP 的报头</strong></p><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%8A%A5%E5%A4%B42.png" alt="tcp报头2"></p><p>TCP 首部里是没有长度这个信息的，跟 UDP 类似，同样可以通过下面的公式获得当前包的 TCP 数据长度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/tcp%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6.png" alt="TCP数据长度"></p><p>跟 UDP 不同在于，TCP 发送端在发的时候就<strong>不保证发的是一个完整的数据报</strong>，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。</p><h3 id="为什么长度字段冗余还要加到-UDP-首部中"><a href="#为什么长度字段冗余还要加到-UDP-首部中" class="headerlink" title="为什么长度字段冗余还要加到 UDP 首部中"></a>为什么长度字段冗余还要加到 UDP 首部中</h3><p>关于这一点，查了很多资料，<code>《 TCP-IP 详解（卷2）》</code>里说可能是因为要用于计算校验和。也有的说是因为 UDP 底层使用的可以不是 IP 协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是 IP 层协议，而是其他网络层协议，就不能继续这么计算了。</p><p>但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在 IP 头信息了，那么此时的 UDP 数据会被放在 UDP 的 <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，<strong>如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢</strong>？</p><p>因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。</p><p><img src="https://cdn.xiaobaidebug.top/image/%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E8%A6%81%E5%86%97%E4%BD%99%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5.png" alt="为什么UDP要冗余一个长度字段"></p><p>面试的时候咱就把这些全说出去，<strong>显得</strong>咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，<strong>加分加分</strong>。</p><p>如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！</p><p><img src="https://cdn.xiaobaidebug.top/image/dbdbee64f53762c2.jpeg"></p><h3 id="IP-层有粘包问题吗"><a href="#IP-层有粘包问题吗" class="headerlink" title="IP 层有粘包问题吗"></a>IP 层有粘包问题吗</h3><p>IP 层会对大包进行切片，是不是也有粘包问题？</p><p>先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。</p><p>先看看 IP 层的切片分包是怎么回事。</p><p><img src="https://cdn.xiaobaidebug.top/image/P%E5%88%86%E5%8C%85%E4%B8%8E%E9%87%8D%E7%BB%84.png" alt="P分包与重组"></p><ul><li><p>如果消息过长，<code>IP层</code>会按 <strong>MTU 长度</strong>把消息分成 <strong>N 个切片</strong>，每个切片带有自身在<strong>包里的位置（offset）</strong>和<strong>同样的 IP 头信息</strong>。</p></li><li><p>各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后<strong>在最后的终点汇合后再组装</strong>。</p></li><li><p>在接收端收到第一个切片包时会申请一块新内存，创建 IP 包的数据结构，等待其他切片分包数据到位。</p></li><li><p>等消息全部到位后就把整个消息包给到上层（传输层）进行处理。</p></li></ul><p>可以看出整个过程，<code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。</p><p><code>IP 层</code>表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。</p><p>听起来就像 “<strong>我不管产品的需求傻不傻 X，我实现了就行，我不问，也懒得争了</strong>”，这思路值得每一位优秀的划水程序员学习，<strong>respect</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。</p><ul><li>TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。</li><li>TCP 粘包跟 Nagle 算法有关系，但关闭 Nagle 算法并不解决粘包问题。</li><li>UDP 是基于数据报的传输协议，不会有粘包问题。</li><li>IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。</li><li><code>TCP</code> 发送端可以发 <code>10 次</code>字节流数据，接收端可以分 <code>100 次</code>去取；<code>UDP</code> 发送端发了 <code>10 次</code>数据报，那接收端就要在 <code>10 次</code>收完。</li></ul><p>数据包也只是按着 TCP 的方式进行组装和拆分，<strong>如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已</strong>。</p><p>最后，李东工作没了，而小白表示</p><p><img src="https://cdn.xiaobaidebug.top/image/9150e4e5ly1frrh7t0l9jj20ey0cxq3a.jpg"></p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年 golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解 HTTP 知识点+面试题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a></p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员划水指南</title>
      <link href="/2021/03/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E6%8C%87%E5%8D%97/"/>
      <url>/2021/03/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/2021-1-19/1611015645731-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61611015549650.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><p>快过年了，跟我可爱的小侄子通了个电话，上来就说，”叔叔你头发怎么变少了”，我很痛心，我的小侄子，年纪轻轻的，眼神已经这么不好使了。但转念一想，这也是他对我的一种关心，作为叔叔，也该回应一把，今年过年给他带一本《少儿编程》回去当礼物吧。</p><span id="more"></span><p>但转念又一想，也许我真的头发变少了呢，我强壮的体魄不再足以支撑我肮脏的灵魂了呢，或许真的应了那句古语，<strong>程序员固有一死，要么骚死，要么累死？</strong> 我好残忍，我竟然想让我的小侄走上这么一条不归路。</p><p>可是我这一身编程本领好想传授予人，我还想不想那么快一”猝”而就。我还想看着小侄子长大成人，然后在面试他的时候偷偷放水，再把他招进部门结对编程，我一定要活久一点。我想一定还有跟我一样有未了心愿的程序员，于是今天我将祭出所有划水技能，<strong>希望赠与有缘人</strong>。</p><h2 id="换行业"><a href="#换行业" class="headerlink" title="换行业"></a>换行业</h2><p>这是最直接的解决方案，那么问题来了，应该去哪个行业呢？程序员下岗后一般再就业的岗位不是送外卖就是送快递，这两个工作从工作强度和工作时长来说，丝毫不比程序员轻松。这就片面了。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-19/1611015053542-ysqiqillllll.jpg"></p><p>有时间送快递和外卖的话，那不如老老实实考个公务员吧。程序员怎么成为公务员？这里正好有一个 github 项目，就教你如何成为一个公务员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/coder2gwy/coder2gwy</span><br></pre></td></tr></table></figure><p>连怎么安排学习时间，怎么请假都安排得明明白白，贼吉尔细心。<br><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610882082277-image.png"></p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610882318401-image.png"></p><h2 id="跳槽到-965-的公司"><a href="#跳槽到-965-的公司" class="headerlink" title="跳槽到 965 的公司"></a>跳槽到 965 的公司</h2><p>从程序员跳槽到公务员或者是教师这条路子比较艰难，虽然我相信大部分程序员在考试上面都比常人要更擅长些。</p><p>一旦选择考公务员，等于放弃自己学习多年的技能，什么<code>mysql</code>，<code>redis</code>，<code>java</code>，<code>设计模式</code>这些，都将成为过眼云烟，选择成本巨大。就算成了，也可能会后悔，或许会在某个四下无人的下午三点，用当年的程序员杯子装着这周 xx 办主任送的茶叶泡的茶，写着 <strong>《下班总结》</strong>，感叹这个世界少了一个出色的程序员。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610882815684-image.png"><br>那么跳槽到一个 965 的公司，可能可以帮助你更好地划水。那么问题来了，怎么样找到 995 的公司？</p><p>还记得 n 年前的那个 996icu 吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610883077766-image.png"><br>里面贴心地给出了一份 996 的公司名单，如果你坚决拒绝 996，那么从拒绝这份名单里的公司 offer 开始。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU/tree/master/blacklist</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610883287402-image.png"><br>同时给出了这些公司 996 的证据，真正做到”拒绝张嘴就来”和有理有据，非常符合程序员讲事实摆道理的性格。</p><p>建议大家根据钱包厚度和身体承受能力进行选择，996 下班不可怕，可怕的是，半夜一个报警就可以爬起来愉快网上冲浪了。以前高中的时候还要翻墙出去网吧通宵，现在在家里就能做到！</p><p>同时也给出了一份 965 的公司名单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU/tree/master/whitelist</span><br></pre></td></tr></table></figure><p>但是值得一提，这些公司都比较少，同时不排除哪一天不会变成 996。毕竟制度是人定的，公司也是要盈利的，哪天换了个领导冲 kpi，大家也只能一起冲冲冲了。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610883626689-image.png"><br>结论上来说，996 的公司比 965 的公司<strong>多太多</strong>，大部分有志青年都在 996 的公司里，<strong>既然无法避免，那就要学会怎么在工作中划水</strong>。</p><h2 id="学会划水"><a href="#学会划水" class="headerlink" title="学会划水"></a>学会划水</h2><p>如果你已经在 996 的公司里，同时你的钱包需要你通过这种方式出卖劳动，那么显然换行业，跳槽，都不太适合，毕竟轻松意味着钱少。那么怎么在 996 公司里防猝死呢？<br>划水成为唯一答案，划水其实也是一种技术，是分等级的，下面分享几个实用的划水技巧。</p><h3 id="初级划水技能"><a href="#初级划水技能" class="headerlink" title="初级划水技能"></a>初级划水技能</h3><p>初级划水技能是属于每个程序员都要学会的基础技能。</p><h4 id="不要让自己看起来很闲"><a href="#不要让自己看起来很闲" class="headerlink" title="不要让自己看起来很闲"></a>不要让自己看起来很闲</h4><p>不管是因为你是真的很闲，还是因为你效率高很快把活干完了。如果你看起来很闲，老板就容易会认为你工作不饱和，从而不断加活，直到你看起来一直在忙为止。既然如此，如果你一直看起来很忙，那么这样的问题可以被很好的避免。而 vscode 是程序员最常用的编辑器，我们可以在此基础上找到很多划水神器。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896648119-image.png"></p><h5 id="模拟写代码"><a href="#模拟写代码" class="headerlink" title="模拟写代码"></a>模拟写代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/zy445566/vscode-plugin-swimming</span><br></pre></td></tr></table></figure><p>代码写的快，提早完工被压榨怎么办？你需要一个模拟写代码工具，让 VSCode 模拟写代码，划水、摸鱼神器，让代码自己重写一遍。<br><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610885030551-image.png"></p><h5 id="看小说工具"><a href="#看小说工具" class="headerlink" title="看小说工具"></a>看小说工具</h5><p>上学那会偷偷摸摸看小说时会在小说本上套上一层课本封面，以此来掩盖上课划水的行为。同样的道理，下面这个插件感觉跟上课看小说的经历有点像，他让开发者可以在 VSCode 上边写代码边看小说。</p><p>下次等产品经理路过你身旁的时候，以为你写了一堆密密麻麻的的代码，都不好意思再给你加需求。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610885854313-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/zrk1993/read-vscode-e</span><br></pre></td></tr></table></figure><h5 id="听音乐插件"><a href="#听音乐插件" class="headerlink" title="听音乐插件"></a>听音乐插件</h5><p>做事做全套，还要在 vscode 装上听音乐的插件。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610885464251-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nondanee/vsc-netease-music</span><br></pre></td></tr></table></figure><h5 id="炒股"><a href="#炒股" class="headerlink" title="炒股"></a>炒股</h5><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610885801992-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/roblourens/vscode-stocks</span><br></pre></td></tr></table></figure><h3 id="中级划水技能"><a href="#中级划水技能" class="headerlink" title="中级划水技能"></a>中级划水技能</h3><h4 id="项目时间预估"><a href="#项目时间预估" class="headerlink" title="项目时间预估"></a>项目时间预估</h4><p>每次需求迭代，产品都会让开发给出一个开发时间。</p><p>我接触过的百分之 90 的程序员都是老实的小伙子，是多少就报多少，有些为了方便产品快速看效果，还会压缩自己的时间，这种情况在新人程序员里尤为明显。</p><p>但有些不讲武德的产品，会动不动做一点 <strong>小小的改动</strong>，同时因为改动<strong>较小</strong>，之前提到的时间一般不会更改。</p><p>如果你所在的项目中产品不止一个人，就可能出现多个产品给你提需求的情况，改动不大，但挺急。</p><p>一个程序员越老实，就越不会表达，选择闷头苦干，有些甚至牺牲节假日时间在家干活。</p><p>因此为了更好的应对这些非常常见的情况，建议再估计工时的时候，都多预估至少 20~50%的时间当做 buffer。</p><p>如果你提前做好需求，请务必不要提前给产品看，这只会方便他在看到实物后做出更多的变更。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896715125-image.png"></p><h4 id="如何巧妙的推掉需求"><a href="#如何巧妙的推掉需求" class="headerlink" title="如何巧妙的推掉需求"></a>如何巧妙的推掉需求</h4><p>很多产品在做每一期迭代开发需求的时候，会有无穷无尽的想法，而且恨不得都全部实现，最好今天就能给到。</p><p>大部分老实的程序员，会选择尽可能满足这些可爱的需求。这些永远没办法做完的需求，才是耗尽程序员心力的重要因素。</p><p>你需要给每个需求和变更排期，给需求留足 buffer，确保线上出问题的时候你还有时间去处理。</p><p><strong>让产品给这些需求排优先级</strong>，从高到低，算好每个需求的人日，做不了一定要提出来，剩下的让不同产品去 pk 优先级，确保你不过劳。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896919790-image.png"></p><h4 id="减少不必要的沟通"><a href="#减少不必要的沟通" class="headerlink" title="减少不必要的沟通"></a>减少不必要的沟通</h4><p>很多不明真相的产品、运营、其他部门的开发会通过各种途径找到你，大部分时候他们找你都是为了向你询问一些无关痛痒的问题。</p><p>有些时候当他们询问的问题触及技术细节的时候，新人程序员都会想要试图产生程序实现原理细节。</p><p>请记住一句话，<strong>千万不要跟不是搞技术的人聊实现细节，如果可以，最好别跟任何人聊技术实现细节</strong>，不仅会把他们的思路带跑偏，还会越解释越迷糊。</p><p>另外还有一些人遇到一些疑问，会用企业微信或钉钉找到你，如果这个人说的事情不是紧急的事情，同时没有直接找到你面前，<strong>尽量选择过半小时后再处理</strong>。</p><p>你要相信他们自己解决问题的能力，大部分不重要或跟你关系不大的问题，会因为你的延缓处理<strong>自动消失</strong>。</p><p>大部分真正需要你解决的问题，<strong>半小时后还会再找你一次</strong>。</p><p>另外，哪怕不听音乐，带上耳机，可以减少 10%的无效沟通，懂的自然懂。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896784810-image.png"></p><h4 id="提升办事效率"><a href="#提升办事效率" class="headerlink" title="提升办事效率"></a>提升办事效率</h4><p>提升办事效率是为了减少自己无用时间的支出，从而不至于让自己没有时间在工作之余锻炼休闲。</p><p>提升效率这个事情其实比较简单。</p><p>选择适合自己的办公软件。比如印象笔记或有道云笔记来记录工作要点和备忘，用番茄学习时间来强迫自己专心写代码，同时还能装个眼睛护士定时提醒自己要放松一下眼睛。<br> 另外我个人强烈建议大家<strong>多喝水</strong>。<br><img src="https://cdn.xiaobaidebug.top/image/2021-1-19/1611011972160-%E5%A4%9A%E5%96%9D%E7%83%AD%E6%B0%B4.png"></p><p>另外推荐几个 VSCode 效率插件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.infoq.cn/article/c4wbmkc7sslz28gyazll</span><br></pre></td></tr></table></figure><p>mac 效率神器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Louiszhai/tool</span><br></pre></td></tr></table></figure><h3 id="高级划水技能"><a href="#高级划水技能" class="headerlink" title="高级划水技能"></a>高级划水技能</h3><p>划水的最高技巧是提升技术水平，可以减少排查问题的时间，提升工作效率，更好的预估时间（意味着可以更精确地给自己多估两天排期）。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610897376592-%E5%BF%99.png"></p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896517264-image.png"></p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610897804737-%E5%BF%992.png"></p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896443862-image.png"></p><p>只有提升自身硬实力，才能打破这个死循环。</p><p>下面介绍一个 golang 程序员学习提升的项目,里面有超全的 golang 面试问题整理，用问题驱动去学习。</p><p>同时还有一张完整的入门进阶知识图谱，值得 star 一个啊。关于其他编程语言的学习路线，欢迎各位私信我学习地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xiaobaiTech/golangFamily</span><br></pre></td></tr></table></figure><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-8/1610113159235-GO%E6%88%90%E9%95%BF%E8%B7%AF%E7%BA%BF.jpg"></p><h2 id="学会管理自己的时间"><a href="#学会管理自己的时间" class="headerlink" title="学会管理自己的时间"></a>学会管理自己的时间</h2><p>要学习时间管理，就要像这个领域里最顶尖的大师学习。</p><p>而这个领域里我只认罗老师，罗老师去年荣获时间管理大师称号。在业务能力上罗老师绝对是个优秀的好歌手好演员，各领域开花，忙是不可避免的，工作强度不会比程序员弱。<br>在此基础上，还能做到宛如影分身之术一般时间管理能力，除了熬出两个黑眼圈外，身体却十分硬朗。仔细一想，罗老师是在承受着身体和心理都在长时间承受高强度的压力，但却不影响他身心健康。</p><p>我们可以好好分析一下，罗老师为什么能在硬朗这件事情上做的如此出类拔萃。个人拙见，有三点</p><h3 id="热爱自己的事业"><a href="#热爱自己的事业" class="headerlink" title="热爱自己的事业"></a>热爱自己的事业</h3><p>我们可以看下，罗老师的日程表。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610880071658-WX20210117-183727@2x.png"></p><p>这工作强度映射到程序员身上，也差不多跟连续开会写代码 997 差不多了吧，然而他却硬朗得很。</p><p>他到底是怎么做到的呢？一言以蔽之，<strong>热爱</strong>。解 bug 的过程可能是难受压抑紧张的，但是解 bug 成功带来的成就感真的很爽。</p><p>如果不热爱这份工作，那么成就感没了，只剩下难受和压抑了，不快乐的人，说不定哪天<strong>说没就没了</strong>。<br><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896061077-image.png"></p><h3 id="锻炼身体"><a href="#锻炼身体" class="headerlink" title="锻炼身体"></a>锻炼身体</h3><p>他热爱跳舞，被称为“亚洲舞王”。虽然这个称呼有点夸张，但是他不是天赋型选手，跳舞能力是花时间练出来的。</p><p>而跳舞这件事情，和健身类似，让身体动起来了，出汗了，你自然就爽了。</p><p>大家应该都有一种感觉，运动，会让你出汗，会让身体巨酸巨累，但是这个过程中，会让心情变得畅快不压抑，还能让你<strong>因为敲代码而变得瘦弱的肱二头肌变得粗壮一些</strong>。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896129039-image.png"></p><h3 id="事业之外还有自己的爱好"><a href="#事业之外还有自己的爱好" class="headerlink" title="事业之外还有自己的爱好"></a>事业之外还有自己的爱好</h3><p>这个世界上只有一种真正的英雄主义，就是在认清生活的真相之后，还能热爱生活。</p><p>很多程序员在大学刚毕业的时候，都想着自己以后能做一个牛逼哄哄的软件，然后跟乔布斯一样改变这个世界，但是往往又在几年后选择成为一条咸鱼，每天疲惫于跟产品经理斗智斗勇，只要能砍掉哪怕一个需求，那也是一次重大胜利。</p><p>我们都只是普通人，产品经理没错，程序猿也没错，当一条咸鱼也挺香的，但是在工作中当咸鱼可以，唯唯诺诺可以，但下了班，你必须重拳出击。</p><p>你得有自己的爱好，可以是爬山旅游，篮球游泳。如果这些都太索然无味，你还可以去酒吧跟各种臭妹妹坏弟弟喝上一杯。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610895957764-image.png"></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>要<strong>每天看一遍凉凉的新闻</strong>，坚定自己划水的信念。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896383124-image.png"></p><p>鲁迅曾经说过，<strong>划水最好的时候两个时间，一个是十年前，一个是现在</strong>。你懂我意思吧？<br><img src="https://cdn.xiaobaidebug.top/image/2021-1-17/1610896285339-image.png"></p><p>没懂? <strong>点个在看，你的每一次扩散都可能拯救一个累垮边缘的程序猿！</strong><br><img src="https://cdn.xiaobaidebug.top/image/2021-1-10/1610269930614-640.png"></p><p><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核！漫画图解HTTP基础+面试题</title>
      <link href="/2021/02/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/02/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/2021-2-19/1613693230446-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61613437659307.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白 debug」第一时间阅读，回复【教程】获 golang 免费视频教程。本文已经收录在 GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎 Star。</p></blockquote><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613317170976-%E4%B8%8D%E8%A6%81%E6%89%93%E6%89%B0%E6%88%91%E5%AD%A6HTTP.jpg" style="zoom:100%" /><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613436372639-b%E7%AB%99%E6%92%B8%E7%8C%AB%E5%A4%A7%E5%9B%BE.png"></p><span id="more"></span><h1 id="什么是-HTTP"><a href="#什么是-HTTP" class="headerlink" title="什么是 HTTP"></a>什么是 HTTP</h1><p>HTTP 全称<strong>超⽂文本传输协议</strong>，也就是<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol。<br>其中我们常见的<strong>文本，图片，视频</strong>这些东西都可以用超文本进行表示，而我常看的猫片，也属于超文本，所以大家不要再说我偷偷看猫片了，我只是在看超文本。HTTP 只是定义了一套传输超文本的规则，只要符合了这一套规则，不管你是用 iphone，还是用老爷机，都可以实现猫片的传输。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041437612-http%E4%BC%A0%E8%BE%93%E7%A4%BA%E4%BE%8B%E6%BC%AB%E7%94%BB.jpg"></p><h1 id="七层网络"><a href="#七层网络" class="headerlink" title="七层网络"></a>七层网络</h1><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613013885789-image.png" alt="网络协议"></p><p>大概了解了<strong>HTTP</strong>后，给大家看看它在它们家族里的地位。HTTP 位于<strong>应用层</strong>，跟它类似的协议还有常见的<strong>FTP 协议</strong>，常见的<strong>某影天堂</strong>的下载链接曾经经常是以<strong>FTP 开头</strong>的。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613007117086-image.png"></p><h1 id="HTTP-报文格式"><a href="#HTTP-报文格式" class="headerlink" title="HTTP 报文格式"></a>HTTP 报文格式</h1><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613021710607-http%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90.jpg"></p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041939151-image.png" style="zoom:100%" /><p>有点抽象？不知道小白说的啥？那实操一下，用<code>wireshark</code>抓包看一下猫片里的请求报文和响应报文具体长什么样子吧</p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/cmaskboss/164203142_30_1.enhance.webmask</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>upos-sz-staticks3.bilivideo.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://www.bilibili.com</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>cross-site</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>cors</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>empty</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://www.bilibili.com/</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>identity</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=0-16</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这上面第一行的 GET 就是<strong>请求方法</strong>，<code>/cmaskboss/164203142_30_1.enhance.webmask</code> 则是 <strong>URL</strong> , 而<code>HTTP/1.1</code>则是<strong>协议版本</strong>。接下来从<code>Host</code>开始到最后一行<code>Range</code>，都是<strong>Headers 头</strong>。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/octet-stream</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>17</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Tengine</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;92086de1e6d1d4791fb950a0ac7e30ba&quot;</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 30 Jan 2021 09:31:31 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Sun, 04 Oct 2020 01:54:28 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Mon, 01 Mar 2021 09:31:31 GMT</span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">: </span>1018695</span><br><span class="line"><span class="attribute">Content-Range</span><span class="punctuation">: </span>bytes 0-16/353225</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">X-Application-Context</span><span class="punctuation">: </span>application</span><br><span class="line"><span class="attribute">x-kss-request-id</span><span class="punctuation">: </span>75bcbfa8ab194e3c825e89c81a912692</span><br><span class="line"><span class="attribute">x-kss-BucketOwner</span><span class="punctuation">: </span>MjAwMDAyMDEwNw==</span><br><span class="line"><span class="attribute">X-Info-StorageClass</span><span class="punctuation">: </span>-</span><br><span class="line"><span class="attribute">Content-MD5</span><span class="punctuation">: </span>kght4ebR1HkfuVCgrH4wug==</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-JH-MP-01-03</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-TJ-UN-14-13</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-LF-UN-11-25</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://www.bilibili.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Origin,X-Requested-With,Content-Type,Accept,range</span><br><span class="line"><span class="attribute">X-Cdn-Request-ID</span><span class="punctuation">: </span>7e2c783ca7d392624118593ec1dc66bc</span><br></pre></td></tr></table></figure><p>类似请求报文，<code>HTTP/1.1</code>是<strong>协议版本</strong>，<code>206</code>是<strong>状态码</strong>，<code>Partial Content</code> 则是<strong>状态描述符</strong>。接下来从<code>Content-Type</code>开始到最后一行<code>X-Cdn-Request-ID</code>都是<strong>Headers 信息</strong>。</p><h1 id="报文信息解读"><a href="#报文信息解读" class="headerlink" title="报文信息解读"></a>报文信息解读</h1><p>其实上面的抓包信息，在浏览器里按 F12 就能看到，之所以要用<code>wireshark</code>可能<strong>只是装 X 效果比较好吧</strong>。按下 F12 看到的响应数据就跟下图展示的那样。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613043758890-image.png" style="zoom:100%" /><h2 id="1-请求数据"><a href="#1-请求数据" class="headerlink" title="1.请求数据"></a>1.请求数据</h2><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613046030107-image.png" style="zoom:100%" /><h2 id="2-响应数据"><a href="#2-响应数据" class="headerlink" title="2.响应数据"></a>2.响应数据</h2><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613046094269-image.png" style="zoom:100%" /><h2 id="3-Request-URL"><a href="#3-Request-URL" class="headerlink" title="3.Request URL"></a>3.Request URL</h2><h3 id="URL-是什么"><a href="#URL-是什么" class="headerlink" title="URL 是什么"></a>URL 是什么</h3><p>URL 代表着是统一资源定位符（Uniform Resource Locator）。作用是为了告诉使用者 某个资源在 Web 上的地址。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像或一个猫片等等。上面我们请求猫片的 URL 就是 <code>https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.enhance.webmask</code> 这里面细分，又可以分为好几个部分。</p><ul><li>协议部分</li></ul><p>表示该 URL 的协议部分为 http 还是 https，会用//为分隔符。上面的 URL 表示网页用的是 HTTPS 协议，而上面提到的 X 影天堂用的则是 ftp 协议的下载链接。</p><ul><li>域名部分</li></ul><p>域名是<code>upos-sz-staticks3.bilivideo.com</code>，在发送请求前，会向 DNS 服务器解析 IP，如果已经知道 ip，还可以跳过 DNS 解析那一步，直接把 IP 当做域名部分使用。</p><ul><li>端口部分</li></ul><p>域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个 URL 的必须的部分。当网址为<strong>http://<strong>时，默认端口为</strong>80</strong></p><p>当网址为<strong>https://<strong>时，默认端口为</strong>443</strong>，以上两种都可以省略端口号。上面的 URL 其实<strong>省略了 443 端口</strong>号。</p><ul><li>虚拟目录</li></ul><p>从域名的第一个/开始到最后一个/为止，是虚拟目录的部分。虚拟目录也不是 URL 必须的部分，本例中的虚拟目录是<code>/cmaskboss/</code></p><ul><li>文件名部分</li></ul><p>从域名最后一个/开始到?为止，是文件名部分；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。本例中的文件名是<code>164203142_30_1.enhance.webmask</code>，文件名也不是一个 URL 的必须部分。</p><h3 id="URL-和-URI-的区别"><a href="#URL-和-URI-的区别" class="headerlink" title="URL 和 URI 的区别"></a>URL 和 URI 的区别</h3><ul><li><strong>URL</strong>:Uniform Resource Locator <strong>统一资源定位符</strong>；</li><li><strong>URI</strong>: Uniform Resource Identifier <strong>统一资源标识符</strong>；</li></ul><p>其实一直有个误解，很多人以为 URI 是 URL 的子集，其实应该反过来。URL 是 URI 的子集才对。简单解释下。<br>假设”小白”(URI)是一种资源，而”在迪丽亦巴的怀里”表明了一个位置。如果你想要找到（locate）小白，那么你可以到”在迪丽亦巴怀里”找到小白，而”在迪丽亦巴怀里的/小白”才是我们常说的 URL。而”在迪丽亦巴怀里的/小白”（URL）显然是”小白”（URI）的子集，毕竟，”小白”还可能是”在牛亦菲怀里的/小白”（其他 URL）。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613045259027-Untitled%20Diagram%20(3).jpg" style="zoom:100%" /><h2 id="4-Request-Method"><a href="#4-Request-Method" class="headerlink" title="4.Request Method"></a>4.Request Method</h2><p>HTTP 定义了一组<strong>请求方法</strong>，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作.。虽然他们也可以是名词，但这些请求方法有时被称为 HTTP 动词.。每一个请求方法都实现了不同的语义。</p><p>这次请求猫片的请求里用的是 GET，意味着获取。但其实 HTTP 定义了多种请求方法，来满足各种需求。除了 Get，还有几个 POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613055907068-GET%E8%B7%9F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84%E8%BF%98%E6%9C%897%E4%B8%AA.jpg" style="zoom:100%" /><p>常见的各个请求方法的具体功能如下：</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>请求指定的页面信息，并返回消息主体(body)+头信息(header)。</p><h3 id="HEAD："><a href="#HEAD：" class="headerlink" title="HEAD："></a>HEAD：</h3><p>HEAD 和 GET 本质是一样的，区别在于 HEAD 只返回头信息(header)，不返回消息主体(body)。大家不要以为它没用，它跟 GET 和 POST 一样，在 http/1.0 的时候就存在了，实属三元老之一了。主要用途</p><ul><li><p>如果想要判断某个资源是否存在，虽然用 GET 也能做到，但这里用 HEAD 还省下拿 body 的消耗，返回状态码 200 就是有 404 就是无</p></li><li><p>如果请求的是一个比较大的资源，比如一个超大视频和文件，你只想知道它到底有多大，而不需要整个下载下来，这时候使用 HEAD 请求，返回的 headers 会带有文件的大小（<code>content-lenght</code>）。</p></li></ul><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。POST 跟 GET 最常用，但最大的区别在于，POST 每次调用都可能会修改数据，是非幂等的，而 GET 类似于只读，是幂等的。</p><h3 id="PUT："><a href="#PUT：" class="headerlink" title="PUT："></a>PUT：</h3><p>这个方法比较少见。在 HTTP 规范中 POST 是非等幂的，多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而 PUT id/xiaobai 则会创建一个 id 为 xiaobai 的用户，多次调用还是会创建的结果是一样的，所以 PUT 是等幂的。但是一般为了避免造成心智负担，实战中也会使用 POST 替代 PUT。</p><h3 id="DELETE："><a href="#DELETE：" class="headerlink" title="DELETE："></a>DELETE：</h3><p>删除某一个资源。基本上这个也很少见，一般实战中如果是删除操作，也是使用 POST 来替代。</p><h3 id="OPTIONS："><a href="#OPTIONS：" class="headerlink" title="OPTIONS："></a>OPTIONS：</h3><h4 id="options-是什么"><a href="#options-是什么" class="headerlink" title="options 是什么"></a>options 是什么</h4><p>它用于获取当前 URL 所支持的方法。若请求成功，则它会在 HTTP 响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法。比如下图：</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613058818793-image.png" style="zoom:100%" /><p>这里面需要关注的点有两个</p><ul><li><p>Request Header 里的关键字段</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-12/1613060189629-options%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5%20(2).jpg"></p></li><li><p>Response Header 里的关键字段</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613174205328-_options%E5%93%8D%E5%BA%94%E5%AD%97%E6%AE%B5%20(1).jpg"></p></li></ul><p><code>Options</code>堪称是网络协议中的老实人，就好像老实人刚谈了个女朋友，每次牵手前都要问下人家 “我可以牵你的手吗？”， “我可以抱你吗？”，得到了答应后才会下手。差点被这老实人气质感动得留下了不争气的泪水。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613057652579-%E5%8A%A0%E5%86%95%E4%B8%BA%E7%8E%8B.jpg" style="zoom:100%" /><h4 id="什么时候需要使用-options"><a href="#什么时候需要使用-options" class="headerlink" title="什么时候需要使用 options"></a>什么时候需要使用 options</h4><p>在<strong>跨域</strong>（记住这个词，待会解释）的情况下，浏览器发起<strong>复杂请求前</strong>会<strong>自动</strong>发起 options 请求。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p><p>这里提到了两个关键词：</p><ul><li>跨域</li><li>复杂请求</li></ul><h4 id="什么是简单请求和复杂请求。"><a href="#什么是简单请求和复杂请求。" class="headerlink" title="什么是简单请求和复杂请求。"></a>什么是简单请求和复杂请求。</h4><p>某些请求不会触发 CORS 预检请求，这样的请求一般称为”简单请求”，而会触发预检的请求则为”复杂请求”。</p><p>1.简单请求</p><ul><li>请求方法为<code>GET、HEAD、POST</code></li><li>只有以下<code>Headers</code>字段<ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>DPR/Downlink/Save-Data/Viewport-Width/Width</code> (这些不常见，放在一起)</li></ul></li><li><code>Content-Type</code> 只有以下三种<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li><li>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；</li><li>请求中没有使用 ReadableStream 对象。</li></ul><p>2.复杂请求</p><ul><li>不满足简单请求的，都是复杂请求</li></ul><p>由此可见，因为上述请求在获取网上资源的请求 Headers 里带有 <code>Access-Control-Request-Headers: range</code> , 而<code>range</code>正好不在简单请求的条件 2 中提到的 Headers 范围里，因此属于<strong>复杂请求</strong>，于是触发预检 options 请求。</p><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>刚刚提到了一个词叫<strong>跨域</strong>，那什么是跨域呢？在了解跨域之前，首先要了解一个概念：<strong>同源</strong>。所谓<strong>同源</strong>是指，<strong>域名、协议、端口均相同</strong>。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613041939151-image.png" style="zoom:100%" /><p>不明白没关系，举个例子。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613311181978-%E6%98%AF%E5%90%A6%E5%90%8C%E6%BA%90.jpg"></p><p>需要特别注意的是，localhost 和 127.0.0.1 虽然都指向本机，但也<strong>不属于同源</strong>。</p><p>而<strong>非同源</strong>之间网页调用就是我们所说的<strong>跨域</strong>。在<strong>浏览器</strong>同源策略限制下，向不同<strong>源</strong>发送 XHR 请求，<strong>浏览器</strong>认为该请求不受信任，禁止请求，具体表现为请求后不正常响应。</p><h4 id="options-带来什么问题"><a href="#options-带来什么问题" class="headerlink" title="options 带来什么问题"></a>options 带来什么问题</h4><p>由此可见，复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送 2 次请求（一次预检 options，一次复杂请求），这一次 options 就一来一回（一个 RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613176456625-%E5%8A%A0%E5%86%95%E4%B8%BA%E7%8E%8B%20(2).jpg" style="zoom:100%" /><h4 id="如何优化-options"><a href="#如何优化-options" class="headerlink" title="如何优化 options"></a>如何优化 options</h4><p>每次复杂请求前都会调用一次 options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这一次查询？</p><p><code>Access-Control-Max-Age</code>就是优化这个流程中使用的一个 Header。它的作用是当你每次请求<code>options</code>方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和 Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 <code>Access-Control-Max-Age</code>时间（单位是秒）里都支持，则这段时间内，不再需要使用 options 进行请求。特别注意的是，当<code>Access-Control-Max-Age</code>的值为-1 时，表示禁用缓存，每一次请求都需要发送预检请求，即用 OPTIONS 请求进行检测。</p><p><img src="https://cdn.xiaobaidebug.top/image/options%E4%BC%98%E5%8C%96%E5%90%8E.jpg" alt="options优化后"></p><h2 id="5-Status-Code"><a href="#5-Status-Code" class="headerlink" title="5.Status Code"></a>5.Status Code</h2><h3 id="状态码是什么"><a href="#状态码是什么" class="headerlink" title="状态码是什么"></a>状态码是什么</h3><p>HTTP Status Code 是常说的 HTTP 状态码。当用户访问一个网页时，浏览器会向网页所在服务器发出请求。服务器则会根据请求作出响应，而状态码则是响应的一部分，代表着本次请求的结果。所有状态码的第一个数字代表了响应的大概含义，组合上第二第三个数字则可以表示更具体的原因。如果请求失败了，通过这个状态码，大概初步判断出这次请求失败的原因。以下是五类状态码的含义。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-11/1613045090544-%E7%8A%B6%E6%80%81%E7%A0%81%E8%A1%A8%E6%A0%BC.jpg"></p><h3 id="状态码流程"><a href="#状态码流程" class="headerlink" title="状态码流程"></a>状态码流程</h3><p>可以根据以下流程图了解下各类状态码间的关系。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-15/1613345953784-Copy%20of%202xx%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" style="zoom:150%" /><ul><li>2xx 和 3xx 之间的流程关系</li></ul><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613439607255-2xx%E6%B5%81%E7%A8%8B%E5%9B%BE%20(2).jpg"></p><ul><li>4xx 的状态流程</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-15/1613403987304-4xx%E6%B5%81%E7%A8%8B.jpg" style="zoom:100%" /><ul><li>5xx 的状态流程</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-16/1613406108083-5xx%E6%B5%81%E7%A8%8B%E5%9B%BE%20(1).jpg" style="zoom:100%" /><h3 id="常见状态码介绍"><a href="#常见状态码介绍" class="headerlink" title="常见状态码介绍"></a>常见状态码介绍</h3><ul><li>200 OK</li></ul><p>这是最常见的状态码。代表请求已成功，数据也正常返回。而请求猫片虽然响应成功了，但却不是 200，而是 206，是为什么呢，接下去继续看看。</p><ul><li>206 Partial Content</li></ul><p>这个状态码在上面请求的响应结果。服务器已经成功处理了部分 GET 请求。类似于看视频或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><ul><li><p>307 Temporary Redirect</p><p>内部重定向。重定向的意思是，当你输入一个网址的时候，浏览器会自动帮你跳转到另外一个网址上。比如，当你在浏览器输入框输入<code>http://www.baidu.com/</code>时。由于使用 http 并不安全，百度会自动帮你跳转到它对应的 https 网页上。而此时，需要重定向的地址，会通过<code>Response Headers</code>的<code>Location</code>返回</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-13/1613187421644-image.png" style="zoom:100%" /></li><li><p>404 Not Found</p><p>请求失败，请求所希望得到的资源未被在服务器上发现。出现这个错误的最有可能的原因是服务器端没有这个页面，或者是 Request Method 与注册 URL 的 Method 不一致，比如我有一个 URL 在服务端注册的 Request Method 为 <strong>POST</strong>，但调用的时候却错误用了<strong>GET</strong>，则也会出现 404 错误。</p></li><li><p>499 Client has closed connection</p><p>网络请求过程中，由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777634555-Get%E5%92%8CPost%20(1).jpg"></p></li><li><p>502 Bad Gateway</p><p>服务器方面无法给予正常的响应。一般常见于服务器崩溃后，nginx 无法正常收到服务端的响应，给客户端返回 502 状态码。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777745819-502%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"></p></li><li><p>504 Gateway Timeout</p><p>网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于 nginx 设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于 499 表示的是客户端超时，504 是网关超时。如果是 499 超时，可以考虑修改客户端的代码调整超时时间，如果是 504，则考虑调整 nginx 的超时配置。</p><p><img src="https://cdn.xiaobaidebug.top/image/2021-2-20/1613777517520-504%E7%9A%84%E8%BF%87%E7%A8%8B%20(1).jpg"></p></li></ul><h2 id="6-Headers"><a href="#6-Headers" class="headerlink" title="6. Headers"></a>6. Headers</h2><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p><code>Content-Length</code>是 HTTP 的消息长度, 用<strong>十进制数字</strong>表示。<code>Content-Length</code>首部指出报文中消息的当前实际字节大小。如果消息文本进行了 gzip 压缩的话， <code>Content-Length</code>指的就是压缩后的大小而不是原始大小。</p><p>正常情况下<code>Content-Length</code>是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现<code>Content-Length</code>与实际要发送的消息大小不一致，就会出现一些问题。</p><ul><li><p>如果<code>Content-Length</code> &lt; 实际长度</p><p>下面启动一个 HTTP 服务器，所有语言都一样，示例里使用了 golang。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// w表示response对象，返回给客户端的内容都在对象里处理</span></span><br><span class="line"><span class="comment">// r表示客户端请求对象，包含了请求头，请求参数等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;request body=%#v, content_length=%v \nheaders=%v&quot;</span>,<span class="keyword">string</span>(b), r.ContentLength, r.Header)</span><br><span class="line"><span class="comment">// 往w里写入内容，就会在浏览器里输出</span></span><br><span class="line">fmt.Fprintf(w, <span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置路由，如果访问/，则调用index方法</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动web服务，监听9090端口</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> $ curl -L -X POST <span class="string">&#x27;http://127.0.0.1:9999&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -H <span class="string">&#x27;Content-Length: 5&#x27;</span> -d <span class="string">&#x27;1234567&#x27;</span> |  jq</span></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    12  100     5  100     7    828   1160 --:--:-- --:--:-- --:--:--  1400</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>输入的 body 是 <code>1234567</code>，共<strong>7 个数字</strong>，但是输入的 <code>Content-Length</code>为 5。到了服务器那，收到了 <code>12345</code>，共<strong>5 个数字</strong>，数量上跟输入的<code>Content-Length</code>一致。 由此可见当<code>Content-Length</code> &lt; 实际长度， 消息会被截断。</p></li><li><p>如果<code>Content-Length</code> &gt; 实际长度</p><p>还是上面的服务端代码，但是控制台输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -X POST <span class="string">&#x27;http://127.0.0.1:9999&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -H <span class="string">&#x27;Content-Length: 100&#x27;</span> -d <span class="string">&#x27;1234567&#x27;</span> | jq</span></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100     7    0     0    0     7      0      0 --:--:--  0:01:19 --:--:--     0</span><br></pre></td></tr></table></figure><p>这次情况不太一样，会发现请求一直阻塞没有返回。这是因为输入的 body 是 <code>1234567</code>，共<strong>7 个数字</strong>，但是输入的 <code>Content-Length</code>为 100。也就是服务端一直认为这次的 body<strong>长度为 100</strong>，但是目前只收到了<strong>部分消息（长度为 7）</strong>，剩余的长度为 93 的消息由于各种原因<strong>还在路上</strong>，因此选择<strong>傻傻等待剩下的消息</strong>，就造成了上面提到的阻塞。</p></li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613299089850-image.png" style="zoom:100%" /><p>视频播放需要支持用户调整播放进度，支持让用户选择直接跳到中间部分开始播放。为了实现这个功能，需要通过 HTTP Range Requests 协议用于指定需要获取视频片段。而 Request Header 里的 range 头则是用于指定要请求文件的起始和结束位置。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613298634191-image.png" style="zoom:100%" /><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613298705993-image.png" style="zoom:100%" /><ul><li>如果服务器不支持，直接忽略 Range 头，浏览器会正常按流式加载整个视频文件，以状态码 200 响应即可。另外，当我们在 html 中放一个 video 标签，浏览器会直接发起一个 <code>Range: bytes=0-</code> 的请求，向服务器请求从开始到结尾的完整文件。</li><li>如果服务器支持 Range Requests，会读取视频文件，并将他的第 162653 ～ 242638 字节提取出来，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推 20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的 Response Headers 中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range 描述了响应覆盖的范围和整个实体长度。一般格式：<code>Content-Range：开始字节位置-结束字节位置／文件大小（byte）</code>。</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><h4 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h4><ul><li><p>Connection: close</p><p>表示请求响应完成之后立即关闭连接，这是 HTTP/1.0 请求的默认值。每次请求都经过“创建 tcp 连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接”这样的过程</p></li><li><p>Connection: keep-alive</p><p>表示连接不立即关闭，可以继续响应下一个请求。HTTP/1.1 的请求默认使用一个持久连接。可以做到只建立一次连接，多次资源请求都复用该连接，完成后关闭。流程上是 建立 tcp 连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; … （保持连接）… -&gt; 第 n 次请求资源 -&gt; 第 n 次响应资源 -&gt; 释放连接。</p></li></ul><p>在 http1.1 中 Request Header 和 Reponse Header 中都有可能出现一个 Connection: keep-alive 头信息。Request Header 里的 Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而 Response Header 里的 Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会<strong>返回 Connection: close ，相当于告诉客户端“我不支持长连接，你死了这条心，老老实实用短连接吧</strong>” 。</p><h4 id="HTTP-为什么要使用长连接"><a href="#HTTP-为什么要使用长连接" class="headerlink" title="HTTP 为什么要使用长连接"></a>HTTP 为什么要使用长连接</h4><p>我们知道 HTTP 建立在 TCP 传输层协议之上，而 TCP 的建立需要三次握手，关闭需要四次挥手，这些步骤都需要时间，带给 HTTP 的就是请求响应时延。如果使用短连接，那么每次数据传输都需要经历一次上面提到的几个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升 HTTP 性能有很大的帮助。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613290339498-http%E7%9F%AD%E8%BF%9E%E6%8E%A5.jpg" style="zoom:100%" /><ul><li>可以看到，在使用 Connection: close 通信时，每次都需要重新经历一次握手挥手。可以通过 Connection: keep-alive 省下这部分的资源消耗。</li></ul><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613292366161-http%E9%95%BF%E8%BF%9E%E6%8E%A5.jpg" style="zoom:100%" /><ul><li><strong>长连接</strong>可以<strong>省去较多的 TCP 建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。</li><li>解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放。</li></ul><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><h4 id="Cookies-是什么"><a href="#Cookies-是什么" class="headerlink" title="Cookies 是什么"></a>Cookies 是什么</h4><ol><li><p>Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。里面一般带有该浏览器的身份信息。</p></li><li><p>浏览器需要保存这段数据，不得轻易删除。</p></li><li><p>此后每次浏览器访问该服务器，都必须带上这段数据。服务器用使用这段数据确认浏览器身份信息。</p></li></ol><h4 id="Cookie-的作用"><a href="#Cookie-的作用" class="headerlink" title="Cookie 的作用"></a>Cookie 的作用</h4><p>Cookie 一般有两个作用。</p><p>1.识别用户身份。</p><ul><li>举个例子。用户 A 用浏览器访问了“猫猫网”，“猫猫网”的服务器就会立刻给 A 返回一段 Cookie 数据，内含「uid=a」。</li><li>当 A 再次访问“猫猫网”下的其他页面时，比如跳转到“猫猫交友评论”，就会附带上「uid=a」这段数据。</li><li>同理，用户 B 用浏览器访问“猫猫网” 时，就给 B 分配了一段 Cookie 数据，内含「uid=b」。B 之后访问“猫猫网”的时候，就会一直带上「uid=b」这段数据。</li><li>因此“猫猫网”的服务器通过 Cookie 数据就能区分 A 和 B 两个用户了。</li></ul><p>2.持久化用户信息。</p><ul><li>因为 cookies 的数据会被用户浏览器保存到本地下。因此可以利用这一特点保持一些简单的用户数据。</li><li>比如一些博客网站，可以通过 cookies 记录下用户的性别年龄等信息，以此进行一些个性化展示。</li><li>当然上面提到的都是一些比较粗糙的场景，是为了方便大家理解 cookies 的功能。实际使用 cookies 会非常谨慎。</li></ul><h3 id="Referrer-Policy-和-Referrer"><a href="#Referrer-Policy-和-Referrer" class="headerlink" title="Referrer Policy 和 Referrer"></a>Referrer Policy 和 Referrer</h3><img src="https://cdn.xiaobaidebug.top/image/2021-2-1/1612146090912-image.png" style="zoom:100%" /><h4 id="Referrer-是什么"><a href="#Referrer-是什么" class="headerlink" title="Referrer 是什么"></a>Referrer 是什么</h4><p>Referrer 是 HTTP 请求 header 的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的。比如在上面的请求截图里，可以看出我是使用<code>https://www.bilibili.com/</code>访问的视频资源。</p><h4 id="Referrer-Policy-是什么"><a href="#Referrer-Policy-是什么" class="headerlink" title="Referrer Policy 是什么"></a>Referrer Policy 是什么</h4><ul><li><p>Referrer 字段，会用来指定该请求是从哪个页面跳转页来的，里面的信息是浏览器填的。</p></li><li><p>而 Referrer Policy 则是用于控制 Referrer 信息传不传、传哪些信息、在什么时候传的策略。</p></li></ul><p>为什么要这么麻烦呢？因为有些网站一些用户敏感信息，比如 sessionid 或是 token 放在地址栏里，如果当做 Referrer 字段全部传递的话，那第三方网站就会拿到这些信息，会有一定的安全隐患。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容。</p><p>比如在上面的请求截图里，可以看出我是使用<code>strict-origin-when-cross-origin</code>策略，含义是跨域时将当前页面 URL 过滤掉参数及路径部分，仅将协议、域名和端口（如果有的话）当作 Referrer。否则 Referrer 还是传递当前页的全路径。同时当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。</p><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h3><h4 id="什么是-cache-control"><a href="#什么是-cache-control" class="headerlink" title="什么是 cache-control"></a>什么是 cache-control</h4><p>cache-control，用于控制浏览器缓存。简而言之，当某人访问网站时，其浏览器将在本地保存某些资源，例如图像和网站数据。当该用户重新访问同一网站时，缓存控制设置的规则会确定该用户是否从本地缓存中加载这些资源，或者浏览器是否必须向服务器发送新资源的请求。</p><h4 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h4><p>浏览器缓存是指浏览器本地保存网站资源，以便不必再次通过网络从服务器获取它们。例如，“猫猫网”的背景图像可以保存到本地缓存中，这样在用户第二次访问该页面时，该图像将从用户的本地文件加载，剩下网络获取资源的时间，页面加载速度就会更快。</p><p>但是浏览器也不会永远把这些网站资源放在本地，否则本地磁盘就会炸，所以会限定保存资源的时间，这叫生存时间（TTL）。如果 TTL 过期后用户请求缓存的资源，浏览器必须再次通过网络与服务器建立连接并重新下载这个资源。</p><h4 id="常见的缓存控制策略"><a href="#常见的缓存控制策略" class="headerlink" title="常见的缓存控制策略"></a>常见的缓存控制策略</h4><ul><li><p>cache-control: private<br>具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN 或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。</p></li><li><p>cache-control: public<br>相反，“public”指令表示资源可以由任何缓存存储。</p></li><li><p>cache-control: no-store<br>带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。</p></li><li><p>cache-control: max-age<br>此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。</p></li><li><p>cache-control: no-cache</p><p>从网页截图里可以看出，使用的缓存控制指令是<code>cache-control: no-cache</code>。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 <code>ETag</code>。</p></li></ul><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613297647760-image.png" style="zoom:100%" /><p>Etag 是 Entity tag 的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。</p><p>比如，浏览器第一次请求资源的时候，服务端返回了这个资源的<code>ETag: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code>。</p><p>当浏览器再次请求这个资源的时候，浏览器会将<code>If-None-Match: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code> 传输给服务端，服务端拿到该 ETAG，对比资源是否发生变化。</p><ul><li>如果资源未发生改变，则返回 304HTTP 状态码，不返回具体的资源。</li><li>否则表示资源已经更新，浏览器需要下载新版本以提供给用户。</li></ul><p>此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>看个猫片都能学到这么多硬核知识。接下来我打算去舞蹈区看看有没有适合你们的知识点。</p><img src="https://cdn.xiaobaidebug.top/image/2021-2-14/1613314979045-%E8%84%B8%E7%BA%A2%E5%BC%80%E5%BF%83.jpg" style="zoom:100%" /><p>我是小白，有空？一起在知识的海洋里呛水啊，懂我意思？</p><img src="https://cdn.xiaobaidebug.top/image/2021-1-10/1610269930614-640.png" style="zoom:100%" /><img src="https://cdn.xiaobaidebug.top/1696069689495.png" style="zoom:100%" /><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>- [1] 计算机网络自动向下</p><p>- [2] 极客时间-趣谈网络协议</p><p>- [3] 极客时间-透视 HTTP</p><p>- [4] 图解 HTTP</p><p>- [5] 漫画形象-小肥柴</p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题。</title>
      <link href="/2020/11/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98/"/>
      <url>/2020/11/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/DMGVKJ"><img src="https://s3.ax1x.com/2020/11/20/DMGVKJ.png"></a></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">6</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; num; index++ &#123;</span><br><span class="line">resp, _ := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">_, _ = ioutil.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;此时goroutine个数= %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>上面这道题在不执行<code>resp.Body.Close()</code>的情况下，泄漏了吗？如果泄漏，泄漏了多少个<code>goroutine</code>?</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>不进行<code>resp.Body.Close()</code>，泄漏是一定的</strong>。但是泄漏的<code>goroutine</code>个数就让我迷糊了。由于执行了<strong>6遍</strong>，每次泄漏一个<strong>读和写goroutine</strong>，就是<strong>12个goroutine</strong>，加上<code>main函数</code>本身也是一个<code>goroutine</code>，所以答案是<strong>13</strong>.</li><li>然而执行程序，发现<strong>答案是3</strong>，出入有点大，为什么呢？</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>我们直接看源码。<code>golang</code> 的 <code>http</code> 包。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http.Get()</span><br><span class="line"></span><br><span class="line">-- DefaultClient.Get</span><br><span class="line">----<span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span></span></span><br><span class="line">------<span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span></span><br><span class="line">-------- resp, didTimeout, err = send(req, c.transport(), deadline) </span><br><span class="line"><span class="comment">// 以上代码在 go/1.12.7/libexec/src/net/http/client:174 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Transport</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明 <code>http.Get</code> 默认使用 <code>DefaultTransport</code> 管理连接。<h5 id="DefaultTransport-是干嘛的呢？"><a href="#DefaultTransport-是干嘛的呢？" class="headerlink" title="DefaultTransport 是干嘛的呢？"></a><code>DefaultTransport</code> 是干嘛的呢？</h5></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// It establishes network connections as needed</span></span><br><span class="line"><span class="comment">// and caches them for reuse by subsequent calls.</span></span><br></pre></td></tr></table></figure><ul><li><code>DefaultTransport</code> 的作用是根据需要建立网络连接并缓存它们以供后续调用重用。<h5 id="那么-DefaultTransport-什么时候会建立连接呢？"><a href="#那么-DefaultTransport-什么时候会建立连接呢？" class="headerlink" title="那么 DefaultTransport 什么时候会建立连接呢？"></a>那么 <code>DefaultTransport</code> 什么时候会建立连接呢？</h5>接着上面的代码堆栈往下翻</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> </span><br><span class="line">--resp, err = rt.RoundTrip(req) <span class="comment">// 以上代码在 go/1.12.7/libexec/src/net/http/client:250</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *http.Request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">(ctx context.Context, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">go</span> pconn.readLoop()  <span class="comment">// 启动一个读goroutine</span></span><br><span class="line"><span class="keyword">go</span> pconn.writeLoop() <span class="comment">// 启动一个写goroutine</span></span><br><span class="line"><span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次建立连接，就会启动一个<code>读goroutine</code>和<code>写goroutine</code>。这就是为什么一次<code>http.Get()</code>会泄漏<code>两个goroutine</code>的来源。</li><li>泄漏的来源知道了，也知道是因为没有执行<code>close</code></li></ul><h5 id="那为什么不执行-close-会泄漏呢？"><a href="#那为什么不执行-close-会泄漏呢？" class="headerlink" title="那为什么不执行 close 会泄漏呢？"></a>那为什么不执行 <code>close</code> 会泄漏呢？</h5><ul><li>回到刚刚启动的<code>读goroutine</code> 的 <code>readLoop()</code> 代码里 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">alive := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> alive &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">// Before looping back to the top of this function and peeking on</span></span><br><span class="line"><span class="comment">// the bufio.Reader, wait for the caller goroutine to finish</span></span><br><span class="line"><span class="comment">// reading the response body. (or for cancelation or death)</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">pc.t.setReqCanceler(rc.req, <span class="literal">nil</span>) <span class="comment">// before pc might return to idle pool</span></span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">bodyEOF &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br><span class="line"><span class="keyword">if</span> bodyEOF &#123;</span><br><span class="line">eofc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Cancel:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.CancelRequest(rc.req)</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Context().Done():</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>简单来说<code>readLoop</code>就是一个死循环，只要<code>alive</code>为<code>true</code>，<code>goroutine</code>就会一直存在</li><li><code>select</code> 里是 <code>goroutine</code> <strong>有可能</strong>退出的场景：<ul><li><code>body</code> 被读取完毕或<code>body</code>关闭</li><li><code>request</code> 主动 <code>cancel</code></li><li><code>request</code> 的 <code>context Done</code> 状态 <code>true</code></li><li>当前的 <code>persistConn</code> 关闭</li></ul></li></ul><p>其中第一个 <code>body</code> 被读取完或关闭这个 <code>case</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alive = alive &amp;&amp;</span><br><span class="line">    bodyEOF &amp;&amp;</span><br><span class="line">    !pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">    tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure><p><code>bodyEOF</code> 来源于到一个通道 <code>waitForBodyRead</code>，这个字段的 <code>true</code> 和 <code>false</code> 直接决定了 <code>alive</code> 变量的值（<code>alive=true</code>那<code>读goroutine</code>继续活着，循环，否则退出<code>goroutine</code>）。</p><h5 id="那么这个通道的值是从哪里过来的呢？"><a href="#那么这个通道的值是从哪里过来的呢？" class="headerlink" title="那么这个通道的值是从哪里过来的呢？"></a>那么这个通道的值是从哪里过来的呢？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go/1.12.7/libexec/src/net/http/transport.go: 1758</span></span><br><span class="line">body := &amp;bodyEOFSignal&#123;</span><br><span class="line">body: resp.Body,</span><br><span class="line">earlyCloseFn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">waitForBodyRead &lt;- <span class="literal">false</span></span><br><span class="line">&lt;-eofc <span class="comment">// will be closed by deferred call at the end of the function</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">fn: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">isEOF := err == io.EOF</span><br><span class="line">waitForBodyRead &lt;- isEOF</span><br><span class="line"><span class="keyword">if</span> isEOF &#123;</span><br><span class="line">&lt;-eofc <span class="comment">// see comment above eofc declaration</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cerr := pc.canceled(); cerr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cerr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果执行 <code>earlyCloseFn</code> ，<code>waitForBodyRead</code> 通道输入的是 <code>false</code>，<code>alive</code> 也会是 <code>false</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就会退出。</li><li>如果执行 <code>fn</code> ，其中包括正常情况下 <code>body</code> 读完数据抛出 <code>io.EOF</code> 时的 <code>case</code>，<code>waitForBodyRead</code> 通道输入的是 <code>true</code>，那 <code>alive</code> 会是 <code>true</code>，那么 <code>readLoop()</code> 这个 <code>goroutine</code> 就不会退出，同时还顺便执行了 <code>tryPutIdleConn(trace)</code> 。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn&#x27;t registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><ul><li><code>tryPutIdleConn</code> 将 <code>pconn</code> 添加到等待新请求的空闲持久连接列表中，也就是之前说的连接会复用。</li></ul><h5 id="那么问题又来了，什么时候会执行这个-fn-和-earlyCloseFn-呢？"><a href="#那么问题又来了，什么时候会执行这个-fn-和-earlyCloseFn-呢？" class="headerlink" title="那么问题又来了，什么时候会执行这个 fn 和 earlyCloseFn 呢？"></a>那么问题又来了，什么时候会执行这个 <code>fn</code> 和 <code>earlyCloseFn</code> 呢？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> es.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> es.closed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">es.closed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> es.earlyCloseFn != <span class="literal">nil</span> &amp;&amp; es.rerr != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> es.earlyCloseFn() <span class="comment">// 关闭时执行 earlyCloseFn</span></span><br><span class="line">&#125;</span><br><span class="line">err := es.body.Close()</span><br><span class="line"><span class="keyword">return</span> es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面这个其实就是我们比较收悉的 <code>resp.Body.Close()</code> ,在里面会执行 <code>earlyCloseFn</code>，也就是此时 <code>readLoop()</code> 里的 <code>waitForBodyRead</code> 通道输入的是 <code>false</code>，<code>alive</code> 也会是 <code>false</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就会退出，<code>goroutine</code> 不会泄露。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b, err = ioutil.ReadAll(resp.Body)</span><br><span class="line">--<span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> </span><br><span class="line">----<span class="function"><span class="keyword">func</span> <span class="title">readAll</span><span class="params">(r io.Reader, capacity <span class="keyword">int64</span>)</span></span> </span><br><span class="line">------<span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go/1.12.7/libexec/src/bytes/buffer.go:207</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line">m, e := r.Read(b.buf[i:<span class="built_in">cap</span>(b.buf)])  <span class="comment">// 看这里，是body在执行read方法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>read</code>，其实就是 <code>bodyEOFSignal</code> 里的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">n, err = es.body.Read(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">... </span><br><span class="line">    <span class="comment">// 这里会有一个io.EOF的报错，意思是读完了</span></span><br><span class="line">err = es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">condfn</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> es.fn == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = es.fn(err)  <span class="comment">// 这了执行了 fn</span></span><br><span class="line">es.fn = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面这个其实就是我们比较收悉的读取 <code>body</code> 里的内容。 <code>ioutil.ReadAll()</code> ,在读完 <code>body</code> 的内容时会执行 <code>fn</code>，也就是此时 <code>readLoop()</code> 里的 <code>waitForBodyRead</code> 通道输入的是 <code>true</code>，<code>alive</code> 也会是 <code>true</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就不会退出，<code>goroutine</code> 会泄露，然后执行 <code>tryPutIdleConn(trace)</code> 把连接放回池子里复用。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>所以结论呼之欲出了，虽然执行了 <code>6</code> 次循环，而且每次都没有执行 <code>Body.Close()</code> ,就是因为执行了<code>ioutil.ReadAll()</code>把内容都读出来了，连接得以复用，因此只泄漏了一个<code>读goroutine</code>和一个<code>写goroutine</code>，最后加上<code>main goroutine</code>，所以答案就是<code>3个goroutine</code>。</li><li>从另外一个角度说，正常情况下我们的代码都会执行 <code>ioutil.ReadAll()</code>，但如果此时忘了 <code>resp.Body.Close()</code>，确实会导致泄漏。但如果你<strong>调用的域名一直是同一个</strong>的话，那么只会泄漏一个 <code>读goroutine</code> 和一个<code>写goroutine</code>，<strong>这就是为什么代码明明不规范但却看不到明显内存泄漏的原因</strong>。</li><li>那么问题又来了，为什么上面要特意强调是同一个域名呢？改天，回头，以后有空再说吧。</li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/myGJ4TrEoVGqLAN3tbZHMw">连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。</a> </li><li><a href="https://mp.weixin.qq.com/s/SHxcspmiKyPwPBbhfVxsGA">昨天那个在for循环里append元素的同事，今天还在么？</a> </li><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有中文、数字、英文字母的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"><a href="#如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。" class="headerlink" title="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"></a>如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。</h6>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。</title>
      <link href="/2020/10/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%9Enil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%80%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%83%BD%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%9F%E9%82%A3BAT%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AA%E5%A5%BD%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%E4%BA%86%E3%80%82/"/>
      <url>/2020/10/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%9Enil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%80%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%83%BD%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%9F%E9%82%A3BAT%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AA%E5%A5%BD%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%E4%BA%86%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.xiaobaidebug.top/image/640-20210524195843699.png" alt="img"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>   <span class="comment">// nil切片</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)  <span class="comment">// 空切片</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)   <span class="comment">// 空切片</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;s1 pointer:%+v, s2 pointer:%+v, s4 pointer:%+v, \n&quot;</span>, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4)))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4))).Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nil切片和空切片指向的地址一样吗？这个代码会输出什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）</strong></li><li><strong>空切片的引用数组指针地址是有的，且固定为一个值</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 pointer:&#123;Data:0 Len:0 Cap:0&#125;, s2 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, s4 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, </span><br><span class="line">false //nil切片和空切片指向的数组地址不一样</span><br><span class="line">true  //两个空切片指向的数组地址是一样的，都是824634207952</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>之前在<a href="https://zhuanlan.zhihu.com/p/144923309">前面的文章</a>里提到过切片的数据结构为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"> Data <span class="keyword">uintptr</span>  <span class="comment">//引用数组指针地址</span></span><br><span class="line"> Len  <span class="keyword">int</span>     <span class="comment">// 切片的目前使用长度</span></span><br><span class="line"> Cap  <span class="keyword">int</span>     <span class="comment">// 切片的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>nil切片和空切片最大的区别在于<strong>指向的数组引用地址是不一样的</strong>。<br><img src="https://cdn.xiaobaidebug.top/image/640.png" alt="img"></p></li><li><p><strong>所有的空切片指向的数组引用地址都是一样的</strong><br><img src="https://cdn.xiaobaidebug.top/image/640-20210524195829623.png" alt="img"></p></li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/257802146">昨天那个在for循环里append元素的同事，今天还在么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/150629411">对已经关闭的的 chan 进行读写，会怎么样？为什么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/149796956">对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/148341972">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/148175563">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/146590283">golang面试题：怎么避免内存逃逸？？</a></li><li><a href="https://zhuanlan.zhihu.com/p/145468000">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/144923309">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/143056105">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/144980413">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://zhuanlan.zhihu.com/p/145220416">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"><a href="#如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。" class="headerlink" title="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"></a>如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。</h6>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>昨天那个在for循环里append元素的同事，今天还在么？</title>
      <link href="/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%98%A8%E5%A4%A9%E9%82%A3%E4%B8%AA%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E9%87%8Cappend%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8C%E4%BA%8B%EF%BC%8C%E4%BB%8A%E5%A4%A9%E8%BF%98%E5%9C%A8%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%98%A8%E5%A4%A9%E9%82%A3%E4%B8%AA%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E9%87%8Cappend%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8C%E4%BA%8B%EF%BC%8C%E4%BB%8A%E5%A4%A9%E8%BF%98%E5%9C%A8%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/09/23/cPoMQsnbLIExiBZ.png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v:=<span class="keyword">range</span> s &#123;</span><br><span class="line">s =<span class="built_in">append</span>(s, v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s)=%v\n&quot;</span>,<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码会造成死循环吗？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>不会死循环</strong>，<code>for range</code>其实是<code>golang</code>的<code>语法糖</code>，在循环开始前会获取切片的长度 <code>len(切片)</code>，然后再执行<code>len(切片)</code>次数的循环。</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>for range</code>的源码是<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The loop we generate:</span></span><br><span class="line"><span class="comment">//   for_temp := range</span></span><br><span class="line"><span class="comment">//   len_temp := len(for_temp)</span></span><br><span class="line"><span class="comment">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span></span><br><span class="line"><span class="comment">//           value_temp = for_temp[index_temp]</span></span><br><span class="line"><span class="comment">//           index = index_temp</span></span><br><span class="line"><span class="comment">//           value = value_temp</span></span><br><span class="line"><span class="comment">//           original body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure></li><li>上面的代码会被编译器认为是</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">for_temp := s</span><br><span class="line">len_temp := <span class="built_in">len</span>(for_temp)</span><br><span class="line"><span class="keyword">for</span> index_temp := <span class="number">0</span>; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">value_temp := for_temp[index_temp]</span><br><span class="line">_ = index_temp</span><br><span class="line">value := value_temp</span><br><span class="line"><span class="comment">// 以下是 original body</span></span><br><span class="line">s =<span class="built_in">append</span>(s, value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s)=%v\n&quot;</span>,<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码运行输出<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)=<span class="number">6</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">7</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">8</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">9</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>所以说，那个同事用的是golang吗？</strong></p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://s1.ax1x.com/2020/09/22/wqH8c8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么避免内存逃逸？</title>
      <link href="/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%83%BD%E8%AF%B4%E8%AF%B4uintptr%E5%92%8Cunsafe.Pointer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/"/>
      <url>/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%83%BD%E8%AF%B4%E8%AF%B4uintptr%E5%92%8Cunsafe.Pointer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jZDJkODUxZS1hZWQ1LTRlNjYtOGFmNy0wMjczZDc0NDgzNzAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>怎么避免<strong>内存逃逸</strong>？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>在<code>runtime/stubs.go:133</code>有个函数叫<code>noescape</code>。<code>noescape</code>可以在逃逸分析中<strong>隐藏一个指针</strong>。让这个指针在逃逸分析中<strong>不会被检测为逃逸</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// noescape hides a pointer from escape analysis.  noescape is</span></span><br><span class="line"> <span class="comment">// the identity function but escape analysis doesn&#x27;t think the</span></span><br><span class="line"> <span class="comment">// output depends on the input.  noescape is inlined and currently</span></span><br><span class="line"> <span class="comment">// compiles down to zero instructions.</span></span><br><span class="line"> <span class="comment">// USE CAREFULLY!</span></span><br><span class="line"> <span class="comment">//go:nosplit</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">     x := <span class="keyword">uintptr</span>(p)</span><br><span class="line">     <span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">S *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *f.S</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ATrick <span class="keyword">struct</span> &#123;</span><br><span class="line">S unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ATrick)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(f.S)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> A&#123;S: &amp;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewATrick</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">ATrick</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">x := <span class="keyword">uintptr</span>(p)</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">f1 := NewA(s)</span><br><span class="line">f2 := NewATrick(s)</span><br><span class="line">s1 := f1.String()</span><br><span class="line">s2 := f2.String()</span><br><span class="line">_ = s1 + s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">6</span>: can inline (*ATrick).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">6</span>: can inline NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">6</span>: can inline noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">6</span>: can inline NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">29</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">36</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: inlining call to NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">17</span>: inlining call to (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">17</span>: inlining call to (*ATrick).String</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build763863171/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">15</span>: noescape p does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">10</span>: main f1 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">10</span>: main f2 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">42</span>:<span class="number">9</span>: main s1 + s2 does not escape</span><br></pre></td></tr></table></figure><p>其中主要看中间一小段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap    <span class="comment">//这个是NewA中的，逃逸了</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape <span class="comment">// NewATrick里的s的却没逃逸</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p>上段代码对<code>A</code>和<code>ATrick</code>同样的功能有两种实现：他们包含一个 <code>string</code> ，然后用 <code>String()</code> 方法返回这个字符串。但是从逃逸分析看<code>ATrick</code> 版本没有逃逸。</p></li><li><p><code>noescape()</code> 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 <code>p</code> 会通过 <code>x</code> 逃逸， 因为 <code>uintptr()</code> 产生的引用是编译器无法理解的。</p></li><li><p>内置的 <code>uintptr</code> 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 <code>指针地址</code> 的 <code>int</code> 类型。代码的最后一行返回 <code>unsafe.Pointer</code> 也是一个 <code>int</code>。</p></li><li><p><code>noescape()</code> 在 <code>runtime</code> 包中使用 <code>unsafe.Pointer</code> 的地方被大量使用。如果作者清楚被 <code>unsafe.Pointer</code> 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。</p></li><li><p><strong>面试中秀一秀是可以的</strong>，如果在实际项目中如果使用这种 unsafe 包大概率会被同事打死。<strong>不建议使用！</strong> 毕竟包的名字就叫做 <code>unsafe</code>, 而且源码中的注释也写明了 <code>USE CAREFULLY! </code>。</p></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang 面试题：简单聊聊内存逃逸？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang 面试题：字符串转成 byte 数组，会发生内存拷贝吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang 面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang 面试题：拷贝大切片一定比小切片代价大吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang 面试题：能说说 uintptr 和 unsafe.Pointer 的区别吗？</a></li></ul><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试官：for select时，如果通道已经关闭会怎么样？如果select中只有一个case呢？</title>
      <link href="/2020/08/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/for%20select%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%80%9A%E9%81%93%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcase%E5%91%A2%EF%BC%9F/"/>
      <url>/2020/08/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/for%20select%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%80%9A%E9%81%93%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcase%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8yNDFlZTVhYy1kMGY1LTQzZDEtYTU5ZC0yMzExODgzNzMzNDkucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>for</code>循环<code>select</code>时，如果通道已经关闭会怎么样？如果<code>select</code>中的<code>case</code>只有一个，又会怎么样？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>for循环<code>select</code>时，如果其中一个case通道已经关闭，则每次都会执行到这个case。</li><li>如果select里边只有一个case，而这个case被关闭了，则会出现死循环。</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="1-for循环里被关闭的通道"><a href="#1-for循环里被关闭的通道" class="headerlink" title="1.for循环里被关闭的通道"></a>1.for循环里被关闭的通道</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNmU5MzM4MS03YTk3LTRmMDgtODljOS1lODkwNDg1YmE2YmUucG5n?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84OWMxMWU0OS0zYThiLTQxYTAtYmE3MC1mZmQwZWRkOTExMTcucG5n?x-oss-process=image/format,png"></p><ul><li><code>c通道</code>是一个缓冲为<code>0</code>的通道，在<code>main</code>开始时，启动一个协程对<code>c通道</code>写入<code>10</code>，然后就关闭掉这个通道。</li><li>在<code>main</code>中通过 <code>x, ok := &lt;-c</code> 接受<code>通道c</code>里的值，从输出结果里看出，确实从通道里读出了之前塞入通道的<code>10</code>，但是在通道关闭后，这个通道一直能读出内容。</li></ul><h3 id="2-怎么样才能不读关闭后通道"><a href="#2-怎么样才能不读关闭后通道" class="headerlink" title="2.怎么样才能不读关闭后通道"></a>2.怎么样才能不读关闭后通道</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lNDlmNDE4Mi03MGQyLTQxYjAtODRjYy05M2VkMzMxYjc3YjUucG5n?x-oss-process=image/format,png"></p><ul><li><code>x, ok := &lt;-c</code> 返回的值里第一个x是通道内的值，<code>ok</code>是指通道是否关闭，当通道被关闭后，<code>ok</code>则返回<code>false</code>，因此可以根据这个进行操作。读一个已经关闭的通道为什么会出现false，可以看我之前的 <a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">对已经关闭的的chan进行读写，会怎么样？为什么？</a> 。</li><li>当返回的<code>ok</code>为<code>false</code>时，执行<code>c = nil</code> 将通道置为<code>nil</code>，相当于读一个未初始化的通道，则会一直阻塞。至于为什么读一个未初始化的通道会出现阻塞，可以看我的另一篇 <a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">对未初始化的的chan进行读写，会怎么样？为什么？</a> 。<code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。则<code>select</code>会跳过这个阻塞<code>case</code>，可以解决不断读已关闭通道的问题。</li></ul><h3 id="3-如果select里只有一个已经关闭的case，会怎么样？"><a href="#3-如果select里只有一个已经关闭的case，会怎么样？" class="headerlink" title="3.如果select里只有一个已经关闭的case，会怎么样？"></a>3.如果select里只有一个已经关闭的case，会怎么样？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82ZGMxZDQ1Zi04MDk1LTQ1ODAtODUxNi04MWZmNDdkNTI4MGEucG5n?x-oss-process=image/format,png"></p><ul><li>可以看出只有一个<code>case</code>的情况下，则会<code>死循环</code>。</li><li>那如果像上面一个<code>case</code>那样，把通道置为<code>nil</code>就能解决问题了吗？</li></ul><h3 id="4-select里只有一个已经关闭的case，置为nil，会怎么样？"><a href="#4-select里只有一个已经关闭的case，置为nil，会怎么样？" class="headerlink" title="4.select里只有一个已经关闭的case，置为nil，会怎么样？"></a>4.select里只有一个已经关闭的case，置为nil，会怎么样？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hZTAyNWU4NS0yNzZjLTQyMDItYWU2Ny0yMGQ4Njk1Y2I3MTQucG5n?x-oss-process=image/format,png"></p><ul><li>第一次读取<code>case</code>能读到通道里的<code>10</code></li><li>第二次读取<code>case</code>能读到通道已经关闭的信息。此时将通道置为<code>nil</code></li><li>第三次读取<code>case</code>时main协程会被阻塞，此时整个进程没有其他活动的协程了，进程<code>deadlock</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。</li><li>如果没有<code>default</code>字句，<code>select</code>将有可能阻塞，直到某个通道有值可以运行，所以<code>select</code>里最好有一个<code>default</code>，否则将有一直阻塞的风险。</li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ODZiZWU0YS03NzQ1LTQ0YjMtYTFhOS0wMzc5ODIzOGNkNmQucG5n?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</title>
      <link href="/2020/07/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areflect%EF%BC%88%E5%8F%8D%E5%B0%84%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%20tag%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%20json%20%E5%8C%85%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%20tag%EF%BC%9F/"/>
      <url>/2020/07/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areflect%EF%BC%88%E5%8F%8D%E5%B0%84%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%20tag%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%20json%20%E5%8C%85%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%20tag%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kYmE0ODBhYS04ZjNiLTQ2MmMtOTUzYy04OWUxYmNlYmE5YzQucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>json</code>包里使用的时候，会结构体里的字段边上加<code>tag</code>，有没有什么办法可以获取到这个<code>tag</code>的内容呢？</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>tag</code>信息可以通过<code>反射（reflect包）</code>内的方法获取，通过一个例子加深理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">string</span> <span class="comment">//小写无tag</span></span><br><span class="line">    b <span class="keyword">string</span> <span class="string">`json:&quot;B&quot;`</span> <span class="comment">//小写+tag</span></span><br><span class="line">    C <span class="keyword">string</span> <span class="comment">//大写无tag</span></span><br><span class="line">    D <span class="keyword">string</span> <span class="string">`json:&quot;DD&quot; otherTag:&quot;good&quot;`</span> <span class="comment">//大写+tag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTag</span><span class="params">(stru <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(stru).Elem()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n&quot;</span>, i+<span class="number">1</span>, t.Field(i).Name, t.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>), t.Field(i).Tag.Get(<span class="string">&quot;otherTag&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j := J&#123;</span><br><span class="line">      a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      b: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">      C: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">      D: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    printTag(&amp;j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体内第<span class="number">1</span>个字段 a 对应的json tag是  , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">2</span>个字段 b 对应的json tag是 B , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">3</span>个字段 C 对应的json tag是  , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">4</span>个字段 D 对应的json tag是 DD , 还有otherTag？ = good </span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>printTag</code>方法传入的是j的指针。</li><li><code>reflect.TypeOf(stru).Elem()</code>获取指针指向的值对应的结构体内容。</li><li><code>NumField()</code>可以获得该结构体含有几个字段。</li><li>遍历结构体内的字段，通过<code>t.Field(i).Tag.Get(&quot;json&quot;)</code>可以获取到<code>tag</code>为<code>json</code>的字段。</li><li>如果结构体的字段有<code>多个tag</code>，比如叫<code>otherTag</code>,同样可以通过<code>t.Field(i).Tag.Get(&quot;otherTag&quot;)</code>获得。</li></ul><h2 id="再补一句"><a href="#再补一句" class="headerlink" title="再补一句"></a>再补一句</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483698&idx=1&sn=352a5cddf20fe95f5ec26bfc9a6de64b&chksm=9aee289bad99a18d9914d085421e4f218b18d4f0c7a24da306642816e91fb4b235be6aea0e40&token=961196008&lang=zh_CN#rd">上篇文章</a> 提到<code>json包</code>不能导出<code>私有变量的tag</code>是因为<strong>取不到</strong><code>反射信息</code>的说法，但是直接取<code>t.Field(i).Tag.Get(&quot;json&quot;)</code><strong>却可以</strong>获取到私有变量的<code>json字段</code>，是<strong>为什么</strong>呢？  </p><p>其实<strong>准确的</strong>说法是，<code>json</code>包里不能导出私有变量的<code>tag</code>是因为<code>json</code>包里认为私有变量为不可导出的<code>Unexported</code>，所以<strong>跳过获取</strong>名为<code>json</code>的<code>tag</code>的内容。<br>具体可以看<code>/src/encoding/json/encode.go:1070</code>的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeFields</span><span class="params">(t reflect.Type)</span> []<span class="title">field</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">    <span class="comment">// 遍历结构体内的每个字段</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; f.typ.NumField(); i++ &#123;</span><br><span class="line">        sf := f.typ.Field(i)</span><br><span class="line">        isUnexported := sf.PkgPath != <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">        <span class="keyword">if</span> isUnexported &#123;</span><br><span class="line">            <span class="comment">// 如果是不可导出的变量则跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是可导出的变量（public），则获取其json字段</span></span><br><span class="line">        tag := sf.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">        <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 注释掉其他逻辑... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</title>
      <link href="/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8xNDVkOWZiZjQ0NzM0M2Q5YmIxODM4YjNmMzk4MjRhNi5wbmc?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对<strong>已经关闭</strong>的的<code>chan</code>进行读写，会怎么样？<strong>为什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>读<strong>已经关闭</strong>的<code>chan</code>能一直读到东西，但是读到的内容根据通道内<code>关闭前</code>是否有元素而不同。<ul><li>如果<code>chan</code>关闭前，<code>buffer</code>内有元素<strong>还未读</strong>,会正确读到<code>chan</code>内的值，且返回的第二个bool值（是否读成功）为<code>true</code>。</li><li>如果<code>chan</code>关闭前，<code>buffer</code>内有元素<strong>已经被读完</strong>，<code>chan</code>内无值，接下来所有接收的值都会非阻塞直接成功，返回 <code>channel</code> 元素的<strong>零值</strong>，但是第二个<code>bool</code>值一直为<code>false</code>。</li></ul></li><li>写<strong>已经关闭</strong>的<code>chan</code>会<code>panic</code></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h5 id="1-写已经关闭的chan"><a href="#1-写已经关闭的chan" class="headerlink" title="1.写已经关闭的chan"></a>1.写已经关闭的chan</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC9lYjlhZGRhNDU3NGU0ZTAyYjJlODczN2JkODI5NWE0NC5wbmc?x-oss-process=image/format,png"></p><ul><li>注意这个<code>send on closed channel</code>，待会会提到。</li></ul><h5 id="2-读已经关闭的chan"><a href="#2-读已经关闭的chan" class="headerlink" title="2.读已经关闭的chan"></a>2.读已经关闭的chan</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8wZTcyNTVkNzI5NDI0Y2NhYTBhNGNjNmQ5ZGU1MTBkMi5wbmc?x-oss-process=image/format,png"></p><h2 id="多问一句"><a href="#多问一句" class="headerlink" title="多问一句"></a>多问一句</h2><p><strong>1.为什么写已经关闭的<code>chan</code>就会<code>panic</code>呢？</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC81Njc2MDBmYmEyNDE0MjcwYWQ3YWU0YTFjY2RhODQwMy5wbmc?x-oss-process=image/format,png"></p><ul><li>当<code>c.closed != 0</code>则为通道关闭，此时执行写，源码提示直接panic，输出的内容就是上面提到的<code>&quot;send on closed channel&quot;</code>。</li></ul><p><strong>2. 为什么读已关闭的<code>chan</code>会一直能读到值？</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC80YmNjMGYwNjI3MzE0Y2JiYWRkMWI0ODRjNTE4OTRkOS5wbmc?x-oss-process=image/format,png"></p><ul><li><code>c.closed != 0 &amp;&amp; c.qcount == 0</code>指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值）</li><li>如果接收值的地址<code>ep</code>不为空<ul><li>那接收值将获得是一个<strong>该类型的零值</strong></li><li><code>typedmemclr</code> 会<strong>根据类型清理</strong>相应地址的内存</li><li>这就解释了上面代码为什么关闭的<code>chan</code>会返回对应类型的零值</li></ul></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ODZiZWU0YS03NzQ1LTQ0YjMtYTFhOS0wMzc5ODIzOGNkNmQucG5n?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</title>
      <link href="/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8zNjlhMWU4Zi1lNWExLTQ1N2YtYmJmNy1iMjA1Yjc5NjlhYTAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对<strong>未初始化</strong>的的<code>chan</code>进行读写，会怎么样？<strong>为什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>读写<strong>未初始化</strong>的<code>chan</code>都会<strong>阻塞</strong>。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h5 id="1-写未初始化的chan"><a href="#1-写未初始化的chan" class="headerlink" title="1.写未初始化的chan"></a>1.写未初始化的chan</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 写未初始化的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send (<span class="literal">nil</span> <span class="keyword">chan</span>)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/admin18/<span class="keyword">go</span>/src/repos/main.<span class="keyword">go</span>:<span class="number">6</span> +<span class="number">0x36</span></span><br></pre></td></tr></table></figure><p>注意这个<code>chan send (nil chan)</code>，待会会提到。</p><h5 id="2-写读未初始化的chan"><a href="#2-写读未初始化的chan" class="headerlink" title="2.写读未初始化的chan"></a>2.写读未初始化的chan</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 读未初始化的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">num, ok := &lt;-c</span><br><span class="line">fmt.Printf(<span class="string">&quot;读chan的协程结束, num=%v, ok=%v\n&quot;</span>, num, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive (<span class="literal">nil</span> <span class="keyword">chan</span>)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/admin18/<span class="keyword">go</span>/src/repos/main.<span class="keyword">go</span>:<span class="number">6</span> +<span class="number">0x46</span></span><br></pre></td></tr></table></figure><p>注意这个<code>chan receive (nil chan)</code>，待会也会提到。</p><h2 id="多问一句"><a href="#多问一句" class="headerlink" title="多问一句"></a>多问一句</h2><p>关于<code>chan</code>的面试题非常多，这个是比较常见的其中一个。但多问一句：<strong>为什么对未初始化的<code>chan</code>就会阻塞呢？</strong></p><p><strong>1.对于写的情况</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 src/runtime/chan.go中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">      <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">      throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 省略其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>未初始化的<code>chan</code>此时是等于<code>nil</code>，当它不能阻塞的情况下，直接返回 <code>false</code>，表示写 <code>chan</code> 失败</li><li>当<code>chan</code>能阻塞的情况下，则直接阻塞 <code>gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) </code>, 然后调用<code>throw(s string)</code>抛出错误,其中<code>waitReasonChanSendNilChan</code>就是刚刚提到的报错<code>&quot;chan send (nil chan)&quot;</code></li></ul><p><strong>2. 对于读的情况</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 src/runtime/chan.go中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//省略逻辑...</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略逻辑...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>未初始化的<code>chan</code>此时是等于<code>nil</code>，当它不能阻塞的情况下，直接返回 <code>false</code>，表示读 <code>chan</code> 失败</li><li>当<code>chan</code>能阻塞的情况下，则直接阻塞 <code>gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) </code>, 然后调用<code>throw(s string)</code>抛出错误,其中<code>waitReasonChanReceiveNilChan</code>就是刚刚提到的报错<code>&quot;chan receive (nil chan)&quot;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：json包变量不加tag会怎么样？</title>
      <link href="/2020/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajson%E5%8C%85%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8A%A0tag%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F/"/>
      <url>/2020/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajson%E5%8C%85%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8A%A0tag%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81MWY1ZjQ0NS04YzczLTQ1YTYtOTcxOS02NjI2M2Q4NDY2MTYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>json</code>包里使用的时候，结构体里的变量不加<code>tag</code>能不能正常转成<code>json</code>里的字段？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>如果变量<code>首字母小写</code>，则为<code>private</code>。无论如何<code>不能转</code>，因为取不到<code>反射信息</code>。</li><li>如果变量<code>首字母大写</code>，则为<code>public</code>。<ul><li><code>不加tag</code>，可以正常转为<code>json</code>里的字段，<code>json</code>内字段名跟结构体内字段<code>原名一致</code>。</li><li><code>加了tag</code>，从<code>struct</code>转<code>json</code>的时候，<code>json</code>的字段名就是<code>tag</code>里的字段名，原字段名已经没用。</li></ul></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>通过一个例子加深理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">string</span>             <span class="comment">//小写无tag</span></span><br><span class="line">    b <span class="keyword">string</span> <span class="string">`json:&quot;B&quot;`</span>  <span class="comment">//小写+tag</span></span><br><span class="line">    C <span class="keyword">string</span>             <span class="comment">//大写无tag</span></span><br><span class="line">    D <span class="keyword">string</span> <span class="string">`json:&quot;DD&quot;`</span> <span class="comment">//大写+tag</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j := J &#123;</span><br><span class="line">      a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      b: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">      C: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">      D: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json前j结构体的内容 = %+v\n&quot;</span>, j)</span><br><span class="line">    jsonInfo, _ := json.Marshal(j)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json后的内容 = %+v\n&quot;</span>, <span class="keyword">string</span>(jsonInfo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转为json前j结构体的内容 = &#123;a:<span class="number">1</span> b:<span class="number">2</span> C:<span class="number">3</span> D:<span class="number">4</span>&#125;</span><br><span class="line">转为json后的内容 = &#123;<span class="string">&quot;C&quot;</span>:<span class="string">&quot;3&quot;</span>,<span class="string">&quot;DD&quot;</span>:<span class="string">&quot;4&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>结构体里定义了四个字段，分别对应 <code>小写无tag</code>，<code>小写+tag</code>，<code>大写无tag</code>，<code>大写+tag</code>。</li><li>转为<code>json</code>后首字母<code>小写的</code>不管加不加 tag<code>都不能</code>转为<code>json</code>里的内容，而<code>大写的</code>加了<code>tag</code>可以<code>取别名</code>，不加<code>tag</code>则<code>json</code>内的字段跟结构体字段<code>原名一致</code>。</li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483692&idx=1&sn=d5d34fad7a4553e0b9d5714385b7af48&chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&token=961196008&lang=zh_CN#rd">golang 面试题：怎么避免内存逃逸？？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang 面试题：简单聊聊内存逃逸？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang 面试题：字符串转成 byte 数组，会发生内存拷贝吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang 面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang 面试题：拷贝大切片一定比小切片代价大吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang 面试题：能说说 uintptr 和 unsafe.Pointer 的区别吗？</a></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：字符串转成byte数组，会发生内存拷贝吗？</title>
      <link href="/2020/05/17/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90byte%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/17/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90byte%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83OGRhNTQ2My01M2ViLTRjNTctYTA4Yy0wOWJhNGYyOGZmOTYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>字符串转成 byte 数组，会发生内存拷贝吗？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。<br>频繁的内存拷贝操作听起来对性能不大友好。<strong>有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a :=<span class="string">&quot;aaa&quot;</span></span><br><span class="line">ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">b := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;ssh))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>StringHeader</code> 是<code>字符串</code>在 go 的底层结构。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>SliceHeader</code> 是<code>切片</code>在 go 的底层结构。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>那么如果想要在底层转换二者，只需要把 <code>StringHeader</code> 的地址强转成 <code>SliceHeader</code> 就行。那么 go 有个很强的包叫 <code>unsafe</code> 。</p><ul><li><p>1.<code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址。</p></li><li><p>2.<code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串 a 转成底层结构的形式。</p></li><li><p>3.<code>(*[]byte)(unsafe.Pointer(&amp;ssh)) </code> 可以把 ssh 底层结构体转成 byte 的切片的指针。</p></li><li><p>4.再通过 <code>*</code>转为指针指向的实际内容。</p></li></ul></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：怎么避免内存逃逸？</title>
      <link href="/2020/05/16/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/"/>
      <url>/2020/05/16/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jZDJkODUxZS1hZWQ1LTRlNjYtOGFmNy0wMjczZDc0NDgzNzAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>怎么避免<strong>内存逃逸</strong>？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>在<code>runtime/stubs.go:133</code>有个函数叫<code>noescape</code>。<code>noescape</code>可以在逃逸分析中<strong>隐藏一个指针</strong>。让这个指针在逃逸分析中<strong>不会被检测为逃逸</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// noescape hides a pointer from escape analysis.  noescape is</span></span><br><span class="line"> <span class="comment">// the identity function but escape analysis doesn&#x27;t think the</span></span><br><span class="line"> <span class="comment">// output depends on the input.  noescape is inlined and currently</span></span><br><span class="line"> <span class="comment">// compiles down to zero instructions.</span></span><br><span class="line"> <span class="comment">// USE CAREFULLY!</span></span><br><span class="line"> <span class="comment">//go:nosplit</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">     x := <span class="keyword">uintptr</span>(p)</span><br><span class="line">     <span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">S *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *f.S</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ATrick <span class="keyword">struct</span> &#123;</span><br><span class="line">S unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ATrick)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(f.S)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> A&#123;S: &amp;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewATrick</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">ATrick</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">x := <span class="keyword">uintptr</span>(p)</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">f1 := NewA(s)</span><br><span class="line">f2 := NewATrick(s)</span><br><span class="line">s1 := f1.String()</span><br><span class="line">s2 := f2.String()</span><br><span class="line">_ = s1 + s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">6</span>: can inline (*ATrick).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">6</span>: can inline NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">6</span>: can inline noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">6</span>: can inline NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">29</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">36</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: inlining call to NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">17</span>: inlining call to (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">17</span>: inlining call to (*ATrick).String</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build763863171/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">15</span>: noescape p does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">10</span>: main f1 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">10</span>: main f2 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">42</span>:<span class="number">9</span>: main s1 + s2 does not escape</span><br></pre></td></tr></table></figure><p>其中主要看中间一小段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap    <span class="comment">//这个是NewA中的，逃逸了</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape <span class="comment">// NewATrick里的s的却没逃逸</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p>上段代码对<code>A</code>和<code>ATrick</code>同样的功能有两种实现：他们包含一个 <code>string</code> ，然后用 <code>String()</code> 方法返回这个字符串。但是从逃逸分析看<code>ATrick</code> 版本没有逃逸。</p></li><li><p><code>noescape()</code> 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 <code>p</code> 会通过 <code>x</code> 逃逸， 因为 <code>uintptr()</code> 产生的引用是编译器无法理解的。</p></li><li><p>内置的 <code>uintptr</code> 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 <code>指针地址</code> 的 <code>int</code> 类型。代码的最后一行返回 <code>unsafe.Pointer</code> 也是一个 <code>int</code>。</p></li><li><p><code>noescape()</code> 在 <code>runtime</code> 包中使用 <code>unsafe.Pointer</code> 的地方被大量使用。如果作者清楚被 <code>unsafe.Pointer</code> 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。</p></li><li><p><strong>面试中秀一秀是可以的</strong>，如果在实际项目中如果使用这种 unsafe 包大概率会被同事打死。<strong>不建议使用！</strong> 毕竟包的名字就叫做 <code>unsafe</code>, 而且源码中的注释也写明了 <code>USE CAREFULLY! </code>。</p></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang 面试题：简单聊聊内存逃逸？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang 面试题：字符串转成 byte 数组，会发生内存拷贝吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang 面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang 面试题：拷贝大切片一定比小切片代价大吗？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang 面试题：能说说 uintptr 和 unsafe.Pointer 的区别吗？</a></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白 debug】<br><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拷贝大切片一定比小切片代价大吗？</title>
      <link href="/2020/05/13/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%A4%A7%E5%88%87%E7%89%87%E4%B8%80%E5%AE%9A%E6%AF%94%E5%B0%8F%E5%88%87%E7%89%87%E4%BB%A3%E4%BB%B7%E5%A4%A7%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/13/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%A4%A7%E5%88%87%E7%89%87%E4%B8%80%E5%AE%9A%E6%AF%94%E5%B0%8F%E5%88%87%E7%89%87%E4%BB%A3%E4%BB%B7%E5%A4%A7%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jMmM2Y2YxZi0xN2RlLTRiZDEtYjY5Ny02NGQ1ZDlhY2M2MDUucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>拷贝大切片一定比小切片代价大吗？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>并不是，所有切片的大小相同；<strong>三个字段</strong>（一个 uintptr，两个 int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 <strong>拷贝大切片跟小切片的代价应该是一样的</strong>。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>SliceHeader</code> 是<code>切片</code>在 go 的底层结构。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>大切片跟小切片的区别无非就是 <code>Len</code> 和 <code>Cap</code>的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。</li></ul><h6 id="关注公众号-【小白-debug】"><a href="#关注公众号-【小白-debug】" class="headerlink" title="关注公众号:【小白 debug】"></a>关注公众号:【小白 debug】</h6><p><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：简单聊聊内存逃逸？</title>
      <link href="/2020/05/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/"/>
      <url>/2020/05/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNzJkY2JmNi05YTc2LTRlYmMtODBkMC1lZjNmNzZjNDk5NzcucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>知道golang的<strong>内存逃逸</strong>吗？什么情况下会发生内存逃逸？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><figure class="highlight plaintext"><figcaption><span>```逃逸``` 了，必须在```堆上分配```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">能引起变量逃逸到堆上的**典型情况**：</span><br><span class="line">- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</span><br><span class="line">- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</span><br><span class="line">- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</span><br><span class="line">- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</span><br><span class="line">- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 举例</span><br><span class="line">- 通过一个例子加深理解，接下来尝试下怎么通过 ```go build -gcflags=-m``` 查看逃逸的情况。</span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type A struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span><br><span class="line">func foo(s string) *A &#123;</span><br><span class="line">a := new(A) </span><br><span class="line">a.s = s</span><br><span class="line">return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">a := foo(&quot;hello&quot;)</span><br><span class="line">b := a.s + &quot; world&quot;</span><br><span class="line">c := b + &quot;!&quot;</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">6</span>: can inline foo</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">10</span>: inlining call to foo</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build409982591/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">10</span>: leaking param: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">10</span>: <span class="built_in">new</span>(A) escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: io.Writer(os.Stdout) escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: c escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">9</span>: b + <span class="string">&quot;!&quot;</span> escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">10</span>: main <span class="built_in">new</span>(A) does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">11</span>: main a.s + <span class="string">&quot; world&quot;</span> does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: main []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: os.(*File).<span class="built_in">close</span> .this does not escape</span><br></pre></td></tr></table></figure><ul><li><code>./main.go:8:10: new(A) escapes to heap</code> 说明 <code>new(A)</code> 逃逸了,符合上述提到的常见情况中的第一种。</li><li><code>./main.go:14:11: main a.s + &quot; world&quot; does not escape</code> 说明 <code>b</code> 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。</li><li><code>./main.go:15:9: b + &quot;!&quot; escapes to heap</code> 说明 <code>c</code> 变量逃逸，通过<code>fmt.Println(a ...interface&#123;&#125;)</code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。</li></ul><ul><li>以上操作其实就叫<strong>逃逸分析</strong>。<strong>下篇文章，跟大家聊聊怎么用一个比较trick的方法使变量不逃逸。方便大家在面试官面前秀一波</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：翻转含有中文、数字、英文字母的字符串</title>
      <link href="/2020/05/10/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/05/10/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8wNzdhMGZlOC1lZDU2LTQ5ODItYjRmNy1iNzZhMGYyYWIwNmYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>翻转含有<code>中文、数字、英文字母</code>的字符串<br><code>&quot;你好abc啊哈哈&quot;</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">src := <span class="string">&quot;你好abc啊哈哈&quot;</span></span><br><span class="line">dst := reverse([]<span class="keyword">rune</span>(src))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="keyword">string</span>(dst))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">rune</span>)</span> []<span class="title">rune</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>rune</code>关键字，从 golang 源码中看出，它是 int32 的别名（-2^31 ~ 2^31-1），比起 byte（-128 ～ 127），<strong>可表示更多的字符</strong>。</li><li>由于 rune 可表示的范围更大，所以能处理一切字符，当然也包括<strong>中文字符</strong>。在平时计算中文字符，可用 rune。</li><li>因此将<code>字符串</code>转为<code>rune的切片</code>，再进行翻转，完美解决。</li></ul><h6 id="关注公众号-【小白-debug】"><a href="#关注公众号-【小白-debug】" class="headerlink" title="关注公众号:【小白 debug】"></a>关注公众号:【小白 debug】</h6><p><img src="https://cdn.xiaobaidebug.top/1696069689495.png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
