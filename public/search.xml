<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Mysql的索引为什么使用B+树而不使用跳表？</title>
      <link href="/2022/04/16/%E5%9B%BE%E8%A7%A3mysql/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9F/"/>
      <url>/2022/04/16/%E5%9B%BE%E8%A7%A3mysql/Mysql%E7%9A%84%E7%B4%A2%E5%BC%95%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8B+%E6%A0%91%E8%80%8C%E4%B8%8D%E4%BD%BF%E7%94%A8%E8%B7%B3%E8%A1%A8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>在我们的印象中，mysql数据表里无非就是存储一行行的数据。跟个excel似的。</p><p>直接遍历这一行行数据，性能就是O(n)，比较慢。为了加速查询，使用了<strong>B+树</strong>来做索引，将查询性能优化到了O(lg(n))。</p><p>但问题就来了，查询数据性能在 lg(n) 级别的数据结构有很多，比如redis的zset里用到的<strong>跳表</strong>，也是lg(n)，并且实现还贼简单。</p><p><strong>那为什么mysql的索引，不使用跳表呢？</strong></p><p>我们今天就来聊聊这个话题。</p><br><h3 id="B-树的结构"><a href="#B-树的结构" class="headerlink" title="B+树的结构"></a>B+树的结构</h3><p>之前的一篇<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>里，已经提到过<strong>B+树的结构</strong>了。文章不长，如果没看过，建议先看下。</p><p><strong>当然，不看也行。</strong></p><p>在这里，<del>为了混点字数</del>，我简单总结下B+树的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/B+%E6%A0%91%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B-20220403085542636-20220403090359219.png" alt="B+树查询过程"></p><span id="more"></span><p>如上图，一般B+树是由多个页组成的<strong>多层级</strong>结构，每个页<code>16Kb</code>，对于主键索引来说，最末级的<strong>叶子结点</strong>放行数据，<strong>非叶子结点</strong>放的则是索引信息（主键id和页号），用于加速查询。</p><p>比方说我们想要查找行数据5。会先从顶层页的record们入手。<strong>record里包含了主键id和页号（页地址）</strong>。关注黄色的箭头，向左最小id是1，向右最小id是7。那id=5的数据如果存在，那必定在左边箭头。于是顺着的record的页地址就到了<code>6号</code>数据页里，再判断id=5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。</p><p>在<code>105号数据页</code>里，虽然有多行数据，但也<strong>不是挨个遍历的</strong>，数据页内还有个<strong>页目录</strong>的信息，它可以通过<strong>二分查找</strong>的方式加速查询行数据，于是找到id=5的数据行，完成查询。</p><p>从上面可以看出，B+树利用了<strong>空间换时间</strong>的方式（构造了一批非叶子结点用于存放索引信息），**将查询时间复杂度从O(n)优化为O(lg(n))**。</p><br><h3 id="跳表的结构"><a href="#跳表的结构" class="headerlink" title="跳表的结构"></a>跳表的结构</h3><p>看完B+树，我们再来看下跳表是怎么来的。</p><p>同样的，还是为了存储一行行的数据。</p><p>我们可以将它们用<strong>链表</strong>串起来。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8D%95%E9%93%BE%E8%A1%A8.png" alt="单链表"></p><p>想要查询链表中的其中一个结点，时间复杂度是O(n)，这谁顶得住，于是将<strong>部分</strong>链表结点提出来，再构建出一个新的链表。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%A4%E5%B1%82%E8%B7%B3%E8%A1%A8.png" alt="两层跳表"></p><p>这样当我想要查询一个数据的时候，我先查上层的链表，就很容易知道数据落在<strong>哪个范围</strong>，然后<strong>跳到下一个层级里进行查询。</strong>这样就把搜索范围一下子缩小了一大半。</p><p>比如查询id=10的数据，我们先在上层遍历，依次判断1,6,12，很快就可以判断出10在6到12之间，然后往下一跳，就可以在遍历6,7,8,9,10之后，确定id=10的位置。直接将查询范围从原来的1到10，变成现在的1,6,7,8,9,10，算是砍半了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%A4%E5%B1%82%E8%B7%B3%E8%A1%A8%E6%9F%A5%E6%89%BEid%E4%B8%BA10%E7%9A%84%E6%95%B0%E6%8D%AE.drawio.png" alt="两层跳表查找id为10的数据"></p><p>既然两层链表就直接将查询范围砍半了，那我<strong>多加几层</strong>，岂不妙哉？</p><p>于是跳表就这样变成了多层。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%89%E5%B1%82%E8%B7%B3%E8%A1%A8.png" alt="三层跳表"></p><p>如果还是查询id=10的数据，就只需要查询1,6,9,10就能找到，比两层的时候更快一些。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%89%E5%B1%82%E8%B7%B3%E8%A1%A8%E6%9F%A5%E8%AF%A2id%E4%B8%BA10%E7%9A%84%E6%95%B0%E6%8D%AE.png" alt="三层跳表查询id为10的数据"></p><p>可以看出，跳表也是通过<strong>牺牲空间换取时间</strong>的方式提升查询性能。**时间复杂度都是lg(n)**。</p><br><h3 id="B-树和跳表的区别"><a href="#B-树和跳表的区别" class="headerlink" title="B+树和跳表的区别"></a>B+树和跳表的区别</h3><p>从上面可以看到，B+树和跳表的<strong>最下面一层，都包含了所有的数据</strong>，且都是<strong>顺序的，适合用于范围查询</strong>。往上的层级都是构建出来用于提升搜索性能的。这两者实在是太像了。但他们两者在<strong>新增和删除数据</strong>时，还是有些区别的。下面我们以新增数据为例聊一下。</p><br><h4 id="B-树新增数据会怎么样"><a href="#B-树新增数据会怎么样" class="headerlink" title="B+树新增数据会怎么样"></a>B+树新增数据会怎么样</h4><p>B+树本质上是一种多叉平衡二叉树。关键在于”<strong>平衡</strong>“这两个字，对于多叉树结构来说，它的含义是子树们的高度层级尽量一致（一般最多差一个层级），这样在搜索的时候，不管是到哪个子树分支，搜索次数都差不了太多。</p><p>当数据库表不断插入新的数据时，为了维持B+树的平衡，B+树会不断分裂调整数据页。</p><p>我们知道B+树分为<strong>叶子结点和非叶子结点</strong>。</p><p>当插入一条数据时，叶子结点和它上层的索引结点（非叶子结点）最大容量都是16k，它们都有可能会满。</p><p>为了简化问题，我们<strong>假设</strong>一个数据页只能放三条行数据或索引。</p><p>加入一条数据，根据数据页会不会满，分为三种情况。</p><ul><li><strong>叶子结点和索引结点都没满</strong>。这种情况最简单，直接插入到叶子结点中就好了。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8F%B6%E5%AD%90%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E9%83%BD%E6%9C%AA%E6%BB%A1.png" alt="叶子和非叶子都未满"></p><ul><li><strong>叶子结点满了，但索引结点没满</strong>。此时需要拆分叶子结点，同时索引结点要增加新的索引信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8F%B6%E5%AD%90%E6%BB%A1%E4%BA%86%E4%BD%86%E9%9D%9E%E5%8F%B6%E5%AD%90%E6%9C%AA%E6%BB%A1.drawio.png" alt="叶子满了但非叶子未满.drawio"></p><ul><li><strong>叶子结点满了，且索引结点也满了</strong>。叶子和索引结点都要拆分，同时往上还要再<strong>加一层索引。</strong></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8F%B6%E5%AD%90%E5%92%8C%E9%9D%9E%E5%8F%B6%E5%AD%90%E9%83%BD%E6%BB%A1%E4%BA%86.png" alt="叶子和非叶子都满了"></p><p>从上面可以看到，只有在叶子和索引结点<strong>都满了</strong>的情况下，B+树才会考虑加入一层新的结点。</p><p>而从之前的<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>知道，要把三层B+树塞满，那大概需要2kw左右的数据。</p><br><h4 id="跳表新增数据"><a href="#跳表新增数据" class="headerlink" title="跳表新增数据"></a>跳表新增数据</h4><p>跳表同样也是很多层，新增一个数据时，最底层的链表需要插入数据。</p><p>此时，<strong>是否需要在上面的几层中加入数据做索引呢？</strong></p><p>这个就纯靠<strong>随机函数</strong>了。</p><p>理论上为了达到<strong>二分的效果</strong>，每一层的结点数需要是下一层结点数的二分之一。</p><p>也就是说现在有一个新的数据插入了，它有<code>50%</code>的概率需要在<code>第二层</code>加入索引，有<code>25%</code>的概率需要在<code>第三层</code>加个索引，以此类推，直到<code>最顶层</code>。</p><p>举个例子，如果跳表中插入数据id=6，且随机函数返回第三层（有25%的概率），那就需要在跳表的最底层到第三层都插入数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%B7%B3%E8%A1%A8%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE.drawio.png" alt="跳表插入数据"></p><p>如果这个随机函数设计成上面这样，当<strong>数据量样本足够大</strong>的时候，数据的分布就符合我们理想中的”二分”。</p><p>跟上面B+树不一样，跳表是否新增层数，纯粹靠随机函数，根本不关心前后上下结点。</p><br><p>好了，基础科普也结束了，我们可以进入正题了。</p><br><h3 id="Mysql的索引为什么使用B-树而不使用跳表？"><a href="#Mysql的索引为什么使用B-树而不使用跳表？" class="headerlink" title="Mysql的索引为什么使用B+树而不使用跳表？"></a>Mysql的索引为什么使用B+树而不使用跳表？</h3><p><strong>B+树</strong>是多叉树结构，每个结点都是一个16k的数据页，能存放较多索引信息，所以<strong>扇出很高</strong>。<strong>三层</strong>左右就可以存储<code>2kw</code>左右的数据（知道结论就行，想知道原因可以看之前的<a href="https://mp.weixin.qq.com/s/XX_NkIIf_PLyU4IE6lEEYQ">文章</a>）。也就是说查询一次数据，如果这些数据页都在磁盘里，那么最多需要查询<strong>三次磁盘IO</strong>。</p><br><p><strong>跳表</strong>是链表结构，一条数据一个结点，如果最底层要存放<code>2kw</code>数据，且每次查询都要能达到<strong>二分查找</strong>的效果，<code>2kw</code>大概在<code>2的24次方</code>左右，所以，跳表大概高度在<strong>24层</strong>左右。最坏情况下，这24层数据会分散在不同的数据页里，也即是查一次数据会经历<strong>24次磁盘IO</strong>。</p><p>因此存放同样量级的数据，B+树的高度比跳表的要少，如果放在mysql数据库上来说，就是<strong>磁盘IO次数更少，因此B+树查询更快</strong>。</p><p>而针对<strong>写操作</strong>，B+树需要拆分合并索引数据页，跳表则独立插入，并根据随机函数确定层数，没有旋转和维持平衡的开销，因此<strong>跳表的写入性能会比B+树要好。</strong></p><p>其实，mysql的<strong>存储引擎是可以换的</strong>，以前是<code>myisam</code>，后来才有的<code>innodb</code>，它们底层索引用的都是<strong>B+树</strong>。也就是说，你完全可以造一个索引为跳表的存储引擎装到mysql里。事实上，<code>facebook</code>造了个<code>rocksDB</code>的存储引擎，里面就用了<strong>跳表</strong>。直接说结论，它的<strong>写入性能</strong>确实是比innodb要好，但<strong>读性能</strong>确实比innodb要差不少。感兴趣的话，可以在文章最后面的<strong>参考资料</strong>里看到他们的性能对比数据。</p><br><h3 id="redis为什么使用跳表而不使用B-树或二叉树呢？"><a href="#redis为什么使用跳表而不使用B-树或二叉树呢？" class="headerlink" title="redis为什么使用跳表而不使用B+树或二叉树呢？"></a>redis为什么使用跳表而不使用B+树或二叉树呢？</h3><p>redis支持多种数据结构，里面有个<strong>有序集合</strong>，也叫<strong>ZSET</strong>。内部实现就是<strong>跳表</strong>。那为什么要<strong>用跳表而不用B+树等结构呢？</strong></p><p>这个几乎每次面试都要被问一下。</p><p>虽然已经很熟了，但每次都要装作之前没想过，现场思考一下才知道答案。</p><p>真的，很考验演技。</p><p>大家知道，redis 是纯纯的内存数据库。</p><p>进行读写数据都是操作内存，跟磁盘没啥关系，因此也<strong>不存在磁盘IO</strong>了，所以层高就不再是跳表的劣势了。</p><p>并且前面也提到B+树是有一系列合并拆分操作的，换成红黑树或者其他AVL树的话也是各种旋转，目的也是<strong>为了保持树的平衡</strong>。</p><p>而跳表插入数据时，只需要随机一下，就知道自己要不要往上加索引，根本不用考虑前后结点的感受，也就<strong>少了旋转平衡的开销</strong>。</p><p>因此，redis选了跳表，而不是B+树。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>B+树是多叉平衡搜索树，扇出高，只需要3层左右就能存放2kw左右的数据，同样情况下跳表则需要24层左右，假设层高对应<strong>磁盘IO</strong>，那么B+树的读性能会比跳表要好，因此mysql选了B+树做索引。</li><li>redis的读写全在内存里进行操作，不涉及磁盘IO，同时跳表实现简单，相比B+树、AVL树、少了旋转树结构的开销，因此redis使用跳表来实现ZSET，而不是树结构。</li><li>存储引擎RocksDB内部使用了跳表，对比使用B+树的innodb，虽然写性能更好，但读性能属实差了些。在读多写少的场景下，B+树依旧YYDS。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MYSQL内核：INNODB存储引擎 卷1》</p><p>《RocksDB和Innodb引擎性能PK胜负难料？》</p><p><a href="https://cloud.tencent.com/developer/article/1813695">https://cloud.tencent.com/developer/article/1813695</a></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><br><p>最近在看《龙蛇演义》，剧情很一般，但我硬是一口气看到了最新一集，还很上头。</p><p>为啥？</p><p>点开它，看到女主角的时候你就理解我了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220404094330264.png"></p><p>这么说吧，一个颜值出众，身材火辣的姐姐，还是个世界顶级的武术高手，穿着旗袍，踩着高跟，做着各种让牛顿棺材板都快要按不住的动作，只为手把手教会你武术基本功。</p><p>这时候，剧情还重要吗？</p><p>不得不说，当我看到姐姐穿成这样用木棍顶起400斤的汞球时。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220404094549469.png"></p><br><p>我可以肯定，导演根本不懂物理。</p><br><p>但是！</p><br><p>导演很懂男人!</p><br><p>这不得不让我陷入沉思，<strong>到底什么才是好的内容?</strong></p><p>难道现在有个大姐姐穿个黑丝高跟超短裙，教你变量的声明和定义这么基础的东西，你也会去看吗？</p><p>我不知道你们会不会。</p><br><p>反正我会。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006Xk4cbgy1gqzc3sofewj30c805st8u.jpg"></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么大家说mysql数据库单表最大两千万？依据是啥？</title>
      <link href="/2022/04/05/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F%E4%BE%9D%E6%8D%AE%E6%98%AF%E5%95%A5%EF%BC%9F/"/>
      <url>/2022/04/05/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A4%A7%E5%AE%B6%E8%AF%B4mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8D%95%E8%A1%A8%E6%9C%80%E5%A4%A7%E4%B8%A4%E5%8D%83%E4%B8%87%EF%BC%9F%E4%BE%9D%E6%8D%AE%E6%98%AF%E5%95%A5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>故事从好多年前说起。</p><p>想必大家也听说过数据库单表<strong>建议最大2kw</strong>条数据这个说法。如果超过了，性能就会下降得比较厉害。</p><p>巧了。</p><p>我也听说过。</p><p><strong>但我不接受它的建议，硬是单表装了1亿条数据。</strong></p><p>这时候，我们组里新来的实习生看到了之后，天真无邪的问我：”单表不是建议最大两千万吗？为什么这个表都<strong>放了1个亿还不分库分表</strong>“？</p><p>我能说我是<strong>因为懒</strong>吗？我当初设计时哪里想到这表竟然能涨这么快。。。</p><p>我不能。</p><p>说了等于承认自己是<strong>开发组里的毒瘤</strong>，虽然我确实是，但我<strong>不能承认</strong>。</p><p>我如坐针毡，如芒刺背，如鲠在喉。</p><p>开始了一波骚操作。</p><p>“我这么做是有道理的”</p><p>“虽然这个表很大，但你有没有发现它查询其实还是很快”</p><p>“这个2kw是个建议值，我们要来看下这个2kw是怎么来的”</p><br><h3 id="数据库单表行数最大多大？"><a href="#数据库单表行数最大多大？" class="headerlink" title="数据库单表行数最大多大？"></a>数据库单表行数最大多大？</h3><p>我们先看下单表行数理论最大值是多少。</p><p>建表的SQL是这么写的，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">100037</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>其中id就是主键。主键本身唯一，也就是说主键的大小可以限制表的上限。</p><p>如果主键声明为<code>int</code>大小，也就是32位，那么能支持2^32-1，也就是<strong>21个亿</strong>左右。</p><p>如果是<code>bigint</code>，那就是2^64-1，但这个<strong>数字太大</strong>，一般还没到这个限制之前，<strong>磁盘先受不了</strong>。</p><p>搞离谱点。</p><p>如果我把主键声明为 <code>tinyint</code>，一个字节，8位，最大2^8-1，也就是<code>255</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` tinyint(<span class="number">2</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB AUTO_INCREMENT<span class="operator">=</span><span class="number">0</span> <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>如果我想插入一个id=256的数据，那<strong>就会报错</strong>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> `tmp` (`id`, `name`, `age`) <span class="keyword">VALUES</span> (<span class="number">256</span>, <span class="string">&#x27;&#x27;</span>, <span class="number">60</span>);</span><br><span class="line">ERROR <span class="number">1264</span> (<span class="number">22003</span>): <span class="keyword">Out</span> <span class="keyword">of</span> <span class="keyword">range</span> <span class="keyword">value</span> <span class="keyword">for</span> <span class="keyword">column</span> <span class="string">&#x27;id&#x27;</span> <span class="keyword">at</span> <span class="type">row</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>也就是说，<code>tinyint</code>主键限制表内最多255条数据。</p><p>那除了主键，还有哪些因素会影响行数？</p><br><h3 id="索引的结构"><a href="#索引的结构" class="headerlink" title="索引的结构"></a>索引的结构</h3><p>索引内部是用的B+树，这个也是八股文老股了，大家估计也背得很熟了。</p><p>为了不让大家有过于强烈的审丑疲劳，今天我尝试从另外一个角度给大家讲讲这玩意。</p><br><h4 id="页的结构"><a href="#页的结构" class="headerlink" title="页的结构"></a>页的结构</h4><p>假设我们有这么一张user数据表。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png" alt="user表"></p><span id="more"></span><p>其中id是<strong>唯一主键</strong>。</p><p>这看起来的一行行数据，为了方便，我们后面就叫它们<strong>record</strong>吧。</p><p>这张表看起来就跟个excel表格一样。excel的数据在硬盘上是一个xx.excel的文件。</p><p>而上面user表数据，在硬盘上其实也是类似，放在了user.<strong>ibd</strong>文件下。含义是user表的innodb data文件，专业点，又叫<strong>表空间</strong>。</p><p>虽然在数据表里，它们看起来是挨在一起的。但实际上在user.ibd里他们被分成很多小份的<strong>数据页</strong>，每份大小16k。</p><p>类似于下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ibd%E6%96%87%E4%BB%B6%E5%86%85%E9%83%A8%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E9%A1%B5.png" alt="ibd文件内部有大量的页"></p><p>我们把视角聚焦一下，放到页上面。</p><p>整个页<code>16k</code>，不大，但record这么多，一页肯定放不下，所以会分开放到很多页里。并且这16k，也不可能全用来放record对吧。</p><p>因为record们被分成好多份，放到好多页里了，为了唯一标识具体是哪一页，那就需要引入<strong>页号</strong>（其实是一个表空间的地址偏移量）。同时为了把这些数据页给关联起来，于是引入了<strong>前后指针</strong>，用于指向前后的页。这些都被加到了<strong>页头</strong>里。</p><p>页是需要读写的，16k说小也不小，写一半电源线被拔了也是有可能发生的，所以为了保证数据页的正确性，还引入了校验码。这个被加到了<strong>页尾</strong>。</p><p>那剩下的空间，才是用来放我们的record的。而record如果行数特别多的话，进入到页内时挨个遍历，效率也不太行，所以为这些数据生成了一个<strong>页目录</strong>，具体实现细节不重要。只需要知道，它可以通过<strong>二分查找</strong>的方式将查找效率**从O(n) 变成O(lgn)**。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="页结构"><br></p><h4 id="从页到索引"><a href="#从页到索引" class="headerlink" title="从页到索引"></a>从页到索引</h4><p>如果想查一条record，我们可以把表空间里每一页都捞出来，再把里面的record捞出来挨个判断是不是我们要找的。</p><p>行数量小的时候，这么操作也没啥问题。</p><p><strong>行数量大了，性能就慢了</strong>，于是为了加速搜索，我们可以在每个数据页里选出<strong>主键id最小</strong>的record，而且只需要它们的<strong>主键id和所在页的页号</strong>。组成<strong>新的record</strong>，放入到一个新生成的一个数据页中，这个<strong>新数据页跟之前的页结构没啥区别，而且大小还是16k。</strong></p><p>但为了跟之前的数据页进行区分。数据页里加入了<strong>页层级（page level）</strong>的信息，从0开始往上算。于是页与页之间就有了<strong>上下层级</strong>的概念，就像下面这样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%A4%E5%B1%82B+%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="两层B+树结构"></p><p>突然页跟页之间看起来就像是一棵倒过来的树了。也就是我们常说的<strong>B+树</strong>索引。</p><p>最下面那一层，<strong>page level 为0</strong>，也就是所谓的<strong>叶子结点</strong>，其余都叫<strong>非叶子结点</strong>。</p><p>上面展示的是<strong>两层</strong>的树，如果数据变多了，我们还可以再通过类似的方法，再往上构建一层。就成了<strong>三层</strong>的树。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/B+%E6%A0%91%E7%BB%93%E6%9E%841.png" alt="三层B+树结构"></p><br><p>那现在我们就可以通过这样一棵B+树加速查询。举个例子。</p><p>比方说我们想要查找行数据5。会先从顶层页的record们入手。<strong>record里包含了主键id和页号（页地址）</strong>。看下图黄色的箭头，向左最小id是1，向右最小id是7。那id=5的数据如果存在，那必定在左边箭头。于是顺着的record的页地址就到了<code>6号</code>数据页里，再判断id=5&gt;4，所以肯定在右边的数据页里，于是加载<code>105号</code>数据页。在数据页里找到id=5的数据行，完成查询。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/B+%E6%A0%91%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="B+树查询过程"></p><p>另外需要注意的是，上面的页的页号并不是连续的，它们在磁盘里也不一定是挨在一起的。</p><p>这个过程中查询了三个页，如果这三个页都在磁盘中（没有被提前加载到内存中），那么<strong>最多</strong>需要经历三次<strong>磁盘IO查询</strong>，它们才能被加载到内存中。</p><br><h3 id="B-树承载的记录数量"><a href="#B-树承载的记录数量" class="headerlink" title="B+树承载的记录数量"></a>B+树承载的记录数量</h3><p>从上面的结构里可以看出B+树的<strong>最末级叶子结点</strong>里放了record数据。而<strong>非叶子结点</strong>里则放了用来加速查询的索引数据。</p><p>也就是说</p><p>同样一个16k的页，非叶子节点里每一条数据都指向一个新的页，而新的页有两种可能。</p><ul><li>如果是末级叶子节点的话，那么里面放的就是一行行record数据。</li><li>如果是非叶子节点，那么就会循环继续指向新的数据页。</li></ul><p>假设</p><ul><li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li><li>叶子节点内能容纳的record数量为<code>y</code></li><li>B+树的层数为<code>z</code></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%80%BB%E8%A1%8C%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95.png" alt="总行数的计算方法"></p><p>那这棵B+树放的<strong>行数据总量</strong>等于 <code>(x ^ (z-1)) * y</code>。</p><br><h4 id="x怎么算"><a href="#x怎么算" class="headerlink" title="x怎么算"></a>x怎么算</h4><p>我们回去看数据页的结构。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="页结构"></p><p>非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。</p><p>主键假设是<code>bigint（8Byte）</code>，而页号在源码里叫<code>FIL_PAGE_OFFSET（4Byte）</code>，那么非叶子节点里的一条数据是<code>12Byte</code>左右。</p><p>整个数据页<code>16k</code>， 页头页尾那部分数据全加起来大概<code>128Byte</code>，加上页目录毛估占<code>1k</code>吧。那剩下的<strong>15k</strong>除以<code>12Byte</code>，等于<code>1280</code>，也就是可以指向<strong>x=1280页</strong>。</p><p>我们常说的二叉树指的是一个结点可以发散出两个新的结点。m叉树一个节点能指向m个新的结点。这个指向新节点的操作就叫<strong>扇出（fanout）</strong>。</p><p>而上面的B+树，它能指向1280个新的节点，恐怖如斯，可以说<strong>扇出非常高</strong>了。</p><br><h4 id="y的计算"><a href="#y的计算" class="headerlink" title="y的计算"></a>y的计算</h4><p>叶子节点和非叶子节点的数据结构是一样的，所以也假设剩下<code>15kb</code>可以发挥。</p><p>叶子节点里放的是真正的行数据。假设一条行数据<code>1kb</code>，所以一页里能放<strong>y=15行</strong>。</p><br><h4 id="行总数计算"><a href="#行总数计算" class="headerlink" title="行总数计算"></a>行总数计算</h4><p>回到  <code>(x ^ (z-1)) * y </code>   这个公式。</p><p>已知<code>x=1280</code>，<code>y=15</code>。</p><p>假设B+树是<strong>两层</strong>，那<code>z=2</code>。则是<code>(1280 ^ (2-1)) * 15 ≈ 2w </code> </p><p>假设B+树是<strong>三层</strong>，那<code>z=3</code>。则是<code>(1280 ^ (3-1)) * 15 ≈ 2.5kw</code></p><p><strong>这个2.5kw，就是我们常说的单表建议最大行数2kw的由来。</strong>毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘IO，也比较合理。</p><br><h3 id="行数超一亿就慢了吗？"><a href="#行数超一亿就慢了吗？" class="headerlink" title="行数超一亿就慢了吗？"></a>行数超一亿就慢了吗？</h3><p>上面假设单行数据用了1kb，所以一个数据页能放个15行数据。</p><p>如果我单行数据用不了这么多，比如只用了<code>250byte</code>。那么单个数据页能放60行数据。</p><p>那同样是三层B+树，单表支持的行数就是 <code>(1280 ^ (3-1)) * 60 ≈ 1个亿</code>。</p><p>你看我一个亿的数据，其实也就三层B+树，在这个B+树里要查到某行数据，最多也是三次磁盘IO。所以并不慢。</p><p>这就很好的解释了文章开头，为什么我单表1个亿，但查询性能没啥大毛病。</p><br><h3 id="B树承载的记录数量"><a href="#B树承载的记录数量" class="headerlink" title="B树承载的记录数量"></a>B树承载的记录数量</h3><p>既然都聊到这里了，我们就顺着这个话题多聊一些吧。</p><p>我们都知道，现在mysql的索引都是B+树，而有一种树，跟B+树很像，叫<strong>B树，也叫B-树</strong>。</p><p>它跟B+树最大的区别在于，<strong>B+树只在末级叶子结点处放数据表行数据，而B树则会在叶子和非叶子结点上都放。</strong></p><p>于是，B树的结构就类似这样</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/B%E6%A0%91%E7%BB%93%E6%9E%84.png" alt="B树结构"></p><p>B树将行数据都存在非叶子节点上，假设每个数据页还是16kb，掐头去尾每页剩15kb，并且一条数据表行数据还是占1kb，就算不考虑各种页指针的情况下，也只能放个15条数据。<strong>数据页扇出明显变少了。</strong></p><p>计算可承载的总行数的公式也变成了一个<strong>等比数列</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">15 + 15^2 +15^3 + ... + 15^z</span><br></pre></td></tr></table></figure><p>其中<strong>z还是层数</strong>的意思。</p><p>为了能放<code>2kw</code>左右的数据，需要<code>z&gt;=6</code>。也就是树需要有6层，查一次要访问6个页。假设这6个页并不连续，为了查询其中一条数据，最坏情况需要进行<strong>6次磁盘IO</strong>。</p><p>而B+树同样情况下放2kw数据左右，查一次最多是<strong>3次磁盘IO。</strong></p><p>磁盘IO越多则越慢，这两者在性能上差距略大。</p><p>为此，<strong>B+树比B树更适合成为mysql的索引。</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>B+树叶子和非叶子结点的数据页都是16k，且数据结构一致，区别在于叶子节点放的是真实的行数据，而非叶子结点放的是主键和下一个页的地址。</li><li>B+树一般有两到三层，由于其高扇出，三层就能支持2kw以上的数据，且一次查询最多1~3次磁盘IO，性能也还行。</li><li>存储同样量级的数据，B树比B+树层级更高，因此磁盘IO也更多，所以B+树更适合成为mysql索引。</li><li>索引结构不会影响单表最大行数，2kw也只是推荐值，超过了这个值可能会导致B+树层级更高，影响查询性能。</li><li>单表最大值还受主键大小和磁盘大小限制。</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《MYSQL内核：INNODB存储引擎 卷1》</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><br><p>虽然我在单表里塞了1亿条数据，但这个操作的前提是，我很清楚这不会太影响性能。</p><p>这波解释，毫无破绽，无懈可击。</p><p>到这里，连我自己都被自己说服了。想必实习生也是。</p><p>可恶，这该死的毒瘤竟然有些”知识渊博”。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/p34066865-20220327102515813.jpg"></p><br><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mysql数据库查询好慢，除了索引，还能因为什么？</title>
      <link href="/2022/03/22/%E5%9B%BE%E8%A7%A3mysql/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A5%BD%E6%85%A2%EF%BC%8C%E9%99%A4%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%98%E8%83%BD%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/03/22/%E5%9B%BE%E8%A7%A3mysql/Mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%A5%BD%E6%85%A2%EF%BC%8C%E9%99%A4%E4%BA%86%E7%B4%A2%E5%BC%95%EF%BC%8C%E8%BF%98%E8%83%BD%E5%9B%A0%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>我熟练应用ctrl c和ctrl v 开发curd代码好多年了。</p><p>mysql查询为什么会慢，关于这个问题，在实际开发经常会遇到，而面试中，也是个高频题。</p><p>遇到这种问题，我们一般也会想到是因为索引。</p><p><strong>那除开索引之外，还有哪些因素会导致数据库查询变慢呢？</strong></p><p><strong>有哪些操作，可以提升mysql的查询能力呢？</strong></p><p>今天这篇文章，我们就来聊聊会导致数据库查询变慢的场景有哪些，并给出原因和解决方案。</p><br><h3 id="数据库查询流程"><a href="#数据库查询流程" class="headerlink" title="数据库查询流程"></a>数据库查询流程</h3><p>我们先来看下，一条查询语句下来，会经历哪些流程。</p><p>比如我们有一张数据库表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">10</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;年龄&#x27;</span>,</span><br><span class="line">  `gender` <span class="type">int</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;性别&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_age` (`age`),</span><br><span class="line">  KEY `idx_gender` (`gender`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><p>我们平常写的应用代码（go或C++之类的），这时候就叫<strong>客户端</strong>了。</p><p>客户端底层会带着账号密码，尝试向mysql建立一条TCP长链接。</p><p>mysql的<strong>连接管理模块</strong>会对这条连接进行管理。</p><p>建立连接后，客户端执行一条查询sql语句。 比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>客户端会将sql语句通过网络连接给mysql。</p><p>mysql收到sql语句后，会在<strong>分析器</strong>中先判断下SQL语句有没有语法错误，比如select，如果少打一个<code>l</code>，写成<code>slect</code>，则会报错<code>You have an error in your SQL syntax; </code>。这个报错对于我这样的手残党来说可以说是很熟悉了。</p><p>接下来是<strong>优化器</strong>，在这里会<strong>根据一定的规则选择该用什么索引</strong>。</p><p>之后，才是通过<strong>执行器</strong>去调用<strong>存储引擎</strong>的接口函数。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Mysql%E6%9E%B6%E6%9E%843-20220320082526675.png" alt="Mysql架构"></p><span id="more"></span><p><strong>存储引擎</strong>类似于一个个组件，它们才是mysql真正获取一行行数据并返回数据的地方，存储引擎是可以替换更改的，既可以用不支持事务的MyISAM，也可以替换成支持事务的Innodb。这个可以在建表的时候指定。比如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  ...</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br></pre></td></tr></table></figure><p>现在最常用的是<strong>InnoDB</strong>。</p><p>我们就重点说这个。</p><p>InnoDB中，因为直接操作磁盘会比较慢，所以加了一层内存提提速，叫<strong>buffer pool</strong>，这里面，放了很多内存页，每一页16KB，有些内存页放的是数据库表里看到的那种一行行的数据，有些则是放的索引信息。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/bufferPool%E4%B8%8E%E7%A3%81%E7%9B%982.png" alt="bufferPool与磁盘"></p><p>查询SQL到了InnoDB中。会根据前面优化器里计算得到的索引，去<strong>查询相应的索引页</strong>，如果不在buffer pool里则从磁盘里加载索引页。<strong>再通过索引页加速查询，得到数据页</strong>的具体位置。如果这些数据页不在buffer pool中，则从磁盘里加载进来。</p><p>这样我们就得到了我们想要的一行行数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E7%B4%A2%E5%BC%95%E9%A1%B5%E4%B8%8E%E7%A3%81%E7%9B%98%E9%A1%B5%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="索引页与磁盘页的关系"></p><p>最后将得到的数据结果返回给客户端。</p><br><h3 id="慢查询分析"><a href="#慢查询分析" class="headerlink" title="慢查询分析"></a>慢查询分析</h3><p>如果上面的流程比较慢的话，我们可以通过开启<code>profiling</code>看到流程慢在哪。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> profiling<span class="operator">=</span><span class="keyword">ON</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;profiling&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="operator">|</span> profiling     <span class="operator">|</span> <span class="keyword">ON</span>    <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>然后正常执行sql语句。</p><p>这些SQL语句的执行时间都会被记录下来，此时你想查看有哪些语句被记录下来了，可以执行 <code>show profiles;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profiles;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                             <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">1</span> <span class="operator">|</span> <span class="number">0.06811025</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">&gt;=</span><span class="number">60</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">2</span> <span class="operator">|</span> <span class="number">0.00151375</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">80</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">3</span> <span class="operator">|</span> <span class="number">0.00230425</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">60</span>  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">4</span> <span class="operator">|</span> <span class="number">0.00070400</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> gender <span class="operator">=</span> <span class="number">2</span> <span class="keyword">and</span> age <span class="operator">=</span> <span class="number">100</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>        <span class="number">5</span> <span class="operator">|</span> <span class="number">0.07797650</span> <span class="operator">|</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> age<span class="operator">!=</span><span class="number">60</span>                  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------+</span></span><br><span class="line"><span class="number">5</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>关注下上面的<code>query_id</code>，比如<code>select * from user where age&gt;=60 </code>对应的query_id是1，如果你想查看这条SQL语句的具体耗时，那么可以执行以下的命令。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">1</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> Status               <span class="operator">|</span> Duration <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="operator">|</span> starting             <span class="operator">|</span> <span class="number">0.000074</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> checking permissions <span class="operator">|</span> <span class="number">0.000010</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Opening tables       <span class="operator">|</span> <span class="number">0.000034</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> init                 <span class="operator">|</span> <span class="number">0.000032</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">System</span> lock          <span class="operator">|</span> <span class="number">0.000027</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> optimizing           <span class="operator">|</span> <span class="number">0.000020</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> statistics           <span class="operator">|</span> <span class="number">0.000058</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> preparing            <span class="operator">|</span> <span class="number">0.000018</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> executing            <span class="operator">|</span> <span class="number">0.000013</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Sending data         <span class="operator">|</span> <span class="number">0.067701</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">end</span>                  <span class="operator">|</span> <span class="number">0.000021</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> query <span class="keyword">end</span>            <span class="operator">|</span> <span class="number">0.000015</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> closing tables       <span class="operator">|</span> <span class="number">0.000014</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> freeing items        <span class="operator">|</span> <span class="number">0.000047</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> cleaning up          <span class="operator">|</span> <span class="number">0.000027</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------------------+----------+</span></span><br><span class="line"><span class="number">15</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span>, <span class="number">1</span> warning (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>通过上面的各个项，大家就可以看到具体耗时在哪。比如从上面可以看出Sending data的耗时最大，这个是指<strong>执行器</strong>开始查询数据并将数据发送给客户端的耗时，因为我的这张表符合条件的数据有<strong>好几万条</strong>，所以这块耗时最大，也符合预期。</p><p>一般情况下，我们开发过程中，耗时大部分时候都在<code>Sending data</code>阶段，而这一阶段里如果慢的话，最容易想到的还是索引相关的原因。</p><br><h3 id="索引相关原因"><a href="#索引相关原因" class="headerlink" title="索引相关原因"></a>索引相关原因</h3><p>索引相关的问题，一般能用explain命令帮助分析。通过它能看到<strong>用了哪些索引</strong>，大概会<strong>扫描多少行</strong>之类的信息。</p><p>mysql会在<strong>优化器阶段</strong>里看下选择哪个索引，查询速度会更快。</p><p>一般主要考虑几个因素，比如：</p><ul><li>选择这个索引大概要扫描<strong>多少行</strong>（rows）</li><li>为了把这些行取出来，需要读<strong>多少个16kb的页</strong></li><li>走普通索引需要回表，主键索引则不需要，<strong>回表成本</strong>大不大？</li></ul><br><p>回到show profile中提到的sql语句，我们使用<code>explain select * from user where age&gt;=60</code> 分析一下。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220319080215281.png" alt="explain sql"></p><p>上面的这条语句，使用的<code>type</code>为ALL，意味着是<strong>全表扫描</strong>，<code>possible_keys</code>是指<strong>可能用得到的索引</strong>，这里可能使用到的索引是为age建的普通索引，但实际上数据库使用的索引是在<code>key</code>那一列，是<code>NULL</code>。也就是说<strong>这句sql不走索引，全表扫描</strong>。</p><p>这个是因为数据表里，符合条件的数据行数（<code>rows</code>）太多，如果使用age索引，那么需要将它们从age索引中读出来，并且age索引是<strong>普通索引</strong>，还需要<strong>回表</strong>找到对应的<strong>主键</strong>才能找到对应的<strong>数据页</strong>。算下来还不如直接走主键划算。于是最终选择了全表扫描。</p><p>当然上面只是举了个例子，实际上，mysql执行sql时，<strong>不用索引或者用的索引不符合我们预期</strong>这件事经常发生，索引失效的场景有很多，比如用了<strong>不等号，隐式转换</strong>等，这个相信大家背八股文的时候也背过不少了，我也不再赘述。</p><p>聊两个生产中容易遇到的问题吧。</p><br><h4 id="索引不符合预期"><a href="#索引不符合预期" class="headerlink" title="索引不符合预期"></a>索引不符合预期</h4><p>实际开发中有些情况比较特殊，比如有些数据库表一开始数据量小，索引少，执行sql时，确实使用了符合你预期的索引。但随时时间边长，开发的人变多了，数据量也变大了，甚至还可能会加入一些其他重复多余的索引，就有可能出现用着用着，用到了不符合你预期的其他索引了。从而导致查询突然变慢。</p><p>这种问题，也好解决，可以通过<code>force index</code><strong>指定索引</strong>。比如</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220319093631814.png" alt="force index指定索引"></p><p>通过<code>explain</code>可以看出，加了force index之后，sql就选用了idx_age这个索引了。</p><br><h4 id="走了索引还是很慢"><a href="#走了索引还是很慢" class="headerlink" title="走了索引还是很慢"></a>走了索引还是很慢</h4><p>有些sql，用<code>explain</code>命令看，明明是走索引的，但还是很慢。一般是两种情况：</p><p>第一种是索引区分度太低，比如网页全路径的url链接，这拿来做索引，一眼看过去全都是同一个域名，如果<strong>前缀索引</strong>的长度建得不够长，那这走索引跟走<strong>全表扫描</strong>似的，正确姿势是尽量让索引的<strong>区分度</strong>更高，比如域名去掉，只拿后面URI部分去做索引。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E7%B4%A2%E5%BC%95%E5%89%8D%E7%BC%80%E5%8C%BA%E5%88%86%E5%BA%A6%E5%A4%AA%E4%BD%8E.drawio.png" alt="索引前缀区分度太低"></p><p>第二种是索引中匹配到的数据太大，这时候需要关注的是explain里的<strong>rows</strong>字段了。</p><p>它是用于<strong>预估</strong>这个查询语句需要查的行数的，它不一定完全准确，但可以体现个大概量级。</p><p>当它很大时，一般常见的是下面几种情况。</p><ul><li><p>如果这个字段具有<strong>唯一</strong>的属性，比如电话号码等，一般是不应该有大量重复的，那可能是你代码逻辑出现了<strong>大量重复插入</strong>的操作，你需要检查下代码逻辑，或者需要加个<strong>唯一索引</strong>限制下。</p></li><li><p>如果这个字段下的数据就是会很大，是否需要全部拿？如果不需要，加个<code>limit</code>限制下。如果确实要拿全部，那也不能一次性全拿，今天你数据量小，可能一次取一两万都没啥压力，万一哪天涨到了十万级别，那一次性取就有点吃不消了。你可能需要<strong>分批次取</strong>，具体操作是先用<code>order by id</code>排序一下，拿到一批数据后取<code>最大id</code>作为下次取数据的起始位置。</p></li></ul><br><h3 id="连接数过小"><a href="#连接数过小" class="headerlink" title="连接数过小"></a>连接数过小</h3><p>索引相关的原因我们聊完了，我们来聊聊，<strong>除了索引之外，还有哪些因素会限制我们的查询速度的。</strong></p><p>我们可以看到，mysql的server层里有个<strong>连接管理</strong>，它的作用是管理客户端和mysql之间的长连接。</p><p>正常情况下，客户端与server层如果只有<strong>一条</strong>连接，那么在执行sql查询之后，只能阻塞等待结果返回，如果有大量查询同时并发请求，那么<strong>后面的请求都需要等待前面的请求执行完成</strong>后，才能开始执行。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%BF%9E%E6%8E%A5%E8%BF%87%E5%B0%91%E4%BC%9A%E5%AF%BC%E8%87%B4sql%E9%98%BB%E5%A1%9E.png" alt="连接过少会导致sql阻塞"></p><p>因此很多时候我们的应用程序，比如go或java这些，<strong>会打印出sql执行了几分钟的日志，但实际上你把这条语句单独拎出来执行，却又是毫秒级别的。</strong>这都是因为这些sql语句在<strong>等待</strong>前面的sql执行完成。</p><p>怎么解决呢？</p><p>如果我们能<strong>多建几条连接</strong>，那么请求就可以并发执行，后面的连接就不用等那么久了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%A2%9E%E5%8A%A0%E8%BF%9E%E6%8E%A5%E5%8F%AF%E4%BB%A5%E5%8A%A0%E5%BF%AB%E6%89%A7%E8%A1%8Csql.png" alt="增加连接可以加快执行sql"></p><p>而连接数过小的问题，<strong>受数据库和客户端两侧同时限制</strong>。</p><br><h4 id="数据库连接数过小"><a href="#数据库连接数过小" class="headerlink" title="数据库连接数过小"></a>数据库连接数过小</h4><p>Mysql的最大连接数默认是<code>100</code>, 最大可以达到<code>16384</code>。</p><p>可以通过设置mysql的<code>max_connections</code>参数，更改数据库的最大连接数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> max_connections<span class="operator">=</span> <span class="number">500</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;max_connections&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name   <span class="operator">|</span> <span class="keyword">Value</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="operator">|</span> max_connections <span class="operator">|</span> <span class="number">500</span>   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><p>上面的操作，就把最大连接数改成了500。</p><br><h4 id="应用侧连接数过小"><a href="#应用侧连接数过小" class="headerlink" title="应用侧连接数过小"></a>应用侧连接数过小</h4><p>数据库连接大小是调整过了，但貌似问题还是没有变化？还是有很多sql执行达到了几分钟，甚至超时？</p><p>那有可能是因为你应用侧（go，java写的应用，也就是mysql的客户端）的连接数也过小。</p><p>应用侧与mysql底层的连接，是<strong>基于TCP协议的长链接</strong>，而TCP协议，需要经过<strong>三次握手和四次挥手</strong>来实现建连和释放。如果我每次执行sql都重新建立一个新的连接的话，那就要不断握手和挥手，这很<strong>耗时</strong>。所以一般会建立一个<strong>长连接池</strong>，连接用完之后，塞到连接池里，下次要执行sql的时候，再从里面捞一条连接出来用，非常环保。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/connection_pool.png" alt="连接池原理"></p><p>我们一般写代码的时候，都会通过第三方的<strong>orm库</strong>来对数据库进行操作，而成熟的orm库，<strong>百分之一千万都会有个连接池。</strong></p><p>而这个连接池，一般会有个大小。这个大小就控制了你的连接数最大值，如果说你的连接池太小，都还没有数据库的大，那调了数据库的最大连接数也没啥作用。</p><p>一般情况下，可以翻下你使用的orm库的文档，看下怎么设置这个连接池的大小，就几行代码的事情，改改就好。比如go语言里的<code>gorm</code>里是这么设置的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">()</span></span> &#123;</span><br><span class="line">  db, err := gorm.Open(mysql.Open(conn), config)</span><br><span class="line">sqlDB, err := db.DB()</span><br><span class="line"><span class="comment">// SetMaxIdleConns 设置空闲连接池中连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxIdleConns(<span class="number">200</span>)</span><br><span class="line"><span class="comment">// SetMaxOpenConns 设置打开数据库连接的最大数量</span></span><br><span class="line">sqlDB.SetMaxOpenConns(<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h3 id="buffer-pool太小"><a href="#buffer-pool太小" class="headerlink" title="buffer pool太小"></a>buffer pool太小</h3><p>连接数是上去了，速度也提升了。</p><p>曾经遇到过面试官会追问，<strong>有没有其他办法可以让速度更快呢？</strong></p><p>那必须要眉头紧锁，假装思考，然后说：<strong>有的</strong>。</p><p>我们在前面的数据库查询流程里，提到了进了innodb之后，会有一层内存buffer pool，用于将磁盘数据页加载到内存页中，只要查询到buffer pool里有，就可以直接返回，否则就要走磁盘IO，那就慢了。</p><p>也就是说，<strong>如果我的buffer pool 越大，那我们能放的数据页就越多，相应的，sql查询时就更可能命中buffer pool，那查询速度自然就更快了。</strong></p><p>可以通过下面的命令查询到buffer pool的大小，单位是<code>Byte</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">134217728</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>也就是<code>128Mb</code>。</p><p>如果想要调大一点。可以执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">set</span> <span class="keyword">global</span> innodb_buffer_pool_size <span class="operator">=</span> <span class="number">536870912</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.01</span> sec)</span><br><span class="line"></span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;innodb_buffer_pool_size&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name           <span class="operator">|</span> <span class="keyword">Value</span>     <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="operator">|</span> innodb_buffer_pool_size <span class="operator">|</span> <span class="number">536870912</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-------------------------+-----------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>这样就把buffer pool增大到512Mb了。</p><p>但是吧，如果buffer pool大小正常，只是<strong>别的原因</strong>导致的查询变慢，那改buffer pool毫无意义。</p><p>但问题又来了。</p><br><h4 id="怎么知道buffer-pool是不是太小了？"><a href="#怎么知道buffer-pool是不是太小了？" class="headerlink" title="怎么知道buffer pool是不是太小了？"></a>怎么知道buffer pool是不是太小了？</h4><p>这个我们可以看<strong>buffer pool的缓存命中率</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220319113917654.png" alt="查看buffer pool命中率"></p><p>通过 <code>show status like  &#39;Innodb_buffer_pool_%&#39;;</code>可以看到跟buffer pool有关的一些信息。</p><p> <code>Innodb_buffer_pool_read_requests</code>表示读请求的次数。</p><p><code>Innodb_buffer_pool_reads</code> 表示从物理磁盘中读取数据的请求次数。</p><p>所以buffer pool的命中率就可以这样得到：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer pool 命中率 <span class="operator">=</span> <span class="number">1</span> <span class="operator">-</span> (Innodb_buffer_pool_reads<span class="operator">/</span>Innodb_buffer_pool_read_requests) <span class="operator">*</span> <span class="number">100</span><span class="operator">%</span></span><br></pre></td></tr></table></figure><p>比如我上面截图里的就是，1 - (405/2278354) = 99.98%。可以说命中率非常高了。</p><p>一般情况下<strong>buffer pool命中率</strong>都在<code>99%</code>以上，如果低于这个值，才需要考虑加大innodb buffer pool的大小。</p><p>当然，还可以把这个命中率做到<strong>监控</strong>里，这样半夜sql变慢了，早上上班还能定位到原因，就很舒服。</p><br><h3 id="还有哪些骚操作？"><a href="#还有哪些骚操作？" class="headerlink" title="还有哪些骚操作？"></a>还有哪些骚操作？</h3><p>前面提到的是在<strong>存储引擎层</strong>里加入了buffer pool用于缓存内存页，这样可以加速查询。</p><p>那同样的道理，<strong>server层</strong>也可以加个缓存，直接将第一次查询的结果缓存下来，这样<strong>下次</strong>查询就能立刻返回，听着挺美的。</p><p>按道理，如果命中缓存的话，确实是能为查询加速的。但这个功能限制很大，其中最大的问题是只要数据库表被更新过，表里面的<strong>所有缓存都会失效</strong>，数据表频繁的更新，就会带来频繁的缓存失效。所以这个功能只适合用于那些<strong>不怎么更新的数据表。</strong></p><p>另外，这个功能在<code>8.0版本</code>之后，就被<strong>干掉</strong>了。所以这功能用来聊聊天可以，没必要真的在生产中使用啊。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98%E8%A2%AB%E5%88%A0%E9%99%A4.png" alt="查询缓存被删除"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>数据查询过慢一般是索引问题，可能是因为选错索引，也可能是因为查询的行数太多。</li><li>客户端和数据库连接数过小，会限制sql的查询并发数，增大连接数可以提升速度。</li><li>innodb里会有一层内存buffer pool用于提升查询速度，命中率一般&gt;99%，如果低于这个值，可以考虑增大buffer pool的大小，这样也可以提升速度。</li><li>查询缓存（query cache）确实能为查询提速，但一般不建议打开，因为限制比较大，并且8.0以后的Mysql里已经将这个功能干掉了。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p><p>我有个不成熟的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p><br><p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p><p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p><p>我这么善良质朴的愿望，能被满足吗？</p><p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>两个事务并发写，能保证数据唯一吗？</title>
      <link href="/2022/03/16/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%86%99%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E5%90%97%EF%BC%9F/"/>
      <url>/2022/03/16/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%A4%E4%B8%AA%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E5%86%99%EF%BC%8C%E8%83%BD%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%94%AF%E4%B8%80%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>哟，又是我小白。最近有点高产了。</p><p>连我自己都害怕了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006APoFYly8grrdl7zawuj30af0afwiu.jpg"></p><span id="more"></span><p>直接进入正题吧。</p><br><h2 id="两个事务并发写，能保证数据唯一吗？"><a href="#两个事务并发写，能保证数据唯一吗？" class="headerlink" title="两个事务并发写，能保证数据唯一吗？"></a>两个事务并发写，能保证数据唯一吗？</h2><p>我先来解释下标题讲的是个啥。</p><br><p>我们假设有这么一个用户注册的场景。用户并发请求注册新用户。</p><p>你有一张数据库表，也就是下面的user表。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="user表数据库原始状态"></p><p>产品经理要求用户和用户之间，电话号码不能重复，为了保证这一点。我们想到了先查一下数据库，再判断一下，如果存在，就退出，否则插入一条数据。类似下面这样的伪代码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">where</span> phone_no <span class="operator">=</span><span class="number">2</span>;  <span class="operator">/</span><span class="operator">/</span> 查询<span class="keyword">sql</span></span><br><span class="line">if (<span class="keyword">user</span> 存在) &#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">user</span>;   <span class="operator">/</span><span class="operator">/</span> 插入<span class="keyword">sql</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这是两条sql语句，先执行查询sql，判断后再决定要不要执行插入sql。每次用户注册的时候都会执行这么一段逻辑。</p><p>那如果，此时有多个用户在做操作，就会<strong>并发</strong>执行这段逻辑。</p><p>如果都并发执行，第一条sql语句执行完之后，都会发现没有用户存在。此时都执行了插入，这样就出现了两条一样的数据才对。</p><p>所以，有人就想了，这<strong>两条sql语句逻辑应该是一个整体</strong>，不应该拆开，于是就想到了事务，通过事务把这两个sql作为<strong>一个整体</strong>，要么一起执行，要么都回滚。</p><p>这正是数据库ACID里的A（Atomicity），原子性的完美体现啊。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ACID.png" alt="ACID"></p><p>伪代码类似下面这样。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">where</span> phone_no <span class="operator">=</span><span class="number">2</span>;  <span class="operator">/</span><span class="operator">/</span> 查询<span class="keyword">sql</span></span><br><span class="line">if (<span class="keyword">user</span> 存在) &#123;</span><br><span class="line"><span class="keyword">return</span> </span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">insert</span> <span class="keyword">user</span>;   <span class="operator">/</span><span class="operator">/</span> 插入<span class="keyword">sql</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>那么问题来了，<strong>这段逻辑，并发执行，能保证数据唯一？</strong></p><p><strong>当然是不能。</strong></p><p>事务內的多条sql语句，确实是原子的，要么一起成功，要么一起失败，这没错，但跟这个场景没什么太大关系。事务是并发执行的，第一个事务执行查询用户，并<strong>不会阻塞</strong>另一个事务查询用户，所以都有可能查到用户不存在，此时两个事务逻辑都判断为用户不存在，然后插入数据库。事务内两条sql都执行成功了，于是就插入了两条一样的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%86%99%E5%85%A5%E4%B8%A4%E6%9D%A1%E6%95%B0%E6%8D%AE.drawio.png" alt="并发事务写入两条数据.drawio"></p><br><h2 id="怎么保证数据唯一？"><a href="#怎么保证数据唯一？" class="headerlink" title="怎么保证数据唯一？"></a>怎么保证数据唯一？</h2><p>那么我们接下来聊聊，怎么保证上面这种场景下，插入的数据是唯一的。方法有很多种，但我们今天只讨论mysql内部的做法，不考虑其他外部中间件（比如redis分布式锁这些）。</p><br><h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>通过下面的命令，可以为数据库user表的phone_no字段加入唯一索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE `user` ADD unique(`phone_no`);</span><br></pre></td></tr></table></figure><p>我们执行一条写操作时，比如下面这句，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`user_name`, `phone_no`) <span class="keyword">VALUES</span>(<span class="string">&#x27;小红&#x27;</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>第一次会插入成功，第二次再执行插入，则会出现报错。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duplicate entry <span class="string">&#x27;2&#x27;</span> <span class="keyword">for</span> key <span class="string">&#x27;phone_no&#x27;</span></span><br></pre></td></tr></table></figure><p>含义是phone_no这个字段是唯一的，加两次phone_no=2会导致重复。</p><p>于是乎回到我们文章开头的场景里，就完美解决了重复插入的问题了。</p><br><p>那么问题来了。</p><br><h4 id="为什么唯一索引能保证数据唯一？"><a href="#为什么唯一索引能保证数据唯一？" class="headerlink" title="为什么唯一索引能保证数据唯一？"></a>为什么唯一索引能保证数据唯一？</h4><p>我们看看一句写操作，会经历什么。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/Mysql%E6%9E%B6%E6%9E%843.png" alt="Mysql架构"></p><p>首先，mysql作为一个数据库，内部主要分为两层，一层是<strong>server层</strong>，一层是<strong>存储引擎层</strong>（一般是<strong>innodb</strong>）。</p><p>server层主要管的是数据库链接，权限校验，以及sql语句校验和优化之类的工作。请求打到存储引擎层，才是真正的查询和更新数据的操作。</p><p>大家都知道数据库是持久化存储，且最后都是把数据存到<strong>磁盘</strong>上的。</p><p><strong>那数据库读写是直接读写磁盘数据吗？</strong></p><p>不是，如果直接读写磁盘的话，那就太慢了，为了提升速度。</p><p>它在磁盘前面加了一层内存，叫<strong>buffer pool</strong>。它里面有很多细节，但最主要的就是个双向链表，里面放的是一个个数据页，每个数据页的大小默认是 16kb，数据页里面放的就是磁盘的数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/bufferPool%E4%B8%8E%E7%A3%81%E7%9B%98.png" alt="bufferPool与磁盘"></p><p>于是有了这层buffer pool内存，mysql的读和写操作都可以先操作这部分内存，如果想要读写的数据页不在buffer pool里，再跑到磁盘里去捞。由于<strong>读写内存的速度比读写磁盘快得多</strong>。</p><p><strong>所以引擎读写都快多了。</strong></p><p>但这还不够，<strong>很多时候写操作，我的诉求就是把xx更新为xx，或插入xx，数据库光知道这一点就够了，我根本不需要知道数据页原来长什么样子。</strong></p><p>有点抽象？举个例子吧。</p><p>比方说我想要把id=1的这条数据的phone_no字段更新为100，数据库知道这一点就够了，至于这条数据原来phone_no究竟是等于20，还是30，这根本不重要，反正最后都会变成我想要的phone_no=100。</p><p>也就是说，如果有那么<strong>一块内存</strong>，记录下我准备把数据改成什么样子，然后后续异步慢慢更新到磁盘数据上。那我甚至到不需要在一开始就把这块数据从磁盘读到buffer pool中，按照这个思路，<strong>change buffer</strong>就来了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/changeBuffer%E5%9C%A8bufferPool%E5%86%852.png" alt="changeBuffer在bufferPool内"></p><p>于是乎，写加了<strong>普通索引</strong>的数据，它只要把想要写的内容写到change buffer上，就立马结束返回了。后面innodb引擎拿着这个change buffer，再异步读入磁盘数据到内存，将change buffer的数据修改到数据页中，再写回磁盘，这速度就上来了，秒啊。</p><p>但这个change buffer，放在<strong>唯一索引</strong>这里就不管用了，毕竟，它得保证数据真的只有一条，那就得去看下数据库里，是不是真的有这条数据。</p><p>所以，对于insert场景，普通索引把需求扔到change buffer就完事返回了，而唯一索引需要真的把数据从磁盘读到内存来，看下是不是有重复的，没重复的再插入数据。</p><p>这唯一索引，在性能上就输了一截了。</p><p>所以回到<strong>唯一索引为什么能保证数据唯一</strong>的问题上，一句话概括就是，<strong>唯一索引会绕过change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>加唯一索引可以保证数据并发写入时数据唯一，而且最省事省心。</p></li><li><p>数据库通过引入一层buffer pool内存来提升读写速度，普通索引可以利用change buffer提高数据插入的性能。</p></li><li><p>唯一索引会绕过change buffer，确保把磁盘数据读到内存后再判断数据是否存在，不存在才能插入数据，否则报错，以此来保证数据是唯一的。</p></li></ul><br><p>给大家留个问题呗，前面也提到了，<strong>innodb中，利用了change buffer，为普通索引做了加速</strong>。<strong>有没有哪些场景下，change buffer不仅不能给普通索引加速，还起到反作用的呢？</strong></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>大家也别笑，文章开头提到的通过开事务来保证数据唯一性的错误操作，其实很容易犯，而且我曾经也遇到过不止一次这样的事情。</p><p>做这个操作的人，还会信誓旦旦，言之凿凿的说出他的理解，在我解释了几遍发现无果之后，我选择低头假装思考，然后说：”你说的有点道理，我再回去好好想想”，然后默默的为数据表加上唯一索引……</p><p>我相信对方肯定已经理解了。那一刻，我感觉我写的不是代码，我写的是人情世故。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006ARE9vgy1fz5ahct0mhj30mk0m83zo.jpg"></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给32位系统装8g内存条能用吗？为什么？</title>
      <link href="/2022/03/09/%E5%9B%BE%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%9932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%A3%858g%E5%86%85%E5%AD%98%E6%9D%A1%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2022/03/09/%E5%9B%BE%E8%A7%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%BB%9932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%A3%858g%E5%86%85%E5%AD%98%E6%9D%A1%E8%83%BD%E7%94%A8%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/421646663617_.pic_hd.jpg"></p><p>关于32位和64位，这个概念一直让人比较懵。</p><span id="more"></span><p>在买电脑的时候，我们看到过<strong>32位和64位CPU</strong>。</p><p>下软件的时候，我们也看到过<strong>32位或64位的软件</strong>。</p><p>就连装虚拟机的时候，我们也看过<strong>32位和64位的系统</strong>。</p><p>在写代码的时候，我们的数值，也可以定义为<strong>int32或者int64</strong>。</p><p>我们当然很清楚，装软件的时候，一般64位的系统就选64位的软件，肯定不出错，但是这又是为什么呢？既然CPU，软件，操作系统，数值大小都有32位和64位，他们之间就可以随意组合成各种问题，比如32位的系统能装64位的软件吗？32位的系统能计算int64的数值吗？他们之间到底有什么关系？这篇文章会尝试解释清楚。</p><br><h3 id="从代码到到可执行文件"><a href="#从代码到到可执行文件" class="headerlink" title="从代码到到可执行文件"></a>从代码到到可执行文件</h3><p>我们从熟悉的场景开始说起，比方说，我们写代码的时候，会在代码编辑器里写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">         <span class="keyword">int</span> i,j;</span><br><span class="line">         i = <span class="number">3</span>;</span><br><span class="line">         j = <span class="number">2</span>;</span><br><span class="line">         <span class="keyword">return</span> i + j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这个代码是给人看的，机器可看不懂，于是这段代码，还会经过被编译器转成<strong>汇编码</strong>。</p><p>汇编码就是我们大学的时候学的头秃的这种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// gcc -S test.c</span><br><span class="line">pushq%rbp</span><br><span class="line">.cfi_def_cfa_offset 16</span><br><span class="line">.cfi_offset %rbp, -16</span><br><span class="line">movq%rsp, %rbp</span><br><span class="line">.cfi_def_cfa_register %rbp</span><br><span class="line">movl$0, -4(%rbp)</span><br><span class="line">movl$3, -8(%rbp)</span><br><span class="line">movl$2, -12(%rbp)</span><br><span class="line">movl-8(%rbp), %eax</span><br><span class="line">addl-12(%rbp), %eax</span><br><span class="line">popq%rbp</span><br><span class="line">retq</span><br></pre></td></tr></table></figure><p>大家也别去看上面的内容，没必要。</p><p>而汇编，总归还是有各种movl，pushq这些符号，虽然确实不好看，但说到底<strong>还是给人看的</strong>，而机器cpu要的，说到底还是要0101这样的<strong>二进制编码</strong>，所以还需要使用汇编器将汇编转成二进制的<strong>机器码</strong>。我们可以看到下面内容分为3列，左边是指令地址， 右边是汇编码内容，中间的就是指令机器码，是16进制，可以转成二进制01串，这就是机器cpu能认识的内容了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// objdump -d test</span><br><span class="line">0000000000001125 &lt;main&gt;:</span><br><span class="line">    1125:55                   push   %rbp</span><br><span class="line">    1126:48 89 e5             mov    %rsp,%rbp</span><br><span class="line">    1129:c7 45 fc 03 00 00 00 movl   $0x3,-0x4(%rbp)</span><br><span class="line">    1130:c7 45 f8 02 00 00 00 movl   $0x2,-0x8(%rbp)</span><br><span class="line">    1137:8b 55 fc             mov    -0x4(%rbp),%edx</span><br><span class="line">    113a:8b 45 f8             mov    -0x8(%rbp),%eax</span><br><span class="line">    113d:01 d0                add    %edx,%eax</span><br><span class="line">    113f:5d                   pop    %rbp</span><br><span class="line">    1140:c3                   retq   </span><br><span class="line">    1141:66 2e 0f 1f 84 00 00 nopw   %cs:0x0(%rax,%rax,1)</span><br><span class="line">    1148:00 00 00 </span><br><span class="line">    114b:0f 1f 44 00 00       nopl   0x0(%rax,%rax,1)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BB%8E%E9%AB%98%E7%BA%A7%E8%AF%AD%E8%A8%80%E5%88%B0%E6%9C%BA%E5%99%A8%E7%A0%81.drawio-20220419210021874.png" alt="从高级语言到机器码"></p><p>而机器码，最后会放在我们编译生成的<strong>可执行文件</strong>里。</p><p>也就是说我们平时写的代码，最后会变成一堆01机器码，放在可执行文件里，躺在磁盘上。</p><br><h3 id="从可执行文件到进程"><a href="#从可执行文件到进程" class="headerlink" title="从可执行文件到进程"></a>从可执行文件到进程</h3><p>一旦我们执行以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./可执行文件名</span><br></pre></td></tr></table></figure><p>这个可执行文件就会加载进<strong>内存</strong>中，成为一个<strong>进程</strong>，运行起来。</p><p>可执行文件里的机器码也会被加载到内存中，它就像是一张列满todo list的清单，而CPU就对照着这张清单，一行行的执行上面的机器码。从效果上来看，进程就动起来了。</p><p>对CPU来说，它执行到某个特定的编码数值，就会执行特定的操作。比如计算2+3，其实就是通过<strong>总线</strong>把数据2和3从<strong>内存</strong>里读入，然后放到<strong>寄存器</strong>上，再用加法器相加这两个数值并将结果放入到寄存器里，最后将这个数值回写到内存中，以此循环往复，一行行执行机器码直到退出。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%BF%9B%E7%A8%8B%E5%86%85%E5%AD%98%E4%B8%8ECPU%E7%9A%84%E6%89%A7%E8%A1%8C%E9%80%BB%E8%BE%91.drawio-20220419210036155.png" alt="进程内存与CPU的执行逻辑"></p><br><h4 id="CPU位数的含义"><a href="#CPU位数的含义" class="headerlink" title="CPU位数的含义"></a>CPU位数的含义</h4><p>上面这个流程里，最重要的几个关键词，分别是<strong>CPU寄存器，总线，内存</strong>。</p><p>CPU的寄存器，说白了就是个存放数值的小盒子，盒子的大小，叫<strong>位宽</strong>。32位CPU能放入最大2^32的数值。64位就是最大2^64的值。这里的32位位宽的CPU就是我们常说的32位CPU，同理64位CPU也是一样。</p><p>而<strong>CPU跟内存</strong>之间，是用<strong>总线</strong>来进行信号传输的，总线可以分为<strong>数据总线，控制总线，地址总线</strong>。功能如其名，举个例子说明下他们的作用吧。在一个进程的运行过程中，CPU会根据进程的机器码一行行执行操作。</p><p>比如现在有一行是将A地址的数据与B地址的数据相加，那么CPU就会通过<strong>控制总线</strong>，发送信号给内存这个设备，告诉它，现在CPU要通过<strong>地址总线</strong>在内存中找到<strong>A数据的地址</strong>，然后取得A数据的值，假设是100，那么这个100，就会通过<strong>数据总线</strong>回传到CPU的某个寄存器中。B也一样，假设B=200，放到另一个寄存器中，此时A和B相加后，结果是300，然后控制CPU通过<strong>地址总线</strong>找到返回的参数地址，再把数据结果通过<strong>数据总线</strong>传回内存中。这一存一取，CPU都是通过<strong>控制总线</strong>对内存发出指令的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%89%E7%B1%BB%E6%80%BB%E7%BA%BF.png" alt="三类总线"></p><p>而<strong>总线，也可以理解为有个宽度</strong>，比如宽度是32位，那么一次可以传32个0或1的信号，那么这个宽度能表达的数值范围就是0到2^32这么多。</p><p>32位CPU的总线宽度一般是32位，因为刚刚上面提到了，CPU可以利用地址总线在<strong>内存</strong>中进行寻址操作，那么现在这根地址总线，最大能寻址的范围，也就到2^32，其实就是4G。</p><p>64位CPU，按理说总线宽度是64位，但实际上是48位（也有看到说是40位或46位的，没关系，你知道它很大就行了），所以寻址范围能到2^48次方，也就是256T。</p><br><h4 id="系统和软件的位数的含义"><a href="#系统和软件的位数的含义" class="headerlink" title="系统和软件的位数的含义"></a>系统和软件的位数的含义</h4><p>上面提到了32位CPU和64位CPU的内存寻址范围，那么相应的操作系统，和软件（其实操作系统也能说是软件），也应该按CPU所能支持的范围去构建自己的寻址范围。</p><p>比方说下面这个图，在操作系统上运行一个用户态进程，会分为用户态和内核态，并设定一定的内存布局。操作系统和软件都需要以这个内存布局为基础运行程序。比如32位，内核态分配了1个G，用户态分配了3G，这种时候，你总不能将程序的运行内存边界设定在大于10G的地方。所以，系统和软件的位数，可以理解为，这个系统或软件内存寻址的范围位数。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/32%E5%92%8C64%E4%BD%8D%E7%9A%84%E5%86%85%E5%AD%98%E5%B7%AE%E5%BC%82.png" alt="32和64位的内存差异"></p><p>一般情况下，由于现在我们的CPU架构在设计上都是<strong>完全向前兼容</strong>的，别说32位了，16位的都还兼容着，因此64位的CPU是能装上32位操作系统的。</p><p>同理，64位的操作系统是兼容32位的软件的，所以32位软件能装在64位系统上。</p><p>但反过来，因为32位操作系统只支持4g的内存，而64位的软件在编译的时候就设定自己的内存边界不止4个G，并且64位的CPU指令集内容比32位的要多，所以32位操作系统是肯定不能运行64位软件的。</p><p>同理，32位CPU也不能装64位的操作系统的。</p><br><h4 id="程序数值int32和int64的含义"><a href="#程序数值int32和int64的含义" class="headerlink" title="程序数值int32和int64的含义"></a>程序数值int32和int64的含义</h4><p>这个我们平时写代码接触的最多，比较好理解了。int32也就是用4个字节，32位的内存去存储数据，int64也就是用8个字节，64位去存数据。这个数值就是刚刚CPU运行流程中放在<strong>内存里</strong>的数据。</p><br><p>那么问题又来了。</p><br><h4 id="32位的CPU能进行int64位的数值计算吗？"><a href="#32位的CPU能进行int64位的数值计算吗？" class="headerlink" title="32位的CPU能进行int64位的数值计算吗？"></a>32位的CPU能进行int64位的数值计算吗？</h4><p>先说结论，<strong>能</strong>。但比起64位的CPU，<strong>性能会慢一些</strong>。</p><p>如果说我用的是64位的<strong>CPU</strong>，那么我在计算两个int64的<strong>数值</strong>相加时，我就能将数据通过64位的<strong>总线</strong>，一次性存入到64位的<strong>寄存器</strong>，并在进行计算后返回到内存中。整个过程一步到位，一气呵成。</p><p>但如果我现在用的是32位的CPU，那就憋屈一点了，我虽然在代码里放了个int64的数值，但实际上CPU的寄存器根本放不下这么大的数据，因此最简单的方法是，将int64的数值，拆成前后两半，现在两个int64相加，就变成了4个int32的数值相加，并且后半部分加好了之后，拿到进位，才能去计算前面的部分，这里光是执行的指令数就比64位的CPU要多。所以理论上，会更慢些。</p><br><h3 id="系统位数会限制内存吗？"><a href="#系统位数会限制内存吗？" class="headerlink" title="系统位数会限制内存吗？"></a>系统位数会限制内存吗？</h3><p>上面提到了CPU位数，系统位数，软件位数，以及数值位数之间的区别与联系。</p><p>现在，我们回到标题里提到的问题。</p><br><h4 id="32位CPU和系统插8g内存条，能用吗？"><a href="#32位CPU和系统插8g内存条，能用吗？" class="headerlink" title="32位CPU和系统插8g内存条，能用吗？"></a>32位CPU和系统插8g内存条，能用吗？</h4><p>系统能正常工作，但<strong>一般用不到8G</strong>，因为32位系统的总线寻址能力为2的32次方，也就是4G，<strong>哪怕装了8G的内存，真正能被用到的其实只有4g，多少有点浪费。</strong></p><p>注意上面提到的是<strong>一般</strong>，为什么这么说，因为这里有例外，32位系统里，有些是可以支持超过4G内存的，比如<strong>Windows Server 2003</strong>就能最大支持64G的内存，它通过使用 <strong>PAE</strong> （Intel <strong>P</strong>hysical <strong>A</strong>ddress <strong>E</strong>xtension）技术向程序提供更多的物理内存，PAE本质上是通过<strong>分页管理</strong>的方式将32位的总线寻址能力增加到36位。因此<strong>理论上</strong>寻址能力达到2的36次方，也就是64G。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/PAE%E8%83%BD%E8%AE%A932%E4%BD%8D%E7%B3%BB%E7%BB%9F%E8%8E%B7%E5%BE%97%E5%A4%A7%E4%BA%8E4G%E7%9A%84%E5%86%85%E5%AD%98.drawio.png" alt="PAE能让32位系统获得大于4G的内存"></p><p>至于实现细节大家也不用关心，现在用到这玩意的机器也该淘汰的差不多了，而且都是windows server，注意<strong>Windows Server 2003</strong> 名字里带个<strong>server</strong>，是用来做服务器的，我们一般也用不到，知道这件事，除了能帮助我们更好的装x外，就没什么作用了。</p><p>所以，<strong>你当32位系统最大只能用到4G内存，那也没毛病。</strong></p><br><h4 id="64位CPU装32位操作系统，再插上8g的内存条，寻址能力还是4G吗"><a href="#64位CPU装32位操作系统，再插上8g的内存条，寻址能力还是4G吗" class="headerlink" title="64位CPU装32位操作系统，再插上8g的内存条，寻址能力还是4G吗"></a>64位CPU装32位操作系统，再插上8g的内存条，寻址能力还是4G吗</h4><p>上面提到32位CPU就算插上8G内存条，寻址能力也还是4G，那如果说我现在换用64位的CPU，但装了个32位的操作系统，这时候插入8G内存条，寻址能力能超过4G吗？</p><p>寻址能力，除了受到cpu的限制外，还受到操作系统的限制，如果操作系统就是按着32位的指令和寻址范围（4G）来编译的话，那么它就会缺少64位系统该有的指令，它在运行软件的时候就不能做到超过这个限制，因此<strong>寻址能力还会是4G。</strong></p><br><p>最后留下一个问题吧。</p><p>上面提到，我们平时写的代码（也就是C，go，java这些），先转成汇编，再转成机器码。最后CPU执行的是机器码，那么问题来了。</p><p><strong>为什么我们平时写的代码不直接转成机器码，而要先转成汇编，这是不是多此一举？</strong></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>CPU位数主要指的是寄存器的位宽，</p></li><li><p>32位CPU只能装32位的系统和软件，且能计算int64，int32的数值。内存寻址范围是4G。</p></li><li><p>64位CPU，同时兼容32位和64位的系统和软件，并且进行int64数值计算的时候，性能比32位CPU更好，内存寻址范围可以达到256T。</p></li><li><p>32位CPU和操作系统，插入8G的内存，会有点浪费，因为总线寻址范围比较有限，它只能用上4G不到的内存。</p></li><li><p>64位CPU，如果装上32位的操作系统，就算插上8G的内存，效果也还是只能用上4G不到的内存。</p></li></ul><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>刚工作的时候一直觉得int32，有21个亿，这么大的数值肯定够用了吧，结果现实好几次打脸。</p><p>以前做游戏的时候，血量一开始是定义为int32，游戏设定是可以通过充钱，提升角色的属性，还能提升血量上限，谁也没想到，老板们通过氪金，硬是把血量给打到了int32最大值。于是策划提了个一句话需求：”血量要支持到int64大小”，这是我见过最简单的策划案，但也让人加班加的最凶。</p><p>那是我第一次感受到了钞能力。</p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/1593863685553.jpg" width = "50%"   align=center /><br><p>这篇文章老早就想写了，但涉及的知识点有点多，一直很头疼，怎么样才能用最简单的方式把他们表述清楚，于是想着从大家最熟悉的场景开始说起。希望能给大家带来价值。</p><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul><h4 id="计算机组成原理–64位CPU装载32位操作系统，它的寻址能力还是4GB吗？"><a href="#计算机组成原理–64位CPU装载32位操作系统，它的寻址能力还是4GB吗？" class="headerlink" title="计算机组成原理–64位CPU装载32位操作系统，它的寻址能力还是4GB吗？"></a><a href="https://www.cnblogs.com/eret9616/p/9678509.html">计算机组成原理–64位CPU装载32位操作系统，它的寻址能力还是4GB吗？</a></h4><p><a href="https://zhuanlan.zhihu.com/p/369029295">https://zhuanlan.zhihu.com/p/369029295</a></p><p>win7 32位虽然能支持4G内存，实际不能达到4G内存，一般win7 32位显示的内存是3.25G左右。也就是说，win7 32位操作系统安装了8G内存条，但是实际识别的还是不到4G。</p><p>4g内存装上后，我就能用满4g吗？</p><p>不能，mmio</p><p><a href="https://zhuanlan.zhihu.com/p/93993047">https://zhuanlan.zhihu.com/p/93993047</a></p><p><strong>操作系统64位和32位的区别及原理</strong></p><p><a href="https://blog.51cto.com/zliang90/1282301">https://blog.51cto.com/zliang90/1282301</a></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      
      
      <categories>
          
          <category> 图解操作系统 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？</title>
      <link href="/2022/03/02/%E5%9B%BE%E8%A7%A3mysql/mysql%E4%B8%BB%E5%BA%93%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%BA%86%EF%BC%8C%E4%B8%BB%E5%BA%93%E8%BF%98%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC%E5%90%97%EF%BC%9F/"/>
      <url>/2022/03/02/%E5%9B%BE%E8%A7%A3mysql/mysql%E4%B8%BB%E5%BA%93%E6%9B%B4%E6%96%B0%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%BA%86%EF%BC%8C%E4%B8%BB%E5%BA%93%E8%BF%98%E6%9C%89%E5%8F%AF%E8%83%BD%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<br><p>大家好，我是小白，好长时间没更新技术文了，相信大家看我写的水文也看烦了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/1539510639669-20220302001234401.jpg"></p><span id="more"></span><p>今天的文章，其实来自真实的面试题，而且还比较有趣，所以忍不住分享出来。</p><p>直接开始吧。</p><br><p>我们知道，mysql数据库，为了得到更高性能，一般会<strong>读写分离</strong>，主库用于写操作，比如用于执行<code>insert，update</code>操作，从库用于读，也就是最常见的<code>select</code>操作。像下面这个图这样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB2.drawio-20220419205818771.png" alt="mysql读写分离"></p><p>虽然主库一般用于写操作，但也是<strong>能读</strong>的。那么今天的问题来了。</p><ul><li><p>主库更新后，<strong>主库</strong>都读到最新值了，<strong>从库</strong>还有可能读到旧值吗？</p></li><li><p>主库更新后，<strong>从库</strong>都读到最新值了，<strong>主库</strong>还有可能读到旧值吗？</p></li></ul><p>毕竟面试官都这么问了，那当然是有可能的，那至于是为啥，以及怎么做到的，今天我们来好好聊聊。</p><h3 id="正常的主从更新流程"><a href="#正常的主从更新流程" class="headerlink" title="正常的主从更新流程"></a>正常的主从更新流程</h3><p>比如我在主库和从库都有张user表，此时有以下两条数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81.png" alt="数据库原始状态"></p><p>正常情况下，我们往主库执行写操作，比如更新一条数据，执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>虽然这是一个单条写操作，但本质上可以理解为单条语句的事务。等同于下面这样</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">begin</span>;</span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> age <span class="operator">=</span> <span class="number">50</span> <span class="keyword">where</span> id <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><p>这个事务如果执行成功了，数据会先写入到主库的binlog文件中，然后再刷入磁盘。</p><p><strong>binlog文件</strong>是mysql的server层日志，记录了用户对数据库有哪些变更操作，比如建数据库表加字段，对某些行的增删改等。</p><p>它的位置可以通过下面的查询语句看到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> variables <span class="keyword">like</span> &quot;%log_bin%&quot;;</span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Variable_name                   <span class="operator">|</span> <span class="keyword">Value</span>                                <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> log_bin                         <span class="operator">|</span> <span class="keyword">ON</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_basename                <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slave<span class="operator">-</span>bin       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_index                   <span class="operator">|</span> <span class="operator">/</span>var<span class="operator">/</span>lib<span class="operator">/</span>mysql<span class="operator">/</span>mysql<span class="operator">-</span>slave<span class="operator">-</span>bin.index <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_trust_function_creators <span class="operator">|</span> OFF                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> log_bin_use_v1_row_events       <span class="operator">|</span> OFF                                  <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> sql_log_bin                     <span class="operator">|</span> <span class="keyword">ON</span>                                   <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">---------------------------------+--------------------------------------+</span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.04</span> sec)</span><br></pre></td></tr></table></figure><p>其中binlog在 <code>/var/lib/mysql/</code> 下，命名会类似<code>mysql-bin.00000x</code>。感兴趣的可以到这个目录下直接查看文件内容长什么样子。</p><br><p>如果两个mysql配置好了主从的关系，那么他们之间会建立一个<strong>tcp长连接</strong>，主要用于传输同步数据。</p><p>除此之外，主库还会再起一个<strong>binlog dump线程</strong>将binlog文件的变更发给从库。</p><p>可以在<strong>主库</strong>中通过 <code>show full processlist;</code> 查询到 binlog dump线程的存在。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220301084729507.png" alt="主库的binlog dump线程"></p><p>以上，主库的工作就结束了，我们说说从库的。</p><p>从库在收到binlog后，会有一个<strong>io线程</strong>负责把收到的数据写入到<strong>relay log（中继日志）</strong>中。</p><p>然后再有一个<strong>sql 线程</strong>，来读取relay log的内容，然后对从库执行sql语句操作，从结果上来看就是将主库执行过的写操作，在从库上也重放一遍，这样主从数据就一致了。</p><br><p>是不是感觉relay log有些多余？</p><br><p><strong>为什么要先写一遍relay log然后再写从库，直接将数据写入到从库不好吗？</strong></p><p>在这里relay log的作用就类似于一个<strong>中间层</strong>，<strong>主库是多线程并发写的，从库的sql线程是单线程串行执行的，所以这两边的生产和消费速度肯定不同。</strong>当主库发的binlog消息过多时，从库的relay log可以起到暂存主库数据的作用，接着从库的sql线程再慢慢消费这些relay log数据，这样既不会限制主库发消息的速度，也不会给从库造成过大压力。</p><p>可以通过在<strong>从库</strong>中执行 <code>show full processlist;</code> 确认 io线程和sql线程的存在。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20220301102221753.png" alt="io线程和sql线程"></p><p>因此总结起来，主从同步的步骤就是</p><p><strong>1.执行更新sql语句。</strong></p><p><strong>2.主库写成功时，binlog会更新。</strong></p><p><strong>3.主库binlog dump 线程将binlog的更新部分发给从库</strong></p><p><strong>4.从库io线程收到binlog更新部分，然后写入到relay log中</strong></p><p><strong>5.从库sql线程读取relay log内容，重放执行sql，最后主从一致。</strong></p><p><img src="https://gitee.com/xiaobaiTech/image/raw/master/mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png" alt="mysql主从同步"></p><p>到这里，我们可以开始回答文章开头的第一个问题。</p><br><h3 id="主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？"><a href="#主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？" class="headerlink" title="主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？"></a>主库更新后，主库都读到最新值了，从库还有可能读到旧值吗？</h3><p>这是可能的，上面提到的主从同步的5个步骤里，第3到第5步骤，都需要时间去执行，而这些步骤的执行时间总和，就是我们常说的<strong>主从延迟</strong>。</p><p>当更新一行数据后，立马去读主库，主库的数据肯定是最新值，这点没什么好说的，但<strong>如果此时主从延迟过大，这时候读从库，同步可能还没完成，因此读到的就是旧值。</strong></p><p>在实际的开发当中，主从延迟也非常常见，当数据库压力稍微大点，主从延迟就能到100ms甚至1s以上。</p><p>具体的主从延迟时间可以在从库中执行 <code>show slave status \G;</code>来查看，其中里面的<code>Seconds_Behind_Master</code>则是主从延迟的时间，单位是秒。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> slave status \G;</span><br><span class="line"><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span> <span class="number">1.</span> <span class="type">row</span> <span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span><span class="operator">*</span></span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master <span class="keyword">to</span> send event</span><br><span class="line">                  Master_Host: <span class="number">172.17</span><span class="number">.0</span><span class="number">.2</span></span><br><span class="line">                  Master_User: slave</span><br><span class="line">                Connect_Retry: <span class="number">30</span></span><br><span class="line">              Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">          Read_Master_Log_Pos: <span class="number">756</span></span><br><span class="line">               Relay_Log_File: edu<span class="operator">-</span>mysql<span class="operator">-</span>relay<span class="operator">-</span>bin<span class="number">.000004</span></span><br><span class="line">                Relay_Log_Pos: <span class="number">969</span></span><br><span class="line">        Relay_Master_Log_File: mysql<span class="operator">-</span>bin<span class="number">.000002</span></span><br><span class="line">             Slave_IO_Running: Yes</span><br><span class="line">            Slave_SQL_Running: Yes</span><br><span class="line">        Seconds_Behind_Master: <span class="number">2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以如果你有<strong>写数据后就立马要读数据</strong>的场景，要是此时读的是从库，很有可能会读到<strong>更新前</strong>的旧数据，如果你对数据一致性有较高要求，这种时候<strong>建议读主库</strong>。</p><br><h3 id="主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？"><a href="#主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？" class="headerlink" title="主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？"></a>主库更新后，从库都读到最新值了，主库还有可能读到旧值吗？</h3><p>那另一个问题就来了，如果从库都读到最新值了，那说明<strong>主库肯定已经更新完成了</strong>，那此时读主库是不是只能读到最新值呢？</p><p><strong>还真不是的</strong>，待会我给大家复现下，但在这之前我们了解一些<strong>前置知识点</strong>。</p><br><h4 id="mysql的四种隔离级别"><a href="#mysql的四种隔离级别" class="headerlink" title="mysql的四种隔离级别"></a>mysql的四种隔离级别</h4><p>这个绝对是面试八股文老股了。mysql有四种隔离级别，分别是<strong>读未提交（Read uncommitted），读提交（Read committed），可重复读（Repeatable read）和串行化（Serializable）</strong>。在不同的隔离级别下，并发读写效果会不太一样。</p><p>当前数据库处于什么隔离级别可以通过执行 <code>select @@tx_isolation;</code> 查看到。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> @<span class="variable">@tx</span>_isolation;</span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> @<span class="variable">@tx</span>_isolation  <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="operator">|</span> REPEATABLE<span class="operator">-</span>READ <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">-----------------+</span></span><br><span class="line"><span class="number">1</span> <span class="type">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure><p>也可以通过下面的语句去修改隔离级别。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">GLOBAL</span> TRANSACTION ISOLATION LEVEL REPEATABLE<span class="operator">-</span>READ;</span><br></pre></td></tr></table></figure><p>下面用一个case来让大家直观点的理解这四个隔离级别的区别。</p><p>假设我们有两个线程同时对某行数据A(A=1)进行以下操作。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%80%E4%B8%AAcase%E8%A7%A3%E9%87%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.2drawio.png" alt="一个case解释隔离级别"></p><p>我们执行事务都像上面这样，begin可以开启事务，commit会提交事务，上面两个线程，各执行一个事务，且此时是并发执行。</p><p>线程1会将某行的A这个字段从1更新为2。</p><p>线程2啥也不干，就读A。重点关注2线程的三次读A的行为，它们会根据隔离级别的不同，读到不同的值。</p><p><strong>第1次读A：</strong></p><ul><li>如果是<strong>读未提交</strong>，那么会读到2，顾名思义，就算线程1未提交，线程2也能读到最新的值。</li><li>如果是读提交或者可重复读，那读到的都是1，<strong>读提交</strong>只认事务提交后的数据，而<strong>可重复读</strong>只要线程2的事务内没有执行对A的更新sql语句，那读A的数据就会一直不变。</li></ul><p><strong>第2次读A：时机正好在线程1提交了事务之后</strong></p><ul><li>如果是读未提交，前面都读到2了，现在读到的还是2，这个没啥好说的。</li><li>如果是<strong>读提交</strong>，那读到的都是2了，因为线程1的事务提交了，<strong>读提交</strong>只认提交后的数据，所以此时线程2能读到最新数据。</li><li>如果是可重复读那就还是1，理由跟上面一样。</li></ul><p><strong>第3次读A：时机正好在线程2提交了事务之后</strong></p><ul><li>如果是读未提交或读已经提交，结果跟前面一样，还是2。</li><li>如果是<strong>可重复读</strong>，那就变成了2，因为线程2前面的事务结束了，在<strong>同一个事务内A的值重复多次读都是一致的</strong>，但当事务结束了之后，新的查询不再需要受限于上一次开事务时的值。</li></ul><p>上面的情况没有将<strong>串行化</strong>纳入讨论范围，只讨论了<strong>读未提交，读提交和可重复读</strong>这三个隔离级别，因为在这三个隔离级别下都有可能出现两个事务<strong>并发执行</strong>的场景，而在<strong>串行化的隔离级别</strong>中则不会出现，多个事务只会一个挨着一个依次<strong>串行执行</strong>，比如线程1的事务执行完了之后，线程2的事务才执行，因此不会产生并发查询更新的问题。</p><br><p>有了这个知识背景之后，我们就可以回到第二个问题里了。</p><p>数据库原始状态如下，此时主从都一样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%81-20220419205854846.png" alt="数据库原始状态"></p><p>假设当前的数据库事务隔离级别是<strong>可重复读</strong>，现在主库有A，B两个线程，同时执行begin，开启事务。</p><p>此时主库的线程2，<strong>先读一次id=1的数据</strong>，发现age=72，<strong>由于当前事务隔离级别是可重复读</strong>，那么只要线程2在事务内不做更新操作的话，那么<strong>不管重复读多少次，age都是72</strong>。在这之后主库的线程1将age更新为100且执行commit提交了事务。</p><p>主库线程1的事务提交成功之后binlog就会顺利产生，然后同步给从库。此时<strong>从库去查询就能查到最新值age=100</strong>。回过头来，此时主库的线程2因为还没提交事务，所以一直读到的都是旧值age=72。但如果这时候线程2执行commit提交了事务，那么再查询，就能拿到最新值age=100了。</p><p>所以从结论上来说，<strong>出现了从库都读到最新值了，主库却读到了旧值的情况。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/2%E4%BB%8E%E5%BA%93%E8%AF%BB%E5%88%B0%E6%9C%80%E6%96%B0%E5%80%BC%E4%B8%BB%E5%BA%93%E5%8D%B4%E8%AF%BB%E5%88%B0%E6%97%A7%E5%80%BC.drawio.png" alt="从库读到最新值主库却读到旧值"></p><br><p>好了这道题到这里就结束了。</p><p>意不意外？</p><p>这道面试题，通过一个问题，将主从同步，事务隔离级别等知识点都串起来了。</p><p>还是有点意思的。</p><p>那么问题又来了，这四个隔离级别是挺骚气的，那他们是怎么实现的呢？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/1597215709606.gif"></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解mysql </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么张一鸣推崇延时满足。。。</title>
      <link href="/2022/01/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%A0%E4%B8%80%E9%B8%A3%E6%8E%A8%E5%B4%87%E5%BB%B6%E6%97%B6%E6%BB%A1%E8%B6%B3/"/>
      <url>/2022/01/30/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BC%A0%E4%B8%80%E9%B8%A3%E6%8E%A8%E5%B4%87%E5%BB%B6%E6%97%B6%E6%BB%A1%E8%B6%B3/</url>
      
        <content type="html"><![CDATA[<p>大家知道，字节的文化里，有一条叫”<strong>延迟满足</strong>“，意思是为了长远的、更大的利益，自愿延缓或者放弃目前的、较小的满足，有种<strong>先苦后甜</strong>的那个味道。</p><p>看到标题，感觉好像会是个口水文，可能会通过人物故事去剖析，然后讲一些没什么用的鸡汤。</p><p>我需要否定下，至少不是“好像”，这就是口水文。</p><p>我希望能从更底层的原理来聊聊这个话题，而不是光灌鸡汤。</p><br><p>大家高中的时候应该学过，人体具有调节平衡的机制。</p><p>举个例子，当你病毒性感冒时，人体会通过调节体内的白细胞，淋巴，噬菌体这些进行免疫抵抗，所以你会发烧。而打针，一般除了给你杀杀病毒细菌之外，还会通过盐水葡萄糖，让你的身体更快恢复平衡。</p><p>所以这就跟大学时候学的<strong>反馈调节系统</strong>，非常像。</p><p><img src="https://s3.bmp.ovh/imgs/2022/01/80d3a0ad9f620091.png" alt="反馈调节系统"></p><span id="more"></span><p>这个图上面，左边是输入，右边是输出，当被控对象受到干扰的时候，输出就会发生变化，此时比较器就会计算偏差，然后控制器会根据偏差作出调整。</p><p>举个例子，四旋翼无人机能正常飘在空中，这是符合预期的状态，当外界轻微碰了它一下，虽然无人机姿态发生了一些偏移，但此时系统会计算出当前状态和预期状态的差距，然后通过调整四个螺旋桨的转速来不断减少偏差，最终回到原来的状态。</p><p>这里面比较重要的是比较器和控制器。它们做的事情无非就是发现偏差，然后想办法让偏差变小。</p><p>这就是所谓的<strong>反馈调节</strong>。</p><p>从效果上看其实就像个<strong>天平</strong>，你在一端压了重物，天平就倾斜，为了使天平回到平衡，你需要在另外一边也压点东西。而压东西的过程，就是<strong>调节</strong>。</p><p>了解了这一点后，再来了解下<strong>多巴胺</strong>和<strong>内啡肽</strong>是什么。</p><p>多巴胺大家应该经常听到，它可以让人产生快乐，当我们在做一些新鲜好玩的事情时，比如打游戏、听音乐，都会产生这玩意。**”期待”这件事情，也会产生多巴胺<strong>。回想下抖音的</strong>feed流<strong>，你永远不知道，下一个视频是啥，划了再说。如果你对一个东西更感兴趣，那你在面对这个东西的时候会比面对其他东西的时候，分泌更多的多巴胺，而</strong>推荐**机制，则将更多你可能感兴趣的东西推荐到你面前。抖音和头条在这双层机制的把持下，让人上头。</p><p>但如果多巴胺立马降下来了，会给人带来焦虑和空虚的感觉，这也是你进入贤者时间思考人生的重要原因。</p><p>比起多巴胺，可能<strong>内啡肽</strong>大家听得比较少。但<strong>吗啡</strong>大家应该在电视剧里多多少少听说过，一般用这个的人都是做了大手术躺在病床上的，它能止疼镇静还能让人产生愉悦的感觉，并且这种舒爽的感觉还会比较持久。而<strong>内啡肽效果就跟吗啡类似。</strong> 一般在经历了学习，健身，洗冷水澡这种比较痛苦的事情之后会产生。</p><br><p>以上两种，都是人体内的激素，都会对人体内的”天平”产生影响。当人体产生多巴胺之后，人是立刻爽了，但天平也倾斜了，为了使系统恢复平衡，人会产生难受的感觉，所以打完游戏你会一阵空虚。而内啡肽也类似，虽然学习健身让你很不爽，但因为天平也倾斜了，此时身体会通过分泌内啡肽让你重新爽回来，所以运动完会神清气爽。</p><p>总结来说多巴胺和内啡肽都是会让人快乐的东西，但区别点在于，多巴胺即刻满足，而内啡肽延迟满足。</p><p>我们再回过头来看张一鸣同学推崇的<strong>延迟满足</strong>，其实就有点内啡肽的那意思。 而抖音强调的则是即刻满足。<strong>一个推崇延迟满足的人做了一个能让每个人即刻满足的应用</strong>，不得不说，大佬总归是大佬，对人性，三个手指头拿捏得死死的。大佬之所以推崇延时满足，是因为在你真正得到满足之前，往往付出了大量的努力，不管是学习和健身都是反人性的，但是<strong>这些反人性的事情也确确实实对人的发展有益</strong>。</p><br><p>了解一些系统的实现原理，可以帮助我们更好的做系统调优。那么，现在我们明白了人体的设计原理，其实就可以更好的做人体这个系统的调优了。</p><p>有句话是这么说的。</p><p>“<strong>做人嘛，最重要是开心</strong>“。</p><p>古人诚不欺我。</p><p>“<strong>开心</strong>“，就是我们人体这个系统最重要的指标。</p><p>而想办法让自己”更开心”，就是所谓的”<strong>系统调优</strong>“。</p><p>比方说，如果你心情低落，你可以尝试立刻提升多巴胺，比如打开抖音。</p><p>你很清楚内啡肽可以给你带来较为持久的愉悦，那你可以尝试把让你痛苦的事情放在早上做，比如学习或健身都放在早上，这样下午和晚上你都会更加快乐。但如果反过来，早上打完游戏，多巴胺减少，人很难受，下午还要学习，就更难受了，多半真学不动，相信大家都有体会。</p><p>刚开始刷抖音，你会迅速分泌多巴胺，刷的时间长了，多巴胺的分泌带来的快乐则没有一开始那么明显，于是我们会慢慢出现”<strong>麻了</strong>“的感觉，需要更大的刺激才能保持这份快乐，于是出现越刷越上头，越刷也越无聊的情况。所以可以尝试降低刷抖音的时间，加完班回来，只刷前面的十几分钟，真的就够了。早点睡，小心猝死。</p><p>以前不少老哥总拿”学习使我快乐”当反话开玩笑，但其实学习确实会让你快乐，只不过不是当下快乐，而是学习之后你会分泌内啡肽，这其实也会让你快乐。如果你确实感觉不到快乐，那大概率是你学的时间不够长…..</p><br><p>人体不像计算机，我们也看不到人体的源码，否则我高低也给大家整上两行。</p><p>大家估计也清楚，基因这玩意，就是我们的源码。</p><p>我们写的系统没办法实现编码外的功能，而我们也没办法做到我们基因外的功能，比如基因规定了我们没翅膀，那我们就是不能飞。基因规定了我们喜欢看大长腿，那我没办法不去看啊。</p><p>我们能做的就是在理解系统原理的前提下，更好的去使用系统。</p><p>对了，最后补充一句，不管是多巴胺还是内啡肽，都具有成瘾性。</p><p>非要说哪个更好，作为成年人，我选择全都要！</p><p>文章到这里也写完了，我的内啡肽也马上要上来了！</p><p>如果此时我打开抖音。</p><p>那我的快乐，就是<strong>双倍！</strong></p><br><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>快过年了，各位老哥快关注我之前写过的文章，给自己搞点内啡肽。</p><p>如果文章对你有帮助，欢迎…..</p><p>算了。</p><br><p>别说了，一起在知识的海洋里呛水吧</p><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有趣的话题。就<strong>超！开！心！</strong> 快过年了，群里可能会有红包，懂？</p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" style="zoom:50%" /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>大学生毕业找工作，该选择哪个方向。</title>
      <link href="/2021/11/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%EF%BC%8C%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E6%96%B9%E5%90%91%E3%80%82/"/>
      <url>/2021/11/29/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%AF%95%E4%B8%9A%E6%89%BE%E5%B7%A5%E4%BD%9C%EF%BC%8C%E8%AF%A5%E9%80%89%E6%8B%A9%E5%93%AA%E4%B8%AA%E6%96%B9%E5%90%91%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>兄弟们。</p><p>出来说骚话啊。</p><p>考虑到，读者里面，有不少是还未踏入社会的学生党。</p><p>今天在这里想简单介绍下行业的区别。</p><p>虽然都是写代码，虽然大家都叫程序员，但其实，分为很多种类。程序员大体上分为<strong>前端和后端</strong>。</p><p>因为我不懂前端，所以这里主要讲下<strong>后端</strong>吧。</p><p>而后端，可以从很多角度进行分类。</p><p>我们从大家最熟悉的大学专业开始展开吧。</p><br><h3 id="非计算机专业"><a href="#非计算机专业" class="headerlink" title="非计算机专业"></a>非计算机专业</h3><p>一般提到程序员，都会以为都是计算机专业的，但其实除了计算机专业外，还有一些专业，比如电气工程、自动化、通信工程等，都会有不少相关的对口程序员工种。</p><p>比如大学时候学的51单片，STM32之类的相关，那个其实属于嵌入式软件开发的范畴，用的一般是C语言。</p><p>如果是画画PCB电路板之类的，那应该属于嵌入式硬件工程师的范畴。</p><p>跟这两块比较相近的，还有个工作自动控制系统相关的相关工作，叫PLC工程师。用的编程语言也比较特别，叫梯形图。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20211121223351338.png"></p><span id="more"></span><p>以上这几种类型工种，一般出现在较为传统的行业里，比如工业控制、车企、电机电梯等企业，没那么传统的，有共享单车、无人机等。</p><br><h3 id="计算机专业"><a href="#计算机专业" class="headerlink" title="计算机专业"></a>计算机专业</h3><p>这个就很好理解了，也是毕业后进入互联网行业的主力军。而这里面方向也很多，但一般从我了解到的就业情况来说，分为下面这几类。</p><br><h4 id="游戏方向"><a href="#游戏方向" class="headerlink" title="游戏方向"></a>游戏方向</h4><p>游戏方向也算是互联网行业里比较特殊的一个分支。我们常说的前端和后端，在这里一般是叫客户端和服务端。服务端用的一般是C++，少数使用golang，java等，一般是根据游戏类型去区分，比如像的《率土之滨》之类的策略类游戏叫SLG，《王者荣耀》这种叫moba，《xx传奇》叫MMORPG，《地下城与勇士》这类叫ARPG，这里面服务端的架构设计根据游戏类型会有一些不同，但开发之间用的技术栈大体差距不算太大。</p><p>客户端之间差距就有些大了，做2d游戏的一般用cocos，3d游戏前两年一般用unity3D，现在都开始慢慢开始用unreal。而微信小游戏，一般用的laya或者白鹭引擎。当然还有flash小游戏，这个就有些古老了。有一说一，游戏客户端用的技术差异比较大，隔两年换一个新东西学学，太难了。相比之下，游戏服务端用的技术倒是稳定多了。</p><br><h4 id="互联网应用方向"><a href="#互联网应用方向" class="headerlink" title="互联网应用方向"></a>互联网应用方向</h4><br><h5 id="业务开发"><a href="#业务开发" class="headerlink" title="业务开发"></a>业务开发</h5><p>是最常见的curd boy，对于并不复杂的业务，很多时候就是写写数据库的插入（<strong>c</strong>reate），更新（<strong>u</strong>pdate），读取（<strong>r</strong>ead）、删除（<strong>d</strong>elete）等语句。</p><p>这里业务其实还细分为to b方向和to c方向，to b的业务一般用户不多，正因为用户不多，所以他们提的每一个问题都有可能被重视并且转化为<strong>定制化的需求</strong>，因为需求只针对某部分特定人群，所以<strong>产品逻辑做的巨复杂，巨奇怪也很正常</strong>。to b一般也比to c的产品逻辑更复杂，而产品的主要工作也是直接跟用户沟通，收集用户的痛点并且转化成各种奇怪的需求。用户也可以直接找到这个开发，并且反馈自己的疑问，所以很多时候开发也会沦为oncall工具人。</p><p>to c业务<strong>一般</strong>会相对to b业务来说并发稍微高点，因为产品是面向普通用户，所以设计上也会尽量傻瓜式，这就可以反推背后的逻辑也会相对to b 业务要简单一些。</p><br><h5 id="基础架构开发"><a href="#基础架构开发" class="headerlink" title="基础架构开发"></a>基础架构开发</h5><p>又名，高级oncall工程师。跟上面的业务开发不同，业务开发oncall的对象一般是没有编程背景的普通用户。基础架构oncall的主要对象还是开发，所以总的来说，沟通理解成本可能会稍微低一些。做基架，也会给人一种更专业的感觉，很多知识都偏向于计算机底层，且通用，比如做网关的或者mesh的，换个公司，做的事情一般还能差不多且能延续。但业务开发，比如做电商的，如果离职跑去做教育，那需要从零开始重新理解业务。</p><p>行业上很多大佬都是做基架出身的。业务开发上班时间搞本操作系统来看，还看什么内核源码，那多少有些”不务正业”，”天天摸鱼”的感觉，但如果是基架开发，整这个就非常合情合理了。</p><br><h4 id="安全方向"><a href="#安全方向" class="headerlink" title="安全方向"></a>安全方向</h4><p>这里面最特别的就是做信息安全的，就是是最接近电影里黑客的方向，就业方向对口的是安全行业，学的东西也跟其他方向的不太一样，这里面有着比较大的gap。我至今不知道他们平时的工作内容是什么，但是经常能看到一个认识的老哥在网上找各种网站的漏洞然后提交官方后获得多少w刀的一个奖励。反正羡慕死我了。</p><br><h3 id="这么多种类怎么选"><a href="#这么多种类怎么选" class="headerlink" title="这么多种类怎么选"></a>这么多种类怎么选</h3><h4 id="行业怎么选"><a href="#行业怎么选" class="headerlink" title="行业怎么选"></a>行业怎么选</h4><p>我曾经也当过大学生，也理解大家毕业前面对着这些岗位一脸懵逼的痛点。</p><p>如果大家对研究通用化的技术特别感兴趣，并且自身硬实力也较强，可以考虑做基础架构相关的工作，这块学到的东西更通用化。但是这块有个缺点，一般情况下，做基架会离业务远一点。</p><p>既然当程序员，选了这么苦的路，除了少部分对技术有这极大热情的兄弟们，那我盲猜大部分兄弟可能跟我一样，是因为<strong>钱包比较瘦</strong>。</p><p>那既然这样，我们聊聊怎么样的岗位有机会赚更多。</p><p>大家得明白一个道理，<strong>代码不值钱，业务和数据才值钱</strong>。如果业务盈利很猛，那你离业务越近，你越有机会跟着吃肉喝汤。</p><p>在商业化社会，公司都是为了盈利的，而盈利的，一般是业务部门。当然，不是每个部门都有机会盈利，所以一旦不盈利，被裁得最快的也是业务开发。</p><p>那么问题来了，什么样的业务，离曼妮比较近呢。以我浅薄的认知水平，目前看下来，<strong>游戏、电商，金融</strong>这三个行业离曼妮是比较近的，越符合人性的业务功能越容易盈利，比如短视频，游戏这些，就很符合人性。而教育，运动这种，属于比较反人性的，可能就难一些。但凡事无绝对，神级产品经理可以无视一切常理。</p><p>所以，打工人，不要把路走窄了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E7%A6%BB%E6%9B%BC%E5%A6%AE%E8%BF%91%E7%9A%84%E8%A1%8C%E4%B8%9A.png" alt="离钱更近的行业"></p><br><h4 id="语言怎么选"><a href="#语言怎么选" class="headerlink" title="语言怎么选"></a>语言怎么选</h4><p>虽然不管什么语言，都能实现相似的功能，但是从目前的行业情况来看，不同的语言在不同行业里会有一定的分化。</p><p>比如如果你做嵌入式软件开发，那你一般是用C语言。做电商一般也是java，做游戏一般是C++。而golang，目前用的公司也越来越多了，有用它做游戏的，也有用于电商，网页后台。</p><p>为了不引起语言争论，如果大家不知道选什么语言，那可以考虑下java或golang。java这一块人多，竞争激烈些。选C++，学习路线比较陡峭，过于博大精深。选golang的话，比较简单，同时没有太多历史包袱，唯一的缺点就是岗位相对少一些，但目前看下来比前两年更多，相信以后用的人越来越多。</p><p>如果你做游戏，又想转互联网应用方向，那么做golang挺好的，它可以在这两个方向里来回横跳。</p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>当然，以上都是一些人生建议。而且不一定对，都是我认知范围内的一些信息。大家听不听都不重要，毕竟很多人知道很多道理，依然过不好这一生。</p><p>比如我，以前做游戏的时候，游戏版号就被封了好长时间，行业确实也没之前那么景气了。后来认为教育是风口，想成为那头在风口上起飞的猪，结果这今年双减，长期来看可能也不太乐观。</p><p>干啥都凉，我小白，还真的是行业瞑灯啊，害。。。</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！怎么让goroutine跑一半就退出？</title>
      <link href="/2021/11/15/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F/"/>
      <url>/2021/11/15/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%80%8E%E4%B9%88%E8%AE%A9goroutine%E8%B7%91%E4%B8%80%E5%8D%8A%E5%B0%B1%E9%80%80%E5%87%BA%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/doutub_gif2.gif"></p><p>光看标题，大家可能不太理解我说的是啥。</p><span id="more"></span><p>我们平时创建一个协程，跑一段逻辑，代码大概长这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码，正常运行会有下面的结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">3</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>这上面”<strong>打印2</strong>“是在<code>defer</code>中的，所以会在函数结束前打印。因此后置于”<strong>打印3</strong>“。</p><p>那么今天的问题是，如何让<code>Foo()</code>函数<strong>跑一半就结束</strong>，比如说跑到<strong>打印2</strong>，就退出协程。输出如下结果</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p>也不卖关子了，我这边直接说答案。</p><p>在”打印2”后面插入一个 <code>runtime.Goexit()</code>， 协程就会直接结束。并且结束前还能执行到<code>defer</code>里的<strong>打印2</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">runtime.Goexit() <span class="comment">// 加入这行</span></span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line">打印<span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看到<strong>打印3</strong>这一行没出现了，协程确实提前结束了。</p><p>其实面试题到这里就讲完了，这一波自问自答可还行？</p><p>但这不是今天的重点，我们需要搞搞清楚内部的逻辑。</p><h3 id="runtime-Goexit-是什么？"><a href="#runtime-Goexit-是什么？" class="headerlink" title="runtime.Goexit()是什么？"></a>runtime.Goexit()是什么？</h3><p>看一下内部实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Goexit</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 以下函数省略一些逻辑...</span></span><br><span class="line">gp := getg() </span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// 获取defer并执行</span></span><br><span class="line">d := gp._defer</span><br><span class="line">reflectcall(<span class="literal">nil</span>, unsafe.Pointer(d.fn), deferArgs(d), <span class="keyword">uint32</span>(d.siz), <span class="keyword">uint32</span>(d.siz))</span><br><span class="line">&#125;</span><br><span class="line">goexit1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码上看，<code>runtime.Goexit()</code>会先执行一下<code>defer</code>里的方法，这里就解释了开头的代码里为什么<strong>在defer里的打印2</strong>能正常输出。</p><p>然后代码再执行<code>goexit1</code>。本质就是对<code>goexit0</code>的简单封装。</p><p>我们可以把代码继续跟下去，看看<code>goexit0</code>做了什么。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// goexit continuation on g0.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit0</span><span class="params">(gp *g)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前的 goroutine</span></span><br><span class="line">_g_ := getg()</span><br><span class="line"><span class="comment">// 将当前goroutine的状态置为 _Gdead</span></span><br><span class="line">casgstatus(gp, _Grunning, _Gdead)</span><br><span class="line">  <span class="comment">// 全局协程数减一</span></span><br><span class="line"><span class="keyword">if</span> isSystemGoroutine(gp, <span class="literal">false</span>) &#123;</span><br><span class="line">atomic.Xadd(&amp;sched.ngsys, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 省略各种清空逻辑...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把g从m上摘下来。</span></span><br><span class="line">  dropg()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把这个g放回到p的本地协程队列里，放不下放全局协程队列。</span></span><br><span class="line">gfput(_g_.m.p.ptr(), gp)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重新调度，拿下一个可运行的协程出来跑</span></span><br><span class="line">schedule()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这段代码，信息密度比较大。</p><p>很多名词可能让人一脸懵。</p><p>简单描述下，Go语言里有个<strong>GMP模型</strong>的说法，<code>M</code>是内核线程，<code>G</code>也就是我们平时用的协程<code>goroutine</code>，<code>P</code>会在<code>G和M之间</code>做工具人，负责<strong>调度</strong><code>G</code>到<code>M</code>上运行。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E5%9B%BE.png" alt="GMP图"></p><p>既然是<strong>调度</strong>，也就是说不是每个<code>G</code>都能一直处于运行状态，等G不能运行时，就把它存起来，再<strong>调度</strong>下一个能运行的G过来运行。</p><p>暂时不能运行的G，P上会有个<strong>本地队列</strong>去存放这些这些G，P的本地队列存不下的话，还有个全局队列，干的事情也类似。</p><p>了解这个背景后，再回到 <code>goexit0</code> 方法看看，做的事情就是将当前的协程G置为<code>_Gdead</code>状态，然后把它从M上摘下来，尝试放回到P的本地队列中。然后重新调度一波，获取另一个能跑的G，拿出来跑。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/goexit.gif" alt="goexit"></p><p>所以简单总结一下，<strong>只要执行 goexit 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</strong></p><p>看到这里，大家应该就能理解，开头的代码里，为什么<code>runtime.Goexit()</code>能让协程只执行一半就结束了。</p><h3 id="goexit的用途"><a href="#goexit的用途" class="headerlink" title="goexit的用途"></a>goexit的用途</h3><p>看是看懂了，但是会忍不住疑惑。<strong>面试这么问问，那只能说明你遇到了一个喜欢为难年轻人的面试官</strong>，但正经人谁会没事跑一半协程就结束呢？所以<code>goexit</code>的<strong>真实用途</strong>是啥？</p><p>有个<strong>小细节</strong>，不知道大家平时debug的时候有没有关注过。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/0bec52deb6276987.jpeg"></p><p>为了说明问题，这里先给出一段代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的代码，输出什么完全不重要。通过<code>go</code>关键字启动了一个<code>goroutine</code>执行<code>Foo()</code>，里面打印一下就结束，主协程<code>sleep</code>很长时间，只为<strong>死等</strong>。</p><p>这里我们新启动的协程里，在<code>Foo()</code>函数内随便打个断点。然后<code>debug</code>一下。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20211024150223114.png"></p><p>会发现，这个协程的堆栈底部是从<code>runtime.goexit()</code>里开始启动的。</p><p>如果大家平时有注意观察，会发现，<strong>其实所有的堆栈底部，都是从这个函数开始的</strong>。我们继续跟跟代码。</p><h3 id="goexit是什么？"><a href="#goexit是什么？" class="headerlink" title="goexit是什么？"></a>goexit是什么？</h3><p>从上面的<code>debug</code>堆栈里点进去会发现，这是个汇编函数，可以看出调用的是<code>runtime</code>包内的 <code>goexit1()</code> 函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The top-most function running on a goroutine</span></span><br><span class="line"><span class="comment">// returns to goexit+PCQuantum.</span></span><br><span class="line">TEXT runtime·goexit(SB),NOSPLIT,$<span class="number">0</span><span class="number">-0</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br><span class="line">CALLruntime·goexit1(SB)<span class="comment">// does not return</span></span><br><span class="line"><span class="comment">// traceback from goexit1 must hit code range of goexit</span></span><br><span class="line">BYTE$<span class="number">0x90</span><span class="comment">// NOP</span></span><br></pre></td></tr></table></figure><p>于是跟到了<code>pruntime/proc.go</code>里的代码中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 省略部分代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goexit1</span><span class="params">()</span></span> &#123;</span><br><span class="line">mcall(goexit0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>是不是很熟悉，这不就是我们开头讲<code>runtime.Goexit()</code>里内部执行的<code>goexit0</code>吗。</p><h3 id="为什么每个堆栈底部都是这个方法？"><a href="#为什么每个堆栈底部都是这个方法？" class="headerlink" title="为什么每个堆栈底部都是这个方法？"></a>为什么每个堆栈底部都是这个方法？</h3><p>我们首先需要知道的是，函数栈的执行过程，是先进后出。</p><p>假设我们有以下代码</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是main运行B函数，B函数再运行A函数，代码执行时就跟下面的动图那样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%87%BD%E6%95%B0%E5%A0%86%E6%A0%88.gif" alt="函数堆栈执行顺序"></p><p>这个是先进后出的过程，也就是我们常说的函数栈，执行完<strong>子函数A()<strong>后，就会回到</strong>父函数B()<strong>中，执行完</strong>B()后</strong>，最后就会回到<strong>main()<strong>。这里的栈底是<code>main()</code>，如果在</strong>栈底</strong>插入的是 <code>goexit</code> 的话，那么当程序执行结束的时候就都能跑到<code>goexit</code>里去。</p><p>结合前面讲过的内容，我们就能知道，此时栈底的<code>goexit</code>，会在协程内的业务代码跑完后被执行到，从而实现协程退出，并调度下一个<strong>可执行的G</strong>来运行。</p><br><p>那么问题又来了，栈底插入<code>goexit</code>这件事是谁做的，什么时候做的？</p><p>直接说答案，这个在<code>runtime/proc.go</code>里有个<code>newproc1</code>方法，只要是<strong>创建协程</strong>都会用到这个方法。里面有个地方是这么写的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newproc1</span><span class="params">(fn *funcval, argp unsafe.Pointer, narg <span class="keyword">int32</span>, callergp *g, callerpc <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// 获取当前g</span></span><br><span class="line">  _g_ := getg()</span><br><span class="line"><span class="comment">// 获取当前g所在的p</span></span><br><span class="line">_p_ := _g_.m.p.ptr()</span><br><span class="line">  <span class="comment">// 创建一个新 goroutine</span></span><br><span class="line">newg := gfget(_p_)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 底部插入goexit</span></span><br><span class="line">newg.sched.pc = funcPC(goexit) + sys.PCQuantum </span><br><span class="line">newg.sched.g = guintptr(unsafe.Pointer(newg))</span><br><span class="line"><span class="comment">// 把新创建的g放到p中</span></span><br><span class="line">runqput(_p_, newg, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>主要的逻辑是获取当前协程G所在的调度器P，然后创建一个新G，并在栈底插入一个goexit。</p><p>所以我们每次debug的时候，就都能看到函数栈底部有个goexit函数。</p><h3 id="main函数也是个协程，栈底也是goexit？"><a href="#main函数也是个协程，栈底也是goexit？" class="headerlink" title="main函数也是个协程，栈底也是goexit？"></a>main函数也是个协程，栈底也是goexit？</h3><p>关于main函数栈底是不是也有个<code>goexit</code>，我们对下面代码断点看下。直接得出结果。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20211025073255360.png"></p><p>main函数栈底也是<code>goexit()</code>。</p><p>从 <code>asm_amd64.s</code>可以看到Go程序启动的流程，这里提到的 <code>runtime·mainPC</code> 其实就是 <code>runtime.main</code>.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// create a new goroutine to start program</span></span><br><span class="line">MOVQ$runtime·mainPC(SB), AX<span class="comment">// 也就是runtime.main</span></span><br><span class="line">PUSHQAX</span><br><span class="line">PUSHQ$<span class="number">0</span><span class="comment">// arg size</span></span><br><span class="line">CALLruntime·newproc(SB)</span><br></pre></td></tr></table></figure><p>通过<code>runtime·newproc</code>创建<code>runtime.main</code>协程，然后在<code>runtime.main</code>里会启动<code>main.main</code>函数，这个就是我们平时写的那个main函数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// runtime/proc.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 省略大量代码</span></span><br><span class="line">fn := main_main <span class="comment">// 其实就是我们的main函数入口</span></span><br><span class="line">fn() </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname main_main main.main</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main_main</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>结论是，<strong>其实main函数也是由newproc创建的，只要通过newproc创建的goroutine，栈底就会有一个goexit。</strong></p><h3 id="os-Exit-和runtime-Goexit-有什么区别"><a href="#os-Exit-和runtime-Goexit-有什么区别" class="headerlink" title="os.Exit()和runtime.Goexit()有什么区别"></a>os.Exit()和runtime.Goexit()有什么区别</h3><p>最后再回到开头的问题，实现一下首尾呼应。</p><p>开头的面试题，除了<code>runtime.Goexit()</code>，是不是还可以改为用<code>os.Exit()</code>？</p><p>同样都是带有”退出”的含义，两者退出的<strong>对象</strong>不同。<code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。</p><p>可想而知，改用<code>os.Exit()</code> 这种情况下，defer里的内容就不会被执行到了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;打印1&quot;</span>)</span><br><span class="line"><span class="keyword">defer</span> fmt.Println(<span class="string">&quot;打印2&quot;</span>)</span><br><span class="line">os.Exit(<span class="number">0</span>)</span><br><span class="line">fmt.Println(<span class="string">&quot;打印3&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">go</span>  Foo()</span><br><span class="line">fmt.Println(<span class="string">&quot;打印4&quot;</span>)</span><br><span class="line">time.Sleep(<span class="number">1000</span>*time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">打印<span class="number">4</span></span><br><span class="line">打印<span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>通过 <code>runtime.Goexit()</code>可以做到提前结束协程，且结束前还能执行到defer的内容</li><li><code>runtime.Goexit()</code>其实是对goexit0的封装，只要执行 goexit0 这个函数，当前协程就会退出，同时还能调度下一个可执行的协程出来跑。</li><li>通过<code>newproc</code>可以创建出新的<code>goroutine</code>，它会在函数栈底部插入一个goexit。</li><li><code>os.Exit()</code> 指的是整个<strong>进程</strong>退出；而<code>runtime.Goexit()</code>指的是<strong>协程</strong>退出。两者含义有区别。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>无用的知识又增加了。</p><p>一般情况下，业务开发中，谁会没事执行这个函数呢？</p><p><strong>但是开发中不关心，不代表面试官不关心！</strong></p><p>下次面试官问你，<strong>如果想在goroutine执行一半就退出协程，该怎么办？</strong>你知道该怎么回答了吧？</p><br><p>好了，兄弟们，有没有发现这篇文章写的又水又短，真的是因为我变懒了吗？</p><p>不！</p><p>当然不！</p><p>我是为了兄弟们的身体健康考虑，保持蹲姿太久对身体不好，懂？</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>一起在知识的海洋里呛水吧</p><p>我是小白，我们下期见！</p><br><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有趣的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>饶大的《哪来里的 goexit？》- <a href="https://qcrao.com/2021/06/07/where-is-goexit-from/">https://qcrao.com/2021/06/07/where-is-goexit-from/</a></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！没有accept，能建立TCP连接吗？</title>
      <link href="/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%90%97/"/>
      <url>/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B3.gif" alt="握手建立连接流程"></p><p>上面这个动图，是我们平时客户端和服务端建立连接时的代码流程。</p><p>对应的是下面一段简化过的服务端伪代码。</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Step 1: 创建服务器端监听socket描述符listen_fd*/</span>    </span><br><span class="line">    listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 2: bind绑定服务器端的IP和端口，所有客户端都向这个IP和端口发送和请求数据*/</span>    </span><br><span class="line">    bind(listen_fd, xxx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 3: 服务端开启监听*/</span>    </span><br><span class="line">    listen(listen_fd, <span class="number">128</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 服务器等待客户端的链接，返回值cfd为客户端的socket描述符*/</span>    </span><br><span class="line">    cfd = accept(listen_fd, xxx);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*Step 5: 读取客户端发来的数据*/</span></span><br><span class="line">  n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>估计大家也是老熟悉这段伪代码了。</p><p>需要注意的是，在执行<code>listen()</code>方法之后还会执行一个<code>accept()</code>方法。</p><p><strong>一般情况</strong>下，如果启动服务器，会发现最后程序会<strong>阻塞在</strong><code>accept()</code>里。</p><p>此时服务端就算ok了，就等客户端了。</p><p>那么，再看下简化过的客户端伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*Step 1: 创建客户端端socket描述符cfd*/</span>    </span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">   </span><br><span class="line">    <span class="comment">/*Step 2: connect方法,对服务器端的IP和端口号发起连接*/</span>    </span><br><span class="line">    ret = connect(cfd, xxxx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 向服务器端写数据*/</span></span><br><span class="line">    write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端比较简单，创建好<code>socket</code>之后，直接就发起<code>connect</code>方法。</p><p>此时回到服务端，会发现<strong>之前一直阻塞的accept方法，返回结果了</strong>。</p><p>这就算两端成功建立好了一条连接。之后就可以愉快的进行读写操作了。</p><p>那么，我们今天的问题是，<strong>如果没有这个accept方法，TCP连接还能建立起来吗？</strong></p><br><p>其实只要在执行<code>accept()</code> 之前执行一个 <code>sleep(20)</code>，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210917233531475.png" alt="不执行accept时抓包结果"></p><p>从抓包结果看来，<strong>就算不执行accept()方法，三次握手照常进行，并顺利建立连接。</strong></p><p>更骚气的是，<strong>在服务端执行accept()前，如果客户端发送消息给服务端，服务端是能够正常回复ack确认包的。</strong></p><p>并且，<code>sleep(20)</code>结束后，服务端正常执行<code>accept()</code>，客户端前面发送的消息，还是能正常收到的。</p><p>通过这个现象，我们可以多想想为什么。顺便好好了解下三次握手的细节。</p><br><h3 id="三次握手的细节分析"><a href="#三次握手的细节分析" class="headerlink" title="三次握手的细节分析"></a>三次握手的细节分析</h3><p>我们先看面试八股文的老股，三次握手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BF%AE%E6%AD%A3%E7%89%882.png" alt="TCP三次握手"></p><p>服务端代码，对socket执行bind方法可以绑定监听端口，然后执行<code>listen方法</code>后，就会进入监听（<code>LISTEN</code>）状态。内核会为每一个处于<code>LISTEN</code>状态的<code>socket</code> 分配两个队列，分别叫<strong>半连接队列和全连接队列</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%AF%8F%E4%B8%AAlistenSocket.png" alt="每个listen Socket都有一个全连接和半连接队列"></p><br><h4 id="半连接队列、全连接队列是什么"><a href="#半连接队列、全连接队列是什么" class="headerlink" title="半连接队列、全连接队列是什么"></a>半连接队列、全连接队列是什么</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%973.png" alt="半连接队列和全连接队列"></p><ul><li><p><strong>半连接队列（SYN队列）</strong>，服务端收到<strong>第一次握手</strong>后，会将<code>sock</code>加入到这个队列中，队列内的<code>sock</code>都处于<code>SYN_RECV</code> 状态。</p></li><li><p><strong>全连接队列（ACCEPT队列）</strong>，在服务端收到<strong>第三次握手</strong>后，会将半连接队列的<code>sock</code>取出，放到全连接队列中。队列里的<code>sock</code>都处于 <code>ESTABLISHED</code>状态。这里面的连接，就<strong>等着服务端执行accept()后被取出了。</strong></p></li></ul><p>看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要<code>accept()</code> 参与， <strong>执行accept()只是为了从全连接队列里取出一条连接。</strong></p><p>我们把话题再重新回到这两个队列上。</p><p>虽然都叫<strong>队列</strong>，但其实<strong>全连接队列（icsk_accept_queue）是个链表</strong>，而<strong>半连接队列（syn_table）是个哈希表</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="半连接全连接队列的内部结构"></p><br><h4 id="为什么半连接队列要设计成哈希表"><a href="#为什么半连接队列要设计成哈希表" class="headerlink" title="为什么半连接队列要设计成哈希表"></a>为什么半连接队列要设计成哈希表</h4><p>先对比下<strong>全连接里队列</strong>，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为<code>O(1)</code>。</p><p>而<strong>半连接队列</strong>却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，<strong>如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。</strong></p><p>而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到<code>O(1)</code>了。</p><p>因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。</p><br><h4 id="怎么观察两个队列的大小"><a href="#怎么观察两个队列的大小" class="headerlink" title="怎么观察两个队列的大小"></a>怎么观察两个队列的大小</h4><h5 id="查看全连接队列"><a href="#查看全连接队列" class="headerlink" title="查看全连接队列"></a>查看全连接队列</h5><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ss -lnt</span></span><br><span class="line">State      Recv-Q Send-Q     Local Address:Port           Peer Address:Port</span><br><span class="line">LISTEN     0      128        127.0.0.1:46269              *:*              </span><br></pre></td></tr></table></figure><p>通过<code>ss -lnt</code>命令，可以看到全连接队列的大小，其中<code>Send-Q</code>是指全连接队列的最大值，可以看到我这上面的最大值是<code>128</code>；<code>Recv-Q</code>是指当前的全连接队列的使用值，我这边用了<code>0</code>个，也就是全连接队列里为空，连接都被取出来了。</p><p>当上面<code>Send-Q</code>和<code>Recv-Q</code>数值很接近的时候，那么全连接队列可能已经满了。可以通过下面的命令查看是否发生过队列<strong>溢出</strong>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -s | grep overflowed</span></span><br><span class="line">    4343 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><p>上面说明发生过<code>4343次</code>全连接队列溢出的情况。这个查看到的是<strong>历史发生过的次数</strong>。</p><p>如果配合使用<code>watch -d</code> 命令，可以自动每<code>2s</code>间隔执行相同命令，还能高亮显示变化的数字部分，如果溢出的数字不断变多，说明<strong>正在发生</strong>溢出的行为。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># watch -d &#x27;netstat -s | grep overflowed&#x27;</span></span><br><span class="line">Every 2.0s: netstat -s | grep overflowed                                Fri Sep 17 09:00:45 2021</span><br><span class="line"></span><br><span class="line">    4343 <span class="built_in">times</span> the listen queue of a socket overflowed</span><br></pre></td></tr></table></figure><br><h5 id="查看半连接队列"><a href="#查看半连接队列" class="headerlink" title="查看半连接队列"></a>查看半连接队列</h5><p>半连接队列没有命令可以直接查看到，但因为半连接队列里，放的都是<code>SYN_RECV</code> 状态的连接，那可以通过统计处于这个状态的连接的数量，间接获得半连接队列的长度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep -i &#x27;127.0.0.1:8080&#x27; | grep -i &#x27;SYN_RECV&#x27; | wc -l</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>注意半连接队列和全连接队列都是挂在某个<code>Listen socket</code>上的，我这里用的是<code>127.0.0.1:8080</code>，大家可以替换成自己想要查看的<strong>IP端口</strong>。</p><p>可以看到我的机器上的半连接队列长度为<code>0</code>，这个很正常，<strong>正经连接谁会没事老待在半连接队列里。</strong></p><p>当队列里的半连接不断增多，最终也是会发生溢出，可以通过下面的命令查看。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot; </span></span><br><span class="line">    26395 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure><p>可以看到，我的机器上一共发生了<code>26395</code>次半连接队列溢出。同样建议配合<code>watch -d</code> 命令使用。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># watch -d &#x27;netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;&#x27;</span></span><br><span class="line">Every 2.0s: netstat -s | grep -i <span class="string">&quot;SYNs to LISTEN sockets dropped&quot;</span>       Fri Sep 17 08:36:38 2021</span><br><span class="line"></span><br><span class="line">    26395 SYNs to LISTEN sockets dropped</span><br></pre></td></tr></table></figure><br><h4 id="全连接队列满了会怎么样？"><a href="#全连接队列满了会怎么样？" class="headerlink" title="全连接队列满了会怎么样？"></a>全连接队列满了会怎么样？</h4><p>如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。</p><p>但除了丢弃之外，还有一些附带行为，这会受 <code>tcp_abort_on_overflow</code> 参数的影响。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_abort_on_overflow</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure><ul><li><code>tcp_abort_on_overflow</code>设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的<strong>半连接队列里的连接</strong>给删掉。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp_abort_on_overflow%E4%B8%BA0.png" alt="tcp_abort_on_overflow为0"></p><ul><li><code>tcp_abort_on_overflow</code>设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。</li></ul><p>这个现象是不是很熟悉，服务端<strong>端口未监听</strong>时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实无法区分到底是<strong>端口未监听</strong>，还是<strong>全连接队列满了</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp_abort_on_overflow%E4%B8%BA1.png" alt="tcp_abort_on_overflow为1"></p><br><h4 id="半连接队列要是满了会怎么样"><a href="#半连接队列要是满了会怎么样" class="headerlink" title="半连接队列要是满了会怎么样"></a>半连接队列要是满了会怎么样</h4><p><strong>一般是丢弃</strong>，但这个行为可以通过 <code>tcp_syncookies</code> 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。</p><p>首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了<strong>SYN Flood攻击</strong>。</p><p>所谓<strong>SYN Flood攻击</strong>，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/syn%E6%94%BB%E5%87%BB.png" alt="syn攻击"></p><p>那这种情况怎么处理？有没有一种方法可以<strong>绕过半连接队列</strong>？</p><p>有，上面提到的<code>tcp_syncookies</code>派上用场了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_syncookies</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>当它被设置为1的时候，客户端发来<strong>第一次握手</strong>SYN时，服务端<strong>不会将其放入半连接队列中</strong>，而是直接生成一个<code>cookies</code>，这个<code>cookies</code>会跟着<strong>第二次握手</strong>，发回客户端。客户端在发<strong>第三次握手</strong>的时候带上这个<code>cookies</code>，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%BC%80%E5%90%AFtcp_syncookies.drawio.png" alt="tcp_syncookies=1"></p><br><h5 id="会有一个cookies队列吗"><a href="#会有一个cookies队列吗" class="headerlink" title="会有一个cookies队列吗"></a>会有一个cookies队列吗</h5><p>生成是<code>cookies</code>，保存在哪呢？<strong>是不是会有一个队列保存这些cookies？</strong></p><p>我们可以反过来想一下，如果有<code>cookies</code>队列，那它会跟半连接队列一样，到头来，还是会被<strong>SYN Flood 攻击</strong>打满。</p><p>实际上<code>cookies</code>并不会有一个专门的队列保存，它是通过<strong>通信双方的IP地址端口、时间戳、MSS</strong>等信息进行<strong>实时计算</strong>的，保存在<strong>TCP报头</strong>的<code>seq</code>里。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B4_seq%E7%9A%84%E4%BD%8D%E7%BD%AE.png" alt="tcp报头_seq的位置"></p><p>当服务端收到客户端发来的第三次握手包时，会通过seq还原出<strong>通信双方的IP地址端口、时间戳、MSS</strong>，验证通过则建立连接。</p><br><h5 id="cookies方案为什么不直接取代半连接队列？"><a href="#cookies方案为什么不直接取代半连接队列？" class="headerlink" title="cookies方案为什么不直接取代半连接队列？"></a>cookies方案为什么不直接取代半连接队列？</h5><p>目前看下来<code>syn cookies</code>方案省下了半连接队列所需要的队列内存，还能解决 <strong>SYN Flood攻击</strong>，那为什么不直接取代半连接队列？</p><p>凡事皆有利弊，<code>cookies</code>方案虽然能防 <strong>SYN Flood攻击</strong>，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。</p><p>另外，编码解码<code>cookies</code>，都是比较<strong>耗CPU</strong>的，利用这一点，如果此时攻击者构造大量的<strong>第三次握手包（ACK包）</strong>，同时带上各种瞎编的<code>cookies</code>信息，服务端收到<code>ACK包</code>后<strong>以为是正经cookies</strong>，憨憨地跑去解码（<strong>耗CPU</strong>），最后发现不是正经数据包后才丢弃。</p><p>这种通过构造大量<code>ACK包</code>去消耗服务端资源的攻击，叫<strong>ACK攻击</strong>，受到攻击的服务器可能会因为<strong>CPU资源耗尽</strong>导致没能响应正经请求。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ack%E6%94%BB%E5%87%BB2.gif" alt="ack攻击"></p><br><h4 id="没有listen，为什么还能建立连接"><a href="#没有listen，为什么还能建立连接" class="headerlink" title="没有listen，为什么还能建立连接"></a>没有listen，为什么还能建立连接</h4><p>那既然没有<code>accept</code>方法能建立连接，那是不是没有<code>listen</code>方法，也能建立连接？是的，之前写的一篇文章提到过客户端是可以自己连自己的形成连接（<strong>TCP自连接</strong>），也可以两个客户端同时向对方发出请求建立连接（<strong>TCP同时打开</strong>），这两个情况都有个共同点，就是<strong>没有服务端参与，也就是没有listen，就能建立连接。</strong></p><p>当时文章最后也留了个疑问，<strong>没有listen，为什么还能建立连接？</strong></p><p>我们知道执行<code>listen</code>方法时，会创建半连接队列和全连接队列。</p><p>三次握手的过程中会在这两个队列中暂存连接信息。</p><p>所以形成连接，前提是你得<strong>有个地方存放着</strong>，方便握手的时候能根据IP端口等信息找到socket信息。</p><br><p><strong>那么客户端会有半连接队列吗？</strong></p><p><strong>显然没有</strong>，因为客户端没有执行<code>listen</code>，因为半连接队列和全连接队列都是在执行<code>listen</code>方法时，内核自动创建的。</p><p>但内核还有个<strong>全局hash表</strong>，可以用于存放<code>sock</code>连接的信息。这个全局<code>hash</code>表其实还细分为<code>ehash，bhash和listen_hash</code>等，但因为过于细节，大家理解成有一个<strong>全局hash</strong>就够了，</p><p>在TCP自连接的情况中，客户端在<code>connect</code>方法时，最后会将自己的连接信息放入到这个<strong>全局hash表</strong>中，然后将信息发出，消息在经过回环地址重新回到TCP传输层的时候，就会根据IP端口信息，再一次从这个<strong>全局hash</strong>中取出信息。于是握手包一来一回，最后成功建立连接。</p><p>TCP同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。</p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>每一个</strong><code>socket</code>执行<code>listen</code>时，内核都会自动创建一个半连接队列和全连接队列。</p></li><li><p>第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。</p></li><li><p><code>accept方法</code>只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎<strong>毫无关系</strong>。</p></li><li><p>出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了<strong>哈希表</strong>，而全连接队列本质是链表。</p></li><li><p>全连接队列满了，再来第三次握手也会丢弃，此时如果<code>tcp_abort_on_overflow=1</code>，还会直接发<code>RST</code>给客户端。</p></li><li><p>半连接队列满了，可能是因为受到了<code>SYN Flood</code>攻击，可以设置<code>tcp_syncookies</code>，绕开半连接队列。</p></li><li><p>客户端没有半连接队列和全连接队列，但有一个<strong>全局hash</strong>，可以通过它实现自连接或TCP同时打开。</p></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>小林图解网络 – 推荐大家关注《小林coding》</p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>活久见！TCP两次挥手，你见过吗？那四次握手呢？</title>
      <link href="/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F/"/>
      <url>/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>我们都知道，TCP是个<strong>面向连接的、可靠的、基于字节流的传输层</strong>通信协议。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%98%AF%E4%BB%80%E4%B9%882.png" alt="TCP是什么"></p><p>那这里面提到的”<strong>面向连接</strong>“，意味着需要 建立连接，使用连接，释放连接。</p><p><strong>建立连接</strong>是指我们熟知的<strong>TCP三次握手</strong>。</p><p>而<strong>使用连接</strong>，则是通过一发送、一确认的形式，进行<strong>数据传输</strong>。</p><p>还有就是<strong>释放连接</strong>，也就是我们常见的<strong>TCP四次挥手</strong>。</p><p><strong>TCP四次挥手</strong>大家应该比较了解了，但大家见过<strong>三次挥手</strong>吗？还有<strong>两次挥手</strong>呢？</p><p>都见过？ 那<strong>四次握手</strong>呢？</p><p>今天这个话题，不想只是猎奇，也不想搞冷知识。</p><p>我们从四次挥手开始说起，搞点实用的知识点。</p><span id="more"></span><br><h2 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h2><p>简单回顾下TCP四次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B7.png" alt="TCP四次挥手"></p><p>正常情况下。只要数据传输完了，<strong>不管是客户端还是服务端，都可以主动发起四次挥手</strong>，释放连接。</p><p>就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是<strong>主动方</strong>。服务器是被动接收客户端的挥手请求的，叫<strong>被动方</strong>。</p><p>客户端和服务器，一开始，都是处于<code>ESTABLISHED</code>状态。</p><p><strong>第一次挥手</strong>：一般情况下，主动方执行<code>close()</code>或 <code>shutdown()</code>方法，会发个<code>FIN报文</code>出来，表示”<strong>我不再发送数据了</strong>“。</p><p><strong>第二次挥手</strong>：在收到主动方的<code>FIN</code>报文后，被动方立马回应一个<code>ACK</code>，意思是”我收到你的FIN了，也知道你不再发数据了”。</p><p>上面提到的是<strong>主动方</strong>不再发送数据了。但如果这时候，<strong>被动方</strong>还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。</p><p><strong>第三次挥手</strong>：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 <code>close()</code>, 这时候就会发出第三次挥手的 <code>FIN-ACK</code>。</p><p><strong>第四次挥手</strong>：主动方回一个<code>ACK</code>，意思是收到了。</p><p>其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用<code>close()</code>方法），也就是我们平时写代码需要关注的地方。</p><p>第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。</p><p>另外不管是主动还是被动，每方发出了一个 <code>FIN</code> 和一个<code>ACK</code> 。也收到了一个 <code>FIN</code> 和一个<code>ACK</code> 。<strong>这一点大家关注下，待会还会提到。</strong></p><h3 id="FIN一定要程序执行close-或shutdown-才能发出吗？"><a href="#FIN一定要程序执行close-或shutdown-才能发出吗？" class="headerlink" title="FIN一定要程序执行close()或shutdown()才能发出吗？"></a>FIN一定要程序执行close()或shutdown()才能发出吗？</h3><p><strong>不一定</strong>。一般情况下，通过对<code>socket</code>执行 <code>close()</code> 或 <code>shutdown()</code> 方法会发出<code>FIN</code>。但实际上，只要应用程序退出，不管是<strong>主动</strong>退出，还是<strong>被动</strong>退出（因为一些莫名其妙的原因被<code>kill</code>了）, <strong>都会</strong>发出 <code>FIN</code>。</p><blockquote><p>FIN 是指”我不再发送数据”，因此<code>shutdown()</code> 关闭读不会给对方发FIN, 关闭写才会发FIN。</p></blockquote><br><h3 id="如果机器上FIN-WAIT-2状态特别多，是为什么"><a href="#如果机器上FIN-WAIT-2状态特别多，是为什么" class="headerlink" title="如果机器上FIN-WAIT-2状态特别多，是为什么"></a>如果机器上FIN-WAIT-2状态特别多，是为什么</h3><p>根据上面的四次挥手图，可以看出，<code>FIN-WAIT-2</code>是<strong>主动方</strong>那边的状态。</p><p>处于这个状态的程序，一直在等<strong>第三次挥手</strong>的<code>FIN</code>。而第三次挥手需要由被动方在代码里执行<code>close()</code> 发出。</p><p>因此当机器上<code>FIN-WAIT-2</code>状态特别多，那一般来说，另外一台机器上会有大量的 <code>CLOSE_WAIT</code>。需要检查有大量的 <code>CLOSE_WAIT</code>的那台机器，为什么迟迟不愿调用<code>close()</code>关闭连接。</p><p>所以，如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/FIN-WAIT-2%E7%89%B9%E5%88%AB%E5%A4%9A%E7%9A%84%E5%8E%9F%E5%9B%A0.png" alt="FIN-WAIT-2特别多的原因"></p><br><h3 id="主动方在close之后收到的数据，会怎么处理"><a href="#主动方在close之后收到的数据，会怎么处理" class="headerlink" title="主动方在close之后收到的数据，会怎么处理"></a>主动方在close之后收到的数据，会怎么处理</h3><p>之前写的一篇文章《代码执行send成功后，数据就发出去了吗？》中，从源码的角度提到了，<strong>一般情况下</strong>，程序主动执行<code>close()</code>的时候；</p><ul><li>如果当前连接对应的<code>socket</code>的<strong>接收缓冲区</strong>有数据，会发<code>RST</code>。</li><li>如果<strong>发送缓冲区</strong>有数据，那会等待发送完，再发第一次挥手的<code>FIN</code>。</li></ul><p>大家知道，TCP是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>也就是说，虽然<strong>理论上</strong>，第二次和第三次挥手之间，被动方是可以传数据给主动方的。</p><p>但如果 主动方的四次挥手是通过 <code>close()</code> 触发的，那主动方是不会去收这个消息的。而且还会回一个 <code>RST</code>。直接结束掉这次连接。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/close()%E8%A7%A6%E5%8F%91TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B5.png" alt="close()触发TCP四次挥手"></p><br><h3 id="第二第三次挥手之间，不能传输数据吗？"><a href="#第二第三次挥手之间，不能传输数据吗？" class="headerlink" title="第二第三次挥手之间，不能传输数据吗？"></a>第二第三次挥手之间，不能传输数据吗？</h3><p>也不是。前面提到<code>Close()</code>的含义是，要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>那如果能做到<strong>只关闭发送消息</strong>，<strong>不关闭接收消息</strong>的功能，那就能继续收消息了。这种 <code>half-close</code> 的功能，通过调用<code>shutdown()</code> 方法就能做到。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>其中 howto 为断开方式。有以下取值：</p><ul><li>SHUT_RD：关闭读。这时应用层不应该再尝试接收数据，内核协议栈中就算接收缓冲区收到数据也会被丢弃。</li><li>SHUT_WR：关闭写。如果发送缓冲区中还有数据没发，会将将数据传递到目标主机。</li><li>SHUT_RDWR：关闭读和写。相当于<code>close()</code>了。</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/shutdown%E8%A7%A6%E5%8F%91%E7%9A%84TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="shutdown触发的TCP四次挥手"></p><br><h3 id="怎么知道对端socket执行了close还是shutdown"><a href="#怎么知道对端socket执行了close还是shutdown" class="headerlink" title="怎么知道对端socket执行了close还是shutdown"></a>怎么知道对端socket执行了close还是shutdown</h3><p>不管<strong>主动</strong>关闭方调用的是<code>close()</code>还是<code>shutdown()</code>，对于被动方来说，收到的就只有一个<code>FIN</code>。</p><p><strong>被动</strong>关闭方<strong>就懵了</strong>，”我怎么知道对方让不让我继续发数据？”</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/e18d20c94006dfe0-feec70b0eb485633-f0e01cf6d9cce2bccba34029f1ca10e0-20210808141929988.jpg"></p><p>其实，大可不必纠结，该发就发。</p><p>第二次挥手和第三次挥手之间，如果<strong>被动</strong>关闭方想发数据，那么在代码层面上，就是执行了 <code>send()</code> 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">( SOCKET s,<span class="keyword">const</span> <span class="keyword">char</span>* buf,<span class="keyword">int</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><code>send()</code> 会把数据拷贝到本机的<strong>发送缓冲区</strong>。如果发送缓冲区没出问题，都能拷贝进去，所以正常情况下，<code>send()</code><strong>一般</strong>都会返回成功。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp_sendmsg%E9%80%BB%E8%BE%912.png" alt="tcp_sendmsg逻辑"></p><p>然后<strong>被动方</strong>内核协议栈会把数据发给<strong>主动</strong>关闭方。</p><ul><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>shutdown(socket_fd, SHUT_WR)</code>。那此时，<strong>主动关闭方</strong>不再发送消息，但能接收<strong>被动方</strong>的消息，一切如常，皆大欢喜。</p></li><li><p>如果上一次<strong>主动</strong>关闭方调用的是<code>close()</code>。那<strong>主动方</strong>在收到<strong>被动方</strong>的数据后会直接<strong>丢弃</strong>，然后回一个<code>RST</code>。</p></li></ul><p>针对第二种情况。</p><p>被动方<strong>内核协议栈</strong>收到了<code>RST</code>，会把连接关闭。但内核连接关闭了，应用层也不知道（除非被通知）。</p><p>此时被动方<strong>应用层</strong>接下来的操作，无非就是<strong>读或写</strong>。</p><ul><li><p>如果是读，则会返回<code>RST</code>的报错，也就是我们常见的<code>Connection reset by peer</code>。</p></li><li><p>如果是写，那么程序会产生<code>SIGPIPE</code>信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。</p></li></ul><br><p><strong>总结一下</strong>，当被动关闭方 <code>recv()</code> 返回<code>EOF</code>时，说明主动方通过 <code>close()</code>或 <code>shutdown(fd, SHUT_WR)</code> 发起了第一次挥手。 </p><p>如果此时被动方执行<strong>两次</strong> <code>send()</code>。</p><ul><li><p>第一次<code>send()</code>, 一般会成功返回。</p></li><li><p>第二次<code>send()</code>时。如果主动方是通过 <code>shutdown(fd, SHUT_WR)</code> 发起的第一次挥手，那此时<code>send()</code>还是会成功。如果主动方通过 <code>close()</code>发起的第一次挥手，那此时会产生<code>SIGPIPE</code>信号，进程默认会终止，异常退出。不想异常退出的话，记得捕获处理这个信号。</p></li></ul><br><h3 id="如果被动方一直不发第三次挥手，会怎么样"><a href="#如果被动方一直不发第三次挥手，会怎么样" class="headerlink" title="如果被动方一直不发第三次挥手，会怎么样"></a>如果被动方一直不发第三次挥手，会怎么样</h3><p>第三次挥手，是由<strong>被动方</strong>主动触发的，比如调用<code>close()</code>。</p><p>如果由于代码错误或者其他一些原因，被动方就是不执行第三次挥手。</p><p>这时候，主动方会根据自身第一次挥手的时候用的是 <code>close()</code> 还是 <code>shutdown(fd, SHUT_WR)</code> ，有不同的行为表现。</p><ul><li><p>如果是 <code>shutdown(fd, SHUT_WR)</code> ，说明主动方其实只关闭了写，但还可以读，此时会一直处于 <code>FIN-WAIT-2</code>， 死等被动方的第三次挥手。</p></li><li><p>如果是 <code>close()</code>， 说明主动方读写都关闭了，这时候会处于 <code>FIN-WAIT-2</code>一段时间，这个时间由 <code>net.ipv4.tcp_fin_timeout</code> 控制，一般是 <code>60s</code>，这个值正好跟<code>2MSL</code>一样 。<strong>超过这段时间之后，状态不会变成 <code>TIME-WAIT</code>，而是直接变成<code>CLOSED</code>。</strong></p></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/tcp_fin_timeout</span></span><br><span class="line">60</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%80%E7%9B%B4%E4%B8%8D%E5%8F%91%E7%AC%AC%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E6%83%85%E5%86%B53.png" alt="一直不发第三次挥手的情况"></p><br><h2 id="TCP三次挥手"><a href="#TCP三次挥手" class="headerlink" title="TCP三次挥手"></a>TCP三次挥手</h2><p>四次挥手聊完了，那有没有可能出现三次挥手？</p><p><strong>是可能的。</strong></p><p>我们知道，TCP四次挥手里，第二次和第三次挥手之间，是有可能有数据传输的。第三次挥手的目的是为了告诉主动方，”被动方没有数据要发了”。</p><p>所以，在第一次挥手之后，如果被动方没有数据要发给主动方。第二和第三次挥手是<strong>有可能</strong>合并传输的。这样就出现了三次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="TCP三次挥手"></p><br><h3 id="如果有数据要发，就不能是三次挥手了吗"><a href="#如果有数据要发，就不能是三次挥手了吗" class="headerlink" title="如果有数据要发，就不能是三次挥手了吗"></a>如果有数据要发，就不能是三次挥手了吗</h3><p>上面提到的是<strong>没有数据要发</strong>的情况，如果第二、第三次挥手之间<strong>有数据</strong>要发，就不可能变成三次挥手了吗？</p><p><strong>并不是</strong>。TCP中还有个特性叫<strong>延迟确认</strong>。可以简单理解为：<strong>接收方收到数据以后不需要立刻马上回复ACK确认包。</strong></p><p>在此基础上，<strong>不是每一次发送数据包都能对应收到一个 <code>ACK</code> 确认包，因为接收方可以合并确认。</strong></p><p> 而这个合并确认，放在四次挥手里，可以把第二次挥手、第三次挥手，以及他们之间的数据传输都合并在一起发送。因此也就出现了三次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%BB%B6%E8%BF%9F%E7%A1%AE%E8%AE%A4.png" alt="TCP三次挥手延迟确认"></p><br><h2 id="TCP两次挥手"><a href="#TCP两次挥手" class="headerlink" title="TCP两次挥手"></a>TCP两次挥手</h2><p>前面在四次挥手中提到，关闭的时候双方都<strong>发出了一个FIN和收到了一个ACK</strong>。</p><p>正常情况下TCP连接的两端，是不同<strong>IP+端口</strong>的进程。</p><p>但如果TCP连接的两端，<strong>IP+端口</strong>是一样的情况下，那么在关闭连接的时候，也同样做到了<strong>一端发出了一个FIN，也收到了一个 ACK</strong>，只不过正好这两端其实是<code>同一个socket</code> 。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B2.png" alt="TCP两次挥手"></p><p>而这种两端<strong>IP+端口</strong>都一样的连接，叫<strong>TCP自连接</strong>。</p><p>是的，你没看错，我也没打错别字。<strong>同一个socket确实可以自己连自己，形成一个连接。</strong></p><br><h3 id="一个socket能建立连接？"><a href="#一个socket能建立连接？" class="headerlink" title="一个socket能建立连接？"></a>一个socket能建立连接？</h3><p>上面提到了，同一个客户端socket，自己对自己发起连接请求。是可以成功建立连接的。这样的连接，叫<strong>TCP自连接</strong>。</p><p>下面我们尝试下复现。</p><p>注意我是在以下系统进行的实验。在<code>mac</code>上多半无法复现。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  cat /etc/os-release</span></span><br><span class="line">NAME=<span class="string">&quot;CentOS Linux&quot;</span></span><br><span class="line">VERSION=<span class="string">&quot;7 (Core)&quot;</span></span><br><span class="line">ID=<span class="string">&quot;centos&quot;</span></span><br><span class="line">ID_LIKE=<span class="string">&quot;rhel fedora&quot;</span></span><br><span class="line">VERSION_ID=<span class="string">&quot;7&quot;</span></span><br><span class="line">PRETTY_NAME=<span class="string">&quot;CentOS Linux 7 (Core)&quot;</span></span><br></pre></td></tr></table></figure><p>通过<code>nc</code>命令可以很简单的创建一个<strong>TCP自连接</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># nc -p 6666 127.0.0.1 6666</span></span><br></pre></td></tr></table></figure><p>上面的 <code>-p</code> 可以指定源端口号。也就是指定了一个端口号为<code>6666</code>的客户端去连接 <code>127.0.0.1:6666</code> 。 </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep 6666</span></span><br><span class="line">tcp        0      0 127.0.0.1:6666          127.0.0.1:6666          ESTABLISHED</span><br></pre></td></tr></table></figure><p><strong>整个过程中，都没有服务端参与</strong>。可以抓个包看下。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210810093309117.png" alt="image-20210810093309117"></p><p>可以看到，<strong>相同的socket，自己连自己的时候，握手是三次的。挥手是两次的。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E8%87%AA%E8%BF%9E%E6%8E%A52.png" alt="TCP自连接"></p><p>上面这张图里，左右都是同一个客户端，把它画成两个是为了方便大家理解状态的迁移。</p><p>我们可以拿自连接的握手状态<strong>对比下</strong>正常情况下的TCP三次握手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png" alt="正常情况下的TCP三次握手"></p><p>看了自连接的状态图，再看看下面几个问题。</p><br><h4 id="一端发出第一次握手后，如果又收到了第一次握手的SYN包，TCP连接状态会怎么变化？"><a href="#一端发出第一次握手后，如果又收到了第一次握手的SYN包，TCP连接状态会怎么变化？" class="headerlink" title="一端发出第一次握手后，如果又收到了第一次握手的SYN包，TCP连接状态会怎么变化？"></a>一端发出第一次握手后，如果又收到了第一次握手的SYN包，TCP连接状态会怎么变化？</h4><p>第一次握手过后，连接状态就变成了<code>SYN_SENT</code>状态。如果此时又收到了第一次握手的SYN包，那么连接状态就会从<code>SYN_SENT</code>状态变成<code>SYN_RCVD</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_rcv_synsent_state_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// SYN_SENT状态下，收到SYN包</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">        <span class="comment">// 状态置为 SYN_RCVD</span></span><br><span class="line">tcp_set_state(sk, TCP_SYN_RECV);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><br><h4 id="一端发出第二次握手后，如果又收到第二次握手的SYN-ACK包，TCP连接状态会怎么变化？"><a href="#一端发出第二次握手后，如果又收到第二次握手的SYN-ACK包，TCP连接状态会怎么变化？" class="headerlink" title="一端发出第二次握手后，如果又收到第二次握手的SYN+ACK包，TCP连接状态会怎么变化？"></a>一端发出第二次握手后，如果又收到第二次握手的SYN+ACK包，TCP连接状态会怎么变化？</h4><p>第二握手过后，连接状态就变为<code>SYN_RCVD</code>了，此时如果再收到第二次握手的<code>SYN+ACK</code>包。连接状态会变为<code>ESTABLISHED</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_rcv_state_process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 前面省略很多逻辑，能走到这就认为肯定有ACK</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断下这个ack是否合法</span></span><br><span class="line"><span class="keyword">int</span> acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_SYN_RECV:</span><br><span class="line"><span class="keyword">if</span> (acceptable) &#123;</span><br><span class="line">        <span class="comment">// 状态从 SYN_RCVD 转为 ESTABLISHED</span></span><br><span class="line">tcp_set_state(sk, TCP_ESTABLISHED);</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="一端第一次挥手后，又收到第一次挥手的包，TCP连接状态会怎么变化？"><a href="#一端第一次挥手后，又收到第一次挥手的包，TCP连接状态会怎么变化？" class="headerlink" title="一端第一次挥手后，又收到第一次挥手的包，TCP连接状态会怎么变化？"></a>一端第一次挥手后，又收到第一次挥手的包，TCP连接状态会怎么变化？</h4><p>第一次挥手过后，一端状态就会变成 <code>FIN-WAIT-1</code>。正常情况下，是要等待第二次挥手的<code>ACK</code>。但实际上却等来了 一个第一次挥手的 <code>FIN</code>包， 这时候连接状态就会变为<code>CLOSING</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tcp_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (sk-&gt;sk_state) &#123;</span><br><span class="line"><span class="keyword">case</span> TCP_FIN_WAIT1:</span><br><span class="line">tcp_send_ack(sk);</span><br><span class="line">    <span class="comment">// FIN-WAIT-1状态下，收到了FIN，转为 CLOSING</span></span><br><span class="line">tcp_set_state(sk, TCP_CLOSING);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这可以说是<strong>隐藏剧情</strong>了。</p><p><code>CLOSING</code> 很少见，除了出现在<strong>自连接关闭</strong>外，一般还会出现在TCP两端<strong>同时关闭</strong>连接的情况下。</p><p>处于<code>CLOSING</code>状态下时，只要再收到一个<code>ACK</code>，就能进入 <code>TIME-WAIT</code> 状态，然后等个<code>2MSL</code>，连接就彻底断开了。这跟正常的四次挥手还是有些差别的。大家可以滑到文章开头的TCP四次挥手再对比下。</p><br><h4 id="代码复现自连接"><a href="#代码复现自连接" class="headerlink" title="代码复现自连接"></a>代码复现自连接</h4><p>可能大家会产生怀疑，这是不是<code>nc</code>这个软件本身的<code>bug</code>。</p><p>那我们可以尝试下用<code>strace</code>看看它内部都做了啥。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strace nc -p 6666 127.0.0.1 6666</span></span><br><span class="line">// ...</span><br><span class="line">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3</span><br><span class="line">fcntl(3, F_GETFL)                       = 0x2 (flags O_RDWR)</span><br><span class="line">fcntl(3, F_SETFL, O_RDWR|O_NONBLOCK)    = 0</span><br><span class="line">setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0</span><br><span class="line"><span class="built_in">bind</span>(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(<span class="string">&quot;0.0.0.0&quot;</span>)&#125;, 16) = 0</span><br><span class="line">connect(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(<span class="string">&quot;127.0.0.1&quot;</span>)&#125;, 16) = -1 EINPROGRESS (Operation now <span class="keyword">in</span> progress)</span><br><span class="line">// ...</span><br></pre></td></tr></table></figure><p>无非就是以创建了一个客户端<code>socket</code>句柄，然后对这个句柄执行 <code>bind</code>, 绑定它的端口号是<code>6666</code>，然后再向 <code>127.0.0.1:6666</code>发起<code>connect</code>方法。</p><p>我们可以尝试用<code>C语言</code>去复现一遍。</p><p><strong>下面的代码，只用于复现问题。直接跳过也完全不影响阅读。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clie_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clie_addr_len;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFSIZ];</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>, i = <span class="number">0</span>, ret = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;This is a client \n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 1: 创建客户端端socket描述符cfd*/</span>    </span><br><span class="line">    cfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(cfd == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;socket error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> flag=<span class="number">1</span>,len=<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">if</span>( setsockopt(cfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, len) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">perror(<span class="string">&quot;setsockopt&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    bzero(&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    clie_addr.sin_family = AF_INET;</span><br><span class="line">    clie_addr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>, &amp;clie_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 2: 客户端使用bind绑定客户端的IP和端口*/</span>  </span><br><span class="line">    ret = bind(cfd, (struct sockaddr* )&amp;clie_addr, <span class="keyword">sizeof</span>(clie_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;bind error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 3: connect链接服务器端的IP和端口号*/</span>    </span><br><span class="line">    bzero(&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(<span class="number">6666</span>);</span><br><span class="line">    inet_pton(AF_INET,<span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    ret = connect(cfd,(struct sockaddr *)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;connect error&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*Step 4: 向服务器端写数据*/</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        fgets(buf, <span class="keyword">sizeof</span>(buf), <span class="built_in">stdin</span>);</span><br><span class="line">        write(cfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        n = read(cfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">        write(STDOUT_FILENO, buf, n);<span class="comment">//写到屏幕上</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*Step 5: 关闭socket描述符*/</span></span><br><span class="line">    close(cfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存为 <code>client.c</code> 文件，然后执行下面命令，会发现连接成功。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gcc client.c -o client &amp;&amp; ./client</span></span><br><span class="line">This is a client </span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt | grep 6666</span></span><br><span class="line">tcp        0      0 127.0.0.1:6666          127.0.0.1:6666          ESTABLISHED</span><br></pre></td></tr></table></figure><p>说明，这不是nc的bug。事实上，这也是内核允许的一种情况。</p><br><h4 id="自连接的解决方案"><a href="#自连接的解决方案" class="headerlink" title="自连接的解决方案"></a>自连接的解决方案</h4><p>自连接一般不太常见，但遇到了也不难解决。</p><p>解决方案比较简单，只要能保证客户端和服务端的端口不一致就行。</p><p>事实上，我们写代码的时候一般不会去指定客户端的端口，系统会随机给客户端分配某个范围内的端口。而这个范围，可以通过下面的命令进行查询</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># cat /proc/sys/net/ipv4/ip_local_port_range</span></span><br><span class="line">32768   60999</span><br></pre></td></tr></table></figure><p>也就是只要我们的服务器端口不在<code>32768-60999</code>这个范围内，比如设置为<code>8888</code>。就可以规避掉这个问题。</p><p>另外一个解决方案，可以参考<code>golang</code>标准网络库的实现，在连接建立完成之后判断下IP和端口是否一致，如果遇到自连接，则断开重试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dialTCP</span><span class="params">(net <span class="keyword">string</span>, laddr, raddr *TCPAddr, deadline time.Time)</span> <span class="params">(*TCPConn, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 如果是自连接，这里会重试</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span> &amp;&amp; (laddr == <span class="literal">nil</span> || laddr.Port == <span class="number">0</span>) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123;</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">fd.Close()</span><br><span class="line">&#125;</span><br><span class="line">fd, err = internetSocket(net, laddr, raddr, deadline, syscall.SOCK_STREAM, <span class="number">0</span>, <span class="string">&quot;dial&quot;</span>, sockaddrToTCP)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selfConnect</span><span class="params">(fd *netFD, err error)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="comment">// 判断是否端口、IP一致</span></span><br><span class="line"><span class="keyword">return</span> l.Port == r.Port &amp;&amp; l.IP.Equal(r.IP)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h2 id="四次握手"><a href="#四次握手" class="headerlink" title="四次握手"></a>四次握手</h2><p>前面提到的<code>TCP</code>自连接是一个客户端自己连自己的场景。那不同客户端之间是否可以互联？</p><p>答案是<strong>可以的</strong>，有一种情况叫<strong>TCP同时打开</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E5%90%8C%E6%97%B6%E6%89%93%E5%BC%802.png" alt="TCP同时打开"></p><p>大家可以对比下，<strong>TCP同时打开</strong>在握手时的状态变化，跟TCP自连接是非常的像。</p><p>比如<code>SYN_SENT</code>状态下，又收到了一个<code>SYN</code>，其实就相当于自连接里，在发出了第一次握手后，又收到了第一次握手的请求。结果都是变成 <code>SYN_RCVD</code>。</p><p>在 <code>SYN_RCVD</code> 状态下收到了 <code>SYN+ACK</code>，就相当于自连接里，在发出第二次握手后，又收到第二次握手的请求，结果都是变成 <code>ESTABLISHED</code>。<strong>他们的源码其实都是同一块逻辑。</strong></p><br><h4 id="复现TCP同时打开"><a href="#复现TCP同时打开" class="headerlink" title="复现TCP同时打开"></a>复现TCP同时打开</h4><p>分别在<strong>两个控制台</strong>下，分别执行下面两行命令。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> nc -p 2224 127.0.0.1 2223 -v;<span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">true</span>; <span class="keyword">do</span> nc -p 2223 127.0.0.1 2224 -v;<span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>上面两个命令的含义也比较简单，两个客户端互相请求连接对方的端口号，如果失败了则不停重试。</p><p>执行后看到的现象是，一开始会疯狂失败，重试。一段时间后，连接建立完成。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -an | grep  2223</span></span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State </span><br><span class="line">tcp        0      0 127.0.0.1:2224          127.0.0.1:2223          ESTABLISHED</span><br><span class="line">tcp        0      0 127.0.0.1:2223          127.0.0.1:2224          ESTABLISHED</span><br></pre></td></tr></table></figure><p>期间抓包获得下面的结果。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210815090301418.png"></p><p>可以看到，这里面建立连接用了四次交互。因此可以说这是通过**”四次握手”**建立的连接。</p><p>而且更重要的是，这里面只涉及两个客户端，<strong>没有服务端</strong>。</p><p>看到这里，不知道大家有没有跟我一样，被刷新了一波认知，对<code>socket</code>有了重新的认识。</p><p>在以前的观念里，建立连接，必须要有一个客户端和一个服务端，并且服务端还要执行一个<code>listen()</code>和一个<code>accept()</code>。而实际上，这些都不是必须的。</p><p>那么下次，面试官问你**”没有<code>listen()</code>， TCP能建立连接吗？”**， 我想大家应该知道该怎么回答了。</p><p>但问题又来了，只有两个客户端，没有<code>listen()</code> ，为什么能建立<code>TCP</code>连接？</p><p>如果大家感兴趣，我们以后有机会再填上这个坑。</p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><p><strong>四次挥手</strong>中，不管是程序主动执行<code>close()</code>，还是进程被杀，都有可能发出第一次挥手<code>FIN</code>包。如果机器上<code>FIN-WAIT-2</code>状态特别多，一般是因为对端一直不执行<code>close()</code>方法发出第三次挥手。</p></li><li><p><code>Close()</code>会<strong>同时关闭</strong>发送和接收消息的功能。<code>shutdown()</code> 能<strong>单独关闭</strong>发送或接受消息。</p></li><li><p>第二、第三次挥手，是有可能合在一起的。于是四次挥手就变成<strong>三次挥手</strong>了。</p></li><li><p>同一个socket自己连自己，会产生<strong>TCP自连接</strong>，自连接的挥手是<strong>两次挥手</strong>。</p></li><li><p>没有<code>listen</code>，两个客户端之间也能建立连接。这种情况叫<strong>TCP同时打开</strong>，它由<strong>四次握手</strong>产生。</p></li></ul><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>今天提到的，不管是<strong>两次挥手</strong>，还是<strong>自连接</strong>，或是<strong>TCP同时打开</strong>什么的。</p><p>咋一看，可能对日常搬砖没什么用，实际上也确实没什么用。</p><p>并且在面试上大概率也不会被问到。</p><p><strong>毕竟一般面试官也不在意茴字有几种写法。</strong></p><p>这篇文章的目的，主要是想从另外一个角度让大家重新认识下<code>socket</code>。原来<code>TCP</code>是可以自己连自己的，甚至两个客户端之间，不用服务端也能连起来。</p><p>这实在是，太出乎意料了。</p><br><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！收到RST，就一定会断开TCP连接吗？</title>
      <link href="/2021/09/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F/"/>
      <url>/2021/09/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>想必大家已经知道我的niao性，搞个标题，就是不喜欢立马回答。</p><p>就是要搞一大堆<strong>原理性</strong>的东西，再回答标题的问题。</p><p>说这个是因为我这次会把问题的答案就放到开头吗？</p><p>不！</p><p><strong>我就不！</strong></p><span id="more"></span><p>但是大家可以直接根据目录看自己感兴趣的部分。</p><p>之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，<strong>这样有利于建立知识体系</strong>。多一点上下文，少一点<code>gap</code>。</p><p>好了，进入正题。</p><p>下面是这篇文章的目录。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%94%B6%E5%88%B0RST%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E5%90%971.png" alt="收到RST就一定会断开连接吗"></p><br><h3 id="什么是RST"><a href="#什么是RST" class="headerlink" title="什么是RST"></a>什么是RST</h3><p>我们都知道TCP正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它是一个TCP包头中的<strong>标志位</strong>。</p><p><strong>正常情况下</strong>，不管是<strong>发出</strong>，还是<strong>收到</strong>置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是TCP连接被关闭了。</p><p>而接收到 RST的一方，一般会看到一个 <code>connection reset</code> 或  <code>connection refused</code> 的报错。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B4RST%E4%BD%8D.png" alt="TCP报头RST位"></p><br><h3 id="怎么知道收到RST了？"><a href="#怎么知道收到RST了？" class="headerlink" title="怎么知道收到RST了？"></a>怎么知道收到RST了？</h3><p>我们知道<strong>内核</strong>跟<strong>应用层</strong>是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层<strong>只能</strong>通过 <code>send/recv</code> 与内核交互，才能感知到内核是不是收到了<code>RST</code>。</p><p>当本端收到远端发来的<code>RST</code>后，<strong>内核</strong>已经认为此链接已经关闭。</p><p>此时如果本端<strong>应用层</strong>尝试去执行 <strong>读数据</strong>操作，比如<code>recv</code>，应用层就会收到 <strong>Connection reset by peer</strong> 的报错，意思是<strong>远端已经关闭连接</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/resetByPeer1.gif" alt="ResetByPeer"></p><p>如果本端<strong>应用层</strong>尝试去执行<strong>写数据</strong>操作，比如<code>send</code>，那么应用层就会收到 <strong>Broken pipe</strong> 的报错，意思是发送通道已经坏了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/brokenPipe1.gif" alt="BrokenPipe"></p><p>这两个是开发过程中很经常遇到的报错，感觉大家可以<strong>把这篇文章放进收藏夹吃灰</strong>了，等遇到这个问题了，再打开来擦擦灰，说不定对你会有帮助。</p><br><h3 id="出现RST的场景有哪些"><a href="#出现RST的场景有哪些" class="headerlink" title="出现RST的场景有哪些"></a>出现RST的场景有哪些</h3><p><strong>RST</strong>一般出现于异常情况，归类为 <strong>对端的端口不可用</strong> 和 <strong>socket提前关闭</strong>。</p><br><h4 id="端口不可用"><a href="#端口不可用" class="headerlink" title="端口不可用"></a>端口不可用</h4><p>端口不可用分为两种情况。要么是这个端口从来就没有”可用”过，比如根本就没监听<strong>（listen）</strong>过；要么就是曾经”可用”，但现在”不可用”了，比如服务<strong>突然崩</strong>了。</p><h5 id="端口未监听"><a href="#端口未监听" class="headerlink" title="端口未监听"></a>端口未监听</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E8%BF%9E%E6%8E%A5%E6%9C%AA%E7%9B%91%E5%90%AC%E7%9A%84%E7%AB%AF%E5%8F%A3.png" alt="TCP连接未监听的端口"></p><p>服务端<code>listen</code> 方法会创建一个<code>sock</code>放入到全局的<code>哈希表</code>中。</p><p>此时客户端发起一个<code>connect</code>请求到服务端。服务端在收到数据包之后，第一时间会根据IP和端口从哈希表里去获取<code>sock</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%85%A8%E5%B1%80hash%E8%A1%A8.png" alt="全局hash表"></p><p>如果服务端执行过<code>listen</code>，就能从<code>全局哈希表</code>里拿到<code>sock</code>。</p><p>但如果服务端没有执行过<code>listen</code>，那<code>哈希表</code>里也就不会有对应的<code>sock</code>，结果当然是拿不到。此时，<strong>正常情况下</strong>服务端会发<code>RST</code>给客户端。</p><br><h6 id="端口未监听就一定会发RST吗？"><a href="#端口未监听就一定会发RST吗？" class="headerlink" title="端口未监听就一定会发RST吗？"></a>端口未监听就一定会发RST吗？</h6><p><strong>不一定</strong>。上面提到，发RST的前提是<strong>正常情况下</strong>，我们看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_ipv4.c  </span></span><br><span class="line"><span class="comment">// 代码经过删减</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_v4_rcv</span><span class="params">(struct sk_buff *skb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 根据ip、端口等信息 获取sock。</span></span><br><span class="line">sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);</span><br><span class="line"><span class="keyword">if</span> (!sk)</span><br><span class="line"><span class="keyword">goto</span> no_tcp_socket;</span><br><span class="line"></span><br><span class="line">no_tcp_socket:</span><br><span class="line">    <span class="comment">// 检查数据包有没有出错</span></span><br><span class="line"><span class="keyword">if</span> (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; <span class="number">2</span>) || tcp_checksum_complete(skb)) &#123;</span><br><span class="line">        <span class="comment">// 错误记录</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送RST</span></span><br><span class="line">tcp_v4_send_reset(<span class="literal">NULL</span>, skb);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是<strong>TCP还是UDP</strong>走不一样的函数方法。可以简单认为，<strong>TCP</strong>数据包都会走到 <code>tcp_v4_rcv()</code>。 这个方法会从<code>全局哈希表</code>里获取 <code>sock</code>，如果此时服务端没有<code>listen()</code>过 , 那肯定获取不了<code>sock</code>，会跳转到<code>no_tcp_socket</code>的逻辑。</p><p>注意这里会先走一个 <code>tcp_checksum_complete()</code>，目的是看看数据包的**校验和(Checksum)**是否合法。</p><br><blockquote><p><strong>校验和</strong>可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的TCP首部和TCP数据。</p></blockquote><br><p>如果在发送端到接收端传输过程中，数据发生<strong>任何改动</strong>，比如被第三方篡改，那么接收方能检测到校验和有差错，此时TCP段会被直接丢弃。如果校验和没问题，那才会发RST。</p><p>所以，<strong>只有在数据包没问题的情况下，比如校验和没问题，才会发RST包给对端。</strong></p><br><h6 id="为什么数据包异常的情况下，不发RST？"><a href="#为什么数据包异常的情况下，不发RST？" class="headerlink" title="为什么数据包异常的情况下，不发RST？"></a>为什么数据包异常的情况下，不发RST？</h6><p>一个数据包连校验都不能通过，那这个包，<strong>多半有问题</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006cSBLKly1gl6b731molj306405q74a.jpg"></p><p>有可能是在发送的过程中被篡改了，又或者，可能只是一个<strong>胡乱伪造</strong>的数据包。</p><p><strong>五层网络，不管是哪一层</strong>，只要遇到了这种数据，<strong>推荐的做法都是默默扔掉</strong>，<strong>而不是</strong>去回复一个消息告诉对方数据有问题。</p><p>如果对方用的是TCP，是可靠传输协议，发现很久没有<code>ACK</code>响应，自己就会重传。</p><p>如果对方用的是UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。</p><p>因此，数据包异常的情况下，默默扔掉，不发<code>RST</code>，非常合理。</p><br><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006i487Uly1fgqbcncf3gj30b40b43z0-20210908211826494.jpg"></p><p>还是不能理解？那我<strong>再举个例子</strong>。</p><p>正常人喷你，他说话<strong>条理清晰，主谓宾分明</strong>。此时你喷回去，那你是个充满热情，正直，富有判断力的好人。</p><p>而此时一个憨憨也想喷你，但他<strong>思维混乱，连话都说不清楚，一直阿巴阿巴</strong>的，你虽然听不懂，但<strong>大受震撼</strong>，此时你会？</p><ul><li><p>A：跟他激情互喷</p></li><li><p>B：不跟他一般见识，就当没听过</p></li></ul><p>一般来说<strong>最优选择是B</strong>，毕竟你理他，他反而来劲。</p><p>这下，应该就懂了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006m97Kgly1fxtp35bi77j315o15o4qp.jpg"></p><br><h5 id="程序启动了但是崩了"><a href="#程序启动了但是崩了" class="headerlink" title="程序启动了但是崩了"></a>程序启动了但是崩了</h5><p>端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的<strong>应用程序突然崩了</strong>，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会<strong>回一个RST</strong>。在开发过程中，<strong>这种情况是最常见的</strong>。</p><p>比如你的服务端应用程序里，弄了个<strong>空指针</strong>，或者<strong>数组越界</strong>啥的，程序立马就崩了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E7%9B%91%E5%90%AC%E4%BA%86%E4%BD%86%E5%B4%A9%E4%BA%863.png" alt="TCP监听了但崩了"></p><p>这种情况跟<strong>端口未监听</strong>本质上类似，在服务端的应用程序<strong>崩溃后</strong>，原来监听的端口资源就被释放了，从效果上来看，类似于处于<code>CLOSED</code>状态。</p><p>此时服务端又收到了客户端发来的消息，内核协议栈会根据<strong>IP端口</strong>，从全局哈希表里查找<code>sock</code>，结果当然是拿不到对应的<code>sock</code>数据，于是走了跟上面**”端口未监听”<strong>时一样的逻辑，回了个<code>RST</code>。客户端在收到RST后也</strong>释放了sock资源<strong>，从效果上来看，就是</strong>连接断了**。</p><h6 id="RST和502的关系"><a href="#RST和502的关系" class="headerlink" title="RST和502的关系"></a>RST和502的关系</h6><p>上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现<code>RST</code>。但如果在客户端和服务端中间再加一个<code>nginx</code>，就像下图一样。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/RST%E4%B8%8E5021.png" alt="RST与502"></p><p><code>nginx</code>会作为客户端和服务端之间的”中间人角色”，负责<strong>转发</strong>请求和响应结果。但当服务端程序<strong>崩溃</strong>，比如出现<strong>野指针或者OOM</strong>的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个<code>RST</code>给<code>nginx</code>。<code>nginx</code>在收到这个<code>RST</code>后会断开与服务端的连接，同时返回客户端一个<code>502</code>错误码。</p><p>所以，出现502问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了OOM或者日志是否有空指针等报错信息。</p><br><h4 id="socket提前关闭"><a href="#socket提前关闭" class="headerlink" title="socket提前关闭"></a>socket提前关闭</h4><p>这种情况分为<strong>本端</strong>提前关闭，和<strong>远端</strong>提前关闭。</p><h5 id="本端提前关闭"><a href="#本端提前关闭" class="headerlink" title="本端提前关闭"></a>本端提前关闭</h5><p>如果本端<code>socket</code>接收缓冲区<strong>还有数据未读</strong>，此时<strong>提前<code>close()</code> socket</strong>。那么本端会先把接收缓冲区的数据清空，然后给远端发一个RST。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/recvbuf%E9%9D%9E%E7%A9%BA.gif" alt="recvbuf非空"></p><br><h5 id="远端提前关闭"><a href="#远端提前关闭" class="headerlink" title="远端提前关闭"></a>远端提前关闭</h5><p>远端已经<code>close()</code>了<code>socket</code>，此时本端还尝试发数据给远端。那么远端就会回一个RST。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/close()%E8%A7%A6%E5%8F%91TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B5-20210828083457512.png" alt="close()触发TCP四次挥手"></p><p>大家知道，TCP是<strong>全双工通信</strong>，意思是发送数据的同时，还可以接收数据。</p><p><code>Close()</code>的含义是，此时要同时<strong>关闭发送和接收</strong>消息的功能。</p><p>客户端执行<code>close()</code>， 正常情况下，会发出<strong>第一次</strong>挥手FIN，然后服务端回<strong>第二次</strong>挥手ACK。如果在<strong>第二次和第三次挥手之间</strong>，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个RST消息到服务端。直接结束掉这次连接。</p><br><h3 id="对方没收到RST，会怎么样？"><a href="#对方没收到RST，会怎么样？" class="headerlink" title="对方没收到RST，会怎么样？"></a>对方没收到RST，会怎么样？</h3><p>我们知道TCP是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个<code>ACK</code>，意思是”我收到这个包了”。</p><p><strong>而RST，不需要ACK确认包</strong>。</p><p>因为<code>RST</code>本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个<code>ACK</code>吗？<strong>可以幻想，不要妄想。</strong></p><p>但<strong>问题又来了</strong>，网络环境这么复杂，丢包也是分分钟的事情，既然RST包不需要ACK来确认，那万一对方就是没收到RST，会怎么样？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/RST%E4%B8%A2%E5%A4%B13.png" alt="RST丢失"></p><p>RST丢了，问题不大。比方说上图服务端，发了RST之后，服务端就认为连接不可用了。</p><p>如果客户端之前<strong>发送了数据</strong>，一直没等到这个数据的确认ACK，就会重发，重发的时候，自然就会触发一个新的RST包。</p><p>而如果客户端之前<strong>没有发数据</strong>，但服务端的RST丢了，TCP有个keepalive机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个RST。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/RST%E4%B8%A2%E5%A4%B1%E5%90%8Ekeepalive2.png" alt="RST丢失后keepalive"></p><br><h3 id="收到RST就一定会断开连接吗"><a href="#收到RST就一定会断开连接吗" class="headerlink" title="收到RST就一定会断开连接吗?"></a>收到RST就一定会断开连接吗?</h3><p>先说结论，<strong>不一定会断开</strong>。我们看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp_input.c</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_validate_incoming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 获取sock</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1：先判断seq是否合法（是否在合法接收窗口范围内）</span></span><br><span class="line"><span class="keyword">if</span> (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123;</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2：执行收到 RST 后该干的事情</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;rst) &#123;</span><br><span class="line"><span class="keyword">if</span> (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt)</span><br><span class="line">tcp_reset(sk);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tcp_send_challenge_ack(sk);</span><br><span class="line"><span class="keyword">goto</span> discard;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到RST包，第一步会通过<code>tcp_sequence</code>先看下这个seq是否合法，其实主要是看下这个seq是否在合法<strong>接收窗口</strong>范围内。<strong>如果不在范围内，这个RST包就会被丢弃。</strong></p><p>至于接收窗口是个啥，我们先看下面这个图。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3.png" alt="接收窗口"></p><p>这里<strong>黄色的部分</strong>，就是指接收窗口，只要RST包的seq不在这个窗口范围内，那就会被丢弃。</p><br><h4 id="为什么要校验是否在窗口范围内"><a href="#为什么要校验是否在窗口范围内" class="headerlink" title="为什么要校验是否在窗口范围内"></a>为什么要校验是否在窗口范围内</h4><p>正常情况下客户端服务端双方可以通过RST来断开连接。假设不做seq校验，如果这时候有不怀好意的第三方介入，构造了一个RST包，且在TCP和IP等报头都填上客户端的信息，发到服务端，那么服务端就会断开这个连接。同理也可以伪造服务端的包发给客户端。这就叫<strong>RST攻击</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/RST%E6%94%BB%E5%87%BB.png" alt="RST攻击"></p><p>受到RST攻击时，从现象上看，客户端老感觉服务端崩了，这非常影响用户体验。</p><p>如果这是个游戏，我相信多崩几次，第二天大家就不来玩了。</p><p>实际消息发送过程中，接收窗口是不断移动的，seq也是在飞快的变动中，此时第三方是<strong>比较难</strong>构造出合法seq的RST包的，那么通过这个seq校验，就可以拦下了很多不合法的消息。</p><br><h4 id="加了窗口校验就不能用RST攻击了吗"><a href="#加了窗口校验就不能用RST攻击了吗" class="headerlink" title="加了窗口校验就不能用RST攻击了吗"></a>加了窗口校验就不能用RST攻击了吗</h4><p><strong>不是，只是增加了攻击的成本。</strong>但如果想搞，还是可搞的。</p><p>以下是<strong>面向监狱编程</strong>的环节。</p><p>希望大家只<strong>了解原理</strong>就好了，<strong>不建议使用</strong>。</p><p>相信大家都不喜欢穿着蓝白条纹的衣服，拍<strong>纯狱风</strong>的照片。</p><p>从上面可以知道，不是每一个RST包都会导致连接重置的，要求是这个RST包的seq要在窗口范围内，所以，问题就变成了，<strong>我们怎么样才能构造出合法的seq</strong>。</p><br><h5 id="盲猜seq"><a href="#盲猜seq" class="headerlink" title="盲猜seq"></a>盲猜seq</h5><p>窗口数值seq本质上只是个uint32类型。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_skb_cb</span> &#123;</span></span><br><span class="line">__u32seq;<span class="comment">/* Starting sequence number*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在这个范围内疯狂猜测seq数值，并构造对应的包，发到目的机器，虽然概率低，但是总是能被试出来，从而实现<strong>RST攻击</strong>。这种乱棍打死老师傅的方式，就是所谓的<strong>合法窗口盲打（blind in-window attacks）</strong>。</p><p>觉得这种方式比较<strong>笨</strong>？那有没有聪明点的方式，还真有，但是在这之前需要先看下面的这个问题。</p><br><h5 id="已连接状态下收到第一次握手包会怎么样？"><a href="#已连接状态下收到第一次握手包会怎么样？" class="headerlink" title="已连接状态下收到第一次握手包会怎么样？"></a>已连接状态下收到第一次握手包会怎么样？</h5><p>我们需要了解一个问题，比如服务端在已连接（<code>ESTABLISHED</code>）状态下，如果收到客户端发来的第一次握手包（<code>SYN</code>），会怎么样？</p><p>以前我以为<strong>服务单会认为客户端憨憨了，直接RST连接。</strong></p><p><strong>但实际，并不是</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">tcp_validate_incoming</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 判断seq是否在合法窗口内 */</span></span><br><span class="line"><span class="keyword">if</span> (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!th-&gt;rst) &#123;</span><br><span class="line"><span class="comment">// 收到一个不在合法窗口内的SYN包</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn)</span><br><span class="line"><span class="keyword">goto</span> syn_challenge;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * RFC 5691 4.2 : 发送 challenge ack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (th-&gt;syn) &#123;</span><br><span class="line">syn_challenge:</span><br><span class="line">tcp_send_challenge_ack(sk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当客户端发出一个不在合法窗口内的SYN包的时候，服务端会发一个带有正确的seq数据ACK包出来，这个ACK包叫 <code>challenge ack</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210901085509641.png" alt="challenge ack抓包"></p><p>上图是抓包的结果，用<code>scapy</code>随便伪造一个<code>seq=5</code>的包发到服务端（<code>端口9090</code>），服务端回复一个带有正确seq值的<code>challenge ack</code>包给客户端（<code>端口8888</code>）。</p><br><h5 id="利用challenge-ack获取seq"><a href="#利用challenge-ack获取seq" class="headerlink" title="利用challenge ack获取seq"></a>利用challenge ack获取seq</h5><p>上面提到的<strong>这个challenge ack ，仿佛为盲猜seq的老哥们打开了一个新世界。</strong></p><p>在获得这个<code>challenge ack</code>后，攻击程序就可以以ack值为基础，在一定范围内设置seq，这样造成RST攻击的几率就大大增加了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%88%A9%E7%94%A8ChallengeACK%E7%9A%84RST%E6%94%BB%E5%87%BB.png" alt="利用ChallengeACK的RST攻击"></p><br><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>RST其实是TCP包头里的一个标志位，目的是为了在<strong>异常情况</strong>下关闭连接。</li><li>内核收到RST后，应用层只能通过调用读/写操作来感知，此时会对应获得 <strong>Connection reset by peer</strong> 和<strong>Broken pipe</strong> 报错。</li><li>发出RST后不需要得到对方的ACK确认包，因此RST丢失后对方不能立刻感知，但是通过下一次<strong>重传</strong>数据或keepalive<strong>心跳包</strong>可以导致RST重传。</li><li><strong>收到RST包，不一定会断开连接，seq不在合法窗口范围内的数据包会被默默丢弃。</strong>通过构造合法窗口范围内seq，可以造成RST攻击，<strong>这一点大家了解就好，千万别学！</strong></li></ul><br><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>TCP旁路攻击分析与重现 - <a href="https://www.cxyzjd.com/article/qq_27446553/52416369">https://www.cxyzjd.com/article/qq_27446553/52416369</a></p><br><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近想用<code>vscode</code>写小说了，故事梗概都想好了。</p><blockquote><p>十年前，他是大厂最年轻CTO，闭眼刷leetcode，敲代码 0 error ，0 warning， 却被诬陷删库跑路，锒铛入狱，众叛亲离……十年后，他重新归来！却看到自己的女儿在仇人公司里修bug！</p><p>“我要你付出代价！” </p><p>一声令下，十万 <code>p7，p8</code> 应声前来…….</p></blockquote><p><strong>爽否？</strong></p><br><p><strong>如果文章对你有帮助，欢迎…..</strong></p><p>算了。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是<strong>虚伪</strong>的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p><br><p>不满足于在留言区说骚话？</p><p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就<strong>超！开！心！</strong></p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210814073504558.png" width = "50%"   align=center /><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！代码执行send成功后，数据就发出去了吗？</title>
      <link href="/2021/08/10/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Csend%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%B0%B1%E5%8F%91%E5%87%BA%E5%8E%BB%E4%BA%86%E5%90%97%EF%BC%9F/"/>
      <url>/2021/08/10/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Csend%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%B0%B1%E5%8F%91%E5%87%BA%E5%8E%BB%E4%BA%86%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>今天又是被倾盆的需求淹没的一天。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/8e7e47794e20a373.jpeg"></p><p>有没有人知道，那种“<strong>我用3句话，就让产品为我砍了18个需求</strong>”的鸡汤课在哪报名，想报。</p><span id="more"></span><p>“<strong>听懂掌声</strong>“的那种课就算了，太费手了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/2b1dc921fecd27e1.gif"></p><p>扯远了，回到我们今天的正题，我们了解下这篇文的目录。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/send%E7%9B%AE%E5%BD%95.png" alt="目录"></p><p>代码执行send成功后，数据就发出去了吗？</p><p>回答这个问题之前，需要了解什么是<strong>Socket 缓冲区</strong>。</p><br><h2 id="Socket-缓冲区"><a href="#Socket-缓冲区" class="headerlink" title="Socket 缓冲区"></a>Socket 缓冲区</h2><h3 id="什么是-socket-缓冲区"><a href="#什么是-socket-缓冲区" class="headerlink" title="什么是 socket 缓冲区"></a>什么是 socket 缓冲区</h3><p>编程的时候，如果要跟某个IP建立连接，我们需要调用操作系统提供的 <code>socket API</code>。</p><p><strong>socket</strong> 在操作系统层面，可以理解为一个<strong>文件</strong>。</p><p>我们可以对这个文件进行一些<strong>方法操作</strong>。</p><p>用<code>listen</code>方法，可以让程序作为服务器<strong>监听</strong>其他客户端的连接。</p><p>用<code>connect</code>，可以作为客户端<strong>连接</strong>服务器。</p><p>用<code>send</code>或<code>write</code>可以<strong>发送</strong>数据，<code>recv</code>或<code>read</code>可以<strong>接收</strong>数据。</p><p>在建立好连接之后，这个 <strong>socket</strong> 文件就像是远端机器的 <strong>“代理人”</strong> 一样。比如，如果我们想给远端服务发点什么东西，那就只需要对这个文件执行写操作就行了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/socket_api.png" alt="socket_api"></p><p>那写到了这个文件之后，剩下的发送工作自然就是由操作系统<strong>内核</strong>来完成了。</p><p>既然是写给操作系统，那操作系统就需要<strong>提供一个地方给用户写</strong>。同理，接收消息也是一样。</p><p>这个地方就是 <strong>socket 缓冲区</strong>。</p><p>用户<strong>发送</strong>消息的时候写给 send buffer（发送缓冲区）。</p><p>用户<strong>接收</strong>消息的时候，是从 recv buffer（接收缓冲区）中读取数据。</p><p>也就是说<strong>一个socket ，会带有两个缓冲区</strong>，一个用于发送，一个用于接收。因为这是个先进先出的结构，有时候也叫它们<strong>发送、接收队列</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%80%E4%B8%AAsocket%E6%9C%89%E4%B8%A4%E4%B8%AA%E7%BC%93%E5%86%B2%E5%8C%BA.png" alt="一个socket有两个缓冲区"></p><br><h4 id="怎么观察-socket-缓冲区"><a href="#怎么观察-socket-缓冲区" class="headerlink" title="怎么观察 socket 缓冲区"></a>怎么观察 socket 缓冲区</h4><p>如果想要查看 socket 缓冲区，可以在linux环境下执行 <code>netstat -nt</code> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># netstat -nt</span></span><br><span class="line">Active Internet connections (w/o servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State      </span><br><span class="line">tcp        0     60 172.22.66.69:22         122.14.220.252:59889    ESTABLISHED</span><br></pre></td></tr></table></figure><p>这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接。</p><p>还有<strong>Send-Q 是发送缓冲区</strong>，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 <strong>Recv-Q 代表接收缓冲区</strong>， 此时是空的，数据都被应用进程接收干净了。</p><br><h2 id="TCP部分"><a href="#TCP部分" class="headerlink" title="TCP部分"></a>TCP部分</h2><p>我们在使用TCP建立连接之后，一般会使用 send 发送数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    sockfd=socket(AF_INET,SOCK_STREAM, <span class="number">0</span>))</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 建立连接  </span></span><br><span class="line">    connect(sockfd, 服务器ip信息, <span class="keyword">sizeof</span>(server))  </span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 执行 send 发送消息</span></span><br><span class="line">    send(sockfd,str,<span class="keyword">sizeof</span>(str),<span class="number">0</span>))  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭 socket</span></span><br><span class="line">    close(sockfd);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一段伪代码，仅用于展示大概逻辑，我们在建立好连接后，一般会在代码中执行 <code>send</code> 方法。那么此时，消息就会被立刻发到对端机器吗？</p><br><h3 id="执行-send-发送的字节，会立马发送吗？"><a href="#执行-send-发送的字节，会立马发送吗？" class="headerlink" title="执行 send 发送的字节，会立马发送吗？"></a>执行 send 发送的字节，会立马发送吗？</h3><p>答案是不确定！执行 send 之后，数据只是拷贝到了socket 缓冲区。至于什么时候会发数据，发多少数据，<strong>全听操作系统安排</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp_sendmsg%E9%80%BB%E8%BE%913.png" alt="tcp_sendmsg逻辑"></p><p>在用户进程中，程序通过操作 socket 会从用户态进入内核态，而 send方法会将数据一路传到传输层。在识别到是 TCP协议后，会调用 tcp_sendmsg 方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// net/ipv4/tcp.c</span></span><br><span class="line"><span class="comment">// 以下省略了大量逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="comment">// 如果还有可以放数据的空间</span></span><br><span class="line">  <span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 尝试拷贝待发送数据到发送缓冲区</span></span><br><span class="line">    err = skb_add_data_nocache(sk, skb, from, copy);</span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="comment">// 下面是尝试发送的逻辑代码,先省略 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。</p><br><h3 id="如果缓冲区满了会怎么办"><a href="#如果缓冲区满了会怎么办" class="headerlink" title="如果缓冲区满了会怎么办"></a>如果缓冲区满了会怎么办</h3><p>前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。</p><h4 id="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"><a href="#如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？" class="headerlink" title="如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？"></a>如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？</h4><p>这里分两种情况。</p><p>首先，socket在创建的时候，是可以设置是<strong>阻塞</strong>的还是<strong>非阻塞</strong>的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><p>比如通过上面的代码，就可以将 <code>socket</code> 设置为<strong>非阻塞</strong> （<code>SOCK_NONBLOCK</code>）。</p><p>当发送缓冲区<strong>满了</strong>，如果还向socket执行send</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等、死等</strong>，直到释放出新的缓存空间，就继续把数据拷进去，然后<strong>返回</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/send%E9%98%BB%E5%A1%9E.gif" alt="send阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是  <code>Try again</code> , 现在缓冲区满了，你也别等了，待会再试一次。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/send%E9%9D%9E%E9%98%BB%E5%A1%9E.gif" alt="send非阻塞"></p><p>我们可以简单看下源码是怎么实现的。还是回到刚才的 <code>tcp_sendmsg</code> 发送方法中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">  <span class="keyword">if</span> (skb_availroom(skb) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ..如果有足够缓冲区就执行balabla</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果发送缓冲区没空间了，那就等到有空间，至于等的方式，分阻塞和非阻塞</span></span><br><span class="line">    <span class="keyword">if</span> ((err = sk_stream_wait_memory(sk, &amp;timeo)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> do_error;</span><br><span class="line">  &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面提到的  <code>sk_stream_wait_memory</code> 会根据<code>socket</code>是否阻塞，来决定是<strong>一直等</strong>，还是<strong>等一会就返回</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sk_stream_wait_memory</span><span class="params">(struct sock *sk, <span class="keyword">long</span> *timeo_p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 非阻塞模式时，会等到超时返回 EAGAIN</span></span><br><span class="line"><span class="keyword">if</span> (等待超时))</span><br><span class="line"><span class="keyword">return</span> -EAGAIN;     </span><br><span class="line">     <span class="comment">// 阻塞等待时，会等到发送缓冲区有足够的空间了，才跳出</span></span><br><span class="line"><span class="keyword">if</span> (sk_stream_memory_free(sk) &amp;&amp; !vm_wait)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><h4 id="如果接收缓冲区为空，执行-recv-会怎么样？"><a href="#如果接收缓冲区为空，执行-recv-会怎么样？" class="headerlink" title="如果接收缓冲区为空，执行 recv 会怎么样？"></a>如果接收缓冲区为空，执行 recv 会怎么样？</h4><p>接收缓冲区也是类似的情况。</p><p>当接收缓冲区<strong>为空</strong>，如果还向socket执行 recv</p><ul><li>如果此时 socket 是阻塞的，那么程序会在那<strong>干等</strong>，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后<strong>返回</strong>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/recv%E9%98%BB%E5%A1%9E.gif" alt="recv阻塞"></p><ul><li>如果此时 socket 是非阻塞的，程序就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/recv%E9%9D%9E%E9%98%BB%E5%A1%9E2.gif" alt="recv非阻塞"></p><p>下面用一张图汇总一下，方便大家保存面试的时候用哈哈哈。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/socket.png" alt="socket读写缓冲区满了的情况汇总"></p><br><h3 id="如果socket缓冲区还有数据，执行close了，会怎么样？"><a href="#如果socket缓冲区还有数据，执行close了，会怎么样？" class="headerlink" title="如果socket缓冲区还有数据，执行close了，会怎么样？"></a>如果socket缓冲区还有数据，执行close了，会怎么样？</h3><p>首先我们要知道，<strong>一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。</strong></p><p>如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。</p><p>正常情况下，如果 <code>socket</code> 缓冲区<strong>为空</strong>，执行 <code>close</code>。就会触发四次挥手。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B4.png" alt="TCP四次挥手"></p><p>这个也是面试老八股文内容了，<strong>这里我们只需要关注第一次挥手，发的是 <code>FIN</code> 就够了</strong>。</p><br><h4 id="如果接收缓冲区有数据时，执行close了，会怎么样？"><a href="#如果接收缓冲区有数据时，执行close了，会怎么样？" class="headerlink" title="如果接收缓冲区有数据时，执行close了，会怎么样？"></a>如果接收缓冲区有数据时，执行close了，会怎么样？</h4><p><code>socket close</code> 时，主要的逻辑在 <code>tcp_close()</code> 里实现。</p><p>先说结论，关闭过程主要有两种情况：</p><ul><li>如果接收缓冲区<strong>还有数据未读</strong>，会先把接收缓冲区的数据清空，然后给对端发一个RST。</li><li>如果接收缓冲区是<strong>空的</strong>，那么就调用 <code>tcp_send_fin()</code> 开始进行四次挥手过程的第一次挥手。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_close</span><span class="params">(struct sock *sk, <span class="keyword">long</span> timeout)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 如果接收缓冲区有数据，那么清空数据</span></span><br><span class="line"><span class="keyword">while</span> ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq -</span><br><span class="line">  tcp_hdr(skb)-&gt;fin;</span><br><span class="line">data_was_unread += len;</span><br><span class="line">__kfree_skb(skb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (data_was_unread) &#123;</span><br><span class="line">    <span class="comment">// 如果接收缓冲区的数据被清空了，发 RST</span></span><br><span class="line">tcp_send_active_reset(sk, sk-&gt;sk_allocation);</span><br><span class="line"> &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tcp_close_state(sk)) &#123;</span><br><span class="line">    <span class="comment">// 正常四次挥手， 发 FIN</span></span><br><span class="line">tcp_send_fin(sk);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待关闭</span></span><br><span class="line">sk_stream_wait_close(sk, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/recvbuf%E9%9D%9E%E7%A9%BA.gif" alt="recvbuf非空"></p><br><h4 id="如果发送缓冲区有数据时，执行close了，会怎么样？"><a href="#如果发送缓冲区有数据时，执行close了，会怎么样？" class="headerlink" title="如果发送缓冲区有数据时，执行close了，会怎么样？"></a>如果发送缓冲区有数据时，执行close了，会怎么样？</h4><p>以前以为，这种情况下，内核会把发送缓冲区数据清空，然后四次挥手。</p><p>但是发现源码<strong>并不是这样的</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tcp_send_fin</span><span class="params">(struct sock *sk)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 获得发送缓冲区的最后一块数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sk_buff</span> *<span class="title">skb</span>, *<span class="title">tskb</span> =</span> tcp_write_queue_tail(sk);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tcp_sock</span> *<span class="title">tp</span> =</span> tcp_sk(sk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果发送缓冲区还有数据</span></span><br><span class="line"><span class="keyword">if</span> (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) &#123;</span><br><span class="line">TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN; <span class="comment">// 把最后一块数据值为 FIN </span></span><br><span class="line">TCP_SKB_CB(tskb)-&gt;end_seq++;</span><br><span class="line">tp-&gt;write_seq++;</span><br><span class="line">&#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发送缓冲区没有数据，就造一个FIN包</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 发送数据</span></span><br><span class="line">__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。</p><p><code>socket</code> 缓冲区是个<strong>先进先出</strong>的队列，这种情况是指，内核会等待TCP层安静地把发送缓冲区数据都<strong>发完</strong>，最后再执行 四次挥手的第一次挥手（FIN包）。</p><p>有一点需要注意的是，只有在<strong>接收缓冲区为空的前提下</strong>，我们才有可能走到 <code>tcp_send_fin()</code> 。而只有在进入了这个方法之后，我们才有可能考虑<strong>发送缓冲区是否为空</strong>的场景。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/sendbuf%E9%9D%9E%E7%A9%BA.gif" alt="sendbuf非空"></p><br><h2 id="UDP部分"><a href="#UDP部分" class="headerlink" title="UDP部分"></a>UDP部分</h2><h3 id="UDP也有缓冲区吗"><a href="#UDP也有缓冲区吗" class="headerlink" title="UDP也有缓冲区吗"></a>UDP也有缓冲区吗</h3><p>说完TCP了，我们聊聊UDP。这对好基友，同时都是传输层里的重要协议。既然前面提到TCP有发送、接收缓冲区，那UDP有吗？</p><p>以前我以为。</p><blockquote><p> “每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，正因为不需要缓冲数据，所以也不需要发送缓冲区。”</p></blockquote><p>后来我发现我错了。</p><p>UDP socket 也是 socket，一个socket 就是会有收和发两个缓冲区。<strong>跟用什么协议关系不大</strong>。</p><p>有没有是一回事，用不用又是另外一回事。</p><br><h3 id="UDP不用发送缓冲区？"><a href="#UDP不用发送缓冲区？" class="headerlink" title="UDP不用发送缓冲区？"></a>UDP不用发送缓冲区？</h3><p>事实上，UDP不仅<code>有</code>发送缓冲区，也<code>用</code>发送缓冲区。</p><p>一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。</p><p>还有一种情况，是在发送数据的时候，设置一个 <code>MSG_MORE</code> 的标记。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sock, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; <span class="comment">// flag 置为 MSG_MORE</span></span><br></pre></td></tr></table></figure><p>大概的意思是告诉内核，待会还有其他<strong>更多消息</strong>要一起发，先别着急发出去。此时内核就会把这份数据先用<strong>发送缓冲区</strong>缓存起来，待会应用层说ok了，再一起发。</p><p>我们可以看下源码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">udp_sendmsg</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// corkreq 为 true 表示是 MSG_MORE 的方式，仅仅组织报文，不发送；</span></span><br><span class="line"><span class="keyword">int</span> corkreq = up-&gt;corkflag || msg-&gt;msg_flags&amp;MSG_MORE；</span><br><span class="line">    </span><br><span class="line"><span class="comment">//  将要发送的数据，按照MTU大小分割，每个片段一个skb；并且这些</span></span><br><span class="line"><span class="comment">//  skb会放入到套接字的发送缓冲区中；该函数只是组织数据包，并不执行发送动作。</span></span><br><span class="line">err = ip_append_data(sk, fl4, getfrag, msg-&gt;msg_iov, ulen,</span><br><span class="line">     <span class="keyword">sizeof</span>(struct udphdr), &amp;ipc, &amp;rt,</span><br><span class="line">     corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有启用 MSG_MORE 特性，那么直接将发送队列中的数据发送给IP。 </span></span><br><span class="line">    <span class="keyword">if</span> (!corkreq)</span><br><span class="line">err = udp_push_pending_frames(sk);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，不管是不是 <code>MSG_MORE</code>， IP都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。</p><p>而我们大部分情况下，都不会用  <code>MSG_MORE</code>，也就是来一个数据包就直接发一个数据包。从这个行为上来说，<strong>虽然UDP用上了发送缓冲区，但实际上并没有起到”缓冲”的作用。</strong></p><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这篇文章，我也就写了20个小时吧。画图也就画吐了<strong>而已</strong>，每天早上7点钟爬起来写一个多小时再去上班。</p><p>兄弟们都是自家人，点不<strong>点赞</strong>，在不<strong>在看</strong>什么的，没关系的，大家看开心了就好。</p><p><strong>在看，点赞</strong>什么的，我不是特别在意，真的，真的，别不信啊。</p><p>不三连也真的没关系的。</p><p>兄弟们不要在意啊。</p><p>我是心口不一的小白，我们下期见！</p><br><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连接一个 IP 不存在的主机时，握手过程是怎样的？</title>
      <link href="/2021/07/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AAIP%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%97%B6%EF%BC%8C%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/"/>
      <url>/2021/07/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AAIP%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%97%B6%EF%BC%8C%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><p>鸽了好长时间了，最近<strong>很忙</strong>。以前工作忙完，就抽空写文章。</p><p>现在忙完工作，还要一三五学驾照，二四六看家具。有同感的老铁们不要举手，拉到右下角**点个”在看”**就好了。</p><p>真的，全怪某音。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/12021625633784_.pic.jpg"></p><p>扯远了，回到今天的主题。</p><p>方兄最近写了篇很赞的文章 <a href="https://mp.weixin.qq.com/s/SxaNLfGwM4dyzvBUvLAHvA">写给想去字节写 Go 的你</a> ，里面提到了两个问题。</p><p>连接一个 <strong>IP 不存在</strong>的主机时，握手过程是怎样的？</p><p>连接一个 <strong>IP 地址存在但端口号不存在</strong>的主机时，握手过程又是怎样的呢？</p><p>让我回想起曾经也被面试官也问过类似的问题，意识到应该很多朋友会对这个问题感兴趣。</p><p>所以来给大家唠唠。</p><p>这两个问题可以延伸出非常多的点。</p><p>看完了，说不定能加分！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/12011625633784_.pic.jpg"></p><br><h2 id="正常情况的握手过程是怎么样的"><a href="#正常情况的握手过程是怎么样的" class="headerlink" title="正常情况的握手过程是怎么样的"></a>正常情况的握手过程是怎么样的</h2><p>上面提到的问题，其实是指<strong>TCP的三次握手流程</strong>。这绝对是面试八股文里的老股了。</p><p>我们<strong>简单回顾</strong>下基础知识点。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B1.png" alt="正常情况下的TCP三次握手"></p><p>在<strong>服务端</strong>启动好后会调用 <code>listen()</code> 方法，进入到 <code>LISTEN</code> 状态，然后静静等待<strong>客户端</strong>的连接请求到来。</p><p>而此时客户端主动调用 <code>connect(IP地址)</code> ，就会向某个IP地址发起<strong>第一次握手</strong>，发送<code>SYN</code> 到目的服务器。</p><p>服务器在收到第一次握手后就会响应客户端，这是<strong>第二次握手</strong>。</p><p>客户端在收到第二次握手的消息后，响应服务的一个<code>ACK</code>，这算<strong>第三次</strong>握手，此时客户端 就会进入 <code>ESTABLISHED</code>状态，认为连接已经建立完成。</p><p>通过抓包可以直观看出三次握手的流程。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210626164202297.png" alt="正常三次握手抓包"></p><br><h2 id="连一个-IP-不存在的主机时，握手过程是怎样的"><a href="#连一个-IP-不存在的主机时，握手过程是怎样的" class="headerlink" title="连一个 IP 不存在的主机时，握手过程是怎样的"></a>连一个 IP 不存在的主机时，握手过程是怎样的</h2><p>那不存在的IP，分两种，<strong>局域网内和局域网外</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%AE%B6%E7%94%A8%E8%B7%AF%E7%94%B1%E5%99%A8%E5%B1%80%E5%9F%9F%E7%BD%91%E4%BA%92%E8%81%94.png" alt="家用路由器局域网互联"></p><p>我以我家里的情况举例。</p><p>家里有一台<strong>家用路由器</strong>。本质上它的功能已经集成了我们常说的<strong>路由器，交换机和无线接入点</strong>的功能了。</p><p>其中<strong>路由器和交换机</strong>在之前写过的 《<a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a>》里已经详细介绍过了，就不再说一遍了。<strong>无线接入点</strong>基本可以认为就是个放出 wifi 信号的组件。</p><p>家用路由器下，连着我的N台设备，包括手机和电脑，他们的IP都有个<strong>共同点</strong>。都是 <code>192.168.31.xx</code>  形式的。其中，我的电脑的IP是<code>192.168.31.6</code> ，这个可以通过 <code>ifconfig</code>查到。</p><p>符合这个形式的这些个设备，本质上就是通过各种设备（wifi或交换机等）接入到<strong>上图路由器的e2端口</strong>，他们共同构成一个<strong>局域网</strong>。</p><p>因此，在我家，我们可以<strong>粗暴点</strong>认为只要是  <code>192.168.31.xx</code>  形式的IP，就是<strong>局域网内的IP</strong>。否则就是<strong>局域网外的IP</strong>，比如 <code>192.0.2.2</code> 。</p><br><h3 id="目的IP在局域网内"><a href="#目的IP在局域网内" class="headerlink" title="目的IP在局域网内"></a>目的IP在局域网内</h3><p>因为通过 ifconfig 可以查到我的局域网内IP是<code>192.168.31.6</code> ，这里<strong>盲猜</strong>末尾+1是不存在的 IP 。试了下，<code>192.168.31.7</code> 还真不存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 192.168.31.7</span></span><br><span class="line">PING 192.168.31.7 (192.168.31.7): 56 data bytes</span><br><span class="line">Request timeout for icmp_seq 0</span><br><span class="line">Request timeout for icmp_seq 1</span><br><span class="line">Request timeout for icmp_seq 2</span><br><span class="line">Request timeout for icmp_seq 3</span><br><span class="line">^C</span><br><span class="line">--- 192.168.31.7 ping statistics ---</span><br><span class="line">5 packets transmitted, 0 packets received, 100.0% packet loss</span><br></pre></td></tr></table></figure><p>于是写个程序尝试连这个IP 。下面的代码是 <code>golang</code> 写的，<strong>大家不看代码也没关系，放出来只是方便大家自己复现的时候用的。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tcp客户端</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">client, err := net.Dial(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;192.168.31.7:8081&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">defer</span> client.Close()</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">input := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := os.Stdin.Read(input)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;input err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">client.Write([]<span class="keyword">byte</span>(input[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">n, err := client.Read(buf)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="string">&quot;read err:&quot;</span>, err)</span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(<span class="keyword">string</span>(buf[:n]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后尝试抓包。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210619112642833.png" alt="连一个不存在的IP(局域网内)抓包"></p><p>可以发现根本没有三次握手的包，只有一些 ARP 包，在询问“谁是 <code>192.168.31.7</code>，告诉一下 <code>192.168.31.6</code>” 。</p><p>这里有三个问题</p><ul><li>为什么会发ARP请求？</li><li>为什么没有TCP握手包？</li><li>ARP本身是没有重试机制的，为什么ARP请求会发那么多遍？</li></ul><p>首先我们看下正常情况下执行<code>connect</code>，也就是第一次握手 的流程。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%AD%A3%E5%B8%B8connect%E7%9A%84%E6%B5%81%E7%A8%8B.png" alt="正常connect的流程"></p><p>应用层执行<code>connect</code>过后，会通过socket层，操作系统接口，进程会从<strong>用户态进入到内核态</strong>，此时进入 <strong>传输层</strong>，因为是<strong>TCP第一次握手</strong>，会加入<strong>TCP头</strong>，且置<strong>SYN</strong>标志。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B4%E7%9A%84SYN.png" alt="tcp报头的SYN"></p><p>然后进入<strong>网络层</strong>，我想要连的是 <code>192.168.31.7</code> ，虽然它是我瞎编的，但<strong>IP头</strong>还是得老老实实把它加进去。</p><p>此时需要重点介绍的是<strong>邻居子系统</strong>，它在<strong>网络层和数据链路层之间</strong>。可以通过<strong>ARP协议将目的IP转为对应的MAC地址</strong>，然后<strong>数据链路层</strong>就可以用这个MAC地址组装<strong>帧头</strong>。</p><p>我们看下那么<strong>ARP协议的流程</strong>是</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ARP%E6%B5%81%E7%A8%8B3.png" alt="ARP流程"></p><p>1.先到本地ARP表查一下有没有 <code>192.168.31.7</code> 对应的 <strong>mac地址</strong>，有的话就返回，这里显然是不可能会有的。</p><blockquote><p>可以通过 arp -a 命令查看本机的 arp表都记录了哪些信息</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> arp -a</span></span><br><span class="line">? (192.168.31.1) at 88:c1:97:59:d1:c3 on en0 ifscope [ethernet]</span><br><span class="line">? (224.0.0.251) at 1:0:4e:0:1:fb on en0 ifscope permanent [ethernet]</span><br><span class="line">? (239.255.255.250) at 1:0:3e:7f:ff:fb on en0 ifscope permanent [ethernet]</span><br></pre></td></tr></table></figure><p>2.看下 <code>192.168.31.7</code>  跟本机IP  <code>192.168.31.6 </code>在不在一个局域网下。如果在的话，就在局域网内发一个 arp 广播，内容就是 前面提到的 “谁是 <code>192.168.31.7</code>，告诉一下 <code>192.168.31.6</code>”。</p><p>3.如果目的IP跟本机IP不在同一个局域网下，那么会去获取<strong>默认网关的MAC地址</strong>，这里就是指获取<strong>家用路由器的MAC地址</strong>。然后把消息发给家用路由器，让路由器发到互联网，找到下一跳路由器，一跳一跳的发送数据，<strong>直到把消息发到目的IP上，又或者找不到目的地最终被丢弃。</strong></p><p>4.第2和第3点都是本地没有查到 ARP 缓存记录的情况，这时候会<strong>把SYN报文放进一个队列（叫unresolved_queue）里暂存起来</strong>，然后发起ARP请求；等ARP层收到ARP回应报文之后，会再从缓存中取出 SYN 报文，组装 MAC 帧头，完成刚刚没完成的发送流程。</p><p>如果经过 ARP 流程能正常返回 MAC 地址，那皆大欢喜，直接给<strong>数据链路层</strong>，经过 <code>ring buffer</code> 后传到网卡，发出去。</p><p>但因为现在这个IP是瞎编的，因此不可能得到目的地址 MAC ，所以消息也一直没法到数据链路层。<strong>整个流程卡在了ARP流程中。</strong></p><p>而<strong>抓包是在数据链路层之后进行的</strong>，因此 TCP 第一次握手的包一直没能抓到，只能抓到为了获得  <code>192.168.31.7</code> 的MAC地址的ARP请求。</p><blockquote><p>发送数据时，是在经过数据链路层之后的  dev_queue_xmit_nit 方法执行抓包操作的，这是属于网卡驱动层的方法了。</p><p>顺带一提，接收端抓包是在  __netif_receive_skb_core 方法里执行的，也属于网卡驱动层。感兴趣的朋友们可以以这个为关键词搜索相关知识点哈</p></blockquote><p>此时 因为 TCP 协议是可靠的协议，对于 TCP 层来说，第一次握手的消息，已经发出去了，但是一直没有收到 ACK。也不知道消息是出去后是遇到什么事了。为了保证可靠性，它会不断重发。</p><p>而每一次重发，都会因为同样的原因（没有目的 MAC 地址）而尬在了 ARP 那个流程里。因此，才看到好几次重复的 ARP 消息。</p><p>那回到刚刚的三个问题</p><ul><li><p>为什么会发 ARP 请求？</p><p>因为目的地址是瞎编的，本地ARP表没有目的机器的MAC地址，因此发出ARP消息。</p></li><li><p>为什么没有 TCP 握手包？</p><p>因为协议栈的数据到了网络层后，在数据链路层前，就因为没有目的MAC地址，没法发出。因此抓包软件抓不到相关数据。</p></li><li><p>为什么 ARP 请求会发那么多遍？</p><p>因为 TCP 协议的可靠性，会重发第一次握手的消息，但每一次都因为没有目的 MAC 地址而失败，每次都会发出ARP请求。</p></li></ul><br><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>连一个 IP 不存在的主机时，如果<strong>目的IP在局域网内</strong>，则第一次握手会失败，接着不断尝试重发握手的请求。同时，本机会不断发出ARP请求，企图获得目的机器的 MAC 地址。并且，因为没能获得目的 MAC 地址，这些 TCP 握手请求最终都发不出去，</p><br><h3 id="目的IP在局域网外"><a href="#目的IP在局域网外" class="headerlink" title="目的IP在局域网外"></a>目的IP在局域网外</h3><p>上面提到的是，目的 IP 在<strong>局域网内</strong>的情况，下面讨论目的IP在<strong>局域网外</strong>的情况。</p><p>瞎编一个不是  <code>192.168.31.xx</code> 形式的 IP 作为这次要用的局域网外IP， 比如 <code>10.225.31.11</code>。</p><p>先抓包看一下。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210619111302173.png" alt="连一个不存在的IP(局域网外)抓包"></p><p>这次的现象是能发出 TCP 第一次握手的 <code>SYN包</code>。</p><p>这里有两个问题</p><ul><li>为什么连局域网外的 IP 现象跟连局域网内不一致？</li><li>TCP 第一次握手的重试规律好像不太对？</li></ul><br><h4 id="为什么连局域网外的IP现象跟连局域网内不一致？"><a href="#为什么连局域网外的IP现象跟连局域网内不一致？" class="headerlink" title="为什么连局域网外的IP现象跟连局域网内不一致？"></a>为什么连局域网外的IP现象跟连局域网内不一致？</h4><p>这个问题的答案其实在上面 <strong>ARP 的流程</strong>里已经提到过了，如果目的 IP 跟本机 IP 不在同一个局域网下，那么会去获取<strong>默认网关的 MAC 地址</strong>，这里就是指获取<strong>家用路由器的MAC地址</strong>。</p><p>此时ARP流程成功返回<strong>家用路由器的 MAC 地址</strong>，数据链路层加入帧头，消息通过网卡发到了<strong>家用路由器上</strong>。</p><p>消息会通过互联网一直传递到某个局域网为  <code>10.225.31.xx</code> 的路由器上，那个路由器 发出ARP 请求，询问他们局域网内的机器有没有叫 <code>10.225.31.11</code>的 （结果当然没有）。</p><p>最终没能发送成功，发送端也就迟迟收不到目的机的第二次握手响应。</p><p>因此触发TCP重传。</p><br><h4 id="TCP第一次握手的重试规律好像不太对？"><a href="#TCP第一次握手的重试规律好像不太对？" class="headerlink" title="TCP第一次握手的重试规律好像不太对？"></a>TCP第一次握手的重试规律好像不太对？</h4><p>在 Linux 中，第一次握手的 <code>SYN</code> 重传次数，是通过 <code>tcp_syn_retries</code> 参数控制的。可以通过下面的方式查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">cat /proc/sys/net/ipv4/tcp_syn_retries</span></span><br><span class="line">6</span><br></pre></td></tr></table></figure><p>这里的含义是指 <code>syn重传</code> 会发生6次。</p><p>而每次重试都会间隔一定的时间，这里的间隔一般是 1s，2s，4s，8s, 16s, 32s .</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/SYN%E9%87%8D%E4%BC%A0.png" alt="SYN重传"></p><p>而事实上，看我的截图，是先重试4次，每次都是1s，之后才是 1s，2s，4s，8s, 16s, 32s 的重试。</p><p>这跟我们知道的不太一样。</p><p>这个是因为<strong>我用的是macOS抓的包，跟linux就不是一个系统</strong>，各自的TCP协议栈在sync重传方面的实现都可能会有一定的差异。</p><p>我还听说 <code>oppo</code> 和 <code>vivo</code> 的 syn重传 是0.5s起步的。而 <code>windows</code> 的 syn重传 还有自己的专利。</p><p>这些冷知识大家可以不用在意。面试的时候知道linux的就够了，剩下的可以用来装逼。毕竟面试官不在意”茴”字到底有几种写法。</p><br><h2 id="连IP-地址存在但端口号不存在的主机的握手过程"><a href="#连IP-地址存在但端口号不存在的主机的握手过程" class="headerlink" title="连IP 地址存在但端口号不存在的主机的握手过程"></a>连IP 地址存在但端口号不存在的主机的握手过程</h2><p>前面提到的是IP地址压根就不存在的情况。假如<strong>IP地址存在但端口号是瞎编的</strong>呢？</p><h3 id="目的IP是回环地址"><a href="#目的IP是回环地址" class="headerlink" title="目的IP是回环地址"></a>目的IP是回环地址</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210627090037348.png" alt="连回环地址，端口不存在抓包"></p><p>现象也比较简单，已经IP地址是存在的，也就是在互联网中这个机器是存在的。</p><p>那么我们可以正常发消息到目的IP，因为对应的MAC地址和IP都是正确的，所以，数据从数据链路层到网络层都很OK。</p><p>直到传输层，TCP协议在识别到这个端口号对应的进程根本不存在时，就会把数据丢弃，响应一个RST消息给发送端。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%BF%9E%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E6%97%B6%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="连回环地址时端口不存在"></p><br><h4 id="RST是什么？"><a href="#RST是什么？" class="headerlink" title="RST是什么？"></a>RST是什么？</h4><p>我们都是到TCP正常情况下断开连接是用四次挥手，那是<strong>正常时候</strong>的优雅做法。</p><p>但<strong>异常情况</strong>下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。</p><p><strong>RST</strong> 就是用于这种情况，一般用来<strong>异常地</strong>关闭一个连接。它在TCP包头中，在收到置了这个标志位的数据包后，连接就会被关闭，此时接收到 RST的一方，一般会看到一个 <code>connection reset</code> 或  <code>connection refused</code> 的报错。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B4RST%E4%BD%8D.png" alt="TCP报头RST位"></p><br><h3 id="目的IP在局域网内-1"><a href="#目的IP在局域网内-1" class="headerlink" title="目的IP在局域网内"></a>目的IP在局域网内</h3><p>刚刚提到我的本机IP是 <code>192.168.31.6</code> ，局域网内有台 <code>192.168.31.1</code> 。同样尝试连一个不存在的端口。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210619113503022.png" alt="连存在的局域网内IP，端口不存在抓包"></p><p>此时现象跟前者一致。</p><p>唯一不同的是，前者是回环地址，RST数据是从本机的传输层返回的。而这次的情况，RST数据是从目的机器的传输层返回的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%BF%9E%E5%A4%96%E7%BD%91%E5%9C%B0%E5%9D%80%E6%97%B6%E7%AB%AF%E5%8F%A3%E4%B8%8D%E5%AD%98%E5%9C%A8.png" alt="连外网地址时端口不存在"></p><br><h3 id="目的IP在局域网外-1"><a href="#目的IP在局域网外-1" class="headerlink" title="目的IP在局域网外"></a>目的IP在局域网外</h3><p>找一个存在的外网ip，这里我拿了<strong>最近刚白嫖的阿里云服务器</strong>地址 <code> 47.102.221.141</code> 。（炫耀） </p><p>进行连接连接，发现与前面两种情况是一致的，目的机器在收到我的请求后，立马就通过 <strong>RST标志位</strong> 断开了这次的连接。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210619182034584.png" alt="连存在的局域网外IP，端口不存在抓包"></p><p>这一点跟前面两种情况一致。</p><p>熟悉小白的朋友们都知道，每次搞事情做测试，都会用  <code>baidu.com</code> 。</p><p>这次也不例外，ping 一下 <code>baidu.com</code> ,获得它的 <code>IP: 220.181.38.148</code>  。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping baidu.com</span></span><br><span class="line">PING baidu.com (220.181.38.148): 56 data bytes</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=0 ttl=48 time=35.728 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=1 ttl=48 time=38.052 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=2 ttl=48 time=37.845 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=3 ttl=48 time=37.210 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=4 ttl=48 time=38.402 ms</span><br><span class="line">64 bytes from 220.181.38.148: icmp_seq=5 ttl=48 time=37.692 ms</span><br><span class="line">^C</span><br><span class="line">--- baidu.com ping statistics ---</span><br><span class="line">6 packets transmitted, 6 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 35.728/37.488/38.402/0.866 ms</span><br></pre></td></tr></table></figure><p>发消息到给百度域名背后的 IP，且瞎随机指定一个端口 <strong>8080</strong>， 抓包。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210619084158238.png" alt="连baidu，端口不存在抓包"></p><p>现象却不一致。没有 <code>RST</code> 。而且触发了第一次握手的重试消息。这是为什么？</p><p>这是因为baidu的机器，作为线上生产的机器，会设置一系列安全策略，比如只对外暴露某些端口，除此之外的端口，都一律拒绝。</p><p>所以很多发到 8080端口的消息都<strong>在防火墙这一层就被拒绝掉了</strong>，根本到不了目的主机里，而<strong>RST是在目的主机的TCP/IP协议栈里发出</strong>的，都还没到这一层，就更不可能发RST了。因此发送端发现消息没有回应（因为被防火墙丢了），就会重传。所以才会出现上述抓包里的现象。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%98%B2%E7%81%AB%E5%A2%99%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5.png" alt="防火墙安全策略"></p><br><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>连一个 IP 不存在的主机时</p><ul><li><p>如果IP在局域网内，会发送N次ARP请求获得目的主机的MAC地址，同时不能发出TCP握手消息。</p></li><li><p>如果IP在局域网外，会将消息通过路由器发出，但因为最终找不到目的地，触发TCP重试流程。</p></li></ul><p>连IP 地址存在但端口号不存在的主机时</p><ul><li><p>不管目的IP是回环地址还是局域网内外的IP地址，目的主机的传输层都会在收到握手消息后，发现端口不正确，发出RST消息断开连接。</p></li><li><p>当然如果目的机器设置了防火墙策略，限制他人将消息发到不对外暴露的端口，那么这种情况，发送端就会不断重试第一次握手。</p></li></ul><p>最后留个问题，连一个 <strong>不存在的局域网外IP</strong>的主机时，我们可以看到TCP的重发规律是：开始时，每隔1s重发五次 <code>TCP SYN</code>消息，接着2s,4s,8s,16s,32s都重发一次；</p><p>对比连一个 <strong>不存在的局域网内IP</strong>的主机时，却是每隔1s重发了4次<code>ARP请求</code>，接着过了32s后才再发出一次ARP请求。已知ARP请求是没有重传机制的，它的重试就是TCP重试触发的，但两者规律不一致，是为什么？</p><br><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（**<del>卑微</del>疯狂暗示，拜托拜托，这对我真的很重要！**）</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/12051625633785_.pic.jpg"></p><p>我是小白，我们下期见。</p><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p><br><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？</title>
      <link href="/2021/06/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%96%AD%E7%BD%91%E4%BA%86%EF%BC%8C%E8%BF%98%E8%83%BDping%E9%80%9A%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88/"/>
      <url>/2021/06/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%96%AD%E7%BD%91%E4%BA%86%EF%BC%8C%E8%BF%98%E8%83%BDping%E9%80%9A%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<p>首发于个人公众号：小白debug<br>原文地址：<a href="https://mp.weixin.qq.com/s/XsZYiLxZ0AXjVMBgWCnmzw">硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？</a></p><p>你<strong>女神爱不爱你</strong>，你问她，她可能不会告诉你。</p><p>但<strong>网通不通</strong>，你 <code>ping</code> 一下就知道了。 </p><span id="more"></span><p>可能看到标题，你就知道答案了，但是你了解背后的原因吗？那如果把 <code>127.0.0.1</code> 换成 <code>0.0.0.0</code> 或 <code>localhost</code> 会怎么样呢？ 你知道这几个<code>IP</code>有什么区别吗？</p><p>以前面试的时候就遇到过这个问题，大家看个动图了解下面试官和我当时的场景，求当时小白的心里阴影面积。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/cache_1623425479_3538.gif"></p><p>话不多说，我们直接开车。</p><p>拔掉网线，断网。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006WD51tly1fxvyqnfervj308c08c3yo.jpg"></p><p>然后在控制台输入<code> ping 127.0.0.1</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 127.0.0.1</span></span><br><span class="line">PING 127.0.0.1 (127.0.0.1): 56 data bytes</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.080 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.093 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.074 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.079 ms</span><br><span class="line">^C</span><br><span class="line">--- 127.0.0.1 ping statistics ---</span><br><span class="line">5 packets transmitted, 5 packets received, 0.0% packet loss</span><br><span class="line">round-trip min/avg/max/stddev = 0.074/0.081/0.093/0.006 ms</span><br></pre></td></tr></table></figure><p>说明，拔了网线，<code>ping 127.0.0.1</code>  是<strong>能ping通的</strong>。</p><p>其实这篇文章看到这里，标题前半个问题已经被回答了。但是我们可以再想深一点。</p><p>为什么断网了还能 <code>ping</code> 通 <code> 127.0.0.1</code> 呢？</p><p><strong>这能说明你不用交网费就能上网吗？</strong></p><p><strong>不能。</strong></p><p>首先我们需要进入基础科普环节。</p><p>不懂的同学看了就懂了，懂的看了就当查漏补缺吧。</p><h3 id="什么是127-0-0-1"><a href="#什么是127-0-0-1" class="headerlink" title="什么是127.0.0.1"></a>什么是127.0.0.1</h3><p>首先，这是个 <code>IPV4</code> 地址。</p><p><code>IPV4</code> 地址有 <code>32</code> 位，一个字节有 <code>8</code> 位，共 <code>4</code> 个字节。</p><p>其中<strong>127 开头的都属于回环地址</strong>，也是 <code>IPV4</code> 的特殊地址，没什么道理，就是人为规定的。</p><p>而<code>127.0.0.1</code>是<strong>众多</strong>回环地址中的一个。之所以不是 <code>127.0.0.2</code> ，而是 <code>127.0.0.1</code>，是因为源码里就是这么定义的，也没什么道理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Address to loopback in software to local host.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>INADDR_LOOPBACK0x7f000001<span class="comment">/* 127.0.0.1   */</span></span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="回环地址"></p><p><code>IPv4</code> 的地址是 <code>32</code> 位的，2的32次方，大概是<code>40+亿</code>。地球光人口就76亿了，40亿IP这点量，<strong>塞牙缝都不够</strong>，实际上<strong>IP也确实用完</strong>了。</p><p>所以就有了<code>IPV6</code>， <code>IPv6</code> 的地址是 <code>128</code> 位的，大概是2的128次方≈<strong>10的38次方</strong>。据说地球的沙子数量大概是 <strong>10的23次方</strong>，所以IPV6的IP可以认为用不完。</p><p>IPV4以8位一组，每组之间用 <strong>.</strong> 号隔开。</p><p>IPV6就以16位为一组，每组之间用 <strong>:</strong> 号隔开。如果全是0，那么可以省略不写。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ipv6%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="ipv6回环地址"></p><p>在IPV4下的回环地址是 <code>127.0.0.1</code>，在<code>IPV6</code>下，表达为 <code>::1</code> 。中间把<strong>连续的0</strong>给省略了，之所以不是<strong>7个 冒号</strong>，而是<strong>2个冒号:</strong> ， 是因为一个 IPV6 地址中<strong>只允许出现⼀次两个连续的冒号</strong>。</p><blockquote><p>多说一句： 在IPV4下用的是 <strong>ping 127.0.0.1</strong> 命令。 在IPV6下用的是 <strong>ping6  ::1</strong> 命令。</p></blockquote><h3 id="什么是-ping"><a href="#什么是-ping" class="headerlink" title="什么是 ping"></a>什么是 ping</h3><p>ping 是应用层命令，可以理解为它跟游戏或者聊天软件属于同一层。只不过聊天软件可以收发消息，还能点个赞什么的，有很多复杂的功能。而 ping 作为一个小软件，它的功能比较简单，就是<strong>尝试</strong>发送一个小小的消息到目标机器上，判断目的机器是否<strong>可达</strong>，其实也就是判断目标机器网络是否能连通。</p><p>ping应用的底层，用的是网络层的<strong>ICMP协议</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/IP%E5%92%8CICMP%E5%92%8CPing%E6%89%80%E5%9C%A8%E5%88%86%E5%B1%82.png" alt="IP和ICMP和Ping所在分层"></p><p>虽然ICMP协议和IP协议<strong>都属于网络层协议</strong>，但其实<strong>ICMP也是利用了IP协议进行消息的传输</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ip%E5%92%8Cicmp%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="ip和icmp的关系"></p><p>所以，大家在这里完全可以简单的理解为 ping 某个IP 就是往某个IP地址发个消息。</p><h3 id="TCP发数据和ping的区别"><a href="#TCP发数据和ping的区别" class="headerlink" title="TCP发数据和ping的区别"></a>TCP发数据和ping的区别</h3><p>一般情况下，我们会使用 TCP 进行网络数据传输，那么我们可以看下它和 ping 的区别。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ping%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%B3%E7%B3%BB2.png" alt="ping和普通发消息的关系"></p><p>ping和其他应用层软件都属于<strong>应用层</strong>。</p><p>那么我们横向对比一下，比方说聊天软件，如果用的是TCP的方式去发送消息。</p><p>为了发送消息，那就得先知道往哪发。linux里万物皆文件，那你要发消息的目的地，也是个文件，这里就引出了socket 的概念。</p><p>要使用 <code>socket</code> , 那么首先需要创建它。</p><p>在 TCP 传输中创建的方式是  <code>socket(AF_INET, SOCK_STREAM, 0);</code>，其中 <code>AF_INET</code> 表示将使用 IPV4 里 <strong>host:port</strong> 的方式去解析待会你输入的网络地址。<code>SOCK_STREAM</code> 是指使用面向字节流的 TCP 协议，<strong>工作在传输层</strong>。</p><p>创建好了 <code>socket</code> 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的<code>sendto</code>接口的过程中进程会从<strong>用户态进入到内核态</strong>，最后会调用到 <code>sock_sendmsg</code> 方法。</p><p>然后进入传输层，带上<code>TCP</code>头。网络层带上<code>IP</code>头，数据链路层带上 <code>MAC</code>头等一系列操作后。进入网卡的<strong>发送队列 ring buffer</strong> ，顺着网卡就发出去了。</p><p>回到 <code>ping</code> ， 整个过程也基本跟 <code>TCP</code> 发数据类似，差异的地方主要在于，创建 <code>socket</code> 的时候用的是  <code>socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)</code>，<code>SOCK_RAW</code> 是原始套接字 ，<strong>工作在网络层</strong>， 所以构建<code>ICMP</code>（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的  <code>sock_sendmsg</code> 方法，进入到网络层后加上<strong>ICMP和IP头</strong>后，数据链路层加上<strong>MAC头</strong>，也是顺着网卡发出。因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。</p><p>这也解释了<strong>为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能ping通吗？</strong>因为可以简单理解为ping就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。</p><h3 id="为什么断网了还能-ping-通-127-0-0-1"><a href="#为什么断网了还能-ping-通-127-0-0-1" class="headerlink" title="为什么断网了还能 ping 通 127.0.0.1"></a>为什么断网了还能 ping 通 127.0.0.1</h3><p>前面提到，有网的情况下，ping 最后是<strong>通过网卡</strong>将数据发送出去的。</p><p>那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ping%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80.png" alt="ping回环地址"></p><p>从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的<strong>路由信息</strong>，而这其中就包含选择<strong>哪个网卡</strong>把消息发出。</p><p>当发现<strong>目标IP是外网IP</strong>时，会从”真网卡”发出。</p><p>当发现<strong>目标IP是回环地址</strong>时，就会选择<strong>本地网卡</strong>。</p><p>本地网卡，其实就是个**”假网卡”<strong>，它不像”真网卡”那样有个<code>ring buffer</code>什么的，”假网卡”会把数据推到一个叫 <code> input_pkt_queue</code> 的 <strong>链表</strong> 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个</strong>软中断**。</p><p>专门处理软中断的工具人**”ksoftirqd”** （这是个<strong>内核线程</strong>），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%B7%A5%E5%85%B7%E4%BA%BAksoftirqd.png" alt="工具人ksoftirqd"></p><p>ping 回环地址和<strong>通过TCP等各种协议发送数据到回环地址</strong>都是走这条路径。整条路径从发到收，都没有经过”真网卡”。<strong>之所以127.0.0.1叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，在本机打个转就又回来了。</strong>所以断网，依然能 <code>ping</code> 通 <code>127.0.0.1</code>。</p><h3 id="ping回环地址和ping本机地址有什么区别"><a href="#ping回环地址和ping本机地址有什么区别" class="headerlink" title="ping回环地址和ping本机地址有什么区别"></a>ping回环地址和ping本机地址有什么区别</h3><p>我们在mac里执行 <code>ifconfig</code> 。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ifconfig</span></span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">inet 127.0.0.1 netmask 0xff000000</span><br><span class="line">...</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">inet 192.168.31.6 netmask 0xffffff00 broadcast 192.168.31.255</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>能看到 <strong>lo0</strong>，表示本地回环接口，对应的地址，就是我们前面提到的 <strong>127.0.0.1</strong> ，也就是<strong>回环地址</strong>。</p><p>和 <strong>eth0</strong>，表示本机第一块网卡，对应的IP地址是<strong>192.168.31.6</strong>，管它叫<strong>本机IP</strong>。</p><p>之前一直认为ping本机IP的话会通过”真网卡”出去，然后遇到第一个路由器，再发回来到本机。</p><p>为了验证这个说法，可以进行抓包，但结果跟上面的说法并不相同。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210611225434437.png" alt="ping 127.0.0.1"></p><br><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210611225140197.png" alt="ping 本机地址"></p><p>可以看到 ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的  <strong>lo0</strong>，本地回环接口，也就是前面提到的**”假网卡”**。</p><p>只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 <strong>ping回环地址和ping本机地址没有区别</strong>。</p><h3 id="127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗"><a href="#127-0-0-1-和-localhost-以及-0-0-0-0-有区别吗" class="headerlink" title="127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗"></a>127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗</h3><p>回到文章开头动图里的提问，算是面试八股文里的老常客了。</p><p>以前第一次用 <code>nginx</code> 的时候，发现用这几个 <code>IP</code>，都能正常访问到 <code>nginx</code> 的欢迎网页。一度认为这几个 <code>IP</code> 都是一样的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210530190253656.png" alt="访问127.0.0.1:80"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210530190335350.png" alt="访问localhost:80"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210530190410662.png" alt="访问0.0.0.0:80"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210530191958500.png" alt="访问本机的IP地址"></p><p>但本质上还是有些区别的。</p><p>首先 <code>localhost</code> 就不叫 <code>IP</code>，它是一个域名，就跟 <code>&quot;baidu.com&quot;</code>,是一个形式的东西，只不过默认会把它解析为 <code>127.0.0.1</code> ，当然这可以在 <code>/etc/hosts</code> 文件下进行修改。</p><p>所以默认情况下，使用 <code>localhost</code>  跟使用  <code>127.0.0.1</code>  确实是没区别的。</p><p>其次就是 <code>0.0.0.0</code>，执行 ping 0.0.0.0  ，是会失败的，因为它在<code>IPV4</code>中表示的是无效的<strong>目标地址</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ping 0.0.0.0</span></span><br><span class="line">PING 0.0.0.0 (0.0.0.0): 56 data bytes</span><br><span class="line">ping: sendto: No route to host</span><br><span class="line">ping: sendto: No route to host</span><br></pre></td></tr></table></figure><p>但它还是很有用处的，回想下，我们启动服务器的时候，一般会 <code>listen</code> 一个 IP 和端口，等待客户端的连接。</p><p>如果此时 <code>listen</code> 的是本机的 <code>0.0.0.0</code> , 那么它表示本机上的<strong>所有IPV4地址</strong>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* Address to accept any incoming messages. */</span><br><span class="line"><span class="meta">#</span><span class="bash">defineINADDR_ANY((unsigned long int) 0x00000000) /* 0.0.0.0   */</span></span><br></pre></td></tr></table></figure><p>举个例子。刚刚提到的 <code>127.0.0.1</code> 和 <code>192.168.31.6</code> ，都是本机的IPV4地址，如果监听 <code>0.0.0.0</code>  ，那么用上面两个地址，都能访问到这个服务器。</p><p> 当然， 客户端 <code>connect</code> 时，不能使用 <code>0.0.0.0</code> 。必须指明要连接哪个服务器IP。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><code>127.0.0.1</code> 是<strong>回环地址</strong>。<code>localhost</code>是<strong>域名</strong>，但默认等于 <code>127.0.0.1</code>。</p></li><li><p><code>ping</code> 回环地址和 <code>ping</code> 本机地址，是一样的，走的是<strong>lo0 “假网卡”<strong>，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前</strong>狠狠拐了个弯</strong>， 将数据插入到一个<strong>链表</strong>后就<strong>软中断</strong>通知 <strong>ksoftirqd</strong> 来进行<strong>收数据</strong>的逻辑，<strong>压根就不出网络</strong>。所以断网了也能 <code>ping</code> 通回环地址。</p></li><li><p>如果服务器 <code>listen</code> 的是 <code>0.0.0.0</code>，那么此时用<code>127.0.0.1</code>和本机地址<strong>都可以</strong>访问到服务。</p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近工作上的事情太忙，本来就黑的黑眼圈，就更黑了，鸽了大家这么久实在不好意思哈。</p><p>这篇文章里，有几张大图本来都是动图，但是发现动起来之后发现字太小，点开来放大之后图又不会动了。有些影响体验，我就先改成静态图吧。</p><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《127.0.0.1 之本机网络通信过程知多少 ?！》—— 推荐关注飞哥的《开发内功修炼》</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/VLHCu6b5Anx8HEj_gQZfOg">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！GMP模型里为什么要有P？背后的原因让人暖心</title>
      <link href="/2021/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P/"/>
      <url>/2021/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><h3 id="GM模型是什么"><a href="#GM模型是什么" class="headerlink" title="GM模型是什么"></a>GM模型是什么</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GM%E5%9B%BE.png" alt="GM图"></p><p>在 <code>Go 1.1</code>版本之前，其实用的就是<code>GM</code>模型。</p><span id="more"></span><ul><li><p><strong>G</strong>，协程。通常在代码里用  <code>go</code>  关键字执行一个方法，那么就等于起了一个<code>G</code>。</p></li><li><p><strong>M</strong>，<strong>内核</strong>线程，操作系统内核其实看不见<code>G</code>和<code>P</code>，只知道自己在执行一个线程。<code>G</code>和<code>P</code>都是在<strong>用户层</strong>上的实现。</p></li></ul><p>除了<code>G</code>和<code>M</code>以外，还有一个<strong>全局协程队列</strong>，这个全局队列里放的是多个处于<strong>可运行状态</strong>的<code>G</code>。<code>M</code>如果想要获取<code>G</code>，就需要访问一个<strong>全局队列</strong>。同时，内核线程<code>M</code>是可以同时存在多个的，因此访问时还需要考虑<strong>并发</strong>安全问题。因此这个全局队列有一把<strong>全局的大锁</strong>，每次访问都需要去获取这把大锁。</p><p>并发量小的时候还好，当并发量大了，这把大锁，就成为了<strong>性能瓶颈</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GM%E6%A8%A1%E5%9E%8B.gif" alt="GM模型"></p><h3 id="GMP模型是什么"><a href="#GMP模型是什么" class="headerlink" title="GMP模型是什么"></a>GMP模型是什么</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E5%9B%BE.png" alt="GMP图"></p><p>基于<strong>没有什么是加一个中间层不能解决的</strong>思路，<code>golang</code>在原有的<code>GM</code>模型的基础上加入了一个调度器<code>P</code>，可以简单理解为是在<code>G</code>和<code>M</code>中间加了个中间层。</p><p>于是就有了现在的<code>GMP</code>模型里。</p><ul><li><p><code>P</code> 的加入，还带来了一个<strong>本地协程队列</strong>，跟前面提到的<strong>全局队列</strong>类似，也是用于存放<code>G</code>，想要获取等待运行的<code>G</code>，会<strong>优先</strong>从本地队列里拿，访问本地队列无需加锁。而全局协程队列依然是存在的，但是功能被弱化，不到<strong>万不得已</strong>是不会去全局队列里拿<code>G</code>的。</p></li><li><p><code>GM</code>模型里M想要运行<code>G</code>，直接去全局队列里拿就行了；<code>GMP</code>模型里，<code>M</code>想要运行<code>G</code>，就得先获取<code>P</code>，然后从 <code>P</code> 的本地队列获取 <code>G</code>。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E6%A8%A1%E5%9E%8B1.gif" alt="GMP模型"></p><ul><li><p>新建 <code>G</code> 时，新<code>G</code>会优先加入到 <code>P</code> 的本地队列；如果本地队列满了，则会把本地队列中一半的 <code>G</code> 移动到全局队列。</p></li><li><p><code>P</code> 的本地队列为空时，就从全局队列里去取。</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E6%A8%A1%E5%9E%8B-%E8%8E%B7%E5%8F%96%E5%85%A8%E5%B1%80%E5%8D%8F%E7%A8%8B%E9%98%9F%E5%88%97.gif" alt="GMP模型-获取全局协程队列"></p><ul><li>如果全局队列为空时，<code>M</code> 会从其他 <code>P</code> 的本地队列<strong>偷（stealing）一半G</strong>放到自己 <code>P</code> 的本地队列。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E6%A8%A1%E5%9E%8B-stealing2.gif" alt="GMP模型-stealing"></p><ul><li><code>M</code> 运行 <code>G</code>，<code>G</code> 执行之后，<code>M</code> 会从 <code>P</code> 获取下一个 <code>G</code>，不断重复下去。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/GMP%E6%A8%A1%E5%9E%8B4.gif" alt="GMP模型-循环执行"></p><h3 id="为什么P的逻辑不直接加在M上"><a href="#为什么P的逻辑不直接加在M上" class="headerlink" title="为什么P的逻辑不直接加在M上"></a>为什么P的逻辑不直接加在M上</h3><p>主要还是因为<code>M</code>其实是<strong>内核</strong>线程，内核只知道自己在跑线程，而<code>golang</code>的运行时（包括调度，垃圾回收等）其实都是<strong>用户空间</strong>里的逻辑。操作系统内核哪里还知道，也不需要知道用户空间的golang应用原来还有那么多花花肠子。这一切逻辑交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适啊。</p><blockquote><p> 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p></blockquote><p>我是小白，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>[1]《Golang 调度器 GMP 原理与调度全分析》  ——Aceld :<a href="https://learnku.com/articles/41728">https://learnku.com/articles/41728</a>  </p><p>[2]《GMP模型为什么要有P》   ——煎鱼 :<a href="https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw">https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw</a></p><p>[3]《深度解密Go语言之Scheduler》 ——qcrao :<a href="https://qcrao.com/2019/09/02/dive-into-go-scheduler/#%E4%BB%80%E4%B9%88%E6%98%AF-scheduler">https://qcrao.com/2019/09/02/dive-into-go-scheduler/#%E4%BB%80%E4%B9%88%E6%98%AF-scheduler</a> </p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </li><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </li></ul><h6 id="别说了，关注公众号-【小白debug】，一起在知识的海洋里呛水吧"><a href="#别说了，关注公众号-【小白debug】，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，关注公众号:【小白debug】，一起在知识的海洋里呛水吧"></a>别说了，关注公众号:【小白debug】，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我感觉，我可能要拿图灵奖了。。。</title>
      <link href="/2021/06/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%88%91%E6%84%9F%E8%A7%89%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8B%BF%E5%9B%BE%E7%81%B5%E5%A5%96%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/"/>
      <url>/2021/06/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%88%91%E6%84%9F%E8%A7%89%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8B%BF%E5%9B%BE%E7%81%B5%E5%A5%96%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p>是的，这个是<strong>标题党</strong>。</p><p>事情是这样的，最近在<code>zhihu</code>上回答了一个问题。一夜之间拿到了<code>900+</code>赞，让我相当震惊。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210413074107762.png"></p><p>实话说，就是个抖机灵的回答。不知道是不是命中了什么推荐规则。没想到打开手机突然发现<code>99+</code>的信息，一时之间有些蒙圈。</p><p>打开评论，也是相当有趣哈哈哈。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210413074228059.png"></p><p>在知乎划水这么久，第一次遇到这种场面，纪念下。</p><p>但说说心里话。</p><p>既开心又难过。</p><p>开心是因为能获得那么多赞，刷新一下手机就立马十多个赞，太爽太快乐了。</p><p>难过是因为<strong>之前辛辛苦苦花了好长时间写的文章，加一起点赞都不及随便抖机灵的答案。</strong>果然大家还是比较喜欢轻松快乐的东西，学习是反人性的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210412132121144.png"></p><p>那么多赞还发牢骚，这大概就是所谓的得了便宜还卖乖吧哈哈哈哈。</p><p>对，说的就是我这种情况。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006APoFYly1go727k3ckzj30dw0dw41u.jpg"></p><p>一码归一码，虽然几乎没有涨粉，但能得到这么大的流量，总的来说还是很开心的。</p><p>另外想问下，有大佬知道知乎是什么样一个推荐规则吗？我还想看到<code>99+</code>小红点。。。</p><p>还有有什么可以从<code>zhihu</code>回答引流到<code>【g】【zong】【hao】</code> 的小技巧吗？感觉自己这个门外汉白瞎了这波流量。。。。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210413073559386.png"></p><p>最近看了巨人的漫画大结局，很难受，追了8年了，以前每个月等更新，现在突然感觉生活少了点盼头。巨人的结局影响了我写文的速度，但是，下一篇已经在路上了。。。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210413072037873.png"></p><blockquote><p>首发于个人公众号：小白debug<br>原文地址：<a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA</a></p></blockquote><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </li></ul>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>动图图解！既然IP层会分片，为什么TCP层也还要分段？</title>
      <link href="/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/"/>
      <url>/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E7%9B%AE%E5%BD%95.png"></p><h3 id="什么是TCP分段和IP分片"><a href="#什么是TCP分段和IP分片" class="headerlink" title="什么是TCP分段和IP分片"></a>什么是TCP分段和IP分片</h3><p>我们知道网络就像一根管子，而管子吧，就会有粗细。</p><p>一个数据包想从管子的一端到另一端，得过这个管子。<del>（废话）</del></p><p>但数据包的量<strong>有大有小</strong>，想过管子，数据包不能大于这根管子的粗细。</p><p>问题来了，数据包过大时怎么办？</p><span id="more"></span><p>答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%872.png" alt="数据分片"></p><p>回去看下网络分层协议，数据先过传输层，再到网络层。</p><p>这个行为在<strong>传输层和网络层</strong>都有可能发生。</p><p>在传输层（<code>TCP</code>协议）里，叫<strong>分段</strong>。</p><p>在网络层（<code>IP</code>层），叫<strong>分片</strong>。（注意以下提到的IP没有特殊说明的情况下，都是指<strong>IPV4</strong>）</p><p>那么不管是分片还是分段，肯定需要<strong>按照一定的长度</strong>切分。</p><p>在<code>TCP</code>里，这个长度是<code>MSS</code>。</p><p>在<code>IP</code>层里，这个长度是<code>MTU</code>。</p><p>那<strong>MSS和MTU是什么关系</strong>呢？这个在<a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">之前的文章</a>里简单提到过。这里单独拿出来。</p><h3 id="MSS是什么"><a href="#MSS是什么" class="headerlink" title="MSS是什么"></a>MSS是什么</h3><p><strong>MSS：Maximum Segment Size</strong> 。  TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和  TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/MSS%E5%88%86%E5%8C%85.gif" alt="MSS分包"></p><h4 id="如何查看MSS？"><a href="#如何查看MSS？" class="headerlink" title="如何查看MSS？"></a>如何查看MSS？</h4><p>我们都知道TCP三次握手，而<code>MSS</code>会在三次握手的过程中传递给对方，用于通知对端本地最大可以接收的TCP报文数据大小（不包含TCP和IP报文首部）。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%8A%93%E5%8C%85mss.png" alt="抓包mss"></p><p>比如上图中，B将自己的MSS发送给A，建议A在发数据给B的时候，采用<code>MSS=1420</code>进行分段。而B在发数据给A的时候，同样会带上<code>MSS=1372</code>。两者在对比后，会采用<strong>小的</strong>那个值（1372）作为通信的<code>MSS值</code>，这个过程叫<code>MSS协商</code>。</p><blockquote><p> 另外，一般情况下MSS + 20（TCP头）+ 20（IP头）= MTU，上面抓包的图里对应的MTU分别是1372+40 和 1420+40。 同一个路径上，<strong>MTU不一定是对称的</strong>，也就是说A到B和B到A，两条路径上的MTU可以是不同的，对应的MSS也一样。</p></blockquote><h4 id="三次握手中协商了MSS就不会改变了吗？"><a href="#三次握手中协商了MSS就不会改变了吗？" class="headerlink" title="三次握手中协商了MSS就不会改变了吗？"></a>三次握手中协商了MSS就不会改变了吗？</h4><p>当然不是，每次执行TCP发送消息的函数时，会重新计算一次MSS，再进行分段操作。</p><h4 id="对端不传MSS会怎么样？"><a href="#对端不传MSS会怎么样？" class="headerlink" title="对端不传MSS会怎么样？"></a>对端不传MSS会怎么样？</h4><p>我们再看TCP的报头。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B45.png" alt="TCP报头"></p><p>其实MSS是作为可选项引入的，只不过一般情况下MSS都会传，但是万一遇到了哪台机器的实现上比较调皮，<strong>不传MSS</strong>这个可选项。那对端该怎么办？</p><p><strong>如果没有接收到对端TCP的MSS，本端TCP默认采用MSS=536Byte</strong>。</p><p>那为什么会是<code>536</code>？ </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">536（data） + 20（tcp头）+20（ip头）= 576Byte</span><br></pre></td></tr></table></figure><p>前面提到了IP会切片，那会切片，也就会重组，而这个576正好是 IP 最小重组缓冲区的大小。</p><h3 id="MTU是什么"><a href="#MTU是什么" class="headerlink" title="MTU是什么"></a>MTU是什么</h3><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。 其实这个是由<strong>数据链路层</strong>提供，为了告诉上层IP层，自己的传输能力是多大。IP层就会根据它进行数据包切分。一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= <code>1500</code> byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有 &gt; <code>1500</code> byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的IP包里加上各种信息。比如这个分片在原来的IP包里的偏移offset。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/mtu%E5%88%86%E5%8C%85.gif" alt="MTU分包"></p><h4 id="如何查看MTU"><a href="#如何查看MTU" class="headerlink" title="如何查看MTU"></a>如何查看MTU</h4><p>在<code>mac</code>控制台输入 <code>ifconfig</code>命令，可以看到MTU的值为多大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ipconfig</span></span><br><span class="line">lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384</span><br><span class="line">...</span><br><span class="line">en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500</span><br><span class="line">...</span><br><span class="line">p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>可以看到这上面有好几个<strong>MTU</strong>，可以简单理解为每个网卡的处理能力不同，所以对应的MTU也不同。当然这个值是可以修改的，但不在今天的讨论范畴内，不再展开。</p><p>在一台机器的应用层到这台机器的网卡，<strong>这条链路上</strong>，基本上可以保证，<code>MSS &lt; MTU</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="MSS和MTU的区别"></p><h4 id="为什么MTU一般是1500"><a href="#为什么MTU一般是1500" class="headerlink" title="为什么MTU一般是1500"></a>为什么MTU一般是1500</h4><p>这其实是由传输效率决定的。首先，虽然我们平时用的网络感觉挺稳定的，但其实这是因为TCP在背地里做了各种重传等保证了传输的可靠，其实背地里线路是动不动就丢包的，而越大的包，发生丢包的概率就越大。</p><p>那是不是包越小就越好？也不是</p><p>但是如果选择一个比较小的长度，假设选择<code>MTU</code>为<code>300Byte</code>，<code>TCP payload = 300 - IP Header - TCP Header = 300 - 20 - 20 = 260 byte</code>。那有效传输效率<code>= 260 / 300 = 86%</code></p><p>而如果以太网长度为1500，那有效传输效率<code>= 1460 / 1500 = 96%</code> ，显然比 <code>86%</code> 高多了。</p><p>所以，包越小越不容易丢包，包越大，传输效率又越高，因此权衡之下，选了<code>1500</code>。</p><h3 id="为什么IP层会分片，TCP还要分段"><a href="#为什么IP层会分片，TCP还要分段" class="headerlink" title="为什么IP层会分片，TCP还要分段"></a>为什么IP层会分片，TCP还要分段</h3><p>由于本身IP层就会做分片这件事情。<strong>就算TCP不分段</strong>，到了IP层，数据包也会被分片，数据也能<strong>正常传输</strong>。</p><p>既然网络层就会分片了，那么TCP为什么还要分段？是不是有些多此一举？</p><p>假设有一份数据，较大，且在TCP层不分段，如果这份数据在发送的过程中出现<strong>丢包</strong>现象，TCP会发生重传，那么重传的就是这一大份数据（虽然IP层会把数据切分为MTU长度的N多个小包，但是TCP重传的单位却是那一大份数据）。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E5%88%86%E7%89%871.gif" alt="假设TCP不分段"></p><p>如果TCP把这份数据，分段为N个小于等于MSS长度的数据包，到了IP层后加上IP头和TCP头，还是小于MTU，那么IP层也不会再进行分包。此时在传输路上发生了丢包，那么TCP重传的时候也只是重传那一小部分的MSS段。效率会比TCP不分段时更高。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/TCP%E5%88%86%E6%AE%B5.gif" alt="假设TCP分段"></p><p>类似的，传输层除了TCP外，还有UDP协议，但UDP本身不会分段，所以当数据量较大时，只能交给IP层去分片，然后传到底层进行发送。</p><p>也就是说，正常情况下，在一台机器的传输层到网络层<strong>这条链路上</strong>，如果传输层对数据做了分段，那么IP层就不会再分片。如果传输层没分段，那么IP层就可能会进行分片。</p><p>说白了，<strong>数据在TCP分段，就是为了在IP层不需要分片，同时发生重传的时候只重传分段后的小份数据</strong>。</p><h3 id="TCP分段了，IP层就一定不会分片了吗"><a href="#TCP分段了，IP层就一定不会分片了吗" class="headerlink" title="TCP分段了，IP层就一定不会分片了吗"></a>TCP分段了，IP层就一定不会分片了吗</h3><p>上面提到了，在发送端，TCP分段后，IP层就不会再分片了。</p><p>但是整个传输链路中，可能还会有其他网络层设备，而这些设备的MTU可能小于发送端的MTU。此时虽然数据包在发送端已经<strong>分段</strong>过了，但是在IP层就还会再分片一次。</p><p>如果链路上还有设备有<strong>更小的MTU</strong>，那么还会再分片，最后所有的分片都会在<strong>接收端</strong>处进行组装。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/IP%E5%88%86%E7%89%87%E5%86%8D%E5%88%86%E7%89%87.gif" alt="IP分片再分片"></p><p>因此，就算TCP分段过后，在链路上的其他节点的IP层也是有可能再分片的，而且哪怕数据被第一次IP分片过了，也是有可能被其他机器的IP层进行二次、三次、四次….分片的。</p><h3 id="IP层怎么做到不分片"><a href="#IP层怎么做到不分片" class="headerlink" title="IP层怎么做到不分片"></a>IP层怎么做到不分片</h3><p>上面提到的IP层在传输过程中<strong>因为各个节点间MTU</strong>可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。那么IP层是否可以做到不分片？</p><p>如果有办法知道整个链路上，最小的MTU是多少，并且以最小MTU长度发送数据，那么不管数据传到哪个节点，都不会发生分片。</p><p>整个链路上，<strong>最小的MTU，就叫PMTU</strong>（path MTU）。</p><p>有一个<strong>获得这个PMTU的方法，叫 Path MTU Discovery</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$cat</span> /proc/sys/net/ipv4/ip_no_pmtu_disc</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>默认为<code>0</code>，意思是开启PMTU发现的功能。现在一般机器上都是开启的状态。</p><p>原理比较简单，首先我们先回去看下IP的数据报头。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ip%E6%8A%A5%E5%A4%B4DF1.png" alt="IP报头DF"></p><p>这里有个标红的标志位<code>DF</code>（Don’t Fragment），当它置为1，意味着这个IP报文不分片。</p><p>当链路上某个路由器，收到了这个报文，当IP报文长度大于路由器的MTU时，路由器会看下这个IP报文的<code>DF</code></p><ul><li>如果为<code>0</code>（允许分片），就会分片并把分片后的数据传到下一个路由器</li><li>如果为<code>1</code>，就会把数据丢弃，同时返回一个ICMP包给发送端，并告诉它 <del>“达咩!”</del> 数据不可达，需要分片，同时带上当前机器的MTU</li></ul><p>理解了上面的原理后，我们再看下PMTU发现是怎么实现的。</p><ul><li>应用通过TCP正常发送消息，传输层<strong>TCP分段</strong>后，到<strong>网络层</strong>加上IP头，<strong>DF置为1</strong>，消息再到更底层执行发送</li><li>此时链路上有台<strong>路由器</strong>由于各种原因<strong>MTU变小了</strong></li><li>IP消息到这台路由器了，路由器发现消息长度大于自己的MTU，且消息自带DF不让分片。就把消息丢弃。同时返回一个<code>ICMP</code>错误给发送端，同时带上自己的<code>MTU</code>。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%8E%B7%E5%BE%97pmtu.gif" alt="获得pmtu"></p><ul><li>发送端收到这个ICMP消息，会更新自己的MTU，同时记录到一个<strong>PMTU表</strong>中。</li><li>因为TCP的可靠性，会尝试重传这个消息，同时以这个新MTU值计算出MSS进行分段，此时新的IP包就可以顺利被刚才的路由器转发。</li><li>如果路径上还有更小的MTU的路由器，那上面发生的事情还会再发生一次。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%8E%B7%E5%BE%97pmtu%E5%90%8E%E7%9A%84TCP%E9%87%8D%E4%BC%A0.gif" alt="获得pmtu后的TCP重传"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>数据在TCP分段，在IP层就不需要分片，同时发生重传的时候只重传分段后的小份数据</p></li><li><p>TCP分段时使用MSS，IP分片时使用MTU</p></li><li><p>MSS是通过MTU计算得到，在三次握手和发送消息时都有可能产生变化。</p></li><li><p>IP分片是<strong>不得已</strong>的行为，尽量不在IP层分片，尤其是链路上中间设备的IP分片。因此，在IPv6中已经禁止中间节点设备对IP报文进行分片，分片只能在链路的最开头和最末尾两端进行。</p></li><li><p>建立连接后，路径上节点的MTU值改变时，可以通过PMTU发现更新发送端MTU的值。这种情况下，PMTU发现通过浪费N次发送机会来换取的PMTU，TCP因为有重传可以保证可靠性，在UDP就相当于消息直接丢了。</p></li></ul><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/O_GPwa71zqcpIkNdlkWYnQ">动图图解！GMP模型里为什么要有P？背后的原因让人暖心</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/UBiZp2Bfs7z1_mJ-JnOT1Q">i/o timeout，希望你不要踩到这个net/http包的坑</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </p></li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>画动图，太难了。。。看完求个赞，下次图会动得更凶。</p><p>欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210513085507280.png"></p><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>i/o timeout ， 希望你不要踩到这个net/http包的坑</title>
      <link href="/2021/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/io_timeout%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E4%B8%8D%E8%A6%81%E8%B8%A9%E5%88%B0%E8%BF%99%E4%B8%AAhttp%E5%8C%85%E7%9A%84%E5%9D%91/"/>
      <url>/2021/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/io_timeout%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E4%B8%8D%E8%A6%81%E8%B8%A9%E5%88%B0%E8%BF%99%E4%B8%AAhttp%E5%8C%85%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><br><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>我们来看一段日常代码。</p><span id="more"></span><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">body := bytes.NewReader(data)</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">Transport: tr,</span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>做的事情，比较简单，就是循环去请求 <code>http://www.baidu.com/</code> , 然后等待响应。</p><p><strong>看上去貌似没啥问题吧。</strong></p><p>代码跑起来，也<strong>确实能正常收发消息</strong>。</p><p>但是这段代码跑<strong>一段时间</strong>，就会出现 <code>i/o timeout</code> 的报错。</p><br><p>这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，我这边对代码做了简化。</p><p>实际生产中发生的<strong>现象</strong>是，<code>golang</code>服务在发起<code>http</code>调用时，虽然<code>http.Transport</code>设置了<code>3s</code>超时，会偶发出现<code>i/o timeout</code>的报错。</p><p>但是查看下游服务的时候，发现下游服务其实 <code>100ms</code> 就已经返回了。</p><br><h3 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90.png" alt="五层网络协议对应的消息体变化分析"></p><p>就很奇怪了，明明服务端显示处理耗时才<code>100ms</code>，且客户端超时设的是<code>3s</code>, 怎么就出现超时报错 <code>i/o timeout</code> 呢？ </p><br><p>这里推测有两个可能。</p><ul><li><p>因为服务端打印的日志其实只是<strong>服务端应用层</strong>打印的日志。但客户端应用层发出数据后，中间还经过<strong>客户端的传输层，网络层，数据链路层和物理层</strong>，再经过<strong>服务端的物理层，数据链路层，网络层，传输层到服务端的应用层</strong>。服务端应用层处耗时<strong>100ms</strong>，再原路返回。那剩下的<code>3s-100ms</code><strong>可能是</strong>耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。</p></li><li><p>网络没问题，客户端到服务端链路整个收发流程大概耗时就是<code>100ms</code>左右。客户端处理逻辑问题导致超时。</p><br></li></ul><p><strong>一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了</strong>，不死心就抓个包看下。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/wiresharkcp2.png" alt="抓包结果"></p><p>分析下，从刚开始三次握手（<strong>画了红框的地方</strong>）。</p><p>到最后出现超时报错 <code>i/o timeout</code> （<strong>画了蓝框的地方</strong>）。</p><p>从<code>time</code>那一列从<code>7</code>到<code>10</code>，确实间隔<code>3s</code>。而且看<strong>右下角</strong>的蓝框，是<code>51169</code>端口发到<code>80</code>端口的一次<code>Reset</code>连接。</p><p><code>80</code>端口是服务端的端口。换句话说就是客户端<code>3s</code>超时<strong>主动</strong>断开链接的。</p><p>但是再仔细看下<strong>第一行</strong>三次握手到<strong>最后</strong>客户端超时主动断开连接的中间，其实有<strong>非常多次HTTP请求</strong>。</p><p>回去看代码设置超时的方式。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是说，这里的<code>3s</code>超时，其实是在<strong>建立连接之后</strong>开始算的，而不是<strong>单次调用开始算的</strong>超时。</p><p>看注释里写的是</p><blockquote><p> SetDeadline sets the read and write deadlines associated with the <strong>connection</strong>.</p></blockquote><br><br><h3 id="超时原因"><a href="#超时原因" class="headerlink" title="超时原因"></a>超时原因</h3><p>大家知道<code>HTTP</code>是应用层协议，传输层用的是<code>TCP</code>协议。</p><p>HTTP协议从<code>1.0</code>以前，默认用的是<code>短连接</code>，每次发起请求都会建立TCP连接。收发数据。然后断开连接。</p><p>TCP连接每次都是三次握手。每次断开都要四次挥手。</p><p>其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。</p><p>于是乎，HTTP协议从<code>1.1</code>之后就默认使用<code>长连接</code>。具体相关信息可以看之前的 <a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">这篇文章</a>。</p><p>那么<code>golang标准库</code>里也兼容这种实现。</p><p>通过建立一个连接池，针对<code>每个域名</code>建立一个TCP长连接，比如<code>http://baidu.com</code>和<code>http://golang.com</code> 就是两个不同的域名。</p><p>第一次访问<code>http://baidu.com</code> 域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问<code>http://baidu.com</code> 的时候会重新从连接池里把这个连接捞出来<code>复用</code>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%A4%8D%E7%94%A8%E9%95%BF%E8%BF%9E%E6%8E%A5.png" alt="复用长连接"></p><br><blockquote><p>插个题外话：这也解释了之前<a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">这篇文章</a>里最后的疑问，为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应<strong>一个读goroutine和一个写goroutine</strong>。正因为是同一个域名，所以最后才会泄漏<code>3</code>个goroutine，如果不同域名的话，那就会泄漏 <code>1+2*N</code> 个协程，<code>N</code>就是域名数。</p></blockquote><br><p>假设第一次请求要<code>100ms</code>，每次请求完<code>http://baidu.com</code> 后都<strong>放入</strong>连接池中，下次继续复用，重复<code>29</code>次，耗时<code>2900ms</code>。</p><p>第<code>30</code>次请求的时候，连接从建立开始到服务返回前就已经用了<code>3000ms</code>，刚好到设置的<strong>3s</strong>超时阈值，那么此时客户端就会报超时 <code>i/o timeout</code> 。</p><p>虽然这时候服务端其实才花了<code>100ms</code>，但耐不住前面<code>29次</code>加起来的耗时已经很长。</p><p>也就是说只要通过 <code>http.Transport</code> 设置了 <code>err = conn.SetDeadline(time.Now().Add(time.Second * 3)) </code>，并且你用了<strong>长连接</strong>，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，你的程序会报超时错误。</p><h3 id="正确姿势"><a href="#正确姿势" class="headerlink" title="正确姿势"></a>正确姿势</h3><p>原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。</p><p>另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。</p><p>基于这两点，改一下代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;bytes&quot;</span></span><br><span class="line"><span class="string">&quot;encoding/json&quot;</span></span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tr *http.Transport</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">tr = &amp;http.Transport&#123;</span><br><span class="line">MaxIdleConns: <span class="number">100</span>,</span><br><span class="line"><span class="comment">// 下面的代码被干掉了</span></span><br><span class="line"><span class="comment">//Dial: func(netw, addr string) (net.Conn, error) &#123;</span></span><br><span class="line"><span class="comment">//conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return nil, err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时</span></span><br><span class="line"><span class="comment">//if err != nil &#123;</span></span><br><span class="line"><span class="comment">//return nil, err</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//return conn, nil</span></span><br><span class="line"><span class="comment">//&#125;,</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">data, err := json.Marshal(m)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">body := bytes.NewReader(data)</span><br><span class="line">req, _ := http.NewRequest(<span class="string">&quot;Get&quot;</span>, url, body)</span><br><span class="line">req.Header.Add(<span class="string">&quot;content-type&quot;</span>, <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line"></span><br><span class="line">client := &amp;http.Client&#123;</span><br><span class="line">Transport: tr,</span><br><span class="line">Timeout: <span class="number">3</span>*time.Second,  <span class="comment">// 超时加在这里，是每次调用的超时</span></span><br><span class="line">&#125;</span><br><span class="line">res, err := client.Do(req) </span><br><span class="line"><span class="keyword">if</span> res != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">defer</span> res.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line">resBody, err := ioutil.ReadAll(res.Body)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> resBody, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">_, err := Get(<span class="string">&quot;http://www.baidu.com/&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>看注释会发现，改动的点有两个</p><ul><li><p><code>http.Transport</code>里的建立连接时的一些超时设置干掉了。</p></li><li><p>在发起http请求的时候会场景<code>http.Client</code>，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释</p><blockquote><p>Timeout specifies a time limit for <strong>requests</strong> made by this Client.</p></blockquote></li></ul><p>到这里，代码就改好了，实际生产中问题也就解决了。</p><p>实例代码里，如果拿去跑的话，其实还会下面的错</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Get http:<span class="comment">//www.baidu.com/: EOF</span></span><br></pre></td></tr></table></figure><p>这个是因为调用得太猛了，<code>http://www.baidu.com</code> 那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，<strong>毕竟每个人都像这么搞，服务器是会炸的</strong>。。。</p><p>解决方案很简单，每次HTTP调用中间加个<code>sleep</code>间隔时间就好。</p><br><p>到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。对读源码不感兴趣的朋友们可以不用接着往下看，直接拉到文章底部<strong>右下角</strong>，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p><strong>用的go版本是1.12.7</strong>。</p><p>从发起一个网络请求开始跟。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">res, err := client.Do(req)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">Do</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.do(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> resp, didTimeout, err = c.send(req, deadline); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...    </span></span><br><span class="line">resp, err = rt.RoundTrip(req)</span><br><span class="line"> <span class="comment">// ...  </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 从这里进入 RoundTrip 逻辑</span></span><br><span class="line">/src/net/http/roundtrip.<span class="keyword">go</span>: <span class="number">16</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> t.roundTrip(req)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span> <span class="params">(*Response, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// 尝试去获取一个空闲连接，用于发起 http 连接</span></span><br><span class="line">  pconn, err := t.getConn(treq, cm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重点关注这个函数，返回是一个长连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// 省略了大量逻辑，只关注下面两点</span></span><br><span class="line"><span class="comment">// 有空闲连接就返回</span></span><br><span class="line">pc := &lt;-t.getIdleConnCh(cm)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 没有创建连接</span></span><br><span class="line">  pc, err := t.dialConn(ctx, cm)</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。</p><p>最后一个上面的代码里有个 <code>getConn</code> 方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。</p><ul><li><p>如果有空闲连接，就拿空闲连接</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">810</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getIdleConnCh</span><span class="params">(cm connectMethod)</span> <span class="title">chan</span> *<span class="title">persistConn</span></span> &#123;</span><br><span class="line">   <span class="comment">// 返回放空闲连接的chan</span></span><br><span class="line">   ch, ok := t.idleConnCh[key]</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>没有空闲连接，就创建长连接。</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">1357</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  conn, err := t.dial(ctx, <span class="string">&quot;tcp&quot;</span>, cm.addr())</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">go</span> pconn.readLoop()</span><br><span class="line">  <span class="keyword">go</span> pconn.writeLoop()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当<strong>第一次</strong>发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个<strong>读goroutine和一个写goroutine</strong>。 </p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%AF%BB%E5%86%99%E5%8D%8F%E7%A8%8B.png" alt="读写协程"></p><p>注意上面代码里的<code>t.dial(ctx, &quot;tcp&quot;, cm.addr())</code>，如果像文章开头那样设置了 <code>http.Transport</code>的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Dial: <span class="function"><span class="keyword">func</span><span class="params">(netw, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">   conn, err := net.DialTimeout(netw, addr, time.Second*<span class="number">2</span>) <span class="comment">//设置建立连接超时</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   err = conn.SetDeadline(time.Now().Add(time.Second * <span class="number">3</span>)) <span class="comment">//设置发送接受数据超时</span></span><br><span class="line">   <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> conn, <span class="literal">nil</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>那么这里就会在下面的<code>dial</code>里被执行到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dial</span><span class="params">(ctx context.Context, network, addr <span class="keyword">string</span>)</span> <span class="params">(net.Conn, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">  c, err := t.Dial(network, addr)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面调用的设置超时，会执行到</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">/src/net/net.<span class="keyword">go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">SetDeadline</span><span class="params">(t time.Time)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">c.fd.SetDeadline(t)</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setDeadlineImpl</span><span class="params">(fd *FD, t time.Time, mode <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadline</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollSetDeadline</span><span class="params">(pd *pollDesc, d <span class="keyword">int64</span>, mode <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 设置一个定时器事件</span></span><br><span class="line">  rtf = netpollDeadline</span><br><span class="line"><span class="comment">// 并将事件注册到定时器里</span></span><br><span class="line">  modtimer(&amp;pd.rt, pd.rd, <span class="number">0</span>, rtf, pd, pd.rseq)</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个<strong>定时器事件</strong>，假设时间设了<code>3s</code>，那么这个事件会在<code>3s</code>后发生，然后执行注册事件的逻辑。而这个注册事件就是<code>netpollDeadline</code>。 <strong>注意这个<code>netpollDeadline</code>，待会会提到。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%AF%BB%E5%86%99%E5%8D%8F%E7%A8%8B%E5%AE%9A%E6%97%B6%E5%99%A8%E4%BA%8B%E4%BB%B6.png" alt="读写协程定时器事件"></p><p>设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。</p><p>直到<code>3s</code>过后，这时候看<code>读goroutine</code>，会等待网络数据返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/src/net/http/tansport.<span class="keyword">go</span>:<span class="number">1642</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">for</span> alive &#123;</span><br><span class="line">_, err := pc.br.Peek(<span class="number">1</span>)  <span class="comment">// 阻塞读取服务端返回的数据</span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是一直跟代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">src/bufio/bufio.<span class="keyword">go</span>: <span class="number">129</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">Peek</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   b.fill() </span><br><span class="line">   <span class="comment">// ...   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Reader)</span> <span class="title">fill</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err := b.rd.Read(b.buf[b.w:])</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/net/http/transport.<span class="keyword">go</span>: <span class="number">1517</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err = pc.conn.Read(p)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// /src/net/net.go: 173</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *conn)</span> <span class="title">Read</span><span class="params">(b []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">n, err := c.fd.Read(b)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *netFD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">n, err = fd.pfd.Read(p)</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/internal/poll/fd_unix.<span class="keyword">go</span>: </span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(fd *FD)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(<span class="keyword">int</span>, error)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">  <span class="keyword">if</span> err = fd.pd.waitRead(fd.isFile); err == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">waitRead</span><span class="params">(isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> pd.wait(<span class="string">&#x27;r&#x27;</span>, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pd *pollDesc)</span> <span class="title">wait</span><span class="params">(mode <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  res := runtime_pollWait(pd.runtimeCtx, mode)</span><br><span class="line"><span class="keyword">return</span> convertErr(res, isFile)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>直到跟到 <strong>runtime_pollWait</strong>，这个可以简单认为是<strong>等待服务端数据返回</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWait</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">poll_runtime_pollWait</span><span class="params">(pd *pollDesc, mode <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.如果网络正常返回数据就跳出</span></span><br><span class="line">  <span class="keyword">for</span> !netpollblock(pd, <span class="keyword">int32</span>(mode), <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 2.如果有出错情况也跳出</span></span><br><span class="line">err = netpollcheckerr(pd, <span class="keyword">int32</span>(mode))</span><br><span class="line"><span class="keyword">if</span> err != <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整条链路跟下来，就是会一直等待数据，等待的结果只有两个</p><ul><li>有可以读的数据 </li><li>出现报错</li></ul><p>这里面的<strong>报错</strong>，又有那么两种</p><ul><li>连接关闭</li><li>超时</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollcheckerr</span><span class="params">(pd *pollDesc, mode <span class="keyword">int32</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> pd.closing &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> <span class="comment">// errClosing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中提到的<code>超时</code>，就是指这里面返回的<code>数字2</code>，会通过下面的函数，转化为 <code>ErrTimeout</code>， 而 <code>ErrTimeout.Error()</code> 其实就是 <code>i/o timeout</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertErr</span><span class="params">(res <span class="keyword">int</span>, isFile <span class="keyword">bool</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> res &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line"><span class="keyword">return</span> errClosing(isFile)</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line"><span class="keyword">return</span> ErrTimeout <span class="comment">// ErrTimeout.Error() 就是 &quot;i/o timeout&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">println</span>(<span class="string">&quot;unreachable: &quot;</span>, res)</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么问题来了。上面返回的超时错误，也就是<strong>返回2的时候的条件是怎么满足的</strong>？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mode == <span class="string">&#x27;r&#x27;</span> &amp;&amp; pd.rd &lt; <span class="number">0</span>) || (mode == <span class="string">&#x27;w&#x27;</span> &amp;&amp; pd.wd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span> <span class="comment">// errTimeout</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还记得刚刚提到的 <code>netpollDeadline</code>吗？</p><p>这里面放了定时器<code>3s</code>到点时执行的逻辑。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">timerproc</span><span class="params">(tb *timersBucket)</span></span> &#123;</span><br><span class="line"><span class="comment">// 计时器到设定时间点了，触发之前注册函数</span></span><br><span class="line">f(arg, seq) <span class="comment">// 之前注册的是 netpollDeadline</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpollDeadline</span><span class="params">(arg <span class="keyword">interface</span>&#123;&#125;, seq <span class="keyword">uintptr</span>)</span></span> &#123;</span><br><span class="line">netpolldeadlineimpl(arg.(*pollDesc), seq, <span class="literal">true</span>, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/src/runtime/netpoll.<span class="keyword">go</span>: <span class="number">428</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">netpolldeadlineimpl</span><span class="params">(pd *pollDesc, seq <span class="keyword">uintptr</span>, read, write <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> read &#123;</span><br><span class="line">pd.rd = <span class="number">-1</span></span><br><span class="line">rg = netpollunblock(pd, <span class="string">&#x27;r&#x27;</span>, <span class="literal">false</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会设置<code>pd.rd=-1</code>，是指 <code>poller descriptor.read deadline</code> ，含义<strong>网络轮询器文件描述符</strong>的<strong>读超时时间</strong>， 我们知道在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的<strong>socket</strong>。</p><p>这时候再回去看<strong>发生超时的条件</strong>就是<code>if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0) </code>。</p><p>至此。我们的代码里就收到了 <code>io timeout</code> 的报错。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>不要在 <code>http.Transport</code>中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名 <code>io timeout</code>报错。</p></li><li><p>请求的超时在创建<code>client</code>里设置。</p></li></ul><p>如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（<strong>点两下</strong>）支持一下。（<strong>疯狂暗示，拜托拜托，这对我真的很重要！</strong>）</p><p>我是小白，我们下期见。</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><a href="https://mp.weixin.qq.com/s/btksE3RUxtioSYrYpChEeQ">妙啊! 程序猿的第一本互联网黑话指南</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA">我感觉，我可能要拿图灵奖了。。。</a> </li><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:<strong>【小白debug】</strong><br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>妙啊！程序猿的第一本互联网黑话指南</title>
      <link href="/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A6%99%E5%95%8A%EF%BC%81%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D%E6%8C%87%E5%8D%97/"/>
      <url>/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A6%99%E5%95%8A%EF%BC%81%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61617799367126.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><br><p>很烦，小侄子最近不给我打电话了。</p><p>放下作为叔叔的面子，拨通电话。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/3f5e9f7e95a2cc21.jpeg" alt="打电话"></p><p>他说，他最近很烦。</p><p>我以为他长大了，谈恋爱了。</p><p>他说，最近他们学校，换了个校长。</p><p>喜欢在早上升国旗之后发表演讲。</p><p>“发表演讲挺好的啊，德智体美。”</p><p>他说他听不懂。比如校长今天早上提到说：</p><p>“我们需要大力推进新型教育<strong>场景</strong>，尝试建立一些新的教学<strong>模型</strong>，用心打磨<strong>细节</strong>。</p><p>并重点关注其他教育形式的<strong>可能性</strong>。利用传统教育形式去<strong>驱动</strong>新型教育形式，打通<strong>底层逻辑</strong>，形成<strong>闭环</strong>。用传统教育理念<strong>赋能</strong>新型教育场景。让传统和新型教育形式作为一整套<strong>组合拳</strong>，加速学生更好更快的<strong>发展</strong>。”</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/89254ec8063c5fc9.jpeg"></p><p>好家伙，这么长的一句话，<strong>信息量竟然为0</strong>。</p><p>再仔细一想。</p><p>心里一惊，原来是同行啊，这老哥，一定是互联网出来的。</p><p>光听到<strong>赋能</strong>这个词，我就知道是哪个厂出来的了。</p><p>我劝小侄子，这个想听懂，得有<strong>一定的互联网阅历</strong>才行啊。</p><p>小侄子却表示：“叔叔，你不是在互联网公司上班吗？你教教我吧”</p><p>不行，这对于年幼的他，还太早了。</p><p>直到他告诉我，“我们班长现在已经学会这种超酷的说话方式了，现在班里的女生都超爱听他说话”</p><p>这？？？</p><p>不，这能忍？就算是这样的我，也有想要守护的东西。我必须教会。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210404153251619.png"></p><p>那晚我打了3小时视频电话，畅快淋漓，让我差点忘了手机还欠费47块这件事。</p><br><p>三天后，侄子跟我说，好是挺好的，就是有点废纸，现在班里的女同学都喜欢找他要签名。</p><p>嗯，不是很环保。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210404153859729.png"></p><p>考虑到身边还有很多连互联网黑话都不会说的胖友们，在这里简单写一份程序员必知必会的<strong>互联网黑话指南</strong>。赠与有缘人。</p><p>诚实质朴如你，实在无法低下高傲的头颅的话，希望你也能听懂别人在不讲人话的时候，到底背后是几层意思。</p><p>我不允许我的胖友们听不懂！更不允许你们被蒙在鼓里！</p><br><br><p>领导开口闭口都是商业模式，闭环？整个会听下来，就记住了<strong>赋能，抓住，推进，深入</strong>这些词？</p><p>产品让你跟她<strong>对齐</strong>一下？</p><p>其他部门同事说再不马上处理某个问题，她就要<strong>上升</strong>了，而这时候你以为她是要<strong>上天</strong>？</p><p>hr跟你说公司扁平化管理，一年有两次加薪机会的时候，你只听到了<strong>加薪</strong>，却听漏了这只是<strong>机会</strong>？</p><br><p>看完下面，你会对上面的场景有不一样的认识。</p><br><p>首先对于<strong>国内互联网大厂</strong>，我们盘一下常说的一些话。</p><p>比如<strong>抓手</strong>，是指手可以抓得到的地方，一般是指项目的<strong>切入点</strong>。</p><p>当提到项目需要努力<strong>寻找抓手</strong>的时候，说明项目现在比较<strong>蒙圈</strong>，还没有好的切入点，还在各种试错。</p><p>划重点了，项目怎么做都没想清楚，建议各位老哥 <code>LeetCode</code> 刷起来吧。</p><br><p>当你在职级答辩的时候，也可能被问到某件事情的<strong>抓手</strong>是什么。</p><p>一般是问你这个问题的切入点在哪，从哪里开始解决，</p><p>一般是要你说下从现象到本质的判断过程。</p><p>比如，机器内存暴涨导致报警，这时候现象切入点是某个进程，再定位代码更新部分，最后定位问题。</p><br><p>而一般项目的<strong>抓手</strong>都是从某个<strong>垂直领域</strong>里的<strong>细分领域</strong>里发力，</p><p>垂直领域和细分领域的<strong>区别</strong>大概可以理解为编程和用<code>golang</code>编程之间的区别。</p><br><p>领域不够垂直，不够细分，大概就是说，啥都干了点，不够专，不够精。</p><br><p><strong>赋能</strong>是个啥，第一次接触这个词的时候，我还去搜了一下定义</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210407121032572.png" alt="赋能的定义"></p><p>好家伙，竟然拿<strong>一堆</strong>别人看不懂的词去解释<strong>一个</strong>别人看不懂的词，<strong>属实让人意外了</strong>。</p><p>后来搞明白了。说白了，别人没有某个东西，而你有，你<strong>主动</strong>找他跟你合作。重点在于<strong>主动</strong>这个词，有<strong>忽悠</strong>内味了。</p><br><p>还有，如果运营产品们喜欢探讨项目的<strong>盈利模式</strong>，你就要知道，他们其实心里也没底这玩意到底能不能赚钱。如果赚钱了，就会找出<strong>各种理由</strong>解释“这个项目为什么能赚钱”，这就是所谓的各种<strong>方法论</strong>了。</p><p>当然，如果项目赚钱了，又不给你发钱，就可以说是<strong>延迟满足感</strong>。</p><br><p>类似的不讲人话的词还有很多。</p><p>开个会，叫<strong>对齐</strong>一下。</p><p>找你领导，叫<strong>上升</strong>。</p><p>最容易<code>pian</code>到投资的领域，叫<strong>风口</strong>。</p><p>同时用多种方法去搞钱，就叫<strong>组合拳</strong>。</p><p>跟别的公司产生了合作，那就出现了<strong>生态</strong>，合作的公司多了，就叫<strong>生态链</strong>。</p><p>生态链产生<strong>闭环</strong>，这里就划重点了，意思是<strong>开始赚钱</strong>了。</p><p>还有另外一个需要<strong>敲黑板，划重点</strong>的考点。</p><p>当老板提到要向社会<strong>输送人才</strong>，就是要开始解雇咸鱼了。。不管读多少遍，我还是觉得说这话的人是真的厉害，这才是语！言！艺！术！请各位老哥<strong>把牛皮打在公屏上</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/9150e4e5ly1flnjufq3eaj204w05cjra.jpg"></p><p>作为不讲人话的高发场地，面试那张方寸小桌，经常会出现一些让人觉得高深莫测的词语。</p><p>比如当你听到<code>hr</code>介绍公司<strong>弹性工作制</strong>，不打卡，也就是指下班时间不定，也没有加班这一说。</p><p><strong>扁平化管理</strong>，在公司层面可能有各种积极意义。但对你<strong>个人而言</strong>，基本上约等于<strong>一般没有晋升</strong>。</p><p><strong>能独立完成工作任务</strong>，当然就是产品的开发全都你一个人干。</p><br><p>很多时候hr会看着招聘简介上的信息问你问题。</p><p>问你有没有做过<strong>高并发</strong>相关，如果你给机器扩容过，大胆说有。</p><p>用了主备机器，就说是<strong>高可用</strong>。</p><p>用了缓存，那就是<strong>高性能</strong>了。</p><p>用了 <code>Mysql</code>，妥了，<strong>持久化</strong>。</p><p>虽然我很普通，但我很自信。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/415f82b9ly1fy7bddcac0j20c80c90tp.jpg"></p><p>这时候你可能就会产生疑问了，这是不是<strong>国内互联网大厂</strong>才有的通病？</p><p>我去<strong>外企</strong>是不是就好了？</p><br><br><p>那欢迎来到<strong>快乐星球</strong>了。</p><p>上班等电梯的时候，你会听到旁边的 <code>Lucy</code> 端着她的<strong>美式卡布奇诺</strong>很惊讶的对 <code>Emily</code> 说</p><p>“<code>Emiliy</code> 你知道吗？我跟你说，昨天，<code>Alice</code> 他的手机在 <code>meeting</code> 的时候摔得粉粉碎，真的粉粉碎哦”</p><p>“哇哦，<code>what a pity</code>“</p><p>早上，老板会让大家开个 <code>daily meeting</code>。说一下大家今天的 <code>todo list</code>。还有 <code>project</code> 的进展。</p><p>可能这个 <code>project</code> 的 <code>schedule</code> 有些问题，尤其是<code>buffer</code>不多。另外，<code>cost</code>也偏高。</p><p>项目组没法 <code>confirm</code> 手上的 <code>resource</code> 能完全 <code>take</code> 得了。</p><p><code>anyway</code>，我们可以先 <code>argue</code> 一下，再 <code>follow up</code> 最终的 <code>output</code>，先 <code>run</code> 起来，看<code>work</code> 不 <code>work</code>。</p><p><code>more importantly</code> ，我们要尝试 <code>cover</code> 掉所有的 <code>difficulty</code>。</p><p>瞧瞧，瞬间觉得抓手闭环<strong>亲切了许多</strong>。</p><p>在这里我要<strong>正能量</strong>一波，否则对不起我这全日制本科的学历。</p><p>本来一些类似<code>hr</code>，<code>kindle</code>专有名词用英语，可以提升沟通效率，但是大量在不必要的场景下用这些中英文混杂的话，真的让人难受。</p><p>沟通，最 <code>important</code> 的是 <code>efficiency</code>，<code>understand</code>？ </p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/CUKEOz4pHnNw4KZUEH9P0-P1JVVY9Atf1pUFZcdI1EdPGrlfX02981wq2nhcibqbIMlzBL6FVIRpw4lKrJkz_WOPa7t6ivga2L75aav9VwWyh6Pdeq2CsP_nGth8xjSv6ggZ7vFYU-r-ZtZgog52dryw.jpeg"></p><p>以前在网上看到过一个话题叫<strong>我想一巴掌扇si那个中英夹杂讲话的朋友！</strong></p><p>当初年轻，高低也想说上那么两句。</p><p>现在成熟了，只会努力克制不要拿<strong>百宝袋</strong>里的<strong>四次元大嘴巴子</strong>扇人。</p><p>让更不成熟的年轻人去扇吧，<strong>要带响的</strong>哦。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/a9cf8ef6ly1fm3yy1ks5bj205e05iaad.jpg"></p><br><br><p><strong>国内的大厂和外企</strong>都不爱讲人话？</p><p>那我去<strong>小厂</strong>，总归可以了吧？</p><br><br><p><strong>小了，</strong></p><p><strong>格局小了。</strong></p><br><br><br><br><br><p>你忘了大厂给社会<strong>输送的人才</strong>了吗？</p><p>你猜他们都去哪了？</p><br><br><p>还是没学会怎么说黑话？</p><p>那就用数量堆叠的方式，让人在无数莫名其妙的<strong>动词名词形容词</strong>下沦陷。</p><p>让他一时之间眼花缭乱，抓不住任何重点。</p><p>反正，某厂周报，就是这么干的。</p><br><br><p>会说话就多说点吧。</p><p>我是小白，我们下期见。</p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></li><li><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </li><li><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li><li><a href="https://mp.weixin.qq.com/s/BJqp72EyEMahxi2XOfSrBQ">硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？</a> </li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核！阿里面试就是不一样！30张图带你搞懂路由器，集线器，交换机，网桥，光猫有啥区别？</title>
      <link href="/2021/04/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%8130%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%EF%BC%81%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E7%BD%91%E6%A1%A5%EF%BC%8C%E5%85%89%E7%8C%AB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
      <url>/2021/04/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%8130%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%EF%BC%81%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E7%BD%91%E6%A1%A5%EF%BC%8C%E5%85%89%E7%8C%AB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210404152601935.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><p>故事就从一个车轱辘说起吧。先来看一个车轱辘。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%BD%A6%E8%BD%AE.jpeg"></p><p>辐条从车轱辘边缘，一直汇聚到 中心的轴，这个轴在英文里叫<strong>hub</strong>。</p><p>而我们今天要讲到的<strong>集线器</strong>，英文里也叫<strong>hub</strong>。</p><p>都叫<strong>hub</strong>，多少有点关系，看下这面这个图大概能明白，其实两者有点像。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/hub%E7%9A%84%E7%94%B1%E6%9D%A52.png" alt="hub的由来"></p><p>大概想表达的意思是，它是汇聚网线的中心，因此就叫<strong>集线器</strong>。</p><p>所以可以理解，大家常逛的 <strong>Github，Docker Hub, 还有P**hub</strong> ，都是为了表达它们是<strong>某类资源的中心</strong>了吧。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/9e02d8ba2ebbd4a5.jpeg"></p><p>那么<strong>集线器是什么</strong>呢？那就要从<strong>电脑是怎么互联的</strong>这个话题说起。</p><p>小学的时候，有一种网吧，它其实是不能上外网的。也就是不能打开度娘，不能搜索资料。</p><p>不能上网的网吧还能叫网吧？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/e18d20c94006dfe0-7524faeb6c8ff751-a0be6febc4215ebabfd22cf9ea5b4be8.jpg"></p><p><strong>能</strong>。虽然不能上外网，但网吧老板可以把很多台机子连起来，实现网吧内互联，形成一个<strong>局域网</strong>（<strong>L</strong>ocal <strong>A</strong>rea <strong>N</strong>etwork，简称<strong>LAN</strong>）。</p><p>网吧内互联之后，就可以放上各种游戏，比如CS，实现网吧内对线。</p><p>这种网吧有种好处，<strong>没有那么多键盘侠</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/5c93b203960156ee.jpeg"></p><p>毕竟你不知道什么时候键着键着，对方就<del>顺着网线</del><strong>找过来了</strong>。</p><p>对战直接<strong>从线上转移到线下</strong>了。</p><p>因此大家打游戏都很和谐，客气，场面十分感人就是了。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/7be71adb6ffe357e.jpeg"></p><p>那么网吧内的电脑是怎么互联呢？</p><h3 id="一根网线互联电脑"><a href="#一根网线互联电脑" class="headerlink" title="一根网线互联电脑"></a>一根网线互联电脑</h3><p>从最简单的场景说起，假设网吧内只有<strong>两台</strong>电脑</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%A4%E5%8F%B0%E7%94%B5%E8%84%91%E4%BA%92%E8%81%94.png" alt="两台电脑互联"></p><p>随便连根网线就能实现互联吗？</p><p><strong>当然不是。</strong></p><p>还记得网络分层吗?</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96.png" alt="网络分层"></p><p>数据如果要进行传输，会从A电脑经过这些网络分层把消息组装好，再到B电脑层层解包。</p><p>网线，只是代替了上面的<strong>灰色部分</strong>，实现<strong>物理层</strong>上互联。</p><p>如果想要两台电脑互联成功，还需要确保每一层所需要的步骤都要做到位，这样数据才能确保正确投送并返回。</p><p>我们自顶向下，从细节开始说一下实现互联需要做什么。</p><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><p>该层的网络功能由应用本身保证。</p><p>假设两台电脑是打算用游戏进行联网，那么该应用层的功能由游戏程序保证。</p><h4 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h4><p>绝大部分游戏用的传输层协议都是TCP，我们可以看下<strong>TCP报头</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B43.png" alt="TCP报头"></p><p>这里面我们需要关注的是<strong>源和目的端口</strong>，这个可以定位到这台电脑上哪个进程在收发数据。</p><p>这两个端口信息一般是游戏内部已经填好。</p><p>AB两台电脑，其中一台作为服务端启动，比如A，起了个<strong>服务器</strong>进程。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210330070559257.png" alt="建立服务器"></p><p>服务器会开放一个<strong>固定的端口</strong>，比如27015。这就是<strong>目的端口</strong>。</p><p>这时候A和B都可以搜索到这个服务器。启动一个<strong>客户端</strong>进程，连接进入A的<strong>服务器</strong>进程。</p><p>而源端口，则由A和B自己生成。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210330071609786.png"></p><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><p>上图除了端口，我们还看到一个<code>192.168.0.105</code>，这个就是A的<strong>IP地址</strong>。</p><p>我们看一下IP层的报文头。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ip%E6%8A%A5%E5%A4%B43.png" alt="IP报头"></p><p>这里面需要关注是<strong>源和目的IP地址</strong>。</p><p>如果两台电脑想通过一根网线进行消息通信，那么他们需要在一个<strong>局域网</strong>内。</p><p>这意味着，他们的子网掩码需要一致。局域网内，假设子网掩码是 <code>225.225.225.0</code>，会认为 <code>192.168.0.x</code> 这些IP都属于一个局域网。所以当A的IP地址是<code>192.168.0.105</code> 时，那么B的IP地址可以配成<code>192.168.0.106</code> 。</p><p>关于IP这一块是啥，后面会细讲，大家如果没明白我说的是啥，不要急。</p><p>组装好网络层报头后，数据包传入到数据链路据层。</p><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><p>以上解决了网络层的互联，而在数据链路层，数据包里需要拼接上<strong>MAC报头</strong>。先看下MAC报头长什么样子。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/mac%E6%8A%A5%E5%A4%B41.png" alt="MAC报头"></p><p>其中需要关心的是标红的<strong>源和目的MAC地址</strong>。MAC地址可以粗略理解是这台电脑网卡的唯一标识。大概长这样</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">28:f9:d3:62:7d:31</span><br></pre></td></tr></table></figure><p>源和目的地址，在发送消息的时候就会被填上。</p><p>但是A只知道自己的MAC地址，怎么才能知道B的MAC地址呢？</p><p>这时候需要ARP协议。</p><p><strong>ARP</strong>（<strong>A</strong>ddress <strong>R</strong>esolution <strong>P</strong>rotocal），即地址解析协议。用于将IP地址解析为以太网的MAC地址的协议。</p><p>在局域网中，当主机A有数据要发送给主机B时，A必须知道B的IP地址。</p><p>但是仅仅有IP地址还是不够的，因为IP数据报文还需要在<strong>数据链路层</strong>封装成<strong>帧</strong>才能通过物理网络发送。因为发送端还必须有接收端的MAC地址，所以需要一个从IP地址到MAC地址的映射。ARP就是干这事情的协议。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ARP%E6%B5%81%E7%A8%8B1.png" alt="ARP流程"></p><ul><li><p>A查本地ARP表发现B的IP和MAC映射关系不存在</p></li><li><p>A通过ARP广播的形式向局域网发出消息，询问某IP对应的MAC地址是多少。比如A此时知道B的IP，但并不知道B的MAC地址是多少，就会尝试在局域网内发起ARP广播，询问局域网下所有机器，哪个机器的IP与B的IP一致。</p></li><li><p>B收到这个ARP消息，发现A要问的IP与自己的IP一致，就会把自己的MAC地址作为应答返回给A。</p></li><li><p>此时A就知道了B的MAC地址，顺便把消息记录到本地ARP表里，下次直接用表里的关系就行，不需要每次都去问。</p></li></ul><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><p>从数据链路层到物理层，数据会被转为<strong>01比特流</strong>。</p><p>此时需要把比特流传到另一台电脑。</p><p>通过一根网线，两段水晶头插入网口，把两台电脑连起来。</p><p>但对网线有一些要求。</p><p>这根网线两端的水晶头需要采用<strong>交叉互联法</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%A4%E5%8F%89%E4%BA%92%E8%81%94%E6%B3%951.png" alt="交叉互联法"></p><p>水晶头里有8根线，<strong>注意上图里的颜色</strong>，是有顺序的。第1、2根线起着收信号的作用，而第3、6脚发信号的作用。将一端的1号和3号线、2号和6号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到。</p><p>当然，现在有些网卡有<strong>自适应</strong>的功能，就算是<strong>直连互联法</strong>的线，也能有<strong>交叉互联法</strong>的效果。如果你用的是这种网卡，就<strong>当我物理层这块什么都没说吧</strong>。</p><h4 id="互联"><a href="#互联" class="headerlink" title="互联"></a>互联</h4><p>此时，在确保<strong>关闭防火墙</strong>的前提下，可以尝试从A电脑中ping一下B，再从B电脑中ping一下A。如无意外，都能ping通。</p><p>A给B发个消息，从应用层到数据链路层，会分别加上A和B的各种’’身份信息”。比如在传输层会加上A和B的应用端口号，在网络层加上源和目的IP，在数据链路层会加上源和目的网卡的MAC头部信息。</p><p>B收到消息后逐层解包，验证，最后顺利到达应用层。实现AB两台机器消息互通。</p><p>至此游戏就能正常联机对线，两台电脑互联成功！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/2ffcf90e51d0ab39.jpeg"></p><h3 id="什么是集线器"><a href="#什么是集线器" class="headerlink" title="什么是集线器"></a>什么是集线器</h3><p>两个人打cs，总会觉得无聊，但是每台电脑又只有一个网线口。</p><p>想要邀请更多的人一起玩，怎么办？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%89%E5%8F%B0%E7%94%B5%E8%84%91%E4%BA%92%E8%81%94.png" alt="三台电脑互联"></p><p>那就要回到文章开头提到的<strong>集线器（hub）</strong>了。</p><p>这是个工作在<strong>物理层</strong>的设备。</p><p>有<strong>多个网口</strong>，很好的解决了电脑上只有一个网口的问题，可以做到多台电脑的网线都插入到集线器上。</p><p>同时工作原理也非常简单，会把某个端口收到的数据，输入到<strong>中继电路</strong>。</p><p>中继电路的基本功能是将输入的信号广播到集线器的所有端口上。</p><p>简单来说就是无脑复制N份到其余N个端口上。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BA%92%E8%81%94.png" alt="集线器互联"></p><p>数据复制到N个端口后。对应转发到N台机器里。</p><h4 id="集线器内部结构"><a href="#集线器内部结构" class="headerlink" title="集线器内部结构"></a>集线器内部结构</h4><p>说到这里，已经对集线器有个大概认识了。</p><p>接下来，我们看下集线器的内部结构。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="集线器内部结构"></p><p>从A网口进入集线器的消息，此时还是电信号。这里经过一个PHY模块。</p><blockquote><p>要理解PHY模块的作用，首先要先了解每个网口，都可能接着网线（<del>废话</del>），而每根网线的传输的格式都是有可能不同的。而PHY的作用，就是把这些格式转化为一个通用的格式。</p><p>举个例子。PHY就好比一个翻译器，有的人说英文，有的人说日文。但是PHY，会把它统一转为普通话，给内部电路处理。内部电路处理完之后，再经过PHY模块，转为英语，或日文从对应网口里输出。</p></blockquote><p>经过PHY的处理后，以电信号的形式输入到中继电路，被无脑广播，再次经过PHY模块后变成BCD网口的格式输出。</p><p>这里面的电信号，是会受噪声干扰，导致信号形变出错的。</p><p>但就算是错了，也还是会<strong>原封不动</strong>的广播出去，这就是上面提到<strong>无脑</strong>的精髓所在。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/f650357e0bdd3258.jpeg"></p><p>那信号如果出错了怎么办？</p><p>只能让接收方收到消息后进行校验。</p><p>还记得上文里提到的数据链路层的MAC报头里最末尾有个<strong>FCS</strong>吗？</p><p>FCS里存放的是发送方通过循环冗余校验CRC计算得到的值。</p><p><strong>接收方</strong>用收到的数据算一次CRC，与FCS里的值进行对比。</p><p>如果一致，那证明数据没问题。如果出错，则<strong>直接丢弃</strong>。</p><blockquote><p>当然，丢弃包并不会影响数据的传输， 因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包， 并对该包进行重传。</p></blockquote><p>如果消息没出错，但是因为无脑广播，C也能收到A发给B的数据包。</p><p>此时 C 会在接受到数据包后一层层的”剥开”。</p><p>正常情况下，在数据链路层时，识别到目的 MAC 地址跟 C 的不一致时，也会把<strong>数据丢弃</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%9B%86%E7%BA%BF%E5%99%A8%E4%BA%92%E8%81%94%E6%97%B6%E5%B9%BF%E6%92%AD%E6%B6%88%E6%81%AF.png" alt="集线器互联时广播消息"></p><h3 id="什么是交换机"><a href="#什么是交换机" class="headerlink" title="什么是交换机"></a>什么是交换机</h3><p>目前只有 ABC 三台机器，每次都是广播发消息倒还好。</p><p>如果机器越来越多，每台机器发一条消息，都会被广播，就有点顶不住了。</p><p>举个例子。</p><p>假设N台机器，其中两台机器A和B，A发到B和B发给A，共两条消息。</p><p>如果这N台机器，用的是集线器。还是AB之间互发消息，每条消息都是广播的话，就是(N-1)+(N-1)条消息，差距有些大，对网络资源浪费就有些严重了。</p><p>那么，有没有可能做到，A发给B的消息，就不要转发给C呢？</p><p>可以的，把集线器换成交换机。</p><p><strong>交换机</strong>，又叫<strong>switch</strong>，跟集线器长得很像。</p><p>但是功能更强一些，从网络分层上来说，属于<strong>数据链路层</strong>，比集线器所在的<strong>物理层</strong>还要高一层。</p><p>所有发到交换机的数据，都会先进入交换机的缓存区。接着消息再被<strong>转发</strong>到对应机器上。</p><p>注意这里用的是<strong>转发</strong>，而不是<strong>集线器的广播</strong>，交换机是怎么做到转发的呢？</p><h4 id="MAC地址表"><a href="#MAC地址表" class="headerlink" title="MAC地址表"></a>MAC地址表</h4><p>交换机内部维护了一张<strong>MAC地址表</strong>。</p><p>记录了 端口号和MAC地址的对应关系。</p><p>这个表的数据是交换机<strong>不断学习</strong>的结果。</p><p>当A发消息到交换机时，交换机发现消息是从1号端口进来的，则会在MAC地址表上，记录A的MAC地址对应1号端口。</p><p>如果A没有很长时间没发消息到这个1号端口，那这条记录就会<strong>过期并被删除</strong>。</p><p>那么，当时间足够长，ABC 都发过消息给交换机后，地址表就会有完整的关系信息。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E4%BA%92%E8%81%94%E6%97%B6%E8%BD%AC%E5%8F%91%E6%B6%88%E6%81%AF1.png" alt="交换机互联时转发消息1"></p><ul><li>A准备发送消息给B，此时A会把B的MAC地址，放入要发送的数据里。数据顺着网线发出。</li><li>交换机从端口收到数据，会把数据里的源和目的MAC地址提出来，跟MAC地址表进行对比。</li><li>发现<strong>B的MAC地址正好在2号端口</strong>，那么就把数据转发给2号端口。</li><li>此时B电脑从网线收到来自交换机2号端口的数据。</li></ul><h4 id="两种特殊情况"><a href="#两种特殊情况" class="headerlink" title="两种特殊情况"></a>两种特殊情况</h4><p>正常流程很清楚了，看两个<strong>特殊情况</strong>：</p><ol><li>交换机查询地址表时，发现目的 MAC 地址的目标端口和这个包的源端口，是同一个端口，怎么办？</li></ol><p>先说结论，<strong>会直接丢弃这个包</strong>。</p><p>我们看下，假设它不丢弃，会发生什么情况。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%BA%90%E5%92%8C%E7%9B%AE%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%80%E8%87%B4%E6%97%B6.png" alt="交换机源和目的端口一致时"></p><ul><li>A发了个消息给B，中间经过一个<strong>集线器</strong>，此时消息会被<strong>广播</strong>到B和交换机。</li><li>此时B收到<strong>第一条</strong>A发给它的消息</li><li>交换机从1号端口收到A的消息后，解包，获得目的MAC地址是BB-BB-BB-BB-BB-BB。查MAC地址表，发现要发到1号端口。此时，源和目的端口都是同一个，<strong>如果交换机不丢弃这个消息</strong>，B会收到<strong>第二条</strong>A发给它的消息。</li></ul><p>A只发了<strong>一次</strong>消息，B却收到<strong>两条</strong>消息，明显不对。</p><p>因此，当交换机查询地址表时，发现目标端口和源端口，是同一个端口时，会丢弃这个包。</p><ol start="2"><li>MAC地址表里找不到对应的MAC地址，怎么办？</li></ol><p>这可能是因为具有该地址的设备，还没有向交换机发送过包，或者这个设备一段时间没有工作，导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上，都能收到这个包。</p><p>此时，交换机就会跟集线器一样进行<strong>广播</strong>。</p><p>发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入地址表，下次也就不需要把包 发到所有端口了。</p><h4 id="交换机内部结构"><a href="#交换机内部结构" class="headerlink" title="交换机内部结构"></a>交换机内部结构</h4><p>再看下交换机内部结构。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%A4%E6%8D%A2%E6%9C%BA%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84.png" alt="交换机内部结构"></p><p>其实对比可以发现，交换机和集线器内部结构很像。</p><p>重点需要提到的是MAC模块。消息以<strong>电信号</strong>的形式从网口进入，到了PHY会被转成<strong>通用格式</strong>的电信号。而MAC模块的作用是把这个电信号转为<strong>数字信号</strong>，这样就能提取出MAC包头，并通过MAC数据帧末尾的<strong>FCS校验</strong>这个包有没有问题，如果没问题，则把数据放到<strong>内存缓冲区</strong>里，否则直接丢弃。</p><p>另外，这个MAC模块，虽然这么叫。但其实<strong>交换机MAC模块不具有 MAC 地址</strong>。因此交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。</p><p>放入到内存缓冲区后，还会把MAC地址和端口号记录到MAC地址表中。同时检查<strong>目的MAC地址</strong>在不在MAC地址表中，在的话则会<strong>转发</strong>到对应端口。否则<strong>广播</strong>。</p><h4 id="交换机与网桥的区别"><a href="#交换机与网桥的区别" class="headerlink" title="交换机与网桥的区别"></a>交换机与网桥的区别</h4><p>网桥，本质上可以理解为<strong>两个网线口的交换机</strong>，正好可以把两台电脑给连起来，也叫<strong>桥接</strong>。而交换机，则是<strong>多网线口的网桥</strong>，可以把多台电脑给连（桥接）起来。</p><p>其他功能方面，大差不差，不必太过纠结。</p><h4 id="交换机和二层交换机和三层交换机有什么区别"><a href="#交换机和二层交换机和三层交换机有什么区别" class="headerlink" title="交换机和二层交换机和三层交换机有什么区别"></a>交换机和二层交换机和三层交换机有什么区别</h4><p>这一部分提到的<strong>交换机</strong>，其实就是<strong>二层交换机</strong>，也就是工作在第二层（<strong>数据链路层</strong>）的交换机，二者<strong>没区别</strong>。</p><p>而<strong>三层交换机</strong>，是工作在第三层（<strong>网络层</strong>）的交换机，其实就是接下来要提到的<strong>路由器</strong>。</p><h3 id="什么是路由器"><a href="#什么是路由器" class="headerlink" title="什么是路由器"></a>什么是路由器</h3><p>有了交换机之后，小网吧里的电脑就都可以被连起来了。交换机网口不够？那就再接个交换机。</p><p>但世界上电脑这么多，交换机里的MAC地址表难道全都要记住吗?</p><p>显然做不到。为了解决这个问题。</p><p>于是就有了<strong>路由器</strong>，工作在<strong>网络层</strong>，比数据链路层更高一层。</p><p>网络层引入了IP的概念。</p><h4 id="什么是IP"><a href="#什么是IP" class="headerlink" title="什么是IP"></a>什么是IP</h4><p>比如前面提到的 <code>192.168.0.105</code> 就是一个IP，同一个<strong>局域网</strong>内还可能会有一个IP是<code>192.168.0.106</code>。有没有发现，它们都是<code>192.168.0.xxx</code>。</p><p>像极了 <code>上海市.黄浦区.南京东路.105号</code>，这样的地址。现实生活中，我们可以通过一个地址定位到要去哪。到了 <code>上海市.黄浦区.南京东路.105号</code>楼里，我们就可以再去找某个叫身份证为<code>xiaobaixxxxx</code>的人。</p><p>那互联网世界里，我们也就可以通过IP地址，定位到某个广域网段，再通过广域网内部的局域网的MAC地址定位到具体某个电脑。</p><p> <code>上海市.黄浦区.南京东路.105号</code>可以帮助我们定位到在南京东路上的第105号楼的位置。但还有些路，比如南京西路，可能不止105号，可能要到257号。</p><p>实际上一个IP由网络号和主机号组成，共32位组成。如果拿了前面24位做网络号，那主机号就剩8位了，2的8次方=256，最多表示表示256号楼。因此为了多表示几个楼，可以向网络号多挪几位过来作为主机号。</p><p>那么具体多少位作为网络号呢？可以在IP后面加一个数字，用来表明这一点。</p><p>于是就有了 <code>192.168.0.105/24</code>这种表示方法，表明前24位<code>192.168.0.0</code>是网络号，105是主机号。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E7%BD%91%E7%BB%9C%E5%8F%B7%E5%92%8C%E4%B8%BB%E6%9C%BA%E5%8F%B7.png" alt="网络号和主机号"></p><p><strong>有了网段，就可以一次性表示一大批地址。就不需要像交换机那样苦哈哈的一条一条MAC地址记录在表里。</strong></p><h4 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h4><p>路由器的作用，可以帮助我们在互联网世界里转发消息到对应的IP。</p><p>对比一下。</p><p>交换机，是通过 MAC 头部中，接收方 MAC 地址，来判断转发目标的。</p><p>路由器，则是根据 IP 头部中， IP 地址来判断的。</p><p>由于使用的地址不同，记录转发信息的表也会不同。</p><p>类似交换机的MAC地址表，路由器也维护了一张<strong>路由表</strong>。</p><p>而路由表，是用于告诉路由器，什么样的消息该转发到什么端口。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%B7%AF%E7%94%B1%E4%BA%92%E8%81%94%E6%97%B6.png" alt="路由互联时"></p><p>假设A要发消息到D。也就是<code>192.168.0.105/24</code>要发消息到<code>192.168.1.11/24</code>。</p><p>那么A会把消息经过交换机发到路由器。</p><p>路由器通过<code>192.168.0.105/24</code>获得其网络号是 <code>192.168.0.0</code> ，而目的地的网络号是<code>192.168.1.0</code>，二者网络号不同，处于不同局域网。</p><p>查<strong>路由表</strong>，发现<code>192.168.1.0</code>,在e2端口，那么就会把消息从e2端口发出，到达交换机，交换机发现MAC地址是它局域网下的D机器，就把消息打过去。</p><p>当然，如果路由表里找不到，那就打到默认<strong>网关</strong>吧，也就是从e1口发出，发到IP<code>192.0.2.1</code>。<strong>这个路由器的路由表不知道该去哪，说不定其他路由器知道</strong>。</p><h4 id="路由器的内部结构"><a href="#路由器的内部结构" class="headerlink" title="路由器的内部结构"></a>路由器的内部结构</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E8%B7%AF%E7%94%B1%E5%99%A8%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%841.png" alt="路由器内部结构"></p><p>路由器内部，分为<strong>控制平面和数据平面</strong>，说白了就是对应<strong>软件部分和硬件部分</strong>。</p><p>硬件部分跟交换机很像。数据从A<strong>网口</strong>进入，此时数据还是网线上格式的电信号，会被<strong>PHY模块</strong>转为通用信号格式，再被<strong>MAC模块</strong>转为数字信号，通过FCS进行错误校验，同时<strong>校验MAC地址是否是自己</strong>，通过校验则进入<strong>内存</strong>缓冲区，否则丢弃。</p><p>再进入<strong>软件部分</strong>，由路由选择处理器，通过一定规则（软件逻辑），查询<strong>路由表</strong>判断转发目标和对应<strong>转发口</strong>，再经由<strong>硬件部分</strong>的<strong>交换结构</strong>转发出去。</p><p>如果路由表中<strong>无法找到</strong>匹配记录，路由器会丢弃这个包，并通过<strong>ICMP</strong>消息告知发送方。</p><h4 id="路由器和交换机的主要区别"><a href="#路由器和交换机的主要区别" class="headerlink" title="路由器和交换机的主要区别"></a>路由器和交换机的主要区别</h4><h5 id="MAC模块的区别"><a href="#MAC模块的区别" class="headerlink" title="MAC模块的区别"></a>MAC模块的区别</h5><p>路由器和交换机不同点在于，它的<strong>每个网口下，都有一个MAC地址和IP地址</strong>。</p><p>正因为路由器具有 MAC 地址，因此它能够成为数据链路层的的<strong>发送方和接收方</strong>。</p><p>怎么理解这句话？</p><p>前面提到交换机，是不具备MAC地址的，而<strong>MAC报头</strong>是需要填上目的MAC地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到<strong>目的地</strong>。</p><p>但路由器，是有MAC地址的，因此MAC报头就可以写上，下一站目的地就是xx路由。</p><p>到了路由器后，路由器可以再次组装下一站的目的MAC地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。</p><p>而同时因为交换机不具有MAC地址，因此也不会校验收到的数据帧的MAC地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的MAC报头里的目的MAC地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。</p><h5 id="找不到转发目的地时的处理方式有区别"><a href="#找不到转发目的地时的处理方式有区别" class="headerlink" title="找不到转发目的地时的处理方式有区别"></a>找不到转发目的地时的处理方式有区别</h5><p>如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP消息告知发送方。</p><p>而交换机在<strong>MAC地址表</strong>里找不到转发端口时会选择广播。</p><p>这里的处理方式两者是不同的，原因在于网络规模的大小。</p><p>交换机连接的网络最多也就是几千台设备的规模，这个规模并 不大。如果只有几千台设备，遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上，虽然这个方法很简单粗暴，但不会引发什么 问题。</p><p>但路由器工作的网络环境就是互联网，全世界所有的设备都连接在互联网上，规模非常大，并且这个规模还在持续扩大中。如果此时它的操作跟交换机一样，将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞。因此，路由器遇到不知道该转发到哪里的包， 就会直接丢弃。</p><h4 id="路由器和光猫有什么区别"><a href="#路由器和光猫有什么区别" class="headerlink" title="路由器和光猫有什么区别"></a>路由器和光猫有什么区别</h4><p>不管是交换机还是路由器，前面都是提到网口输入的是<strong>电信号</strong>。但现在流行的是<strong>光纤传输</strong>，传输的是<strong>光信号</strong>。</p><p>而<strong>光猫</strong>（modem），是一种调制解调器，其实就是用于<strong>光电信号转换</strong>的设备。</p><p>接收数据时，可以将光纤里的<strong>光信号转化为电信号</strong>，发给路由器，路由器内部再转成数字信号，并在此基础上做各种处理。</p><p>相反，也会把路由器传来的<strong>电信号转为光信号</strong>，发到光纤，并进入互联网。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%85%89%E7%8C%AB%E5%92%8C%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="光猫和路由器的区别2"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>两台电脑可以通过一根网线直接连接，进行通信。</li><li>机器一多，可以把网线都接到<strong>集线器</strong>（物理层）上，但是集线器会不管三七二十一进行<strong>广播</strong>。</li><li>不想广播，可以用（二层）<strong>交换机</strong>（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产MAC地址表，知道消息发到哪，那就<strong>不需要广播</strong>啦</li><li>互联网电脑这么多，交换机MAC地址表总不能全放下吧。改用<strong>路由器</strong>（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦。</li><li>路由器和光猫之间是好搭档，<strong>光猫</strong>负责把光纤里的光信号转换成电信号给路由器。 </li><li>现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。</li></ul><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>以前整个班的同学家里都不见得有一台电脑，都喜欢偷偷跑去网吧玩电脑。改革开放的春风，把电脑吹进了每家每户，也把网吧给吹成了网咖。</p><p>从前的我晚上偷偷上网，现在的我，接到报警，也能在大半夜爬起来网上冲浪。</p><p>没想到我以这种方式保持了当初最纯粹的质朴。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/2602a035ddaa4d72.jpeg"></p><p>我是小白，<strong>看下右下角，你懂我意思的</strong>。</p><p>夏天快来了，我们下期见。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>网络是怎么连接的 - 户根勤 </p><p>趣谈网络协议-  极客时间</p><h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/0H8WL6QeZ2VbO1hHPkn8Ug">硬核图解，TCP粘包是什么？为什么UDP不粘包？</a> </p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>TCP粘包  数据包：我只是犯了每个数据包都会犯的错 |硬核图解</title>
      <link href="/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/"/>
      <url>/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61616129034230.png" alt="默认文件1616129034230"></p><p>事情从一个健身教练说起吧。</p><span id="more"></span><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/0073Cjx6ly1gkbnt17cilj30j60jxgmz.jpg"></p><p>李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件<strong>琛琛</strong>上发布广告。</p><p>键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/9150e4e5jw1fcfryt6ztqg205k041wey.gif"></p><p>还记得<strong>四层网络协议</strong>长什么样子吗？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE1.png" alt="四层网络协议"></p><p>四层网络模型每层各司其职，消息在进入每一层时都会多加一个<strong>报头</strong>，每多一个报头可以理解为<strong>数据报多戴一顶帽子</strong>。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，**<code>mac头部</code>记录的是硬件的唯一地址，<code>IP头</code>记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程**。</p><p>在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96.png" alt="四层网络协议 (1)"></p><h3 id="为什么要将数据切片"><a href="#为什么要将数据切片" class="headerlink" title="为什么要将数据切片"></a>为什么要将数据切片</h3><p>软件<strong>琛琛</strong>是属于<strong>应用层</strong>上的。</p><p>而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是<strong>传输层上的 TCP 协议</strong>。消息在进入<strong>传输层（TCP）</strong>时会被切片为一个个数据包。这个数据包的长度是<code>MSS</code>。</p><p>可以把网络比喻为一个水管，是有一定的<strong>粗细</strong>的，这个粗细由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>，一般认为是的<code>MTU</code>（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%871.png" alt="数据分片"></p><h3 id="MTU-和-MSS-有什么区别"><a href="#MTU-和-MSS-有什么区别" class="headerlink" title="MTU 和 MSS 有什么区别"></a>MTU 和 MSS 有什么区别</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="MSS和MTU的区别"></p><ul><li><p><strong>MTU: Maximum Transmit Unit</strong>，最大传输单元。  由<strong>网络接口层（数据链路层）</strong>提供给<strong>网络层</strong>最大一次传输数据的大小；一般 MTU=<strong>1500 Byte</strong>。<br>假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。</p></li><li><p><strong>MSS：Maximum Segment Size</strong> 。  TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和  TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。<br>假设 MTU= 1500 byte，那么 <strong>MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte</strong>，如果应用层有 <strong>2000 byte</strong> 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。</p></li></ul><h3 id="什么是粘包"><a href="#什么是粘包" class="headerlink" title="什么是粘包"></a>什么是粘包</h3><p>那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E5%88%B0%E7%BD%91%E7%BB%9C1.jpg" alt="发送消息到网络"></p><p>网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的<strong>字节流（stream）</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%B6%88%E6%81%AF%E4%BB%8E%E7%BD%91%E7%BB%9C%E6%8E%A5%E6%94%B6.png" alt="消息从网络接收"></p><p>但由于聊天软件<strong>琛琛</strong>是新开发的，而且开发者叫<strong>小白</strong>，完了，是个<strong>臭名昭著的造 bug 工程师</strong>。经过他的代码，在处理<strong>字节流</strong>的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的<strong>粘包</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/testcolour-20210319081110880.png" alt="消息对比"></p><p>一个号称<strong>健康终结者</strong>的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。</p><h3 id="为什么会出现粘包"><a href="#为什么会出现粘包" class="headerlink" title="为什么会出现粘包"></a>为什么会出现粘包</h3><p>那就要从 TCP 是啥说起。</p><p><strong>TCP，Transmission Control Protocol</strong>。传输控制协议，是一种面向连接的、可靠的、基于<strong>字节流</strong>的传输层通信协议。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="TCP是什么"></p><p>其中跟<strong>粘包</strong>关系最大的就是<strong>基于字节流</strong>这个特点。</p><p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间<strong>没有任何边界</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.png" alt="二进制字节流"></p><p>应用层传到 TCP 协议的数据，不是以<strong>消息报为单位</strong>向目的主机发送，而是以<strong>字节流</strong>的方式发送到下游，这些数据可能被<strong>切割和组装</strong>成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。</p><h3 id="为什么要组装发送的数据"><a href="#为什么要组装发送的数据" class="headerlink" title="为什么要组装发送的数据"></a>为什么要组装发送的数据</h3><p>上面提到 TCP <strong>切割</strong>数据包是为了能顺利通过网络这根水管。相反，还有一个<strong>组装</strong>的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较<strong>浪费</strong>网络 io 。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%AD%A3%E5%B8%B8%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%8C%852.png" alt="正常发送数据包"></p><p>比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。</p><p>优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先<strong>等待</strong>，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。</p><p>上面说的其实就是<code>TCP</code>的 <strong>Nagle 算法</strong>优化，目的是为了避免发送小的数据包。</p><p>在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送：</p><ul><li>如果包长度达到<code>MSS</code>（或含有<code>Fin</code>包），立刻发送，否则<strong>等待</strong>下一个包到来；如果下一包到来后两个包的总长度超过<code>MSS</code>的话，就会进行拆分发送；</li><li>等待超时（一般为<code>200ms</code>），第一个包没到<code>MSS</code>长度，但是又迟迟等不到第二个包的到来，则立即发送。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/negle2.png" alt="Nagle2"></p><ul><li>由于启动了<strong>Nagle算法</strong>， msg1 小于 mss ，此时等待<code>200ms</code>内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为<code>MSS</code>。此时发送出去。</li><li>剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。</li><li>剩余的 msg3(2) 长度不足<code>mss</code>，同时在<code>200ms</code>内没有等到下一个包，等待超时，直接发送。</li><li>此时三个包虽然在图里<strong>颜色不同</strong>，但是实际场景中，他们都是<strong>一整个 01 串</strong>，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就<strong>像是两个包粘在一起</strong>，就会导致<strong>粘包问题</strong>。</li></ul><h3 id="关掉-Nagle-算法就不会粘包了吗？"><a href="#关掉-Nagle-算法就不会粘包了吗？" class="headerlink" title="关掉 Nagle 算法就不会粘包了吗？"></a>关掉 Nagle 算法就不会粘包了吗？</h3><p><strong>Nagle</strong> 算法其实是个<strong>有些年代</strong>的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。</p><p>但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。</p><p>所以现在<strong>一般也会把它关掉</strong>。</p><p>看起来，Nagle 算法的优化作用貌似不大，还会导致**粘包”问题”<strong>。那么是不是关掉这个算法就可以解决掉这个</strong>粘包”问题”**呢？</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP_NODELAY = 1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E5%85%B3%E9%97%ADnegle%E5%B0%B1%E4%B8%8D%E4%BC%9A%E7%B2%98%E5%8C%85%E4%BA%86%E5%90%97.png" alt="关闭Nagle就不会粘包了吗"></p><ul><li>接受端应用层在收到 <strong>msg1</strong> 时立马就取走了，那此时 <strong>msg1</strong> 没粘包问题</li><li>**msg2 **到了后，应用层在忙，没来得及取走，就呆在 <strong>TCP Recv Buffer</strong> 中了</li><li>**msg3 **此时也到了，跟 <strong>msg2</strong> 和 <strong>msg3</strong> 一起放在了 <strong>TCP Recv Buffer</strong> 中</li><li>这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中<strong>都是 01 串</strong>，此时一起取走，发现还是粘包。</li></ul><p>因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/image-20210319125906894.png"></p><h3 id="怎么处理粘包"><a href="#怎么处理粘包" class="headerlink" title="怎么处理粘包"></a>怎么处理粘包</h3><p>粘包出现的根本原因是不确定<strong>消息的边界</strong>。接收端在面对**”无边无际”的二进制流<strong>的时候，根本不知道收了多少 01 才算</strong>一个消息<strong>。一不小心拿多了就说是</strong>粘包**。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。</p><p>只要在发送端每次发送消息的时候给消息<strong>带上识别消息边界的信息</strong>，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。</p><p>常见的方法有</p><ul><li><p>加入特殊标志</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E5%A4%B4%E5%B0%BE%E6%A0%87%E5%BF%97.png" alt="消息边界头尾标志"></p><p>可以通过特殊的标志作为头尾，比如当收到了<code>0xfffffe</code>或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志<code>0xfffffe</code>或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 <strong>chunked 编码</strong> 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。</p></li><li><p>加入消息长度信息</p></li></ul><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%97.png" alt="消息边界长度标志"></p><p>这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的<code>Content-Length</code>就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时，关于这一点<a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">上一篇文章</a>里有更详细的说明。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/006mowZngy1fu63g3y5g1j309q09g3yu.jpg"></p><p>可能这时候会有朋友会问，采用<code>0xfffffe</code>标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/69db3af78753efb7.gif"></p><p>是的，<strong>怕</strong>，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（<code>校验和</code>或者对整段完整数据进行 <code>CRC</code> 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E5%A4%B4%E5%B0%BE%E5%8A%A0%E6%A0%A1%E9%AA%8C%E6%A0%87%E5%BF%97.png" alt="消息边界头尾加校验标志"></p><h3 id="UDP-会粘包吗"><a href="#UDP-会粘包吗" class="headerlink" title="UDP 会粘包吗"></a>UDP 会粘包吗</h3><p>跟 <code>TCP</code> 同为传输层的另一个协议，<strong>UDP，User Datagram Protocol</strong>。用户数据包协议，是面向无连接，不可靠的，基于<strong>数据报</strong>的传输层通信协议。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/udp%E6%98%AF%E4%BB%80%E4%B9%88.png" alt="UDP是什么"></p><p>基于<strong>数据报</strong>是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为<strong>基于数据报</strong>和<strong>基于字节流</strong>的差异，<strong>TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。</strong></p><p>我们先看下<strong>IP报头</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/ip%E6%8A%A5%E5%A4%B42.png" alt="ip报头"></p><p>注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 <strong>UDP 的报头</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/udp%E6%8A%A5%E5%A4%B44.png" alt="UDP报头"></p><p>在报头中有<code>16bit</code>用于指示 <strong>UDP 数据报文的长度</strong>，假设这个长度是 n ，以此作为<strong>数据边界</strong>。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个<strong>完整的</strong>数据报，从而避免粘包和拆包的问题。</p><p>当然，就算没有这个位（<strong>16位 UDP 长度</strong>），因为 IP 的头部已经包含了数据的<strong>总长度</strong>信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个<strong>总长度</strong>其实就包含了 UDP 的头部和 UDP 的数据。</p><p>因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了<code>数据和选项</code>以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/UDP%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6-20210319074710451.png" alt="UDP数据长度"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/cb8849427e15334b.jpeg"></p><p>可以再来看下 <strong>TCP 的报头</strong></p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%8A%A5%E5%A4%B42.png" alt="tcp报头2"></p><p>TCP首部里是没有长度这个信息的，跟UDP类似，同样可以通过下面的公式获得当前包的TCP数据长度。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/tcp%E6%95%B0%E6%8D%AE%E9%95%BF%E5%BA%A6.png" alt="TCP数据长度"></p><p>跟 UDP 不同在于，TCP 发送端在发的时候就<strong>不保证发的是一个完整的数据报</strong>，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。</p><h3 id="为什么长度字段冗余还要加到-UDP-首部中"><a href="#为什么长度字段冗余还要加到-UDP-首部中" class="headerlink" title="为什么长度字段冗余还要加到 UDP 首部中"></a>为什么长度字段冗余还要加到 UDP 首部中</h3><p>关于这一点，查了很多资料，<code>《 TCP-IP 详解（卷2）》</code>里说可能是因为要用于计算校验和。也有的说是因为UDP底层使用的可以不是IP协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是IP层协议，而是其他网络层协议，就不能继续这么计算了。</p><p>但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的  <code>Socket Buffer</code> 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，<strong>如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢</strong>？</p><p>因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E4%B8%BA%E4%BB%80%E4%B9%88UDP%E8%A6%81%E5%86%97%E4%BD%99%E4%B8%80%E4%B8%AA%E9%95%BF%E5%BA%A6%E5%AD%97%E6%AE%B5.png" alt="为什么UDP要冗余一个长度字段"></p><p>面试的时候咱就把这些全说出去，<strong>显得</strong>咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，<strong>加分加分</strong>。</p><p>如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/dbdbee64f53762c2.jpeg"></p><h3 id="IP-层有粘包问题吗"><a href="#IP-层有粘包问题吗" class="headerlink" title="IP 层有粘包问题吗"></a>IP 层有粘包问题吗</h3><p>IP 层会对大包进行切片，是不是也有粘包问题？</p><p>先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。</p><p>先看看 IP 层的切片分包是怎么回事。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/P%E5%88%86%E5%8C%85%E4%B8%8E%E9%87%8D%E7%BB%84.png" alt="P分包与重组"></p><ul><li><p>如果消息过长，<code>IP层</code>会按 <strong>MTU 长度</strong>把消息分成 <strong>N 个切片</strong>，每个切片带有自身在<strong>包里的位置（offset）</strong>和<strong>同样的IP头信息</strong>。</p></li><li><p>各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后<strong>在最后的终点汇合后再组装</strong>。</p></li><li><p>在接收端收到第一个切片包时会申请一块新内存，创建IP包的数据结构，等待其他切片分包数据到位。</p></li><li><p>等消息全部到位后就把整个消息包给到上层（传输层）进行处理。</p></li></ul><p>可以看出整个过程，<code>IP 层</code>从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。</p><p><code>IP 层</code>表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。</p><p>听起来就像 “<strong>我不管产品的需求傻不傻X，我实现了就行，我不问，也懒得争了</strong>”，这思路值得每一位优秀的划水程序员学习，<strong>respect</strong>。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。</p><ul><li>TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。</li><li>TCP 粘包跟Nagle算法有关系，但关闭 Nagle 算法并不解决粘包问题。</li><li>UDP 是基于数据报的传输协议，不会有粘包问题。</li><li>IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。</li><li><code>TCP</code> 发送端可以发 <code>10 次</code>字节流数据，接收端可以分 <code>100 次</code>去取；<code>UDP</code> 发送端发了 <code>10 次</code>数据报，那接收端就要在 <code>10 次</code>收完。</li></ul><p>数据包也只是按着 TCP 的方式进行组装和拆分，<strong>如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已</strong>。</p><p>最后，李东工作没了，而小白表示</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/9150e4e5ly1frrh7t0l9jj20ey0cxq3a.jpg"></p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><p><a href="https://mp.weixin.qq.com/s/T6XXaFFyyOJioD6dqDJpFg">给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/T41YBEmG4lkxokDLzRxVgA">硬核！漫画图解HTTP知识点+面试题</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/PwIbKDTi0uSxhUWC56sJYg">程序员防猝死指南</a> </p></li></ul><h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>程序员划水指南</title>
      <link href="/2021/03/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E6%8C%87%E5%8D%97/"/>
      <url>/2021/03/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-19/1611015645731-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61611015549650.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><p>快过年了，跟我可爱的小侄子通了个电话，上来就说，”叔叔你头发怎么变少了”，我很痛心，我的小侄子，年纪轻轻的，眼神已经这么不好使了。但转念一想，这也是他对我的一种关心，作为叔叔，也该回应一把，今年过年给他带一本《少儿编程》回去当礼物吧。   </p><span id="more"></span><p>但转念又一想，也许我真的头发变少了呢，我强壮的体魄不再足以支撑我肮脏的灵魂了呢，或许真的应了那句古语，<strong>程序员固有一死，要么骚死，要么累死？</strong> 我好残忍，我竟然想让我的小侄走上这么一条不归路。  </p><p>可是我这一身编程本领好想传授予人，我还想不想那么快一”猝”而就。我还想看着小侄子长大成人，然后在面试他的时候偷偷放水，再把他招进部门结对编程，我一定要活久一点。我想一定还有跟我一样有未了心愿的程序员，于是今天我将祭出所有划水技能，<strong>希望赠与有缘人</strong>。  </p><h2 id="换行业"><a href="#换行业" class="headerlink" title="换行业"></a>换行业</h2><p>这是最直接的解决方案，那么问题来了，应该去哪个行业呢？程序员下岗后一般再就业的岗位不是送外卖就是送快递，这两个工作从工作强度和工作时长来说，丝毫不比程序员轻松。这就片面了。  </p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-19/1611015053542-ysqiqillllll.jpg"></p><p>有时间送快递和外卖的话，那不如老老实实考个公务员吧。程序员怎么成为公务员？这里正好有一个github项目，就教你如何成为一个公务员。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/coder2gwy/coder2gwy</span><br></pre></td></tr></table></figure><p>连怎么安排学习时间，怎么请假都安排得明明白白，贼吉尔细心。<br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610882082277-image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610882318401-image.png"></p><h2 id="跳槽到965的公司"><a href="#跳槽到965的公司" class="headerlink" title="跳槽到965的公司"></a>跳槽到965的公司</h2><p>从程序员跳槽到公务员或者是教师这条路子比较艰难，虽然我相信大部分程序员在考试上面都比常人要更擅长些。</p><p>一旦选择考公务员，等于放弃自己学习多年的技能，什么<code>mysql</code>，<code>redis</code>，<code>java</code>，<code>设计模式</code>这些，都将成为过眼云烟，选择成本巨大。就算成了，也可能会后悔，或许会在某个四下无人的下午三点，用当年的程序员杯子装着这周xx办主任送的茶叶泡的茶，写着 <strong>《下班总结》</strong>，感叹这个世界少了一个出色的程序员。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610882815684-image.png"><br>那么跳槽到一个965的公司，可能可以帮助你更好地划水。那么问题来了，怎么样找到995的公司？ </p><p>还记得n年前的那个996icu吗？  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610883077766-image.png"><br>里面贴心地给出了一份996的公司名单，如果你坚决拒绝996，那么从拒绝这份名单里的公司offer开始。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU/tree/master/blacklist</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610883287402-image.png"><br>同时给出了这些公司996的证据，真正做到”拒绝张嘴就来”和有理有据，非常符合程序员讲事实摆道理的性格。</p><p>建议大家根据钱包厚度和身体承受能力进行选择，996下班不可怕，可怕的是，半夜一个报警就可以爬起来愉快网上冲浪了。以前高中的时候还要翻墙出去网吧通宵，现在在家里就能做到！  </p><p>同时也给出了一份965的公司名单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/996icu/996.ICU/tree/master/whitelist</span><br></pre></td></tr></table></figure><p>但是值得一提，这些公司都比较少，同时不排除哪一天不会变成996。毕竟制度是人定的，公司也是要盈利的，哪天换了个领导冲kpi，大家也只能一起冲冲冲了。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610883626689-image.png"><br>结论上来说，996的公司比965的公司<strong>多太多</strong>，大部分有志青年都在996的公司里，<strong>既然无法避免，那就要学会怎么在工作中划水</strong>。</p><h2 id="学会划水"><a href="#学会划水" class="headerlink" title="学会划水"></a>学会划水</h2><p>如果你已经在996的公司里，同时你的钱包需要你通过这种方式出卖劳动，那么显然换行业，跳槽，都不太适合，毕竟轻松意味着钱少。那么怎么在996公司里防猝死呢？<br>划水成为唯一答案，划水其实也是一种技术，是分等级的，下面分享几个实用的划水技巧。</p><h3 id="初级划水技能"><a href="#初级划水技能" class="headerlink" title="初级划水技能"></a>初级划水技能</h3><p>初级划水技能是属于每个程序员都要学会的基础技能。</p><h4 id="不要让自己看起来很闲"><a href="#不要让自己看起来很闲" class="headerlink" title="不要让自己看起来很闲"></a>不要让自己看起来很闲</h4><p>不管是因为你是真的很闲，还是因为你效率高很快把活干完了。如果你看起来很闲，老板就容易会认为你工作不饱和，从而不断加活，直到你看起来一直在忙为止。既然如此，如果你一直看起来很忙，那么这样的问题可以被很好的避免。而vscode是程序员最常用的编辑器，我们可以在此基础上找到很多划水神器。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896648119-image.png"></p><h5 id="模拟写代码"><a href="#模拟写代码" class="headerlink" title="模拟写代码"></a>模拟写代码</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/zy445566/vscode-plugin-swimming</span><br></pre></td></tr></table></figure><p>代码写的快，提早完工被压榨怎么办？你需要一个模拟写代码工具，让VSCode模拟写代码，划水、摸鱼神器，让代码自己重写一遍。<br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610885030551-image.png"></p><h5 id="看小说工具"><a href="#看小说工具" class="headerlink" title="看小说工具"></a>看小说工具</h5><p>上学那会偷偷摸摸看小说时会在小说本上套上一层课本封面，以此来掩盖上课划水的行为。同样的道理，下面这个插件感觉跟上课看小说的经历有点像，他让开发者可以在 VSCode 上边写代码边看小说。</p><p>下次等产品经理路过你身旁的时候，以为你写了一堆密密麻麻的的代码，都不好意思再给你加需求。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610885854313-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/zrk1993/read-vscode-e</span><br></pre></td></tr></table></figure><h5 id="听音乐插件"><a href="#听音乐插件" class="headerlink" title="听音乐插件"></a>听音乐插件</h5><p>做事做全套，还要在vscode装上听音乐的插件。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610885464251-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/nondanee/vsc-netease-music</span><br></pre></td></tr></table></figure><h5 id="炒股"><a href="#炒股" class="headerlink" title="炒股"></a>炒股</h5><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610885801992-image.png"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/roblourens/vscode-stocks</span><br></pre></td></tr></table></figure><h3 id="中级划水技能"><a href="#中级划水技能" class="headerlink" title="中级划水技能"></a>中级划水技能</h3><h4 id="项目时间预估"><a href="#项目时间预估" class="headerlink" title="项目时间预估"></a>项目时间预估</h4><p>  每次需求迭代，产品都会让开发给出一个开发时间。  </p><p>  我接触过的百分之90的程序员都是老实的小伙子，是多少就报多少，有些为了方便产品快速看效果，还会压缩自己的时间，这种情况在新人程序员里尤为明显。</p><p>  但有些不讲武德的产品，会动不动做一点 <strong>小小的改动</strong>，同时因为改动<strong>较小</strong>，之前提到的时间一般不会更改。</p><p>  如果你所在的项目中产品不止一个人，就可能出现多个产品给你提需求的情况，改动不大，但挺急。  </p><p>  一个程序员越老实，就越不会表达，选择闷头苦干，有些甚至牺牲节假日时间在家干活。</p><p>  因此为了更好的应对这些非常常见的情况，建议再估计工时的时候，都多预估至少20~50%的时间当做buffer。  </p><p>  如果你提前做好需求，请务必不要提前给产品看，这只会方便他在看到实物后做出更多的变更。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896715125-image.png"></p><h4 id="如何巧妙的推掉需求"><a href="#如何巧妙的推掉需求" class="headerlink" title="如何巧妙的推掉需求"></a>如何巧妙的推掉需求</h4><p>  很多产品在做每一期迭代开发需求的时候，会有无穷无尽的想法，而且恨不得都全部实现，最好今天就能给到。</p><p>  大部分老实的程序员，会选择尽可能满足这些可爱的需求。这些永远没办法做完的需求，才是耗尽程序员心力的重要因素。</p><p>  你需要给每个需求和变更排期，给需求留足buffer，确保线上出问题的时候你还有时间去处理。</p><p>  <strong>让产品给这些需求排优先级</strong>，从高到低，算好每个需求的人日，做不了一定要提出来，剩下的让不同产品去pk优先级，确保你不过劳。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896919790-image.png"></p><h4 id="减少不必要的沟通"><a href="#减少不必要的沟通" class="headerlink" title="减少不必要的沟通"></a>减少不必要的沟通</h4><p>很多不明真相的产品、运营、其他部门的开发会通过各种途径找到你，大部分时候他们找你都是为了向你询问一些无关痛痒的问题。</p><p>有些时候当他们询问的问题触及技术细节的时候，新人程序员都会想要试图产生程序实现原理细节。</p><p>请记住一句话，<strong>千万不要跟不是搞技术的人聊实现细节，如果可以，最好别跟任何人聊技术实现细节</strong>，不仅会把他们的思路带跑偏，还会越解释越迷糊。</p><p>另外还有一些人遇到一些疑问，会用企业微信或钉钉找到你，如果这个人说的事情不是紧急的事情，同时没有直接找到你面前，<strong>尽量选择过半小时后再处理</strong>。</p><p>你要相信他们自己解决问题的能力，大部分不重要或跟你关系不大的问题，会因为你的延缓处理<strong>自动消失</strong>。</p><p>大部分真正需要你解决的问题，<strong>半小时后还会再找你一次</strong>。</p><p>另外，哪怕不听音乐，带上耳机，可以减少10%的无效沟通，懂的自然懂。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896784810-image.png"></p><h4 id="提升办事效率"><a href="#提升办事效率" class="headerlink" title="提升办事效率"></a>提升办事效率</h4><p>  提升办事效率是为了减少自己无用时间的支出，从而不至于让自己没有时间在工作之余锻炼休闲。  </p><p>  提升效率这个事情其实比较简单。  </p><p>  选择适合自己的办公软件。比如印象笔记或有道云笔记来记录工作要点和备忘，用番茄学习时间来强迫自己专心写代码，同时还能装个眼睛护士定时提醒自己要放松一下眼睛。<br>  另外我个人强烈建议大家<strong>多喝水</strong>。<br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-19/1611011972160-%E5%A4%9A%E5%96%9D%E7%83%AD%E6%B0%B4.png"></p><p>另外推荐几个 VSCode 效率插件  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.infoq.cn/article/c4wbmkc7sslz28gyazll</span><br></pre></td></tr></table></figure><p>mac 效率神器  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/Louiszhai/tool</span><br></pre></td></tr></table></figure><h3 id="高级划水技能"><a href="#高级划水技能" class="headerlink" title="高级划水技能"></a>高级划水技能</h3><p>划水的最高技巧是提升技术水平，可以减少排查问题的时间，提升工作效率，更好的预估时间（意味着可以更精确地给自己多估两天排期）。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610897376592-%E5%BF%99.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896517264-image.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610897804737-%E5%BF%992.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896443862-image.png"></p><p>只有提升自身硬实力，才能打破这个死循环。  </p><p>下面介绍一个golang程序员学习提升的项目,里面有超全的golang面试问题整理，用问题驱动去学习。</p><p>同时还有一张完整的入门进阶知识图谱，值得star一个啊。关于其他编程语言的学习路线，欢迎各位私信我学习地址。  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/xiaobaiTech/golangFamily</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-8/1610113159235-GO%E6%88%90%E9%95%BF%E8%B7%AF%E7%BA%BF.jpg">  </p><h2 id="学会管理自己的时间"><a href="#学会管理自己的时间" class="headerlink" title="学会管理自己的时间"></a>学会管理自己的时间</h2><p>要学习时间管理，就要像这个领域里最顶尖的大师学习。  </p><p>而这个领域里我只认罗老师，罗老师去年荣获时间管理大师称号。在业务能力上罗老师绝对是个优秀的好歌手好演员，各领域开花，忙是不可避免的，工作强度不会比程序员弱。<br>在此基础上，还能做到宛如影分身之术一般时间管理能力，除了熬出两个黑眼圈外，身体却十分硬朗。仔细一想，罗老师是在承受着身体和心理都在长时间承受高强度的压力，但却不影响他身心健康。    </p><p>我们可以好好分析一下，罗老师为什么能在硬朗这件事情上做的如此出类拔萃。个人拙见，有三点  </p><h3 id="热爱自己的事业"><a href="#热爱自己的事业" class="headerlink" title="热爱自己的事业"></a>热爱自己的事业</h3><p>  我们可以看下，罗老师的日程表。  </p><p>  <img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610880071658-WX20210117-183727@2x.png">    </p><p>  这工作强度映射到程序员身上，也差不多跟连续开会写代码997差不多了吧，然而他却硬朗得很。  </p><p>  他到底是怎么做到的呢？一言以蔽之，<strong>热爱</strong>。解bug的过程可能是难受压抑紧张的，但是解bug成功带来的成就感真的很爽。</p><p>  如果不热爱这份工作，那么成就感没了，只剩下难受和压抑了，不快乐的人，说不定哪天<strong>说没就没了</strong>。<br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896061077-image.png">  </p><h3 id="锻炼身体"><a href="#锻炼身体" class="headerlink" title="锻炼身体"></a>锻炼身体</h3><p>他热爱跳舞，被称为“亚洲舞王”。虽然这个称呼有点夸张，但是他不是天赋型选手，跳舞能力是花时间练出来的。</p><p>而跳舞这件事情，和健身类似，让身体动起来了，出汗了，你自然就爽了。</p><p>大家应该都有一种感觉，运动，会让你出汗，会让身体巨酸巨累，但是这个过程中，会让心情变得畅快不压抑，还能让你<strong>因为敲代码而变得瘦弱的肱二头肌变得粗壮一些</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896129039-image.png">  </p><h3 id="事业之外还有自己的爱好"><a href="#事业之外还有自己的爱好" class="headerlink" title="事业之外还有自己的爱好"></a>事业之外还有自己的爱好</h3><p>这个世界上只有一种真正的英雄主义，就是在认清生活的真相之后，还能热爱生活。 </p><p>很多程序员在大学刚毕业的时候，都想着自己以后能做一个牛逼哄哄的软件，然后跟乔布斯一样改变这个世界，但是往往又在几年后选择成为一条咸鱼，每天疲惫于跟产品经理斗智斗勇，只要能砍掉哪怕一个需求，那也是一次重大胜利。 </p><p>我们都只是普通人，产品经理没错，程序猿也没错，当一条咸鱼也挺香的，但是在工作中当咸鱼可以，唯唯诺诺可以，但下了班，你必须重拳出击。</p><p>你得有自己的爱好，可以是爬山旅游，篮球游泳。如果这些都太索然无味，你还可以去酒吧跟各种臭妹妹坏弟弟喝上一杯。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610895957764-image.png">  </p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>要<strong>每天看一遍凉凉的新闻</strong>，坚定自己划水的信念。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896383124-image.png">    </p><p>鲁迅曾经说过，<strong>划水最好的时候两个时间，一个是十年前，一个是现在</strong>。你懂我意思吧？<br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-17/1610896285339-image.png"></p><p>没懂? <strong>点个在看，你的每一次扩散都可能拯救一个累垮边缘的程序猿！</strong><br><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-10/1610269930614-640.png"></p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-6/1609890505711-%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-01-06-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> 骚话连篇 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>硬核！漫画图解HTTP基础+面试题</title>
      <link href="/2021/02/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9+%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2021/02/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9+%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-19/1613693230446-%E9%BB%98%E8%AE%A4%E6%96%87%E4%BB%B61613437659307.png"></p><blockquote><p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p></blockquote><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613317170976-%E4%B8%8D%E8%A6%81%E6%89%93%E6%89%B0%E6%88%91%E5%AD%A6HTTP.jpg" style="zoom:100%" /><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-16/1613436372639-b%E7%AB%99%E6%92%B8%E7%8C%AB%E5%A4%A7%E5%9B%BE.png"></p><span id="more"></span><h1 id="什么是HTTP"><a href="#什么是HTTP" class="headerlink" title="什么是HTTP"></a>什么是HTTP</h1><p>HTTP 全称<strong>超⽂文本传输协议</strong>，也就是<strong>H</strong>yper<strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol。<br>其中我们常见的<strong>文本，图片，视频</strong>这些东西都可以用超文本进行表示，而我常看的猫片，也属于超文本，所以大家不要再说我偷偷看猫片了，我只是在看超文本。HTTP只是定义了一套传输超文本的规则，只要符合了这一套规则，不管你是用iphone，还是用老爷机，都可以实现猫片的传输。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613041437612-http%E4%BC%A0%E8%BE%93%E7%A4%BA%E4%BE%8B%E6%BC%AB%E7%94%BB.jpg"></p><h1 id="七层网络"><a href="#七层网络" class="headerlink" title="七层网络"></a>七层网络</h1><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613013885789-image.png" alt="网络协议"></p><p>大概了解了<strong>HTTP</strong>后，给大家看看它在它们家族里的地位。HTTP位于<strong>应用层</strong>，跟它类似的协议还有常见的<strong>FTP协议</strong>，常见的<strong>某影天堂</strong>的下载链接曾经经常是以<strong>FTP开头</strong>的。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613007117086-image.png"></p><h1 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h1><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613021710607-http%E6%8A%A5%E6%96%87%E8%A7%A3%E6%9E%90.jpg"></p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613041939151-image.png" style="zoom:100%" /> <p>有点抽象？不知道小白说的啥？那实操一下，用<code>wireshark</code>抓包看一下猫片里的请求报文和响应报文具体长什么样子吧</p><h2 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/cmaskboss/164203142_30_1.enhance.webmask</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>upos-sz-staticks3.bilivideo.com</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>*/*</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>https://www.bilibili.com</span><br><span class="line"><span class="attribute">Sec-Fetch-Site</span><span class="punctuation">: </span>cross-site</span><br><span class="line"><span class="attribute">Sec-Fetch-Mode</span><span class="punctuation">: </span>cors</span><br><span class="line"><span class="attribute">Sec-Fetch-Dest</span><span class="punctuation">: </span>empty</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>https://www.bilibili.com/</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>identity</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.9</span><br><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=0-16</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这上面第一行的GET 就是<strong>请求方法</strong>，<code>/cmaskboss/164203142_30_1.enhance.webmask</code> 则是 <strong>URL</strong> , 而<code>HTTP/1.1</code>则是<strong>协议版本</strong>。接下来从<code>Host</code>开始到最后一行<code>Range</code>，都是<strong>Headers头</strong>。</p><h2 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">HTTP/1.1</span> <span class="number">206</span> Partial Content</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/octet-stream</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>17</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>keep-alive</span><br><span class="line"><span class="attribute">Server</span><span class="punctuation">: </span>Tengine</span><br><span class="line"><span class="attribute">ETag</span><span class="punctuation">: </span>&quot;92086de1e6d1d4791fb950a0ac7e30ba&quot;</span><br><span class="line"><span class="attribute">Date</span><span class="punctuation">: </span>Sat, 30 Jan 2021 09:31:31 GMT</span><br><span class="line"><span class="attribute">Last-Modified</span><span class="punctuation">: </span>Sun, 04 Oct 2020 01:54:28 GMT</span><br><span class="line"><span class="attribute">Expires</span><span class="punctuation">: </span>Mon, 01 Mar 2021 09:31:31 GMT</span><br><span class="line"><span class="attribute">Age</span><span class="punctuation">: </span>1018695</span><br><span class="line"><span class="attribute">Content-Range</span><span class="punctuation">: </span>bytes 0-16/353225</span><br><span class="line"><span class="attribute">Accept-Ranges</span><span class="punctuation">: </span>bytes</span><br><span class="line"><span class="attribute">X-Application-Context</span><span class="punctuation">: </span>application</span><br><span class="line"><span class="attribute">x-kss-request-id</span><span class="punctuation">: </span>75bcbfa8ab194e3c825e89c81a912692</span><br><span class="line"><span class="attribute">x-kss-BucketOwner</span><span class="punctuation">: </span>MjAwMDAyMDEwNw==</span><br><span class="line"><span class="attribute">X-Info-StorageClass</span><span class="punctuation">: </span>-</span><br><span class="line"><span class="attribute">Content-MD5</span><span class="punctuation">: </span>kght4ebR1HkfuVCgrH4wug==</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-JH-MP-01-03</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-TJ-UN-14-13</span><br><span class="line"><span class="attribute">X-Cache-Status</span><span class="punctuation">: </span>HIT from KS-CLOUD-LF-UN-11-25</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>https://www.bilibili.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span><span class="punctuation">: </span>Origin,X-Requested-With,Content-Type,Accept,range</span><br><span class="line"><span class="attribute">X-Cdn-Request-ID</span><span class="punctuation">: </span>7e2c783ca7d392624118593ec1dc66bc</span><br></pre></td></tr></table></figure><p>类似请求报文，<code>HTTP/1.1</code>是<strong>协议版本</strong>，<code>206</code>是<strong>状态码</strong>，<code>Partial Content</code> 则是<strong>状态描述符</strong>。接下来从<code>Content-Type</code>开始到最后一行<code>X-Cdn-Request-ID</code>都是<strong>Headers信息</strong>。</p><h1 id="报文信息解读"><a href="#报文信息解读" class="headerlink" title="报文信息解读"></a>报文信息解读</h1><p>其实上面的抓包信息，在浏览器里按F12就能看到，之所以要用<code>wireshark</code>可能<strong>只是装X效果比较好吧</strong>。按下F12看到的响应数据就跟下图展示的那样。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613043758890-image.png" style="zoom:100%" /><h2 id="1-请求数据"><a href="#1-请求数据" class="headerlink" title="1.请求数据"></a>1.请求数据</h2><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613046030107-image.png" style="zoom:100%" /><h2 id="2-响应数据"><a href="#2-响应数据" class="headerlink" title="2.响应数据"></a>2.响应数据</h2><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613046094269-image.png" style="zoom:100%" /><h2 id="3-Request-URL"><a href="#3-Request-URL" class="headerlink" title="3.Request URL"></a>3.Request URL</h2><h3 id="URL是什么"><a href="#URL是什么" class="headerlink" title="URL是什么"></a>URL是什么</h3><p>URL 代表着是统一资源定位符（Uniform Resource Locator）。作用是为了告诉使用者 某个资源在 Web 上的地址。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像或一个猫片等等。上面我们请求猫片的URL就是 <code>https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.enhance.webmask</code> 这里面细分，又可以分为好几个部分。</p><ul><li>协议部分</li></ul><p>表示该URL的协议部分为http还是https，会用//为分隔符。上面的URL表示网页用的是HTTPS协议，而上面提到的X影天堂用的则是ftp协议的下载链接。</p><ul><li>域名部分</li></ul><p>域名是<code>upos-sz-staticks3.bilivideo.com</code>，在发送请求前，会向DNS服务器解析IP，如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用。</p><ul><li>端口部分</li></ul><p>域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个URL的必须的部分。当网址为<strong>http://<strong>时，默认端口为</strong>80</strong></p><p>当网址为<strong>https://<strong>时，默认端口为</strong>443</strong>，以上两种都可以省略端口号。上面的URL其实<strong>省略了443端口</strong>号。</p><ul><li>虚拟目录</li></ul><p>从域名的第一个/开始到最后一个/为止，是虚拟目录的部分。虚拟目录也不是URL必须的部分，本例中的虚拟目录是<code>/cmaskboss/</code></p><ul><li>文件名部分</li></ul><p>从域名最后一个/开始到?为止，是文件名部分；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。本例中的文件名是<code>164203142_30_1.enhance.webmask</code>，文件名也不是一个URL的必须部分。</p><h3 id="URL-和-URI-的区别"><a href="#URL-和-URI-的区别" class="headerlink" title="URL 和 URI 的区别"></a>URL 和 URI 的区别</h3><ul><li><strong>URL</strong>:Uniform Resource Locator <strong>统一资源定位符</strong>；  </li><li><strong>URI</strong>: Uniform Resource Identifier <strong>统一资源标识符</strong>；</li></ul><p>其实一直有个误解，很多人以为URI是URL的子集，其实应该反过来。URL是URI的子集才对。简单解释下。<br>假设”小白”(URI)是一种资源，而”在迪丽亦巴的怀里”表明了一个位置。如果你想要找到（locate）小白，那么你可以到”在迪丽亦巴怀里”找到小白，而”在迪丽亦巴怀里的/小白”才是我们常说的URL。而”在迪丽亦巴怀里的/小白”（URL）显然是”小白”（URI）的子集，毕竟，”小白”还可能是”在牛亦菲怀里的/小白”（其他URL）。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613045259027-Untitled%20Diagram%20(3).jpg" style="zoom:100%" /><h2 id="4-Request-Method"><a href="#4-Request-Method" class="headerlink" title="4.Request Method"></a>4.Request Method</h2><p>HTTP 定义了一组<strong>请求方法</strong>，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作.。虽然他们也可以是名词，但这些请求方法有时被称为HTTP动词.。每一个请求方法都实现了不同的语义。</p><p>这次请求猫片的请求里用的是GET，意味着获取。但其实HTTP定义了多种请求方法，来满足各种需求。除了Get，还有几个POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613055907068-GET%E8%B7%9F%E6%88%91%E4%B8%80%E6%A0%B7%E7%9A%84%E8%BF%98%E6%9C%897%E4%B8%AA.jpg" style="zoom:100%" /><p>常见的各个请求方法的具体功能如下：</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><p>请求指定的页面信息，并返回消息主体(body)+头信息(header)。</p><h3 id="HEAD："><a href="#HEAD：" class="headerlink" title="HEAD："></a>HEAD：</h3><p>HEAD和GET本质是一样的，区别在于HEAD只返回头信息(header)，不返回消息主体(body)。大家不要以为它没用，它跟GET和POST一样，在http/1.0的时候就存在了，实属三元老之一了。主要用途 </p><ul><li><p>如果想要判断某个资源是否存在，虽然用GET也能做到，但这里用HEAD还省下拿body的消耗，返回状态码200就是有404就是无</p></li><li><p>如果请求的是一个比较大的资源，比如一个超大视频和文件，你只想知道它到底有多大，而不需要整个下载下来，这时候使用HEAD请求，返回的headers会带有文件的大小（<code>content-lenght</code>）。</p></li></ul><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><p>向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。POST跟GET最常用，但最大的区别在于，POST每次调用都可能会修改数据，是非幂等的，而GET类似于只读，是幂等的。</p><h3 id="PUT："><a href="#PUT：" class="headerlink" title="PUT："></a>PUT：</h3><p>这个方法比较少见。在HTTP规范中POST是非等幂的，多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而PUT id/xiaobai 则会创建一个id为 xiaobai 的用户，多次调用还是会创建的结果是一样的，所以PUT是等幂的。但是一般为了避免造成心智负担，实战中也会使用POST替代PUT。</p><h3 id="DELETE："><a href="#DELETE：" class="headerlink" title="DELETE："></a>DELETE：</h3><p>删除某一个资源。基本上这个也很少见，一般实战中如果是删除操作，也是使用POST来替代。</p><h3 id="OPTIONS："><a href="#OPTIONS：" class="headerlink" title="OPTIONS："></a>OPTIONS：</h3><h4 id="options是什么"><a href="#options是什么" class="headerlink" title="options是什么"></a>options是什么</h4><p>它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法。比如下图：</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613058818793-image.png" style="zoom:100%" /><p>这里面需要关注的点有两个</p><ul><li><p>Request Header里的关键字段</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-12/1613060189629-options%E8%AF%B7%E6%B1%82%E5%AD%97%E6%AE%B5%20(2).jpg"></p></li><li><p>Response Header里的关键字段</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-13/1613174205328-_options%E5%93%8D%E5%BA%94%E5%AD%97%E6%AE%B5%20(1).jpg"></p></li></ul><p><code>Options</code>堪称是网络协议中的老实人，就好像老实人刚谈了个女朋友，每次牵手前都要问下人家 “我可以牵你的手吗？”， “我可以抱你吗？”，得到了答应后才会下手。差点被这老实人气质感动得留下了不争气的泪水。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613057652579-%E5%8A%A0%E5%86%95%E4%B8%BA%E7%8E%8B.jpg" style="zoom:100%" /><h4 id="什么时候需要使用options"><a href="#什么时候需要使用options" class="headerlink" title="什么时候需要使用options"></a>什么时候需要使用options</h4><p>在<strong>跨域</strong>（记住这个词，待会解释）的情况下，浏览器发起<strong>复杂请求前</strong>会<strong>自动</strong>发起 options 请求。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。</p><p>这里提到了两个关键词：</p><ul><li>跨域</li><li>复杂请求</li></ul><h4 id="什么是简单请求和复杂请求。"><a href="#什么是简单请求和复杂请求。" class="headerlink" title="什么是简单请求和复杂请求。"></a>什么是简单请求和复杂请求。</h4><p>某些请求不会触发 CORS 预检请求，这样的请求一般称为”简单请求”，而会触发预检的请求则为”复杂请求”。</p><p>1.简单请求</p><ul><li>请求方法为<code>GET、HEAD、POST</code></li><li>只有以下<code>Headers</code>字段<ul><li><code>Accept</code></li><li><code>Accept-Language</code></li><li><code>Content-Language</code></li><li><code>Content-Type</code></li><li><code>DPR/Downlink/Save-Data/Viewport-Width/Width</code> (这些不常见，放在一起)</li></ul></li><li><code>Content-Type</code> 只有以下三种<ul><li><code>application/x-www-form-urlencoded</code></li><li><code>multipart/form-data</code></li><li><code>text/plain</code></li></ul></li><li>请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器；</li><li>请求中没有使用 ReadableStream 对象。</li></ul><p>2.复杂请求</p><ul><li>不满足简单请求的，都是复杂请求</li></ul><p>由此可见，因为上述请求在获取网上资源的请求Headers里带有 <code>Access-Control-Request-Headers: range</code> , 而<code>range</code>正好不在简单请求的条件2中提到的Headers范围里，因此属于<strong>复杂请求</strong>，于是触发预检options请求。</p><h4 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h4><p>刚刚提到了一个词叫<strong>跨域</strong>，那什么是跨域呢？在了解跨域之前，首先要了解一个概念：<strong>同源</strong>。所谓<strong>同源</strong>是指，<strong>域名、协议、端口均相同</strong>。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613041939151-image.png" style="zoom:100%" /><p>不明白没关系，举个例子。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613311181978-%E6%98%AF%E5%90%A6%E5%90%8C%E6%BA%90.jpg"></p><p>需要特别注意的是，localhost和127.0.0.1虽然都指向本机，但也<strong>不属于同源</strong>。</p><p>而<strong>非同源</strong>之间网页调用就是我们所说的<strong>跨域</strong>。在<strong>浏览器</strong>同源策略限制下，向不同<strong>源</strong>发送XHR请求，<strong>浏览器</strong>认为该请求不受信任，禁止请求，具体表现为请求后不正常响应。</p><h4 id="options带来什么问题"><a href="#options带来什么问题" class="headerlink" title="options带来什么问题"></a>options带来什么问题</h4><p>由此可见，复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送2次请求（一次预检options，一次复杂请求），这一次options就一来一回（一个RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-13/1613176456625-%E5%8A%A0%E5%86%95%E4%B8%BA%E7%8E%8B%20(2).jpg" style="zoom:100%" /><h4 id="如何优化options"><a href="#如何优化options" class="headerlink" title="如何优化options"></a>如何优化options</h4><p>每次复杂请求前都会调用一次options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这一次查询？</p><p><code>Access-Control-Max-Age</code>就是优化这个流程中使用的一个Header。它的作用是当你每次请求<code>options</code>方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 <code>Access-Control-Max-Age</code>时间（单位是秒）里都支持，则这段时间内，不再需要使用options进行请求。特别注意的是，当<code>Access-Control-Max-Age</code>的值为-1时，表示禁用缓存，每一次请求都需要发送预检请求，即用OPTIONS请求进行检测。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/options%E4%BC%98%E5%8C%96%E5%90%8E.jpg" alt="options优化后"></p><h2 id="5-Status-Code"><a href="#5-Status-Code" class="headerlink" title="5.Status Code"></a>5.Status Code</h2><h3 id="状态码是什么"><a href="#状态码是什么" class="headerlink" title="状态码是什么"></a>状态码是什么</h3><p>HTTP Status Code是常说的HTTP状态码。当用户访问一个网页时，浏览器会向网页所在服务器发出请求。服务器则会根据请求作出响应，而状态码则是响应的一部分，代表着本次请求的结果。所有状态码的第一个数字代表了响应的大概含义，组合上第二第三个数字则可以表示更具体的原因。如果请求失败了，通过这个状态码，大概初步判断出这次请求失败的原因。以下是五类状态码的含义。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-11/1613045090544-%E7%8A%B6%E6%80%81%E7%A0%81%E8%A1%A8%E6%A0%BC.jpg"></p><h3 id="状态码流程"><a href="#状态码流程" class="headerlink" title="状态码流程"></a>状态码流程</h3><p>可以根据以下流程图了解下各类状态码间的关系。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-15/1613345953784-Copy%20of%202xx%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" style="zoom:150%" /><ul><li>2xx和3xx之间的流程关系</li></ul><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-16/1613439607255-2xx%E6%B5%81%E7%A8%8B%E5%9B%BE%20(2).jpg"></p><ul><li>4xx的状态流程</li></ul><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-15/1613403987304-4xx%E6%B5%81%E7%A8%8B.jpg" style="zoom:100%" /><ul><li>5xx的状态流程</li></ul><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-16/1613406108083-5xx%E6%B5%81%E7%A8%8B%E5%9B%BE%20(1).jpg" style="zoom:100%" /><h3 id="常见状态码介绍"><a href="#常见状态码介绍" class="headerlink" title="常见状态码介绍"></a>常见状态码介绍</h3><ul><li>200 OK</li></ul><p>这是最常见的状态码。代表请求已成功，数据也正常返回。而请求猫片虽然响应成功了，但却不是200，而是206，是为什么呢，接下去继续看看。</p><ul><li>206 Partial Content</li></ul><p>这个状态码在上面请求的响应结果。服务器已经成功处理了部分 GET 请求。类似于看视频或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。</p><ul><li><p>307 Temporary Redirect</p><p>内部重定向。重定向的意思是，当你输入一个网址的时候，浏览器会自动帮你跳转到另外一个网址上。比如，当你在浏览器输入框输入<code>http://www.baidu.com/</code>时。由于使用http并不安全，百度会自动帮你跳转到它对应的https网页上。而此时，需要重定向的地址，会通过<code>Response Headers</code>的<code>Location</code>返回</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-13/1613187421644-image.png" style="zoom:100%" /></li><li><p>404 Not Found</p><p>请求失败，请求所希望得到的资源未被在服务器上发现。出现这个错误的最有可能的原因是服务器端没有这个页面，或者是Request Method与注册URL的Method不一致，比如我有一个URL在服务端注册的Request Method 为 <strong>POST</strong>，但调用的时候却错误用了<strong>GET</strong>，则也会出现404错误。</p></li><li><p>499 Client has closed connection</p><p>网络请求过程中，由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-20/1613777634555-Get%E5%92%8CPost%20(1).jpg"></p></li><li><p>502 Bad Gateway</p><p>服务器方面无法给予正常的响应。一般常见于服务器崩溃后，nginx 无法正常收到服务端的响应，给客户端返回502状态码。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-20/1613777745819-502%E7%9A%84%E8%BF%87%E7%A8%8B.jpg"></p></li><li><p>504 Gateway Timeout</p><p>网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于 nginx设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于499 表示的是客户端超时，504是网关超时。如果是499超时，可以考虑修改客户端的代码调整超时时间，如果是504，则考虑调整nginx的超时配置。</p><p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-20/1613777517520-504%E7%9A%84%E8%BF%87%E7%A8%8B%20(1).jpg"></p></li></ul><h2 id="6-Headers"><a href="#6-Headers" class="headerlink" title="6. Headers"></a>6. Headers</h2><h3 id="Content-Length"><a href="#Content-Length" class="headerlink" title="Content-Length"></a>Content-Length</h3><p><code>Content-Length</code>是HTTP的消息长度, 用<strong>十进制数字</strong>表示。<code>Content-Length</code>首部指出报文中消息的当前实际字节大小。如果消息文本进行了gzip压缩的话， <code>Content-Length</code>指的就是压缩后的大小而不是原始大小。</p><p>正常情况下<code>Content-Length</code>是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现<code>Content-Length</code>与实际要发送的消息大小不一致，就会出现一些问题。</p><ul><li><p>如果<code>Content-Length</code> &lt; 实际长度</p><p>下面启动一个HTTP服务器，所有语言都一样，示例里使用了golang。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;log&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// w表示response对象，返回给客户端的内容都在对象里处理</span></span><br><span class="line"><span class="comment">// r表示客户端请求对象，包含了请求头，请求参数等等</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">index</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">b, _ := ioutil.ReadAll(r.Body)</span><br><span class="line">fmt.Printf(<span class="string">&quot;request body=%#v, content_length=%v \nheaders=%v&quot;</span>,<span class="keyword">string</span>(b), r.ContentLength, r.Header)</span><br><span class="line"><span class="comment">// 往w里写入内容，就会在浏览器里输出</span></span><br><span class="line">fmt.Fprintf(w, <span class="keyword">string</span>(b))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 设置路由，如果访问/，则调用index方法</span></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/&quot;</span>, index)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动web服务，监听9090端口</span></span><br><span class="line">err := http.ListenAndServe(<span class="string">&quot;:9999&quot;</span>, <span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">&quot;ListenAndServe: &quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在控制台输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> $ curl -L -X POST <span class="string">&#x27;http://127.0.0.1:9999&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -H <span class="string">&#x27;Content-Length: 5&#x27;</span> -d <span class="string">&#x27;1234567&#x27;</span> |  jq</span></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100    12  100     5  100     7    828   1160 --:--:-- --:--:-- --:--:--  1400</span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>输入的body是 <code>1234567</code>，共<strong>7个数字</strong>，但是输入的 <code>Content-Length</code>为 5。到了服务器那，收到了 <code>12345</code>，共<strong>5个数字</strong>，数量上跟输入的<code>Content-Length</code>一致。 由此可见当<code>Content-Length</code> &lt; 实际长度， 消息会被截断。</p></li><li><p>如果<code>Content-Length</code> &gt;  实际长度 </p><p>还是上面的服务端代码，但是控制台输入以下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -L -X POST <span class="string">&#x27;http://127.0.0.1:9999&#x27;</span> -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -H <span class="string">&#x27;Content-Length: 100&#x27;</span> -d <span class="string">&#x27;1234567&#x27;</span> | jq</span></span><br><span class="line"><span class="meta">  %</span><span class="bash"> Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span></span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100     7    0     0    0     7      0      0 --:--:--  0:01:19 --:--:--     0</span><br></pre></td></tr></table></figure><p>这次情况不太一样，会发现请求一直阻塞没有返回。这是因为输入的body是 <code>1234567</code>，共<strong>7个数字</strong>，但是输入的 <code>Content-Length</code>为 100。也就是服务端一直认为这次的body<strong>长度为100</strong>，但是目前只收到了<strong>部分消息（长度为7）</strong>，剩余的长度为93的消息由于各种原因<strong>还在路上</strong>，因此选择<strong>傻傻等待剩下的消息</strong>，就造成了上面提到的阻塞。</p></li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613299089850-image.png" style="zoom:100%" /><p>视频播放需要支持用户调整播放进度，支持让用户选择直接跳到中间部分开始播放。为了实现这个功能，需要通过HTTP Range Requests 协议用于指定需要获取视频片段。而 Request Header里的range头则是用于指定要请求文件的起始和结束位置。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613298634191-image.png" style="zoom:100%" /><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613298705993-image.png" style="zoom:100%" /><ul><li>如果服务器不支持，直接忽略 Range 头，浏览器会正常按流式加载整个视频文件，以状态码 200 响应即可。另外，当我们在 html 中放一个 video 标签，浏览器会直接发起一个 <code>Range: bytes=0-</code> 的请求，向服务器请求从开始到结尾的完整文件。</li><li>如果服务器支持 Range Requests，会读取视频文件，并将他的第 162653～242638 字节提取出来，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的Response Headers中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range  描述了响应覆盖的范围和整个实体长度。一般格式：<code>Content-Range：开始字节位置-结束字节位置／文件大小（byte）</code>。</li></ul><h3 id="Connection"><a href="#Connection" class="headerlink" title="Connection"></a>Connection</h3><h4 id="长连接和短连接"><a href="#长连接和短连接" class="headerlink" title="长连接和短连接"></a>长连接和短连接</h4><ul><li><p>Connection: close</p><p>表示请求响应完成之后立即关闭连接，这是HTTP/1.0请求的默认值。每次请求都经过“创建tcp连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接”这样的过程</p></li><li><p>Connection: keep-alive</p><p>表示连接不立即关闭，可以继续响应下一个请求。HTTP/1.1的请求默认使用一个持久连接。可以做到只建立一次连接，多次资源请求都复用该连接，完成后关闭。流程上是 建立tcp连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; … （保持连接）…  -&gt;  第n次请求资源 -&gt; 第n次响应资源 -&gt; 释放连接。</p></li></ul><p>在http1.1中Request Header和Reponse Header中都有可能出现一个Connection: keep-alive 头信息。Request Header里的Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而Response Header里的Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会<strong>返回  Connection: close ，相当于告诉客户端“我不支持长连接，你死了这条心，老老实实用短连接吧</strong>” 。</p><h4 id="HTTP为什么要使用长连接"><a href="#HTTP为什么要使用长连接" class="headerlink" title="HTTP为什么要使用长连接"></a>HTTP为什么要使用长连接</h4><p>我们知道 HTTP 建立在 TCP 传输层协议之上，而 TCP 的建立需要三次握手，关闭需要四次挥手，这些步骤都需要时间，带给 HTTP 的就是请求响应时延。如果使用短连接，那么每次数据传输都需要经历一次上面提到的几个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升HTTP性能有很大的帮助。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613290339498-http%E7%9F%AD%E8%BF%9E%E6%8E%A5.jpg" style="zoom:100%" /><ul><li>可以看到，在使用 Connection: close 通信时，每次都需要重新经历一次握手挥手。可以通过 Connection: keep-alive 省下这部分的资源消耗。</li></ul><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613292366161-http%E9%95%BF%E8%BF%9E%E6%8E%A5.jpg" style="zoom:100%" /><ul><li><strong>长连接</strong>可以<strong>省去较多的TCP建立和关闭的操作，减少浪费，节约时间</strong>。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。</li><li>解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放。</li></ul><h3 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h3><h4 id="Cookies是什么"><a href="#Cookies是什么" class="headerlink" title="Cookies是什么"></a>Cookies是什么</h4><ol><li>Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。里面一般带有该浏览器的身份信息。</li></ol><ol start="2"><li><p>浏览器需要保存这段数据，不得轻易删除。</p></li><li><p>此后每次浏览器访问该服务器，都必须带上这段数据。服务器用使用这段数据确认浏览器身份信息。</p></li></ol><h4 id="Cookie的作用"><a href="#Cookie的作用" class="headerlink" title="Cookie的作用"></a>Cookie的作用</h4><p>Cookie 一般有两个作用。</p><p>1.识别用户身份。</p><ul><li>举个例子。用户 A 用浏览器访问了“猫猫网”，“猫猫网”的服务器就会立刻给 A 返回一段Cookie数据，内含「uid=a」。</li><li>当 A 再次访问“猫猫网”下的其他页面时，比如跳转到“猫猫交友评论”，就会附带上「uid=a」这段数据。</li><li>同理，用户 B 用浏览器访问“猫猫网” 时，就给 B 分配了一段Cookie数据，内含「uid=b」。B 之后访问“猫猫网”的时候，就会一直带上「uid=b」这段数据。</li><li>因此“猫猫网”的服务器通过Cookie数据就能区分 A 和 B 两个用户了。</li></ul><p>2.持久化用户信息。</p><ul><li>因为cookies的数据会被用户浏览器保存到本地下。因此可以利用这一特点保持一些简单的用户数据。</li><li>比如一些博客网站，可以通过cookies记录下用户的性别年龄等信息，以此进行一些个性化展示。</li><li>当然上面提到的都是一些比较粗糙的场景，是为了方便大家理解cookies的功能。实际使用cookies会非常谨慎。</li></ul><h3 id="Referrer-Policy-和-Referrer"><a href="#Referrer-Policy-和-Referrer" class="headerlink" title="Referrer Policy 和 Referrer"></a>Referrer Policy 和 Referrer</h3><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-1/1612146090912-image.png" style="zoom:100%" /><h4 id="Referrer是什么"><a href="#Referrer是什么" class="headerlink" title="Referrer是什么"></a>Referrer是什么</h4><p>Referrer 是HTTP请求header的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的。比如在上面的请求截图里，可以看出我是使用<code>https://www.bilibili.com/</code>访问的视频资源。</p><h4 id="Referrer-Policy-是什么"><a href="#Referrer-Policy-是什么" class="headerlink" title="Referrer Policy 是什么"></a>Referrer Policy 是什么</h4><ul><li><p>Referrer 字段，会用来指定该请求是从哪个页面跳转页来的，里面的信息是浏览器填的。</p></li><li><p>而 Referrer Policy 则是用于控制Referrer信息传不传、传哪些信息、在什么时候传的策略。</p></li></ul><p>为什么要这么麻烦呢？因为有些网站一些用户敏感信息，比如 sessionid 或是 token 放在地址栏里，如果当做Referrer字段全部传递的话，那第三方网站就会拿到这些信息，会有一定的安全隐患。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容。</p><p>比如在上面的请求截图里，可以看出我是使用<code>strict-origin-when-cross-origin</code>策略，含义是跨域时将当前页面URL过滤掉参数及路径部分，仅将协议、域名和端口（如果有的话）当作 Referrer。否则 Referrer 还是传递当前页的全路径。同时当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。</p><h3 id="Cache-control"><a href="#Cache-control" class="headerlink" title="Cache-control"></a>Cache-control</h3><h4 id="什么是cache-control"><a href="#什么是cache-control" class="headerlink" title="什么是cache-control"></a>什么是cache-control</h4><p>cache-control，用于控制浏览器缓存。简而言之，当某人访问网站时，其浏览器将在本地保存某些资源，例如图像和网站数据。当该用户重新访问同一网站时，缓存控制设置的规则会确定该用户是否从本地缓存中加载这些资源，或者浏览器是否必须向服务器发送新资源的请求。</p><h4 id="什么是浏览器缓存"><a href="#什么是浏览器缓存" class="headerlink" title="什么是浏览器缓存"></a>什么是浏览器缓存</h4><p>浏览器缓存是指浏览器本地保存网站资源，以便不必再次通过网络从服务器获取它们。例如，“猫猫网”的背景图像可以保存到本地缓存中，这样在用户第二次访问该页面时，该图像将从用户的本地文件加载，剩下网络获取资源的时间，页面加载速度就会更快。</p><p>但是浏览器也不会永远把这些网站资源放在本地，否则本地磁盘就会炸，所以会限定保存资源的时间，这叫生存时间（TTL）。如果 TTL 过期后用户请求缓存的资源，浏览器必须再次通过网络与服务器建立连接并重新下载这个资源。</p><h4 id="常见的缓存控制策略"><a href="#常见的缓存控制策略" class="headerlink" title="常见的缓存控制策略"></a>常见的缓存控制策略</h4><ul><li><p>cache-control: private<br>具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。</p></li><li><p>cache-control: public<br>相反，“public”指令表示资源可以由任何缓存存储。</p></li><li><p>cache-control: no-store<br>带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。</p></li><li><p>cache-control: max-age<br>此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。</p></li><li><p>cache-control: no-cache</p><p>从网页截图里可以看出，使用的缓存控制指令是<code>cache-control: no-cache</code>。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 <code>ETag</code>。</p></li></ul><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613297647760-image.png" style="zoom:100%" /><p>Etag是 Entity tag的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。</p><p>比如，浏览器第一次请求资源的时候，服务端返回了这个资源的<code>ETag: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code>。</p><p>当浏览器再次请求这个资源的时候，浏览器会将<code>If-None-Match: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;</code> 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化。</p><ul><li>如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。</li><li>否则表示资源已经更新，浏览器需要下载新版本以提供给用户。</li></ul><p>此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>看个猫片都能学到这么多硬核知识。接下来我打算去舞蹈区看看有没有适合你们的知识点。</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-2-14/1613314979045-%E8%84%B8%E7%BA%A2%E5%BC%80%E5%BF%83.jpg" style="zoom:100%" /><p>我是小白，有空？一起在知识的海洋里呛水啊，懂我意思？</p><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-10/1610269930614-640.png" style="zoom:100%" /><img src="https://cdn.jsdelivr.net/gh/zhaolunallen/picture/2021-1-6/1609890505711-%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-01-06-0.gif" style="zoom:100%" /><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>- [1] 计算机网络自动向下</p><p>- [2] 极客时间-趣谈网络协议</p><p>- [3] 极客时间-透视HTTP</p><p>- [4] 图解HTTP</p><p>- [5] 漫画形象-小肥柴</p>]]></content>
      
      
      <categories>
          
          <category> 图解网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题。</title>
      <link href="/2020/11/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98/"/>
      <url>/2020/11/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p><a href="https://imgchr.com/i/DMGVKJ"><img src="https://s3.ax1x.com/2020/11/20/DMGVKJ.png"></a></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"><span class="string">&quot;net/http&quot;</span></span><br><span class="line"><span class="string">&quot;runtime&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">6</span></span><br><span class="line"><span class="keyword">for</span> index := <span class="number">0</span>; index &lt; num; index++ &#123;</span><br><span class="line">resp, _ := http.Get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line">_, _ = ioutil.ReadAll(resp.Body)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Printf(<span class="string">&quot;此时goroutine个数= %d\n&quot;</span>, runtime.NumGoroutine())</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>上面这道题在不执行<code>resp.Body.Close()</code>的情况下，泄漏了吗？如果泄漏，泄漏了多少个<code>goroutine</code>?</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>不进行<code>resp.Body.Close()</code>，泄漏是一定的</strong>。但是泄漏的<code>goroutine</code>个数就让我迷糊了。由于执行了<strong>6遍</strong>，每次泄漏一个<strong>读和写goroutine</strong>，就是<strong>12个goroutine</strong>，加上<code>main函数</code>本身也是一个<code>goroutine</code>，所以答案是<strong>13</strong>.</li><li>然而执行程序，发现<strong>答案是3</strong>，出入有点大，为什么呢？</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>我们直接看源码。<code>golang</code> 的 <code>http</code> 包。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">http.Get()</span><br><span class="line"></span><br><span class="line">-- DefaultClient.Get</span><br><span class="line">----<span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">do</span><span class="params">(req *Request)</span></span></span><br><span class="line">------<span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span></span><br><span class="line">-------- resp, didTimeout, err = send(req, c.transport(), deadline) </span><br><span class="line"><span class="comment">// 以上代码在 go/1.12.7/libexec/src/net/http/client:174 </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Client)</span> <span class="title">transport</span><span class="params">()</span> <span class="title">RoundTripper</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.Transport != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> c.Transport</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> DefaultTransport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>说明 <code>http.Get</code> 默认使用 <code>DefaultTransport</code> 管理连接。<h5 id="DefaultTransport-是干嘛的呢？"><a href="#DefaultTransport-是干嘛的呢？" class="headerlink" title="DefaultTransport 是干嘛的呢？"></a><code>DefaultTransport</code> 是干嘛的呢？</h5></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// It establishes network connections as needed</span></span><br><span class="line"><span class="comment">// and caches them for reuse by subsequent calls.</span></span><br></pre></td></tr></table></figure><ul><li><code>DefaultTransport</code> 的作用是根据需要建立网络连接并缓存它们以供后续调用重用。<h5 id="那么-DefaultTransport-什么时候会建立连接呢？"><a href="#那么-DefaultTransport-什么时候会建立连接呢？" class="headerlink" title="那么 DefaultTransport 什么时候会建立连接呢？"></a>那么 <code>DefaultTransport</code> 什么时候会建立连接呢？</h5>接着上面的代码堆栈往下翻</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(ireq *Request, rt RoundTripper, deadline time.Time)</span></span> </span><br><span class="line">--resp, err = rt.RoundTrip(req) <span class="comment">// 以上代码在 go/1.12.7/libexec/src/net/http/client:250</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">RoundTrip</span><span class="params">(req *http.Request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">roundTrip</span><span class="params">(req *Request)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">getConn</span><span class="params">(treq *transportRequest, cm connectMethod)</span></span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">dialConn</span><span class="params">(ctx context.Context, cm connectMethod)</span> <span class="params">(*persistConn, error)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">go</span> pconn.readLoop()  <span class="comment">// 启动一个读goroutine</span></span><br><span class="line"><span class="keyword">go</span> pconn.writeLoop() <span class="comment">// 启动一个写goroutine</span></span><br><span class="line"><span class="keyword">return</span> pconn, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一次建立连接，就会启动一个<code>读goroutine</code>和<code>写goroutine</code>。这就是为什么一次<code>http.Get()</code>会泄漏<code>两个goroutine</code>的来源。</li><li>泄漏的来源知道了，也知道是因为没有执行<code>close</code></li></ul><h5 id="那为什么不执行-close-会泄漏呢？"><a href="#那为什么不执行-close-会泄漏呢？" class="headerlink" title="那为什么不执行 close 会泄漏呢？"></a>那为什么不执行 <code>close</code> 会泄漏呢？</h5><ul><li>回到刚刚启动的<code>读goroutine</code> 的 <code>readLoop()</code> 代码里 </li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(pc *persistConn)</span> <span class="title">readLoop</span><span class="params">()</span></span> &#123;</span><br><span class="line">alive := <span class="literal">true</span></span><br><span class="line"><span class="keyword">for</span> alive &#123;</span><br><span class="line">        ...</span><br><span class="line"><span class="comment">// Before looping back to the top of this function and peeking on</span></span><br><span class="line"><span class="comment">// the bufio.Reader, wait for the caller goroutine to finish</span></span><br><span class="line"><span class="comment">// reading the response body. (or for cancelation or death)</span></span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> bodyEOF := &lt;-waitForBodyRead:</span><br><span class="line">pc.t.setReqCanceler(rc.req, <span class="literal">nil</span>) <span class="comment">// before pc might return to idle pool</span></span><br><span class="line">alive = alive &amp;&amp;</span><br><span class="line">bodyEOF &amp;&amp;</span><br><span class="line">!pc.sawEOF &amp;&amp;</span><br><span class="line">pc.wroteRequest() &amp;&amp;</span><br><span class="line">tryPutIdleConn(trace)</span><br><span class="line"><span class="keyword">if</span> bodyEOF &#123;</span><br><span class="line">eofc &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Cancel:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.CancelRequest(rc.req)</span><br><span class="line"><span class="keyword">case</span> &lt;-rc.req.Context().Done():</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">pc.t.cancelRequest(rc.req, rc.req.Context().Err())</span><br><span class="line"><span class="keyword">case</span> &lt;-pc.closech:</span><br><span class="line">alive = <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>简单来说<code>readLoop</code>就是一个死循环，只要<code>alive</code>为<code>true</code>，<code>goroutine</code>就会一直存在</li><li><code>select</code> 里是 <code>goroutine</code> <strong>有可能</strong>退出的场景：<ul><li><code>body</code> 被读取完毕或<code>body</code>关闭</li><li><code>request</code> 主动 <code>cancel</code></li><li><code>request</code> 的 <code>context Done</code> 状态 <code>true</code></li><li>当前的 <code>persistConn</code> 关闭</li></ul></li></ul><p>其中第一个 <code>body</code> 被读取完或关闭这个 <code>case</code>:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alive = alive &amp;&amp;</span><br><span class="line">    bodyEOF &amp;&amp;</span><br><span class="line">    !pc.sawEOF &amp;&amp;</span><br><span class="line">    pc.wroteRequest() &amp;&amp;</span><br><span class="line">    tryPutIdleConn(trace)</span><br></pre></td></tr></table></figure><p><code>bodyEOF</code> 来源于到一个通道 <code>waitForBodyRead</code>，这个字段的 <code>true</code> 和 <code>false</code> 直接决定了 <code>alive</code> 变量的值（<code>alive=true</code>那<code>读goroutine</code>继续活着，循环，否则退出<code>goroutine</code>）。</p><h5 id="那么这个通道的值是从哪里过来的呢？"><a href="#那么这个通道的值是从哪里过来的呢？" class="headerlink" title="那么这个通道的值是从哪里过来的呢？"></a>那么这个通道的值是从哪里过来的呢？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// go/1.12.7/libexec/src/net/http/transport.go: 1758</span></span><br><span class="line">body := &amp;bodyEOFSignal&#123;</span><br><span class="line">body: resp.Body,</span><br><span class="line">earlyCloseFn: <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">waitForBodyRead &lt;- <span class="literal">false</span></span><br><span class="line">&lt;-eofc <span class="comment">// will be closed by deferred call at the end of the function</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">&#125;,</span><br><span class="line">fn: <span class="function"><span class="keyword">func</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">isEOF := err == io.EOF</span><br><span class="line">waitForBodyRead &lt;- isEOF</span><br><span class="line"><span class="keyword">if</span> isEOF &#123;</span><br><span class="line">&lt;-eofc <span class="comment">// see comment above eofc declaration</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> cerr := pc.canceled(); cerr != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> cerr</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如果执行 <code>earlyCloseFn</code> ，<code>waitForBodyRead</code> 通道输入的是 <code>false</code>，<code>alive</code> 也会是 <code>false</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就会退出。</li><li>如果执行 <code>fn</code> ，其中包括正常情况下 <code>body</code> 读完数据抛出 <code>io.EOF</code> 时的 <code>case</code>，<code>waitForBodyRead</code> 通道输入的是 <code>true</code>，那 <code>alive</code> 会是 <code>true</code>，那么 <code>readLoop()</code> 这个 <code>goroutine</code> 就不会退出，同时还顺便执行了 <code>tryPutIdleConn(trace)</code> 。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting</span></span><br><span class="line"><span class="comment">// a new request.</span></span><br><span class="line"><span class="comment">// If pconn is no longer needed or not in a good state, tryPutIdleConn returns</span></span><br><span class="line"><span class="comment">// an error explaining why it wasn&#x27;t registered.</span></span><br><span class="line"><span class="comment">// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Transport)</span> <span class="title">tryPutIdleConn</span><span class="params">(pconn *persistConn)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure><ul><li><code>tryPutIdleConn</code> 将 <code>pconn</code> 添加到等待新请求的空闲持久连接列表中，也就是之前说的连接会复用。</li></ul><h5 id="那么问题又来了，什么时候会执行这个-fn-和-earlyCloseFn-呢？"><a href="#那么问题又来了，什么时候会执行这个-fn-和-earlyCloseFn-呢？" class="headerlink" title="那么问题又来了，什么时候会执行这个 fn 和 earlyCloseFn 呢？"></a>那么问题又来了，什么时候会执行这个 <code>fn</code> 和 <code>earlyCloseFn</code> 呢？</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">es.mu.Lock()</span><br><span class="line"><span class="keyword">defer</span> es.mu.Unlock()</span><br><span class="line"><span class="keyword">if</span> es.closed &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">es.closed = <span class="literal">true</span></span><br><span class="line"><span class="keyword">if</span> es.earlyCloseFn != <span class="literal">nil</span> &amp;&amp; es.rerr != io.EOF &#123;</span><br><span class="line"><span class="keyword">return</span> es.earlyCloseFn() <span class="comment">// 关闭时执行 earlyCloseFn</span></span><br><span class="line">&#125;</span><br><span class="line">err := es.body.Close()</span><br><span class="line"><span class="keyword">return</span> es.condfn(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面这个其实就是我们比较收悉的 <code>resp.Body.Close()</code> ,在里面会执行 <code>earlyCloseFn</code>，也就是此时 <code>readLoop()</code> 里的 <code>waitForBodyRead</code> 通道输入的是 <code>false</code>，<code>alive</code> 也会是 <code>false</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就会退出，<code>goroutine</code> 不会泄露。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">b, err = ioutil.ReadAll(resp.Body)</span><br><span class="line">--<span class="function"><span class="keyword">func</span> <span class="title">ReadAll</span><span class="params">(r io.Reader)</span></span> </span><br><span class="line">----<span class="function"><span class="keyword">func</span> <span class="title">readAll</span><span class="params">(r io.Reader, capacity <span class="keyword">int64</span>)</span></span> </span><br><span class="line">------<span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// go/1.12.7/libexec/src/bytes/buffer.go:207</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(b *Buffer)</span> <span class="title">ReadFrom</span><span class="params">(r io.Reader)</span> <span class="params">(n <span class="keyword">int64</span>, err error)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">...</span><br><span class="line">m, e := r.Read(b.buf[i:<span class="built_in">cap</span>(b.buf)])  <span class="comment">// 看这里，是body在执行read方法</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这个<code>read</code>，其实就是 <code>bodyEOFSignal</code> 里的</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">Read</span><span class="params">(p []<span class="keyword">byte</span>)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">n, err = es.body.Read(p)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">... </span><br><span class="line">    <span class="comment">// 这里会有一个io.EOF的报错，意思是读完了</span></span><br><span class="line">err = es.condfn(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(es *bodyEOFSignal)</span> <span class="title">condfn</span><span class="params">(err error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> es.fn == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">err = es.fn(err)  <span class="comment">// 这了执行了 fn</span></span><br><span class="line">es.fn = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上面这个其实就是我们比较收悉的读取 <code>body</code> 里的内容。 <code>ioutil.ReadAll()</code> ,在读完 <code>body</code> 的内容时会执行 <code>fn</code>，也就是此时 <code>readLoop()</code> 里的 <code>waitForBodyRead</code> 通道输入的是 <code>true</code>，<code>alive</code> 也会是 <code>true</code>，那 <code>readLoop()</code> 这个 <code>goroutine</code> 就不会退出，<code>goroutine</code> 会泄露，然后执行 <code>tryPutIdleConn(trace)</code> 把连接放回池子里复用。<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2></li><li>所以结论呼之欲出了，虽然执行了 <code>6</code> 次循环，而且每次都没有执行 <code>Body.Close()</code> ,就是因为执行了<code>ioutil.ReadAll()</code>把内容都读出来了，连接得以复用，因此只泄漏了一个<code>读goroutine</code>和一个<code>写goroutine</code>，最后加上<code>main goroutine</code>，所以答案就是<code>3个goroutine</code>。</li><li>从另外一个角度说，正常情况下我们的代码都会执行 <code>ioutil.ReadAll()</code>，但如果此时忘了 <code>resp.Body.Close()</code>，确实会导致泄漏。但如果你<strong>调用的域名一直是同一个</strong>的话，那么只会泄漏一个 <code>读goroutine</code> 和一个<code>写goroutine</code>，<strong>这就是为什么代码明明不规范但却看不到明显内存泄漏的原因</strong>。</li><li>那么问题又来了，为什么上面要特意强调是同一个域名呢？改天，回头，以后有空再说吧。</li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/myGJ4TrEoVGqLAN3tbZHMw">连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。</a> </li><li><a href="https://mp.weixin.qq.com/s/SHxcspmiKyPwPBbhfVxsGA">昨天那个在for循环里append元素的同事，今天还在么？</a> </li><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有中文、数字、英文字母的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"><a href="#如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。" class="headerlink" title="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"></a>如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。</h6>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。</title>
      <link href="/2020/10/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%9Enil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%80%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%83%BD%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%9F%E9%82%A3BAT%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AA%E5%A5%BD%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%E4%BA%86%E3%80%82/"/>
      <url>/2020/10/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%9Enil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%80%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%83%BD%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%9F%E9%82%A3BAT%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AA%E5%A5%BD%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%E4%BA%86%E3%80%82/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/640-20210524195843699.png" alt="img"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s1 []<span class="keyword">int</span>   <span class="comment">// nil切片</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)  <span class="comment">// 空切片</span></span><br><span class="line">s4 := <span class="built_in">make</span>([]<span class="keyword">int</span>,<span class="number">0</span>)   <span class="comment">// 空切片</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;s1 pointer:%+v, s2 pointer:%+v, s4 pointer:%+v, \n&quot;</span>, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4)))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4))).Data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>nil切片和空切片指向的地址一样吗？这个代码会输出什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）</strong></li><li><strong>空切片的引用数组指针地址是有的，且固定为一个值</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s1 pointer:&#123;Data:0 Len:0 Cap:0&#125;, s2 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, s4 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, </span><br><span class="line">false //nil切片和空切片指向的数组地址不一样</span><br><span class="line">true  //两个空切片指向的数组地址是一样的，都是824634207952</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>之前在<a href="https://zhuanlan.zhihu.com/p/144923309">前面的文章</a>里提到过切片的数据结构为</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line"> Data <span class="keyword">uintptr</span>  <span class="comment">//引用数组指针地址</span></span><br><span class="line"> Len  <span class="keyword">int</span>     <span class="comment">// 切片的目前使用长度</span></span><br><span class="line"> Cap  <span class="keyword">int</span>     <span class="comment">// 切片的容量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>nil切片和空切片最大的区别在于<strong>指向的数组引用地址是不一样的</strong>。<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/640.png" alt="img"></p></li><li><p><strong>所有的空切片指向的数组引用地址都是一样的</strong><br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/640-20210524195829623.png" alt="img"></p></li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/257802146">昨天那个在for循环里append元素的同事，今天还在么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/150629411">对已经关闭的的 chan 进行读写，会怎么样？为什么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/149796956">对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/148341972">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/148175563">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/146590283">golang面试题：怎么避免内存逃逸？？</a></li><li><a href="https://zhuanlan.zhihu.com/p/145468000">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://zhuanlan.zhihu.com/p/144923309">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/143056105">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://zhuanlan.zhihu.com/p/144980413">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://zhuanlan.zhihu.com/p/145220416">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"><a href="#如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。" class="headerlink" title="如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。"></a>如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。</h6>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>昨天那个在for循环里append元素的同事，今天还在么？</title>
      <link href="/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%98%A8%E5%A4%A9%E9%82%A3%E4%B8%AA%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E9%87%8Cappend%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8C%E4%BA%8B%EF%BC%8C%E4%BB%8A%E5%A4%A9%E8%BF%98%E5%9C%A8%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%98%A8%E5%A4%A9%E9%82%A3%E4%B8%AA%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E9%87%8Cappend%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8C%E4%BA%8B%EF%BC%8C%E4%BB%8A%E5%A4%A9%E8%BF%98%E5%9C%A8%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2020/09/23/cPoMQsnbLIExiBZ.png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"><span class="keyword">for</span> _, v:=<span class="keyword">range</span> s &#123;</span><br><span class="line">s =<span class="built_in">append</span>(s, v)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s)=%v\n&quot;</span>,<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这个代码会造成死循环吗？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li><strong>不会死循环</strong>，<code>for range</code>其实是<code>golang</code>的<code>语法糖</code>，在循环开始前会获取切片的长度 <code>len(切片)</code>，然后再执行<code>len(切片)</code>次数的循环。</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>for range</code>的源码是<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The loop we generate:</span></span><br><span class="line"><span class="comment">//   for_temp := range</span></span><br><span class="line"><span class="comment">//   len_temp := len(for_temp)</span></span><br><span class="line"><span class="comment">//   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;</span></span><br><span class="line"><span class="comment">//           value_temp = for_temp[index_temp]</span></span><br><span class="line"><span class="comment">//           index = index_temp</span></span><br><span class="line"><span class="comment">//           value = value_temp</span></span><br><span class="line"><span class="comment">//           original body</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br></pre></td></tr></table></figure></li><li>上面的代码会被编译器认为是</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">for_temp := s</span><br><span class="line">len_temp := <span class="built_in">len</span>(for_temp)</span><br><span class="line"><span class="keyword">for</span> index_temp := <span class="number">0</span>; index_temp &lt; len_temp; index_temp++ &#123;</span><br><span class="line">value_temp := for_temp[index_temp]</span><br><span class="line">_ = index_temp</span><br><span class="line">value := value_temp</span><br><span class="line"><span class="comment">// 以下是 original body</span></span><br><span class="line">s =<span class="built_in">append</span>(s, value)</span><br><span class="line">fmt.Printf(<span class="string">&quot;len(s)=%v\n&quot;</span>,<span class="built_in">len</span>(s))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码运行输出<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">len</span>(s)=<span class="number">6</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">7</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">8</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">9</span></span><br><span class="line"><span class="built_in">len</span>(s)=<span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>所以说，那个同事用的是golang吗？</strong></p><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/lK6I353Iw08robqpmPB6-g">golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？</a> </li><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://s1.ax1x.com/2020/09/22/wqH8c8.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>怎么避免内存逃逸？</title>
      <link href="/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%83%BD%E8%AF%B4%E8%AF%B4uintptr%E5%92%8Cunsafe.Pointer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/"/>
      <url>/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%83%BD%E8%AF%B4%E8%AF%B4uintptr%E5%92%8Cunsafe.Pointer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jZDJkODUxZS1hZWQ1LTRlNjYtOGFmNy0wMjczZDc0NDgzNzAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>怎么避免<strong>内存逃逸</strong>？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>在<code>runtime/stubs.go:133</code>有个函数叫<code>noescape</code>。<code>noescape</code>可以在逃逸分析中<strong>隐藏一个指针</strong>。让这个指针在逃逸分析中<strong>不会被检测为逃逸</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// noescape hides a pointer from escape analysis.  noescape is</span></span><br><span class="line"> <span class="comment">// the identity function but escape analysis doesn&#x27;t think the</span></span><br><span class="line"> <span class="comment">// output depends on the input.  noescape is inlined and currently</span></span><br><span class="line"> <span class="comment">// compiles down to zero instructions.</span></span><br><span class="line"> <span class="comment">// USE CAREFULLY!</span></span><br><span class="line"> <span class="comment">//go:nosplit</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">     x := <span class="keyword">uintptr</span>(p)</span><br><span class="line">     <span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">S *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *f.S</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ATrick <span class="keyword">struct</span> &#123;</span><br><span class="line">S unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ATrick)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(f.S)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> A&#123;S: &amp;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewATrick</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">ATrick</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">x := <span class="keyword">uintptr</span>(p)</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">f1 := NewA(s)</span><br><span class="line">f2 := NewATrick(s)</span><br><span class="line">s1 := f1.String()</span><br><span class="line">s2 := f2.String()</span><br><span class="line">_ = s1 + s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">6</span>: can inline (*ATrick).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">6</span>: can inline NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">6</span>: can inline noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">6</span>: can inline NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">29</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">36</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: inlining call to NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">17</span>: inlining call to (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">17</span>: inlining call to (*ATrick).String</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build763863171/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">15</span>: noescape p does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">10</span>: main f1 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">10</span>: main f2 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">42</span>:<span class="number">9</span>: main s1 + s2 does not escape</span><br></pre></td></tr></table></figure><p>其中主要看中间一小段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap    <span class="comment">//这个是NewA中的，逃逸了</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape <span class="comment">// NewATrick里的s的却没逃逸</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p>上段代码对<code>A</code>和<code>ATrick</code>同样的功能有两种实现：他们包含一个 <code>string</code> ，然后用 <code>String()</code> 方法返回这个字符串。但是从逃逸分析看<code>ATrick</code> 版本没有逃逸。</p></li><li><p><code>noescape()</code> 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 <code>p</code> 会通过 <code>x</code> 逃逸， 因为 <code>uintptr()</code> 产生的引用是编译器无法理解的。</p></li><li><p>内置的 <code>uintptr</code> 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 <code>指针地址</code> 的 <code>int</code> 类型。代码的最后一行返回 <code>unsafe.Pointer</code> 也是一个 <code>int</code>。</p></li><li><p><code>noescape()</code> 在 <code>runtime</code> 包中使用 <code>unsafe.Pointer</code> 的地方被大量使用。如果作者清楚被 <code>unsafe.Pointer</code> 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。</p></li><li><p><strong>面试中秀一秀是可以的</strong>，如果在实际项目中如果使用这种unsafe包大概率会被同事打死。<strong>不建议使用！</strong>  毕竟包的名字就叫做 <code>unsafe</code>, 而且源码中的注释也写明了 <code>USE CAREFULLY! </code>。</p></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试官：for select时，如果通道已经关闭会怎么样？如果select中只有一个case呢？</title>
      <link href="/2020/08/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/for%20select%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%80%9A%E9%81%93%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcase%E5%91%A2%EF%BC%9F/"/>
      <url>/2020/08/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/for%20select%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%80%9A%E9%81%93%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcase%E5%91%A2%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8yNDFlZTVhYy1kMGY1LTQzZDEtYTU5ZC0yMzExODgzNzMzNDkucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>for</code>循环<code>select</code>时，如果通道已经关闭会怎么样？如果<code>select</code>中的<code>case</code>只有一个，又会怎么样？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>for循环<code>select</code>时，如果其中一个case通道已经关闭，则每次都会执行到这个case。</li><li>如果select里边只有一个case，而这个case被关闭了，则会出现死循环。</li></ul><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><h3 id="1-for循环里被关闭的通道"><a href="#1-for循环里被关闭的通道" class="headerlink" title="1.for循环里被关闭的通道"></a>1.for循环里被关闭的通道</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNmU5MzM4MS03YTk3LTRmMDgtODljOS1lODkwNDg1YmE2YmUucG5n?x-oss-process=image/format,png"></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS84OWMxMWU0OS0zYThiLTQxYTAtYmE3MC1mZmQwZWRkOTExMTcucG5n?x-oss-process=image/format,png"></p><ul><li><code>c通道</code>是一个缓冲为<code>0</code>的通道，在<code>main</code>开始时，启动一个协程对<code>c通道</code>写入<code>10</code>，然后就关闭掉这个通道。</li><li>在<code>main</code>中通过 <code>x, ok := &lt;-c</code> 接受<code>通道c</code>里的值，从输出结果里看出，确实从通道里读出了之前塞入通道的<code>10</code>，但是在通道关闭后，这个通道一直能读出内容。</li></ul><h3 id="2-怎么样才能不读关闭后通道"><a href="#2-怎么样才能不读关闭后通道" class="headerlink" title="2.怎么样才能不读关闭后通道"></a>2.怎么样才能不读关闭后通道</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9lNDlmNDE4Mi03MGQyLTQxYjAtODRjYy05M2VkMzMxYjc3YjUucG5n?x-oss-process=image/format,png"></p><ul><li><code>x, ok := &lt;-c</code> 返回的值里第一个x是通道内的值，<code>ok</code>是指通道是否关闭，当通道被关闭后，<code>ok</code>则返回<code>false</code>，因此可以根据这个进行操作。读一个已经关闭的通道为什么会出现false，可以看我之前的 <a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">对已经关闭的的chan进行读写，会怎么样？为什么？</a> 。</li><li>当返回的<code>ok</code>为<code>false</code>时，执行<code>c = nil</code> 将通道置为<code>nil</code>，相当于读一个未初始化的通道，则会一直阻塞。至于为什么读一个未初始化的通道会出现阻塞，可以看我的另一篇 <a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">对未初始化的的chan进行读写，会怎么样？为什么？</a> 。<code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。则<code>select</code>会跳过这个阻塞<code>case</code>，可以解决不断读已关闭通道的问题。</li></ul><h3 id="3-如果select里只有一个已经关闭的case，会怎么样？"><a href="#3-如果select里只有一个已经关闭的case，会怎么样？" class="headerlink" title="3.如果select里只有一个已经关闭的case，会怎么样？"></a>3.如果select里只有一个已经关闭的case，会怎么样？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82ZGMxZDQ1Zi04MDk1LTQ1ODAtODUxNi04MWZmNDdkNTI4MGEucG5n?x-oss-process=image/format,png"></p><ul><li>可以看出只有一个<code>case</code>的情况下，则会<code>死循环</code>。</li><li>那如果像上面一个<code>case</code>那样，把通道置为<code>nil</code>就能解决问题了吗？</li></ul><h3 id="4-select里只有一个已经关闭的case，置为nil，会怎么样？"><a href="#4-select里只有一个已经关闭的case，置为nil，会怎么样？" class="headerlink" title="4.select里只有一个已经关闭的case，置为nil，会怎么样？"></a>4.select里只有一个已经关闭的case，置为nil，会怎么样？</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9hZTAyNWU4NS0yNzZjLTQyMDItYWU2Ny0yMGQ4Njk1Y2I3MTQucG5n?x-oss-process=image/format,png"></p><ul><li>第一次读取<code>case</code>能读到通道里的<code>10</code></li><li>第二次读取<code>case</code>能读到通道已经关闭的信息。此时将通道置为<code>nil</code></li><li>第三次读取<code>case</code>时main协程会被阻塞，此时整个进程没有其他活动的协程了，进程<code>deadlock</code></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。</li><li>如果没有<code>default</code>字句，<code>select</code>将有可能阻塞，直到某个通道有值可以运行，所以<code>select</code>里最好有一个<code>default</code>，否则将有一直阻塞的风险。</li></ul><h2 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h2><ul><li><a href="https://mp.weixin.qq.com/s/qm-8pvHBVRmLQQ4_DHc1Tw">golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ODZiZWU0YS03NzQ1LTQ0YjMtYTFhOS0wMzc5ODIzOGNkNmQucG5n?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？</title>
      <link href="/2020/07/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areflect%EF%BC%88%E5%8F%8D%E5%B0%84%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%20tag%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%20json%20%E5%8C%85%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%20tag%EF%BC%9F/"/>
      <url>/2020/07/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areflect%EF%BC%88%E5%8F%8D%E5%B0%84%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%20tag%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%20json%20%E5%8C%85%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%20tag%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9kYmE0ODBhYS04ZjNiLTQ2MmMtOTUzYy04OWUxYmNlYmE5YzQucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>json</code>包里使用的时候，会结构体里的字段边上加<code>tag</code>，有没有什么办法可以获取到这个<code>tag</code>的内容呢？</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><code>tag</code>信息可以通过<code>反射（reflect包）</code>内的方法获取，通过一个例子加深理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;reflect&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">string</span> <span class="comment">//小写无tag</span></span><br><span class="line">    b <span class="keyword">string</span> <span class="string">`json:&quot;B&quot;`</span> <span class="comment">//小写+tag</span></span><br><span class="line">    C <span class="keyword">string</span> <span class="comment">//大写无tag</span></span><br><span class="line">    D <span class="keyword">string</span> <span class="string">`json:&quot;DD&quot; otherTag:&quot;good&quot;`</span> <span class="comment">//大写+tag</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printTag</span><span class="params">(stru <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">    t := reflect.TypeOf(stru).Elem()</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        fmt.Printf(<span class="string">&quot;结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \n&quot;</span>, i+<span class="number">1</span>, t.Field(i).Name, t.Field(i).Tag.Get(<span class="string">&quot;json&quot;</span>), t.Field(i).Tag.Get(<span class="string">&quot;otherTag&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j := J&#123;</span><br><span class="line">      a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      b: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">      C: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">      D: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    printTag(&amp;j)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">结构体内第<span class="number">1</span>个字段 a 对应的json tag是  , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">2</span>个字段 b 对应的json tag是 B , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">3</span>个字段 C 对应的json tag是  , 还有otherTag？ =  </span><br><span class="line">结构体内第<span class="number">4</span>个字段 D 对应的json tag是 DD , 还有otherTag？ = good </span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>printTag</code>方法传入的是j的指针。</li><li><code>reflect.TypeOf(stru).Elem()</code>获取指针指向的值对应的结构体内容。</li><li><code>NumField()</code>可以获得该结构体含有几个字段。</li><li>遍历结构体内的字段，通过<code>t.Field(i).Tag.Get(&quot;json&quot;)</code>可以获取到<code>tag</code>为<code>json</code>的字段。</li><li>如果结构体的字段有<code>多个tag</code>，比如叫<code>otherTag</code>,同样可以通过<code>t.Field(i).Tag.Get(&quot;otherTag&quot;)</code>获得。</li></ul><h2 id="再补一句"><a href="#再补一句" class="headerlink" title="再补一句"></a>再补一句</h2><p><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483698&idx=1&sn=352a5cddf20fe95f5ec26bfc9a6de64b&chksm=9aee289bad99a18d9914d085421e4f218b18d4f0c7a24da306642816e91fb4b235be6aea0e40&token=961196008&lang=zh_CN#rd">上篇文章</a> 提到<code>json包</code>不能导出<code>私有变量的tag</code>是因为<strong>取不到</strong><code>反射信息</code>的说法，但是直接取<code>t.Field(i).Tag.Get(&quot;json&quot;)</code><strong>却可以</strong>获取到私有变量的<code>json字段</code>，是<strong>为什么</strong>呢？  </p><p>其实<strong>准确的</strong>说法是，<code>json</code>包里不能导出私有变量的<code>tag</code>是因为<code>json</code>包里认为私有变量为不可导出的<code>Unexported</code>，所以<strong>跳过获取</strong>名为<code>json</code>的<code>tag</code>的内容。<br>具体可以看<code>/src/encoding/json/encode.go:1070</code>的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">typeFields</span><span class="params">(t reflect.Type)</span> []<span class="title">field</span></span> &#123;</span><br><span class="line">    <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">    <span class="comment">// 遍历结构体内的每个字段</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; f.typ.NumField(); i++ &#123;</span><br><span class="line">        sf := f.typ.Field(i)</span><br><span class="line">        isUnexported := sf.PkgPath != <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">        <span class="keyword">if</span> isUnexported &#123;</span><br><span class="line">            <span class="comment">// 如果是不可导出的变量则跳过</span></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是可导出的变量（public），则获取其json字段</span></span><br><span class="line">        tag := sf.Tag.Get(<span class="string">&quot;json&quot;</span>)</span><br><span class="line">        <span class="comment">// 注释掉其他逻辑...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 注释掉其他逻辑... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？</title>
      <link href="/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8xNDVkOWZiZjQ0NzM0M2Q5YmIxODM4YjNmMzk4MjRhNi5wbmc?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对<strong>已经关闭</strong>的的<code>chan</code>进行读写，会怎么样？<strong>为什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>读<strong>已经关闭</strong>的<code>chan</code>能一直读到东西，但是读到的内容根据通道内<code>关闭前</code>是否有元素而不同。<ul><li>如果<code>chan</code>关闭前，<code>buffer</code>内有元素<strong>还未读</strong>,会正确读到<code>chan</code>内的值，且返回的第二个bool值（是否读成功）为<code>true</code>。</li><li>如果<code>chan</code>关闭前，<code>buffer</code>内有元素<strong>已经被读完</strong>，<code>chan</code>内无值，接下来所有接收的值都会非阻塞直接成功，返回 <code>channel</code> 元素的<strong>零值</strong>，但是第二个<code>bool</code>值一直为<code>false</code>。</li></ul></li><li>写<strong>已经关闭</strong>的<code>chan</code>会<code>panic</code></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h5 id="1-写已经关闭的chan"><a href="#1-写已经关闭的chan" class="headerlink" title="1.写已经关闭的chan"></a>1.写已经关闭的chan</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC9lYjlhZGRhNDU3NGU0ZTAyYjJlODczN2JkODI5NWE0NC5wbmc?x-oss-process=image/format,png"></p><ul><li>注意这个<code>send on closed channel</code>，待会会提到。</li></ul><h5 id="2-读已经关闭的chan"><a href="#2-读已经关闭的chan" class="headerlink" title="2.读已经关闭的chan"></a>2.读已经关闭的chan</h5><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC8wZTcyNTVkNzI5NDI0Y2NhYTBhNGNjNmQ5ZGU1MTBkMi5wbmc?x-oss-process=image/format,png"></p><h2 id="多问一句"><a href="#多问一句" class="headerlink" title="多问一句"></a>多问一句</h2><p><strong>1.为什么写已经关闭的<code>chan</code>就会<code>panic</code>呢？</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC81Njc2MDBmYmEyNDE0MjcwYWQ3YWU0YTFjY2RhODQwMy5wbmc?x-oss-process=image/format,png"></p><ul><li>当<code>c.closed != 0</code>则为通道关闭，此时执行写，源码提示直接panic，输出的内容就是上面提到的<code>&quot;send on closed channel&quot;</code>。</li></ul><p><strong>2. 为什么读已关闭的<code>chan</code>会一直能读到值？</strong><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zdGF0aWMwMS5pbWdrci5jb20vdGVtcC80YmNjMGYwNjI3MzE0Y2JiYWRkMWI0ODRjNTE4OTRkOS5wbmc?x-oss-process=image/format,png"></p><ul><li><code>c.closed != 0 &amp;&amp; c.qcount == 0</code>指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值）</li><li>如果接收值的地址<code>ep</code>不为空<ul><li>那接收值将获得是一个<strong>该类型的零值</strong></li><li><code>typedmemclr</code> 会<strong>根据类型清理</strong>相应地址的内存</li><li>这就解释了上面代码为什么关闭的<code>chan</code>会返回对应类型的零值</li></ul></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s/ixJu0wrGXsCcGzveCqnr6A">对未初始化的的chan进行读写，会怎么样？为什么？</a> </li><li><a href="https://mp.weixin.qq.com/s/WK9StkC3Jfy-o1dUqlo7Dg">golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？</a> </li><li><a href="https://mp.weixin.qq.com/s/zZM_iLuopyenI0LD6VYZGw">golang面试题：json包变量不加tag会怎么样？</a> </li><li><a href="https://mp.weixin.qq.com/s/4QAxGEr9KxtZXyfSG8VoCQ">golang面试题：怎么避免内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/4YYR1eYFIFsNOaTxL4Q-eQ">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s/d80m0hgoKcHfKp4ZXH1M4A">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s/OIRPOszH-rTJp03AeRgnRQ">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s/hPYdiHYRufimyKT4FcW4HA">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s/IkOwh9bh36vK6JgN7b3KjA">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id="如果你想每天学习一个知识点？"><a href="#如果你想每天学习一个知识点？" class="headerlink" title="如果你想每天学习一个知识点？"></a>如果你想每天学习一个知识点？</h6><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85ODZiZWU0YS03NzQ1LTQ0YjMtYTFhOS0wMzc5ODIzOGNkNmQucG5n?x-oss-process=image/format,png"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？</title>
      <link href="/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
      <url>/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8zNjlhMWU4Zi1lNWExLTQ1N2YtYmJmNy1iMjA1Yjc5NjlhYTAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对<strong>未初始化</strong>的的<code>chan</code>进行读写，会怎么样？<strong>为什么？</strong></p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>读写<strong>未初始化</strong>的<code>chan</code>都会<strong>阻塞</strong>。</p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><h5 id="1-写未初始化的chan"><a href="#1-写未初始化的chan" class="headerlink" title="1.写未初始化的chan"></a>1.写未初始化的chan</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">// 写未初始化的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">c &lt;- <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> send (<span class="literal">nil</span> <span class="keyword">chan</span>)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/admin18/<span class="keyword">go</span>/src/repos/main.<span class="keyword">go</span>:<span class="number">6</span> +<span class="number">0x36</span></span><br></pre></td></tr></table></figure><p>注意这个<code>chan send (nil chan)</code>，待会会提到。</p><h5 id="2-写读未初始化的chan"><a href="#2-写读未初始化的chan" class="headerlink" title="2.写读未初始化的chan"></a>2.写读未初始化的chan</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">// 读未初始化的chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">num, ok := &lt;-c</span><br><span class="line">fmt.Printf(<span class="string">&quot;读chan的协程结束, num=%v, ok=%v\n&quot;</span>, num, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine <span class="number">1</span> [<span class="keyword">chan</span> receive (<span class="literal">nil</span> <span class="keyword">chan</span>)]:</span><br><span class="line">main.main()</span><br><span class="line">        /Users/admin18/<span class="keyword">go</span>/src/repos/main.<span class="keyword">go</span>:<span class="number">6</span> +<span class="number">0x46</span></span><br></pre></td></tr></table></figure><p>注意这个<code>chan receive (nil chan)</code>，待会也会提到。</p><h2 id="多问一句"><a href="#多问一句" class="headerlink" title="多问一句"></a>多问一句</h2><p>关于<code>chan</code>的面试题非常多，这个是比较常见的其中一个。但多问一句：<strong>为什么对未初始化的<code>chan</code>就会阻塞呢？</strong></p><p><strong>1.对于写的情况</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 src/runtime/chan.go中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>, callerpc <span class="keyword">uintptr</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="comment">// 不能阻塞，直接返回 false，表示未发送成功</span></span><br><span class="line">      <span class="keyword">if</span> !block &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">      gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">      throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">// 省略其他逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>未初始化的<code>chan</code>此时是等于<code>nil</code>，当它不能阻塞的情况下，直接返回 <code>false</code>，表示写 <code>chan</code> 失败</li><li>当<code>chan</code>能阻塞的情况下，则直接阻塞 <code>gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) </code>, 然后调用<code>throw(s string)</code>抛出错误,其中<code>waitReasonChanSendNilChan</code>就是刚刚提到的报错<code>&quot;chan send (nil chan)&quot;</code></li></ul><p><strong>2. 对于读的情况</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 src/runtime/chan.go中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="keyword">bool</span>)</span> <span class="params">(selected, received <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//省略逻辑...</span></span><br><span class="line">    <span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> !block &#123;</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//省略逻辑...</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><ul><li>未初始化的<code>chan</code>此时是等于<code>nil</code>，当它不能阻塞的情况下，直接返回 <code>false</code>，表示读 <code>chan</code> 失败</li><li>当<code>chan</code>能阻塞的情况下，则直接阻塞 <code>gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) </code>, 然后调用<code>throw(s string)</code>抛出错误,其中<code>waitReasonChanReceiveNilChan</code>就是刚刚提到的报错<code>&quot;chan receive (nil chan)&quot;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：json包变量不加tag会怎么样？</title>
      <link href="/2020/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajson%E5%8C%85%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8A%A0tag%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F/"/>
      <url>/2020/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajson%E5%8C%85%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8A%A0tag%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81MWY1ZjQ0NS04YzczLTQ1YTYtOTcxOS02NjI2M2Q4NDY2MTYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>json</code>包里使用的时候，结构体里的变量不加<code>tag</code>能不能正常转成<code>json</code>里的字段？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><ul><li>如果变量<code>首字母小写</code>，则为<code>private</code>。无论如何<code>不能转</code>，因为取不到<code>反射信息</code>。</li><li>如果变量<code>首字母大写</code>，则为<code>public</code>。<ul><li><code>不加tag</code>，可以正常转为<code>json</code>里的字段，<code>json</code>内字段名跟结构体内字段<code>原名一致</code>。</li><li><code>加了tag</code>，从<code>struct</code>转<code>json</code>的时候，<code>json</code>的字段名就是<code>tag</code>里的字段名，原字段名已经没用。</li></ul></li></ul><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>通过一个例子加深理解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;encoding/json&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> J <span class="keyword">struct</span> &#123;</span><br><span class="line">    a <span class="keyword">string</span>             <span class="comment">//小写无tag</span></span><br><span class="line">    b <span class="keyword">string</span> <span class="string">`json:&quot;B&quot;`</span>  <span class="comment">//小写+tag</span></span><br><span class="line">    C <span class="keyword">string</span>             <span class="comment">//大写无tag</span></span><br><span class="line">    D <span class="keyword">string</span> <span class="string">`json:&quot;DD&quot;`</span> <span class="comment">//大写+tag</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    j := J &#123;</span><br><span class="line">      a: <span class="string">&quot;1&quot;</span>,</span><br><span class="line">      b: <span class="string">&quot;2&quot;</span>,</span><br><span class="line">      C: <span class="string">&quot;3&quot;</span>,</span><br><span class="line">      D: <span class="string">&quot;4&quot;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json前j结构体的内容 = %+v\n&quot;</span>, j)</span><br><span class="line">    jsonInfo, _ := json.Marshal(j)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;转为json后的内容 = %+v\n&quot;</span>, <span class="keyword">string</span>(jsonInfo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">转为json前j结构体的内容 = &#123;a:<span class="number">1</span> b:<span class="number">2</span> C:<span class="number">3</span> D:<span class="number">4</span>&#125;</span><br><span class="line">转为json后的内容 = &#123;<span class="string">&quot;C&quot;</span>:<span class="string">&quot;3&quot;</span>,<span class="string">&quot;DD&quot;</span>:<span class="string">&quot;4&quot;</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>结构体里定义了四个字段，分别对应 <code>小写无tag</code>，<code>小写+tag</code>，<code>大写无tag</code>，<code>大写+tag</code>。</li><li>转为<code>json</code>后首字母<code>小写的</code>不管加不加tag<code>都不能</code>转为<code>json</code>里的内容，而<code>大写的</code>加了<code>tag</code>可以<code>取别名</code>，不加<code>tag</code>则<code>json</code>内的字段跟结构体字段<code>原名一致</code>。</li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483692&idx=1&sn=d5d34fad7a4553e0b9d5714385b7af48&chksm=9aee2885ad99a193253c1e57bd361b3f5af643d3ba14f56f25c0c5551990c848c6f30a5ca23e&token=961196008&lang=zh_CN#rd">golang面试题：怎么避免内存逃逸？？</a> </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：字符串转成byte数组，会发生内存拷贝吗？</title>
      <link href="/2020/05/17/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90byte%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/17/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90byte%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS83OGRhNTQ2My01M2ViLTRjNTctYTA4Yy0wOWJhNGYyOGZmOTYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>字符串转成byte数组，会发生内存拷贝吗？ </p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。<br>频繁的内存拷贝操作听起来对性能不大友好。<strong>有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？</strong> </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;reflect&quot;</span></span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">a :=<span class="string">&quot;aaa&quot;</span></span><br><span class="line">ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</span><br><span class="line">b := *(*[]<span class="keyword">byte</span>)(unsafe.Pointer(&amp;ssh))  </span><br><span class="line">fmt.Printf(<span class="string">&quot;%v&quot;</span>,b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p><code>StringHeader</code> 是<code>字符串</code>在go的底层结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StringHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>SliceHeader</code> 是<code>切片</code>在go的底层结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>那么如果想要在底层转换二者，只需要把 <code>StringHeader</code> 的地址强转成 <code>SliceHeader</code> 就行。那么go有个很强的包叫 <code>unsafe</code> 。    </p><ul><li><p>1.<code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址。  </p></li><li><p>2.<code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式。  </p></li><li><p>3.<code>(*[]byte)(unsafe.Pointer(&amp;ssh)) </code> 可以把ssh底层结构体转成byte的切片的指针。</p></li><li><p>4.再通过 <code>*</code>转为指针指向的实际内容。</p></li></ul></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：怎么避免内存逃逸？</title>
      <link href="/2020/05/16/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/"/>
      <url>/2020/05/16/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jZDJkODUxZS1hZWQ1LTRlNjYtOGFmNy0wMjczZDc0NDgzNzAucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>怎么避免<strong>内存逃逸</strong>？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>在<code>runtime/stubs.go:133</code>有个函数叫<code>noescape</code>。<code>noescape</code>可以在逃逸分析中<strong>隐藏一个指针</strong>。让这个指针在逃逸分析中<strong>不会被检测为逃逸</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// noescape hides a pointer from escape analysis.  noescape is</span></span><br><span class="line"> <span class="comment">// the identity function but escape analysis doesn&#x27;t think the</span></span><br><span class="line"> <span class="comment">// output depends on the input.  noescape is inlined and currently</span></span><br><span class="line"> <span class="comment">// compiles down to zero instructions.</span></span><br><span class="line"> <span class="comment">// USE CAREFULLY!</span></span><br><span class="line"> <span class="comment">//go:nosplit</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">     x := <span class="keyword">uintptr</span>(p)</span><br><span class="line">     <span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><ul><li>通过一个例子加深理解，接下来尝试下怎么通过 <code>go build -gcflags=-m</code> 查看逃逸的情况。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;unsafe&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">S *<span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *A)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *f.S</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> ATrick <span class="keyword">struct</span> &#123;</span><br><span class="line">S unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(f *ATrick)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> *(*<span class="keyword">string</span>)(f.S)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewA</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">A</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> A&#123;S: &amp;s&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewATrick</span><span class="params">(s <span class="keyword">string</span>)</span> <span class="title">ATrick</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">noescape</span><span class="params">(p unsafe.Pointer)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123;</span><br><span class="line">x := <span class="keyword">uintptr</span>(p)</span><br><span class="line"><span class="keyword">return</span> unsafe.Pointer(x ^ <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">s := <span class="string">&quot;hello&quot;</span></span><br><span class="line">f1 := NewA(s)</span><br><span class="line">f2 := NewATrick(s)</span><br><span class="line">s1 := f1.String()</span><br><span class="line">s2 := f2.String()</span><br><span class="line">_ = s1 + s2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">6</span>: can inline (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">6</span>: can inline (*ATrick).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">6</span>: can inline NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">6</span>: can inline noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">6</span>: can inline NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">29</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">36</span>:<span class="number">6</span>: can inline main</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: inlining call to NewA</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to NewATrick</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: inlining call to noescape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">17</span>: inlining call to (*A).String</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">17</span>: inlining call to (*ATrick).String</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build763863171/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">11</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">19</span>:<span class="number">7</span>: leaking param: f to result ~r0 level=<span class="number">2</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">31</span>:<span class="number">15</span>: noescape p does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">38</span>:<span class="number">14</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">39</span>:<span class="number">19</span>: main &amp;s does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">40</span>:<span class="number">10</span>: main f1 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">41</span>:<span class="number">10</span>: main f2 does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">42</span>:<span class="number">9</span>: main s1 + s2 does not escape</span><br></pre></td></tr></table></figure><p>其中主要看中间一小段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./main.<span class="keyword">go</span>:<span class="number">24</span>:<span class="number">16</span>: &amp;s escapes to heap    <span class="comment">//这个是NewA中的，逃逸了</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">23</span>:<span class="number">13</span>: moved to heap: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">27</span>:<span class="number">18</span>: NewATrick s does not escape <span class="comment">// NewATrick里的s的却没逃逸</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">28</span>:<span class="number">45</span>: NewATrick &amp;s does not escape</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p>上段代码对<code>A</code>和<code>ATrick</code>同样的功能有两种实现：他们包含一个 <code>string</code> ，然后用 <code>String()</code> 方法返回这个字符串。但是从逃逸分析看<code>ATrick</code> 版本没有逃逸。</p></li><li><p><code>noescape()</code> 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 <code>p</code> 会通过 <code>x</code> 逃逸， 因为 <code>uintptr()</code> 产生的引用是编译器无法理解的。</p></li><li><p>内置的 <code>uintptr</code> 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 <code>指针地址</code> 的 <code>int</code> 类型。代码的最后一行返回 <code>unsafe.Pointer</code> 也是一个 <code>int</code>。</p></li><li><p><code>noescape()</code> 在 <code>runtime</code> 包中使用 <code>unsafe.Pointer</code> 的地方被大量使用。如果作者清楚被 <code>unsafe.Pointer</code> 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。</p></li><li><p><strong>面试中秀一秀是可以的</strong>，如果在实际项目中如果使用这种unsafe包大概率会被同事打死。<strong>不建议使用！</strong>  毕竟包的名字就叫做 <code>unsafe</code>, 而且源码中的注释也写明了 <code>USE CAREFULLY! </code>。</p></li></ul><h4 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h4><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483686&idx=1&sn=e48c51107191f02da5751a19a54f7d41&chksm=9aee288fad99a199c126d5ff735af7320356ce4bb5753ae59ac6231e596354499414b5705b79&token=2092782362&lang=zh_CN#rd">golang面试题：简单聊聊内存逃逸？</a> </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483669&idx=1&sn=88f754ddabc04eb3f66ba8ac37ee1461&chksm=9aee28bcad99a1aa1ada41cfccaffc7ef4719a9bc11c1bef45b7d1b5427c1faa12d8d0c3156f&token=2092782362&lang=zh_CN#rd">golang面试题：字符串转成byte数组，会发生内存拷贝吗？</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483664&idx=1&sn=23a0cf8a78b1d9c30b2e3bc102bf421e&chksm=9aee28b9ad99a1af6c879ba4b1f6439e4c21c363f0a668f322c082ca334b62255507828f66d4&token=2092782362&lang=zh_CN#rd">golang面试题：翻转含有<code>中文、数字、英文字母</code>的字符串</a>  </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483674&idx=1&sn=ce4b5fee48c54ff69127ef2bd5d91427&chksm=9aee28b3ad99a1a57eed7651a16fd4bdc35ff23937e423c5e1322a234652fd135f1a16abbece&token=2092782362&lang=zh_CN#rd">golang面试题：拷贝大切片一定比小切片代价大吗？</a>   </li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAwMDAxNjU4Mg==&mid=2247483679&idx=1&sn=7075859e59741b1d0a81dc472b8ce45f&chksm=9aee28b6ad99a1a0599416886660d9ea56bd7fec18841af0e5fe86c3daea3973732a83d7eabb&token=2092782362&lang=zh_CN#rd">golang面试题：能说说uintptr和unsafe.Pointer的区别吗？</a></li></ul><h6 id=""><a href="#" class="headerlink" title=""></a></h6><p>关注公众号:【小白debug】<br><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>拷贝大切片一定比小切片代价大吗？</title>
      <link href="/2020/05/13/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%A4%A7%E5%88%87%E7%89%87%E4%B8%80%E5%AE%9A%E6%AF%94%E5%B0%8F%E5%88%87%E7%89%87%E4%BB%A3%E4%BB%B7%E5%A4%A7%E5%90%97%EF%BC%9F/"/>
      <url>/2020/05/13/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%A4%A7%E5%88%87%E7%89%87%E4%B8%80%E5%AE%9A%E6%AF%94%E5%B0%8F%E5%88%87%E7%89%87%E4%BB%A3%E4%BB%B7%E5%A4%A7%E5%90%97%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jMmM2Y2YxZi0xN2RlLTRiZDEtYjY5Ny02NGQ1ZDlhY2M2MDUucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>拷贝大切片一定比小切片代价大吗？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><p>并不是，所有切片的大小相同；<strong>三个字段</strong>（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 <strong>拷贝大切片跟小切片的代价应该是一样的</strong>。</p><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p><code>SliceHeader</code> 是<code>切片</code>在go的底层结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> SliceHeader <span class="keyword">struct</span> &#123;</span><br><span class="line">Data <span class="keyword">uintptr</span></span><br><span class="line">Len  <span class="keyword">int</span></span><br><span class="line">Cap  <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>大切片跟小切片的区别无非就是 <code>Len</code> 和 <code>Cap</code>的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。    </p></li></ul><h6 id="关注公众号-【小白debug】"><a href="#关注公众号-【小白debug】" class="headerlink" title="关注公众号:【小白debug】"></a>关注公众号:【小白debug】</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：简单聊聊内存逃逸？</title>
      <link href="/2020/05/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/"/>
      <url>/2020/05/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9jNzJkY2JmNi05YTc2LTRlYmMtODBkMC1lZjNmNzZjNDk5NzcucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>知道golang的<strong>内存逃逸</strong>吗？什么情况下会发生内存逃逸？</p><h2 id="怎么答"><a href="#怎么答" class="headerlink" title="怎么答"></a>怎么答</h2><figure class="highlight plaintext"><figcaption><span>```逃逸``` 了，必须在```堆上分配```。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">  </span><br><span class="line">能引起变量逃逸到堆上的**典型情况**：</span><br><span class="line">- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</span><br><span class="line">- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</span><br><span class="line">- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</span><br><span class="line">- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</span><br><span class="line">- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 举例</span><br><span class="line">- 通过一个例子加深理解，接下来尝试下怎么通过 ```go build -gcflags=-m``` 查看逃逸的情况。</span><br><span class="line">```go</span><br><span class="line">package main</span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line">type A struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line">// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况</span><br><span class="line">func foo(s string) *A &#123;</span><br><span class="line">a := new(A) </span><br><span class="line">a.s = s</span><br><span class="line">return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">a := foo(&quot;hello&quot;)</span><br><span class="line">b := a.s + &quot; world&quot;</span><br><span class="line">c := b + &quot;!&quot;</span><br><span class="line">fmt.Println(c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行<code>go build -gcflags=-m main.go</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> build -gcflags=-m main.<span class="keyword">go</span></span><br><span class="line"># command-line-arguments</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">6</span>: can inline foo</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">10</span>: inlining call to foo</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: inlining call to fmt.Println</span><br><span class="line">/<span class="keyword">var</span>/folders/<span class="number">45</span>/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/<span class="keyword">go</span>-build409982591/b001/_gomod_.<span class="keyword">go</span>:<span class="number">6</span>:<span class="number">6</span>: can inline init<span class="number">.0</span></span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">7</span>:<span class="number">10</span>: leaking param: s</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">8</span>:<span class="number">10</span>: <span class="built_in">new</span>(A) escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: io.Writer(os.Stdout) escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: c escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">15</span>:<span class="number">9</span>: b + <span class="string">&quot;!&quot;</span> escapes to heap</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">13</span>:<span class="number">10</span>: main <span class="built_in">new</span>(A) does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">14</span>:<span class="number">11</span>: main a.s + <span class="string">&quot; world&quot;</span> does not escape</span><br><span class="line">./main.<span class="keyword">go</span>:<span class="number">16</span>:<span class="number">13</span>: main []<span class="keyword">interface</span> &#123;&#125; literal does not escape</span><br><span class="line">&lt;autogenerated&gt;:<span class="number">1</span>: os.(*File).<span class="built_in">close</span> .this does not escape</span><br></pre></td></tr></table></figure><ul><li><code>./main.go:8:10: new(A) escapes to heap</code> 说明 <code>new(A)</code> 逃逸了,符合上述提到的常见情况中的第一种。</li><li><code>./main.go:14:11: main a.s + &quot; world&quot; does not escape</code> 说明 <code>b</code> 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。</li><li><code>./main.go:15:9: b + &quot;!&quot; escapes to heap</code> 说明 <code>c</code> 变量逃逸，通过<code>fmt.Println(a ...interface&#123;&#125;)</code>打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。</li></ul><ul><li>以上操作其实就叫<strong>逃逸分析</strong>。<strong>下篇文章，跟大家聊聊怎么用一个比较trick的方法使变量不逃逸。方便大家在面试官面前秀一波</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>golang面试题：翻转含有中文、数字、英文字母的字符串</title>
      <link href="/2020/05/10/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2020/05/10/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS8wNzdhMGZlOC1lZDU2LTQ5ODItYjRmNy1iNzZhMGYyYWIwNmYucG5n?x-oss-process=image/format,png"></p><span id="more"></span><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>翻转含有<code>中文、数字、英文字母</code>的字符串<br><code>&quot;你好abc啊哈哈&quot;</code></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span><span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">src := <span class="string">&quot;你好abc啊哈哈&quot;</span></span><br><span class="line">dst := reverse([]<span class="keyword">rune</span>(src))</span><br><span class="line">fmt.Printf(<span class="string">&quot;%v\n&quot;</span>, <span class="keyword">string</span>(dst))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(s []<span class="keyword">rune</span>)</span> []<span class="title">rune</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(s)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> s</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><code>rune</code>关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），<strong>可表示更多的字符</strong>。  </li><li>由于rune可表示的范围更大，所以能处理一切字符，当然也包括<strong>中文字符</strong>。在平时计算中文字符，可用rune。</li><li>因此将<code>字符串</code>转为<code>rune的切片</code>，再进行翻转，完美解决。</li></ul><h6 id="关注公众号-【小白debug】"><a href="#关注公众号-【小白debug】" class="headerlink" title="关注公众号:【小白debug】"></a>关注公众号:【小白debug】</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaobaiTech/image/%E9%BB%98%E8%AE%A4%E6%A0%87%E9%A2%98_%E5%8A%A8%E6%80%81%E6%A8%AA%E7%89%88%E4%BA%8C%E7%BB%B4%E7%A0%81_2021-03-19-0.gif"></p>]]></content>
      
      
      <categories>
          
          <category> golang面试题 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
