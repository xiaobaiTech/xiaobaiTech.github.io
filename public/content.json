{"meta":{"title":"小白debug","subtitle":"一起在知识的海洋里呛水","description":"有时骚话连篇，有时硬核图解","author":null,"url":"https://xiaobaitech.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-09-25T16:03:51.000Z","updated":"2021-09-25T16:10:16.525Z","comments":true,"path":"categories/index.html","permalink":"https://xiaobaitech.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"动图图解！没有accept，能建立TCP连接吗？","slug":"图解网络/没有accept能建立TCP连接吗","date":"2021-09-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.781Z","comments":true,"path":"2021/09/25/图解网络/没有accept能建立TCP连接吗/","link":"","permalink":"https://xiaobaitech.github.io/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B2%A1%E6%9C%89accept%E8%83%BD%E5%BB%BA%E7%AB%8BTCP%E8%BF%9E%E6%8E%A5%E5%90%97/","excerpt":"上面这个动图，是我们平时客户端和服务端建立连接时的代码流程。 对应的是下面一段简化过的服务端伪代码。","text":"上面这个动图，是我们平时客户端和服务端建立连接时的代码流程。 对应的是下面一段简化过的服务端伪代码。 1234567891011121314151617int main()&#123; /*Step 1: 创建服务器端监听socket描述符listen_fd*/ listen_fd = socket(AF_INET, SOCK_STREAM, 0); /*Step 2: bind绑定服务器端的IP和端口，所有客户端都向这个IP和端口发送和请求数据*/ bind(listen_fd, xxx); /*Step 3: 服务端开启监听*/ listen(listen_fd, 128); /*Step 4: 服务器等待客户端的链接，返回值cfd为客户端的socket描述符*/ cfd = accept(listen_fd, xxx); /*Step 5: 读取客户端发来的数据*/ n = read(cfd, buf, sizeof(buf));&#125; 估计大家也是老熟悉这段伪代码了。 需要注意的是，在执行listen()方法之后还会执行一个accept()方法。 一般情况下，如果启动服务器，会发现最后程序会阻塞在accept()里。 此时服务端就算ok了，就等客户端了。 那么，再看下简化过的客户端伪代码。 1234567891011int main()&#123; /*Step 1: 创建客户端端socket描述符cfd*/ cfd = socket(AF_INET, SOCK_STREAM, 0); /*Step 2: connect方法,对服务器端的IP和端口号发起连接*/ ret = connect(cfd, xxxx); /*Step 4: 向服务器端写数据*/ write(cfd, buf, strlen(buf));&#125; 客户端比较简单，创建好socket之后，直接就发起connect方法。 此时回到服务端，会发现之前一直阻塞的accept方法，返回结果了。 这就算两端成功建立好了一条连接。之后就可以愉快的进行读写操作了。 那么，我们今天的问题是，如果没有这个accept方法，TCP连接还能建立起来吗？ 其实只要在执行accept() 之前执行一个 sleep(20)，然后立刻执行客户端相关的方法，同时抓个包，就能得出结论。 从抓包结果看来，就算不执行accept()方法，三次握手照常进行，并顺利建立连接。 更骚气的是，在服务端执行accept()前，如果客户端发送消息给服务端，服务端是能够正常回复ack确认包的。 并且，sleep(20)结束后，服务端正常执行accept()，客户端前面发送的消息，还是能正常收到的。 通过这个现象，我们可以多想想为什么。顺便好好了解下三次握手的细节。 三次握手的细节分析我们先看面试八股文的老股，三次握手。 服务端代码，对socket执行bind方法可以绑定监听端口，然后执行listen方法后，就会进入监听（LISTEN）状态。内核会为每一个处于LISTEN状态的socket 分配两个队列，分别叫半连接队列和全连接队列。 半连接队列、全连接队列是什么 半连接队列（SYN队列），服务端收到第一次握手后，会将sock加入到这个队列中，队列内的sock都处于SYN_RECV 状态。 全连接队列（ACCEPT队列），在服务端收到第三次握手后，会将半连接队列的sock取出，放到全连接队列中。队列里的sock都处于 ESTABLISHED状态。这里面的连接，就等着服务端执行accept()后被取出了。 看到这里，文章开头的问题就有了答案，建立连接的过程中根本不需要accept() 参与， 执行accept()只是为了从全连接队列里取出一条连接。 我们把话题再重新回到这两个队列上。 虽然都叫队列，但其实全连接队列（icsk_accept_queue）是个链表，而半连接队列（syn_table）是个哈希表。 为什么半连接队列要设计成哈希表先对比下全连接里队列，他本质是个链表，因为也是线性结构，说它是个队列也没毛病。它里面放的都是已经建立完成的连接，这些连接正等待被取走。而服务端取走连接的过程中，并不关心具体是哪个连接，只要是个连接就行，所以直接从队列头取就行了。这个过程算法复杂度为O(1)。 而半连接队列却不太一样，因为队列里的都是不完整的连接，嗷嗷等待着第三次握手的到来。那么现在有一个第三次握手来了，则需要从队列里把相应IP端口的连接取出，如果半连接队列还是个链表，那我们就需要依次遍历，才能拿到我们想要的那个连接，算法复杂度就是O(n)。 而如果将半连接队列设计成哈希表，那么查找半连接的算法复杂度就回到O(1)了。 因此出于效率考虑，全连接队列被设计成链表，而半连接队列被设计为哈希表。 怎么观察两个队列的大小查看全连接队列123# ss -lntState Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 128 127.0.0.1:46269 *:* 通过ss -lnt命令，可以看到全连接队列的大小，其中Send-Q是指全连接队列的最大值，可以看到我这上面的最大值是128；Recv-Q是指当前的全连接队列的使用值，我这边用了0个，也就是全连接队列里为空，连接都被取出来了。 当上面Send-Q和Recv-Q数值很接近的时候，那么全连接队列可能已经满了。可以通过下面的命令查看是否发生过队列溢出。 12# netstat -s | grep overflowed 4343 times the listen queue of a socket overflowed 上面说明发生过4343次全连接队列溢出的情况。这个查看到的是历史发生过的次数。 如果配合使用watch -d 命令，可以自动每2s间隔执行相同命令，还能高亮显示变化的数字部分，如果溢出的数字不断变多，说明正在发生溢出的行为。 1234# watch -d &#x27;netstat -s | grep overflowed&#x27;Every 2.0s: netstat -s | grep overflowed Fri Sep 17 09:00:45 2021 4343 times the listen queue of a socket overflowed 查看半连接队列半连接队列没有命令可以直接查看到，但因为半连接队列里，放的都是SYN_RECV 状态的连接，那可以通过统计处于这个状态的连接的数量，间接获得半连接队列的长度。 12# netstat -nt | grep -i &#x27;127.0.0.1:8080&#x27; | grep -i &#x27;SYN_RECV&#x27; | wc -l0 注意半连接队列和全连接队列都是挂在某个Listen socket上的，我这里用的是127.0.0.1:8080，大家可以替换成自己想要查看的IP端口。 可以看到我的机器上的半连接队列长度为0，这个很正常，正经连接谁会没事老待在半连接队列里。 当队列里的半连接不断增多，最终也是会发生溢出，可以通过下面的命令查看。 12# netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot; 26395 SYNs to LISTEN sockets dropped 可以看到，我的机器上一共发生了26395次半连接队列溢出。同样建议配合watch -d 命令使用。 1234# watch -d &#x27;netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot;&#x27;Every 2.0s: netstat -s | grep -i &quot;SYNs to LISTEN sockets dropped&quot; Fri Sep 17 08:36:38 2021 26395 SYNs to LISTEN sockets dropped 全连接队列满了会怎么样？如果队列满了，服务端还收到客户端的第三次握手ACK，默认当然会丢弃这个ACK。 但除了丢弃之外，还有一些附带行为，这会受 tcp_abort_on_overflow 参数的影响。 12# cat /proc/sys/net/ipv4/tcp_abort_on_overflow0 tcp_abort_on_overflow设置为 0，全连接队列满了之后，会丢弃这个第三次握手ACK包，并且开启定时器，重传第二次握手的SYN+ACK，如果重传超过一定限制次数，还会把对应的半连接队列里的连接给删掉。 tcp_abort_on_overflow设置为 1，全连接队列满了之后，就直接发RST给客户端，效果上看就是连接断了。 这个现象是不是很熟悉，服务端端口未监听时，客户端尝试去连接，服务端也会回一个RST。这两个情况长一样，所以客户端这时候收到RST之后，其实无法区分到底是端口未监听，还是全连接队列满了。 半连接队列要是满了会怎么样一般是丢弃，但这个行为可以通过 tcp_syncookies 参数去控制。但比起这个，更重要的是先了解下半连接队列为什么会被打满。 首先我们需要明白，一般情况下，半连接的”生存”时间其实很短，只有在第一次和第三次握手间，如果半连接都满了，说明服务端疯狂收到第一次握手请求，如果是线上游戏应用，能有这么多请求进来，那说明你可能要富了。但现实往往比较骨感，你可能遇到了SYN Flood攻击。 所谓SYN Flood攻击，可以简单理解为，攻击方模拟客户端疯狂发第一次握手请求过来，在服务端憨憨地回复第二次握手过去之后，客户端死活不发第三次握手过来，这样做，可以把服务端半连接队列打满，从而导致正常连接不能正常进来。 那这种情况怎么处理？有没有一种方法可以绕过半连接队列？ 有，上面提到的tcp_syncookies派上用场了。 12# cat /proc/sys/net/ipv4/tcp_syncookies1 当它被设置为1的时候，客户端发来第一次握手SYN时，服务端不会将其放入半连接队列中，而是直接生成一个cookies，这个cookies会跟着第二次握手，发回客户端。客户端在发第三次握手的时候带上这个cookies，服务端验证到它就是当初发出去的那个，就会建立连接并放入到全连接队列中。可以看出整个过程不再需要半连接队列的参与。 会有一个cookies队列吗生成是cookies，保存在哪呢？是不是会有一个队列保存这些cookies？ 我们可以反过来想一下，如果有cookies队列，那它会跟半连接队列一样，到头来，还是会被SYN Flood 攻击打满。 实际上cookies并不会有一个专门的队列保存，它是通过通信双方的IP地址端口、时间戳、MSS等信息进行实时计算的，保存在TCP报头的seq里。 当服务端收到客户端发来的第三次握手包时，会通过seq还原出通信双方的IP地址端口、时间戳、MSS，验证通过则建立连接。 cookies方案为什么不直接取代半连接队列？目前看下来syn cookies方案省下了半连接队列所需要的队列内存，还能解决 SYN Flood攻击，那为什么不直接取代半连接队列？ 凡事皆有利弊，cookies方案虽然能防 SYN Flood攻击，但是也有一些问题。因为服务端并不会保存连接信息，所以如果传输过程中数据包丢了，也不会重发第二次握手的信息。 另外，编码解码cookies，都是比较耗CPU的，利用这一点，如果此时攻击者构造大量的第三次握手包（ACK包），同时带上各种瞎编的cookies信息，服务端收到ACK包后以为是正经cookies，憨憨地跑去解码（耗CPU），最后发现不是正经数据包后才丢弃。 这种通过构造大量ACK包去消耗服务端资源的攻击，叫ACK攻击，受到攻击的服务器可能会因为CPU资源耗尽导致没能响应正经请求。 没有listen，为什么还能建立连接那既然没有accept方法能建立连接，那是不是没有listen方法，也能建立连接？是的，之前写的一篇文章提到过客户端是可以自己连自己的形成连接（TCP自连接），也可以两个客户端同时向对方发出请求建立连接（TCP同时打开），这两个情况都有个共同点，就是没有服务端参与，也就是没有listen，就能建立连接。 当时文章最后也留了个疑问，没有listen，为什么还能建立连接？ 我们知道执行listen方法时，会创建半连接队列和全连接队列。 三次握手的过程中会在这两个队列中暂存连接信息。 所以形成连接，前提是你得有个地方存放着，方便握手的时候能根据IP端口等信息找到socket信息。 那么客户端会有半连接队列吗？ 显然没有，因为客户端没有执行listen，因为半连接队列和全连接队列都是在执行listen方法时，内核自动创建的。 但内核还有个全局hash表，可以用于存放sock连接的信息。这个全局hash表其实还细分为ehash，bhash和listen_hash等，但因为过于细节，大家理解成有一个全局hash就够了， 在TCP自连接的情况中，客户端在connect方法时，最后会将自己的连接信息放入到这个全局hash表中，然后将信息发出，消息在经过回环地址重新回到TCP传输层的时候，就会根据IP端口信息，再一次从这个全局hash中取出信息。于是握手包一来一回，最后成功建立连接。 TCP同时打开的情况也类似，只不过从一个客户端变成了两个客户端而已。 总结 每一个socket执行listen时，内核都会自动创建一个半连接队列和全连接队列。 第三次握手前，TCP连接会放在半连接队列中，直到第三次握手到来，才会被放到全连接队列中。 accept方法只是为了从全连接队列中拿出一条连接，本身跟三次握手几乎毫无关系。 出于效率考虑，虽然都叫队列，但半连接队列其实被设计成了哈希表，而全连接队列本质是链表。 全连接队列满了，再来第三次握手也会丢弃，此时如果tcp_abort_on_overflow=1，还会直接发RST给客户端。 半连接队列满了，可能是因为受到了SYN Flood攻击，可以设置tcp_syncookies，绕开半连接队列。 客户端没有半连接队列和全连接队列，但有一个全局hash，可以通过它实现自连接或TCP同时打开。 参考资料小林图解网络 – 推荐大家关注《小林coding》 如果文章对你有帮助，欢迎….. 算了。 兄弟们都是自家人，点不点赞，在不在看什么的，没关系的，大家看开心了就好。 在看，点赞什么的，我不是特别在意，真的，真的，别不信啊。 不三连也真的没关系的。 兄弟们不要在意啊。 我是虚伪的小白，我们下期见！ 别说了，一起在知识的海洋里呛水吧点击下方名片，关注公众号:【小白debug】 不满足于在留言区说骚话？ 加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就超！开！心！ 文章推荐： 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 动图图解！既然IP层会分片，为什么TCP层也还要分段？","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"活久见！TCP两次挥手，你见过吗？那四次握手呢？","slug":"图解网络/活久见！TCP两次挥手，你见过吗？那四次握手呢？","date":"2021-09-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.387Z","comments":true,"path":"2021/09/25/图解网络/活久见！TCP两次挥手，你见过吗？那四次握手呢？/","link":"","permalink":"https://xiaobaitech.github.io/2021/09/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%B4%BB%E4%B9%85%E8%A7%81%EF%BC%81TCP%E4%B8%A4%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E4%BD%A0%E8%A7%81%E8%BF%87%E5%90%97%EF%BC%9F%E9%82%A3%E5%9B%9B%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%91%A2%EF%BC%9F/","excerpt":"我们都知道，TCP是个面向连接的、可靠的、基于字节流的传输层通信协议。 那这里面提到的”面向连接“，意味着需要 建立连接，使用连接，释放连接。 建立连接是指我们熟知的TCP三次握手。 而使用连接，则是通过一发送、一确认的形式，进行数据传输。 还有就是释放连接，也就是我们常见的TCP四次挥手。 TCP四次挥手大家应该比较了解了，但大家见过三次挥手吗？还有两次挥手呢？ 都见过？ 那四次握手呢？ 今天这个话题，不想只是猎奇，也不想搞冷知识。 我们从四次挥手开始说起，搞点实用的知识点。","text":"我们都知道，TCP是个面向连接的、可靠的、基于字节流的传输层通信协议。 那这里面提到的”面向连接“，意味着需要 建立连接，使用连接，释放连接。 建立连接是指我们熟知的TCP三次握手。 而使用连接，则是通过一发送、一确认的形式，进行数据传输。 还有就是释放连接，也就是我们常见的TCP四次挥手。 TCP四次挥手大家应该比较了解了，但大家见过三次挥手吗？还有两次挥手呢？ 都见过？ 那四次握手呢？ 今天这个话题，不想只是猎奇，也不想搞冷知识。 我们从四次挥手开始说起，搞点实用的知识点。 TCP四次挥手简单回顾下TCP四次挥手。 正常情况下。只要数据传输完了，不管是客户端还是服务端，都可以主动发起四次挥手，释放连接。 就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是主动方。服务器是被动接收客户端的挥手请求的，叫被动方。 客户端和服务器，一开始，都是处于ESTABLISHED状态。 第一次挥手：一般情况下，主动方执行close()或 shutdown()方法，会发个FIN报文出来，表示”我不再发送数据了“。 第二次挥手：在收到主动方的FIN报文后，被动方立马回应一个ACK，意思是”我收到你的FIN了，也知道你不再发数据了”。 上面提到的是主动方不再发送数据了。但如果这时候，被动方还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。 第三次挥手：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 close(), 这时候就会发出第三次挥手的 FIN-ACK。 第四次挥手：主动方回一个ACK，意思是收到了。 其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用close()方法），也就是我们平时写代码需要关注的地方。 第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。 另外不管是主动还是被动，每方发出了一个 FIN 和一个ACK 。也收到了一个 FIN 和一个ACK 。这一点大家关注下，待会还会提到。 FIN一定要程序执行close()或shutdown()才能发出吗？不一定。一般情况下，通过对socket执行 close() 或 shutdown() 方法会发出FIN。但实际上，只要应用程序退出，不管是主动退出，还是被动退出（因为一些莫名其妙的原因被kill了）, 都会发出 FIN。 FIN 是指”我不再发送数据”，因此shutdown() 关闭读不会给对方发FIN, 关闭写才会发FIN。 如果机器上FIN-WAIT-2状态特别多，是为什么根据上面的四次挥手图，可以看出，FIN-WAIT-2是主动方那边的状态。 处于这个状态的程序，一直在等第三次挥手的FIN。而第三次挥手需要由被动方在代码里执行close() 发出。 因此当机器上FIN-WAIT-2状态特别多，那一般来说，另外一台机器上会有大量的 CLOSE_WAIT。需要检查有大量的 CLOSE_WAIT的那台机器，为什么迟迟不愿调用close()关闭连接。 所以，如果机器上FIN-WAIT-2状态特别多，一般是因为对端一直不执行close()方法发出第三次挥手。 主动方在close之后收到的数据，会怎么处理之前写的一篇文章《代码执行send成功后，数据就发出去了吗？》中，从源码的角度提到了，一般情况下，程序主动执行close()的时候； 如果当前连接对应的socket的接收缓冲区有数据，会发RST。 如果发送缓冲区有数据，那会等待发送完，再发第一次挥手的FIN。 大家知道，TCP是全双工通信，意思是发送数据的同时，还可以接收数据。 Close()的含义是，此时要同时关闭发送和接收消息的功能。 也就是说，虽然理论上，第二次和第三次挥手之间，被动方是可以传数据给主动方的。 但如果 主动方的四次挥手是通过 close() 触发的，那主动方是不会去收这个消息的。而且还会回一个 RST。直接结束掉这次连接。 第二第三次挥手之间，不能传输数据吗？也不是。前面提到Close()的含义是，要同时关闭发送和接收消息的功能。 那如果能做到只关闭发送消息，不关闭接收消息的功能，那就能继续收消息了。这种 half-close 的功能，通过调用shutdown() 方法就能做到。 1int shutdown(int sock, int howto); 其中 howto 为断开方式。有以下取值： SHUT_RD：关闭读。这时应用层不应该再尝试接收数据，内核协议栈中就算接收缓冲区收到数据也会被丢弃。 SHUT_WR：关闭写。如果发送缓冲区中还有数据没发，会将将数据传递到目标主机。 SHUT_RDWR：关闭读和写。相当于close()了。 怎么知道对端socket执行了close还是shutdown不管主动关闭方调用的是close()还是shutdown()，对于被动方来说，收到的就只有一个FIN。 被动关闭方就懵了，”我怎么知道对方让不让我继续发数据？” 其实，大可不必纠结，该发就发。 第二次挥手和第三次挥手之间，如果被动关闭方想发数据，那么在代码层面上，就是执行了 send() 方法。 1int send( SOCKET s,const char* buf,int len,int flags); send() 会把数据拷贝到本机的发送缓冲区。如果发送缓冲区没出问题，都能拷贝进去，所以正常情况下，send()一般都会返回成功。 然后被动方内核协议栈会把数据发给主动关闭方。 如果上一次主动关闭方调用的是shutdown(socket_fd, SHUT_WR)。那此时，主动关闭方不再发送消息，但能接收被动方的消息，一切如常，皆大欢喜。 如果上一次主动关闭方调用的是close()。那主动方在收到被动方的数据后会直接丢弃，然后回一个RST。 针对第二种情况。 被动方内核协议栈收到了RST，会把连接关闭。但内核连接关闭了，应用层也不知道（除非被通知）。 此时被动方应用层接下来的操作，无非就是读或写。 如果是读，则会返回RST的报错，也就是我们常见的Connection reset by peer。 如果是写，那么程序会产生SIGPIPE信号，应用层代码可以捕获并处理信号，如果不处理，则默认情况下进程会终止，异常退出。 总结一下，当被动关闭方 recv() 返回EOF时，说明主动方通过 close()或 shutdown(fd, SHUT_WR) 发起了第一次挥手。 如果此时被动方执行两次 send()。 第一次send(), 一般会成功返回。 第二次send()时。如果主动方是通过 shutdown(fd, SHUT_WR) 发起的第一次挥手，那此时send()还是会成功。如果主动方通过 close()发起的第一次挥手，那此时会产生SIGPIPE信号，进程默认会终止，异常退出。不想异常退出的话，记得捕获处理这个信号。 如果被动方一直不发第三次挥手，会怎么样第三次挥手，是由被动方主动触发的，比如调用close()。 如果由于代码错误或者其他一些原因，被动方就是不执行第三次挥手。 这时候，主动方会根据自身第一次挥手的时候用的是 close() 还是 shutdown(fd, SHUT_WR) ，有不同的行为表现。 如果是 shutdown(fd, SHUT_WR) ，说明主动方其实只关闭了写，但还可以读，此时会一直处于 FIN-WAIT-2， 死等被动方的第三次挥手。 如果是 close()， 说明主动方读写都关闭了，这时候会处于 FIN-WAIT-2一段时间，这个时间由 net.ipv4.tcp_fin_timeout 控制，一般是 60s，这个值正好跟2MSL一样 。超过这段时间之后，状态不会变成 TIME-WAIT，而是直接变成CLOSED。 12# cat /proc/sys/net/ipv4/tcp_fin_timeout60 TCP三次挥手四次挥手聊完了，那有没有可能出现三次挥手？ 是可能的。 我们知道，TCP四次挥手里，第二次和第三次挥手之间，是有可能有数据传输的。第三次挥手的目的是为了告诉主动方，”被动方没有数据要发了”。 所以，在第一次挥手之后，如果被动方没有数据要发给主动方。第二和第三次挥手是有可能合并传输的。这样就出现了三次挥手。 如果有数据要发，就不能是三次挥手了吗上面提到的是没有数据要发的情况，如果第二、第三次挥手之间有数据要发，就不可能变成三次挥手了吗？ 并不是。TCP中还有个特性叫延迟确认。可以简单理解为：接收方收到数据以后不需要立刻马上回复ACK确认包。 在此基础上，不是每一次发送数据包都能对应收到一个 ACK 确认包，因为接收方可以合并确认。 而这个合并确认，放在四次挥手里，可以把第二次挥手、第三次挥手，以及他们之间的数据传输都合并在一起发送。因此也就出现了三次挥手。 TCP两次挥手前面在四次挥手中提到，关闭的时候双方都发出了一个FIN和收到了一个ACK。 正常情况下TCP连接的两端，是不同IP+端口的进程。 但如果TCP连接的两端，IP+端口是一样的情况下，那么在关闭连接的时候，也同样做到了一端发出了一个FIN，也收到了一个 ACK，只不过正好这两端其实是同一个socket 。 而这种两端IP+端口都一样的连接，叫TCP自连接。 是的，你没看错，我也没打错别字。同一个socket确实可以自己连自己，形成一个连接。 一个socket能建立连接？上面提到了，同一个客户端socket，自己对自己发起连接请求。是可以成功建立连接的。这样的连接，叫TCP自连接。 下面我们尝试下复现。 注意我是在以下系统进行的实验。在mac上多半无法复现。 1234567# cat /etc/os-releaseNAME=&quot;CentOS Linux&quot;VERSION=&quot;7 (Core)&quot;ID=&quot;centos&quot;ID_LIKE=&quot;rhel fedora&quot;VERSION_ID=&quot;7&quot;PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot; 通过nc命令可以很简单的创建一个TCP自连接 1# nc -p 6666 127.0.0.1 6666 上面的 -p 可以指定源端口号。也就是指定了一个端口号为6666的客户端去连接 127.0.0.1:6666 。 12# netstat -nt | grep 6666tcp 0 0 127.0.0.1:6666 127.0.0.1:6666 ESTABLISHED 整个过程中，都没有服务端参与。可以抓个包看下。 可以看到，相同的socket，自己连自己的时候，握手是三次的。挥手是两次的。 上面这张图里，左右都是同一个客户端，把它画成两个是为了方便大家理解状态的迁移。 我们可以拿自连接的握手状态对比下正常情况下的TCP三次握手。 看了自连接的状态图，再看看下面几个问题。 一端发出第一次握手后，如果又收到了第一次握手的SYN包，TCP连接状态会怎么变化？第一次握手过后，连接状态就变成了SYN_SENT状态。如果此时又收到了第一次握手的SYN包，那么连接状态就会从SYN_SENT状态变成SYN_RCVD。 12345678910// net/ipv4/tcp_input.cstatic int tcp_rcv_synsent_state_process()&#123; // SYN_SENT状态下，收到SYN包 if (th-&gt;syn) &#123; // 状态置为 SYN_RCVD tcp_set_state(sk, TCP_SYN_RECV); &#125;&#125; 一端发出第二次握手后，如果又收到第二次握手的SYN+ACK包，TCP连接状态会怎么变化？第二握手过后，连接状态就变为SYN_RCVD了，此时如果再收到第二次握手的SYN+ACK包。连接状态会变为ESTABLISHED。 12345678910111213141516// net/ipv4/tcp_input.cint tcp_rcv_state_process()&#123; // 前面省略很多逻辑，能走到这就认为肯定有ACK if (true) &#123; // 判断下这个ack是否合法 int acceptable = tcp_ack(sk, skb, FLAG_SLOWPATH | FLAG_UPDATE_TS_RECENT) &gt; 0; switch (sk-&gt;sk_state) &#123; case TCP_SYN_RECV: if (acceptable) &#123; // 状态从 SYN_RCVD 转为 ESTABLISHED tcp_set_state(sk, TCP_ESTABLISHED); &#125; &#125; &#125;&#125; 一端第一次挥手后，又收到第一次挥手的包，TCP连接状态会怎么变化？第一次挥手过后，一端状态就会变成 FIN-WAIT-1。正常情况下，是要等待第二次挥手的ACK。但实际上却等来了 一个第一次挥手的 FIN包， 这时候连接状态就会变为CLOSING。 1234567891011// net/static void tcp_fin(struct sock *sk)&#123; switch (sk-&gt;sk_state) &#123; case TCP_FIN_WAIT1: tcp_send_ack(sk); // FIN-WAIT-1状态下，收到了FIN，转为 CLOSING tcp_set_state(sk, TCP_CLOSING); break; &#125;&#125; 这可以说是隐藏剧情了。 CLOSING 很少见，除了出现在自连接关闭外，一般还会出现在TCP两端同时关闭连接的情况下。 处于CLOSING状态下时，只要再收到一个ACK，就能进入 TIME-WAIT 状态，然后等个2MSL，连接就彻底断开了。这跟正常的四次挥手还是有些差别的。大家可以滑到文章开头的TCP四次挥手再对比下。 代码复现自连接可能大家会产生怀疑，这是不是nc这个软件本身的bug。 那我们可以尝试下用strace看看它内部都做了啥。 123456789# strace nc -p 6666 127.0.0.1 6666// ...socket(AF_INET, SOCK_STREAM, IPPROTO_TCP) = 3fcntl(3, F_GETFL) = 0x2 (flags O_RDWR)fcntl(3, F_SETFL, O_RDWR|O_NONBLOCK) = 0setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0bind(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(&quot;0.0.0.0&quot;)&#125;, 16) = 0connect(3, &#123;sa_family=AF_INET, sin_port=htons(6666), sin_addr=inet_addr(&quot;127.0.0.1&quot;)&#125;, 16) = -1 EINPROGRESS (Operation now in progress)// ... 无非就是以创建了一个客户端socket句柄，然后对这个句柄执行 bind, 绑定它的端口号是6666，然后再向 127.0.0.1:6666发起connect方法。 我们可以尝试用C语言去复现一遍。 下面的代码，只用于复现问题。直接跳过也完全不影响阅读。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/socket.h&gt;#include &lt;stdlib.h&gt;#include &lt;arpa/inet.h&gt;#include &lt;ctype.h&gt;#include &lt;string.h&gt;#include &lt;strings.h&gt; int main()&#123; int lfd, cfd; struct sockaddr_in serv_addr, clie_addr; socklen_t clie_addr_len; char buf[BUFSIZ]; int n = 0, i = 0, ret = 0 ; printf(&quot;This is a client \\n&quot;); /*Step 1: 创建客户端端socket描述符cfd*/ cfd = socket(AF_INET, SOCK_STREAM, 0); if(cfd == -1) &#123; perror(&quot;socket error&quot;); exit(1); &#125; int flag=1,len=sizeof(int); if( setsockopt(cfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, len) == -1) &#123; perror(&quot;setsockopt&quot;); exit(1); &#125; bzero(&amp;clie_addr, sizeof(clie_addr)); clie_addr.sin_family = AF_INET; clie_addr.sin_port = htons(6666); inet_pton(AF_INET,&quot;127.0.0.1&quot;, &amp;clie_addr.sin_addr.s_addr); /*Step 2: 客户端使用bind绑定客户端的IP和端口*/ ret = bind(cfd, (struct sockaddr* )&amp;clie_addr, sizeof(clie_addr)); if(ret != 0) &#123; perror(&quot;bind error&quot;); exit(2); &#125; /*Step 3: connect链接服务器端的IP和端口号*/ bzero(&amp;serv_addr, sizeof(serv_addr)); serv_addr.sin_family = AF_INET; serv_addr.sin_port = htons(6666); inet_pton(AF_INET,&quot;127.0.0.1&quot;, &amp;serv_addr.sin_addr.s_addr); ret = connect(cfd,(struct sockaddr *)&amp;serv_addr, sizeof(serv_addr)); if(ret != 0) &#123; perror(&quot;connect error&quot;); exit(3); &#125; /*Step 4: 向服务器端写数据*/ while(1) &#123; fgets(buf, sizeof(buf), stdin); write(cfd, buf, strlen(buf)); n = read(cfd, buf, sizeof(buf)); write(STDOUT_FILENO, buf, n);//写到屏幕上 &#125; /*Step 5: 关闭socket描述符*/ close(cfd); return 0;&#125; 保存为 client.c 文件，然后执行下面命令，会发现连接成功。 12# gcc client.c -o client &amp;&amp; ./clientThis is a client 12# netstat -nt | grep 6666tcp 0 0 127.0.0.1:6666 127.0.0.1:6666 ESTABLISHED 说明，这不是nc的bug。事实上，这也是内核允许的一种情况。 自连接的解决方案自连接一般不太常见，但遇到了也不难解决。 解决方案比较简单，只要能保证客户端和服务端的端口不一致就行。 事实上，我们写代码的时候一般不会去指定客户端的端口，系统会随机给客户端分配某个范围内的端口。而这个范围，可以通过下面的命令进行查询 12# cat /proc/sys/net/ipv4/ip_local_port_range32768 60999 也就是只要我们的服务器端口不在32768-60999这个范围内，比如设置为8888。就可以规避掉这个问题。 另外一个解决方案，可以参考golang标准网络库的实现，在连接建立完成之后判断下IP和端口是否一致，如果遇到自连接，则断开重试。 123456789101112131415func dialTCP(net string, laddr, raddr *TCPAddr, deadline time.Time) (*TCPConn, error) &#123; // 如果是自连接，这里会重试 for i := 0; i &lt; 2 &amp;&amp; (laddr == nil || laddr.Port == 0) &amp;&amp; (selfConnect(fd, err) || spuriousENOTAVAIL(err)); i++ &#123; if err == nil &#123; fd.Close() &#125; fd, err = internetSocket(net, laddr, raddr, deadline, syscall.SOCK_STREAM, 0, &quot;dial&quot;, sockaddrToTCP) &#125; // ...&#125;func selfConnect(fd *netFD, err error) bool &#123; // 判断是否端口、IP一致 return l.Port == r.Port &amp;&amp; l.IP.Equal(r.IP)&#125; 四次握手前面提到的TCP自连接是一个客户端自己连自己的场景。那不同客户端之间是否可以互联？ 答案是可以的，有一种情况叫TCP同时打开。 大家可以对比下，TCP同时打开在握手时的状态变化，跟TCP自连接是非常的像。 比如SYN_SENT状态下，又收到了一个SYN，其实就相当于自连接里，在发出了第一次握手后，又收到了第一次握手的请求。结果都是变成 SYN_RCVD。 在 SYN_RCVD 状态下收到了 SYN+ACK，就相当于自连接里，在发出第二次握手后，又收到第二次握手的请求，结果都是变成 ESTABLISHED。他们的源码其实都是同一块逻辑。 复现TCP同时打开分别在两个控制台下，分别执行下面两行命令。 123while true; do nc -p 2224 127.0.0.1 2223 -v;donewhile true; do nc -p 2223 127.0.0.1 2224 -v;done 上面两个命令的含义也比较简单，两个客户端互相请求连接对方的端口号，如果失败了则不停重试。 执行后看到的现象是，一开始会疯狂失败，重试。一段时间后，连接建立完成。 1234# netstat -an | grep 2223Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 0 127.0.0.1:2224 127.0.0.1:2223 ESTABLISHEDtcp 0 0 127.0.0.1:2223 127.0.0.1:2224 ESTABLISHED 期间抓包获得下面的结果。 可以看到，这里面建立连接用了四次交互。因此可以说这是通过**”四次握手”**建立的连接。 而且更重要的是，这里面只涉及两个客户端，没有服务端。 看到这里，不知道大家有没有跟我一样，被刷新了一波认知，对socket有了重新的认识。 在以前的观念里，建立连接，必须要有一个客户端和一个服务端，并且服务端还要执行一个listen()和一个accept()。而实际上，这些都不是必须的。 那么下次，面试官问你**”没有listen()， TCP能建立连接吗？”**， 我想大家应该知道该怎么回答了。 但问题又来了，只有两个客户端，没有listen() ，为什么能建立TCP连接？ 如果大家感兴趣，我们以后有机会再填上这个坑。 总结 四次挥手中，不管是程序主动执行close()，还是进程被杀，都有可能发出第一次挥手FIN包。如果机器上FIN-WAIT-2状态特别多，一般是因为对端一直不执行close()方法发出第三次挥手。 Close()会同时关闭发送和接收消息的功能。shutdown() 能单独关闭发送或接受消息。 第二、第三次挥手，是有可能合在一起的。于是四次挥手就变成三次挥手了。 同一个socket自己连自己，会产生TCP自连接，自连接的挥手是两次挥手。 没有listen，两个客户端之间也能建立连接。这种情况叫TCP同时打开，它由四次握手产生。 最后今天提到的，不管是两次挥手，还是自连接，或是TCP同时打开什么的。 咋一看，可能对日常搬砖没什么用，实际上也确实没什么用。 并且在面试上大概率也不会被问到。 毕竟一般面试官也不在意茴字有几种写法。 这篇文章的目的，主要是想从另外一个角度让大家重新认识下socket。原来TCP是可以自己连自己的，甚至两个客户端之间，不用服务端也能连起来。 这实在是，太出乎意料了。 如果文章对你有帮助，欢迎….. 算了。 兄弟们都是自家人，点不点赞，在不在看什么的，没关系的，大家看开心了就好。 在看，点赞什么的，我不是特别在意，真的，真的，别不信啊。 不三连也真的没关系的。 兄弟们不要在意啊。 我是虚伪的小白，我们下期见！ 别说了，一起在知识的海洋里呛水吧点击下方名片，关注公众号:【小白debug】 不满足于在留言区说骚话？ 加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就超！开！心！ 文章推荐： 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 动图图解！GMP模型里为什么要有P？背后的原因让人暖心 i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"动图图解！收到RST，就一定会断开TCP连接吗？","slug":"图解网络/动图图解！收到RST，就一定会断开TCP连接吗？","date":"2021-09-01T14:57:55.000Z","updated":"2021-10-08T01:37:47.143Z","comments":true,"path":"2021/09/01/图解网络/动图图解！收到RST，就一定会断开TCP连接吗？/","link":"","permalink":"https://xiaobaitech.github.io/2021/09/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%94%B6%E5%88%B0RST%EF%BC%8C%E5%B0%B1%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%96%AD%E5%BC%80TCP%E8%BF%9E%E6%8E%A5%E5%90%97%EF%BC%9F/","excerpt":"想必大家已经知道我的niao性，搞个标题，就是不喜欢立马回答。 就是要搞一大堆原理性的东西，再回答标题的问题。 说这个是因为我这次会把问题的答案就放到开头吗？ 不！ 我就不！","text":"想必大家已经知道我的niao性，搞个标题，就是不喜欢立马回答。 就是要搞一大堆原理性的东西，再回答标题的问题。 说这个是因为我这次会把问题的答案就放到开头吗？ 不！ 我就不！ 但是大家可以直接根据目录看自己感兴趣的部分。 之所以要先铺垫一些原理，还是希望大家能先看些基础的，再慢慢循序渐进，这样有利于建立知识体系。多一点上下文，少一点gap。 好了，进入正题。 下面是这篇文章的目录。 什么是RST我们都知道TCP正常情况下断开连接是用四次挥手，那是正常时候的优雅做法。 但异常情况下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。 RST 就是用于这种情况，一般用来异常地关闭一个连接。它是一个TCP包头中的标志位。 正常情况下，不管是发出，还是收到置了这个标志位的数据包，相应的内存、端口等连接资源都会被释放。从效果上来看就是TCP连接被关闭了。 而接收到 RST的一方，一般会看到一个 connection reset 或 connection refused 的报错。 怎么知道收到RST了？我们知道内核跟应用层是分开的两层，网络通信功能在内核，我们的客户端或服务端属于应用层。应用层只能通过 send/recv 与内核交互，才能感知到内核是不是收到了RST。 当本端收到远端发来的RST后，内核已经认为此链接已经关闭。 此时如果本端应用层尝试去执行 读数据操作，比如recv，应用层就会收到 Connection reset by peer 的报错，意思是远端已经关闭连接。 如果本端应用层尝试去执行写数据操作，比如send，那么应用层就会收到 Broken pipe 的报错，意思是发送通道已经坏了。 这两个是开发过程中很经常遇到的报错，感觉大家可以把这篇文章放进收藏夹吃灰了，等遇到这个问题了，再打开来擦擦灰，说不定对你会有帮助。 出现RST的场景有哪些RST一般出现于异常情况，归类为 对端的端口不可用 和 socket提前关闭。 端口不可用端口不可用分为两种情况。要么是这个端口从来就没有”可用”过，比如根本就没监听（listen）过；要么就是曾经”可用”，但现在”不可用”了，比如服务突然崩了。 端口未监听 服务端listen 方法会创建一个sock放入到全局的哈希表中。 此时客户端发起一个connect请求到服务端。服务端在收到数据包之后，第一时间会根据IP和端口从哈希表里去获取sock。 如果服务端执行过listen，就能从全局哈希表里拿到sock。 但如果服务端没有执行过listen，那哈希表里也就不会有对应的sock，结果当然是拿不到。此时，正常情况下服务端会发RST给客户端。 端口未监听就一定会发RST吗？不一定。上面提到，发RST的前提是正常情况下，我们看下源码。 123456789101112131415161718// net/ipv4/tcp_ipv4.c // 代码经过删减int tcp_v4_rcv(struct sk_buff *skb)&#123; // 根据ip、端口等信息 获取sock。 sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest); if (!sk) goto no_tcp_socket;no_tcp_socket: // 检查数据包有没有出错 if (skb-&gt;len &lt; (th-&gt;doff &lt;&lt; 2) || tcp_checksum_complete(skb)) &#123; // 错误记录 &#125; else &#123; // 发送RST tcp_v4_send_reset(NULL, skb); &#125;&#125; 内核在收到数据后会从物理层、数据链路层、网络层、传输层、应用层，一层一层往上传递。到传输层的时候，根据当前数据包的协议是TCP还是UDP走不一样的函数方法。可以简单认为，TCP数据包都会走到 tcp_v4_rcv()。 这个方法会从全局哈希表里获取 sock，如果此时服务端没有listen()过 , 那肯定获取不了sock，会跳转到no_tcp_socket的逻辑。 注意这里会先走一个 tcp_checksum_complete()，目的是看看数据包的**校验和(Checksum)**是否合法。 校验和可以验证数据从端到端的传输中是否出现异常。由发送端计算，然后由接收端验证。计算范围覆盖数据包里的TCP首部和TCP数据。 如果在发送端到接收端传输过程中，数据发生任何改动，比如被第三方篡改，那么接收方能检测到校验和有差错，此时TCP段会被直接丢弃。如果校验和没问题，那才会发RST。 所以，只有在数据包没问题的情况下，比如校验和没问题，才会发RST包给对端。 为什么数据包异常的情况下，不发RST？一个数据包连校验都不能通过，那这个包，多半有问题。 有可能是在发送的过程中被篡改了，又或者，可能只是一个胡乱伪造的数据包。 五层网络，不管是哪一层，只要遇到了这种数据，推荐的做法都是默默扔掉，而不是去回复一个消息告诉对方数据有问题。 如果对方用的是TCP，是可靠传输协议，发现很久没有ACK响应，自己就会重传。 如果对方用的是UDP，说明发送端已经接受了“不可靠会丢包”的事实，那丢了就丢了。 因此，数据包异常的情况下，默默扔掉，不发RST，非常合理。 还是不能理解？那我再举个例子。 正常人喷你，他说话条理清晰，主谓宾分明。此时你喷回去，那你是个充满热情，正直，富有判断力的好人。 而此时一个憨憨也想喷你，但他思维混乱，连话都说不清楚，一直阿巴阿巴的，你虽然听不懂，但大受震撼，此时你会？ A：跟他激情互喷 B：不跟他一般见识，就当没听过 一般来说最优选择是B，毕竟你理他，他反而来劲。 这下，应该就懂了。 程序启动了但是崩了端口不可用的场景里，除了端口未监听以外，还有可能是从前监听了，但服务端机器上做监听操作的应用程序突然崩了，此时客户端还像往常一样正常发送消息，服务器内核协议栈收到消息后，则会回一个RST。在开发过程中，这种情况是最常见的。 比如你的服务端应用程序里，弄了个空指针，或者数组越界啥的，程序立马就崩了。 这种情况跟端口未监听本质上类似，在服务端的应用程序崩溃后，原来监听的端口资源就被释放了，从效果上来看，类似于处于CLOSED状态。 此时服务端又收到了客户端发来的消息，内核协议栈会根据IP端口，从全局哈希表里查找sock，结果当然是拿不到对应的sock数据，于是走了跟上面**”端口未监听”时一样的逻辑，回了个RST。客户端在收到RST后也释放了sock资源，从效果上来看，就是连接断了**。 RST和502的关系上面这张图，服务端程序崩溃后，如果客户端再有数据发送，会出现RST。但如果在客户端和服务端中间再加一个nginx，就像下图一样。 nginx会作为客户端和服务端之间的”中间人角色”，负责转发请求和响应结果。但当服务端程序崩溃，比如出现野指针或者OOM的问题，那转发到服务器的请求，必然得不到响应，后端服务端还会返回一个RST给nginx。nginx在收到这个RST后会断开与服务端的连接，同时返回客户端一个502错误码。 所以，出现502问题，一般情况下都是因为后端程序崩了，基于这一点假设，去看看监控是不是发生了OOM或者日志是否有空指针等报错信息。 socket提前关闭这种情况分为本端提前关闭，和远端提前关闭。 本端提前关闭如果本端socket接收缓冲区还有数据未读，此时提前close() socket。那么本端会先把接收缓冲区的数据清空，然后给远端发一个RST。 远端提前关闭远端已经close()了socket，此时本端还尝试发数据给远端。那么远端就会回一个RST。 大家知道，TCP是全双工通信，意思是发送数据的同时，还可以接收数据。 Close()的含义是，此时要同时关闭发送和接收消息的功能。 客户端执行close()， 正常情况下，会发出第一次挥手FIN，然后服务端回第二次挥手ACK。如果在第二次和第三次挥手之间，如果服务方还尝试传数据给客户端，那么客户端不仅不收这个消息，还会发一个RST消息到服务端。直接结束掉这次连接。 对方没收到RST，会怎么样？我们知道TCP是可靠传输，意味着本端发一个数据，远端在收到这个数据后就会回一个ACK，意思是”我收到这个包了”。 而RST，不需要ACK确认包。 因为RST本来就是设计来处理异常情况的，既然都已经在异常情况下了，还指望对方能正常回你一个ACK吗？可以幻想，不要妄想。 但问题又来了，网络环境这么复杂，丢包也是分分钟的事情，既然RST包不需要ACK来确认，那万一对方就是没收到RST，会怎么样？ RST丢了，问题不大。比方说上图服务端，发了RST之后，服务端就认为连接不可用了。 如果客户端之前发送了数据，一直没等到这个数据的确认ACK，就会重发，重发的时候，自然就会触发一个新的RST包。 而如果客户端之前没有发数据，但服务端的RST丢了，TCP有个keepalive机制，会定期发送探活包，这种数据包到了服务端，也会重新触发一个RST。 收到RST就一定会断开连接吗?先说结论，不一定会断开。我们看下源码。 1234567891011121314151617181920// net/ipv4/tcp_input.cstatic bool tcp_validate_incoming()&#123; // 获取sock struct tcp_sock *tp = tcp_sk(sk); // step 1：先判断seq是否合法（是否在合法接收窗口范围内） if (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123; goto discard; &#125; // step 2：执行收到 RST 后该干的事情 if (th-&gt;rst) &#123; if (TCP_SKB_CB(skb)-&gt;seq == tp-&gt;rcv_nxt) tcp_reset(sk); else tcp_send_challenge_ack(sk); goto discard; &#125;&#125; 收到RST包，第一步会通过tcp_sequence先看下这个seq是否合法，其实主要是看下这个seq是否在合法接收窗口范围内。如果不在范围内，这个RST包就会被丢弃。 至于接收窗口是个啥，我们先看下面这个图。 这里黄色的部分，就是指接收窗口，只要RST包的seq不在这个窗口范围内，那就会被丢弃。 为什么要校验是否在窗口范围内正常情况下客户端服务端双方可以通过RST来断开连接。假设不做seq校验，如果这时候有不怀好意的第三方介入，构造了一个RST包，且在TCP和IP等报头都填上客户端的信息，发到服务端，那么服务端就会断开这个连接。同理也可以伪造服务端的包发给客户端。这就叫RST攻击。 受到RST攻击时，从现象上看，客户端老感觉服务端崩了，这非常影响用户体验。 如果这是个游戏，我相信多崩几次，第二天大家就不来玩了。 实际消息发送过程中，接收窗口是不断移动的，seq也是在飞快的变动中，此时第三方是比较难构造出合法seq的RST包的，那么通过这个seq校验，就可以拦下了很多不合法的消息。 加了窗口校验就不能用RST攻击了吗不是，只是增加了攻击的成本。但如果想搞，还是可搞的。 以下是面向监狱编程的环节。 希望大家只了解原理就好了，不建议使用。 相信大家都不喜欢穿着蓝白条纹的衣服，拍纯狱风的照片。 从上面可以知道，不是每一个RST包都会导致连接重置的，要求是这个RST包的seq要在窗口范围内，所以，问题就变成了，我们怎么样才能构造出合法的seq。 盲猜seq窗口数值seq本质上只是个uint32类型。 123struct tcp_skb_cb &#123; __u32 seq; /* Starting sequence number */&#125; 如果在这个范围内疯狂猜测seq数值，并构造对应的包，发到目的机器，虽然概率低，但是总是能被试出来，从而实现RST攻击。这种乱棍打死老师傅的方式，就是所谓的合法窗口盲打（blind in-window attacks）。 觉得这种方式比较笨？那有没有聪明点的方式，还真有，但是在这之前需要先看下面的这个问题。 已连接状态下收到第一次握手包会怎么样？我们需要了解一个问题，比如服务端在已连接（ESTABLISHED）状态下，如果收到客户端发来的第一次握手包（SYN），会怎么样？ 以前我以为服务单会认为客户端憨憨了，直接RST连接。 但实际，并不是。 123456789101112131415161718192021static bool tcp_validate_incoming()&#123; struct tcp_sock *tp = tcp_sk(sk); /* 判断seq是否在合法窗口内 */ if (!tcp_sequence(tp, TCP_SKB_CB(skb)-&gt;seq, TCP_SKB_CB(skb)-&gt;end_seq)) &#123; if (!th-&gt;rst) &#123; // 收到一个不在合法窗口内的SYN包 if (th-&gt;syn) goto syn_challenge; &#125; &#125; /* * RFC 5691 4.2 : 发送 challenge ack */ if (th-&gt;syn) &#123;syn_challenge: tcp_send_challenge_ack(sk); &#125;&#125; 当客户端发出一个不在合法窗口内的SYN包的时候，服务端会发一个带有正确的seq数据ACK包出来，这个ACK包叫 challenge ack。 上图是抓包的结果，用scapy随便伪造一个seq=5的包发到服务端（端口9090），服务端回复一个带有正确seq值的challenge ack包给客户端（端口8888）。 利用challenge ack获取seq上面提到的这个challenge ack ，仿佛为盲猜seq的老哥们打开了一个新世界。 在获得这个challenge ack后，攻击程序就可以以ack值为基础，在一定范围内设置seq，这样造成RST攻击的几率就大大增加了。 总结 RST其实是TCP包头里的一个标志位，目的是为了在异常情况下关闭连接。 内核收到RST后，应用层只能通过调用读/写操作来感知，此时会对应获得 Connection reset by peer 和Broken pipe 报错。 发出RST后不需要得到对方的ACK确认包，因此RST丢失后对方不能立刻感知，但是通过下一次重传数据或keepalive心跳包可以导致RST重传。 收到RST包，不一定会断开连接，seq不在合法窗口范围内的数据包会被默默丢弃。通过构造合法窗口范围内seq，可以造成RST攻击，这一点大家了解就好，千万别学！ 参考资料TCP旁路攻击分析与重现 - https://www.cxyzjd.com/article/qq_27446553/52416369 最后最近想用vscode写小说了，故事梗概都想好了。 十年前，他是大厂最年轻CTO，闭眼刷leetcode，敲代码 0 error ，0 warning， 却被诬陷删库跑路，锒铛入狱，众叛亲离……十年后，他重新归来！却看到自己的女儿在仇人公司里修bug！ “我要你付出代价！” 一声令下，十万 p7，p8 应声前来……. 爽否？ 如果文章对你有帮助，欢迎….. 算了。 兄弟们都是自家人，点不点赞，在不在看什么的，没关系的，大家看开心了就好。 在看，点赞什么的，我不是特别在意，真的，真的，别不信啊。 不三连也真的没关系的。 兄弟们不要在意啊。 我是虚伪的小白，我们下期见！ 别说了，一起在知识的海洋里呛水吧点击下方名片，关注公众号:【小白debug】 不满足于在留言区说骚话？ 加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点阳间的话题。就超！开！心！ 文章推荐： 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 动图图解！既然IP层会分片，为什么TCP层也还要分段？","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"动图图解！代码执行send成功后，数据就发出去了吗？","slug":"图解网络/动图图解！代码执行send成功后，数据就发出去了吗？","date":"2021-08-10T14:57:55.000Z","updated":"2021-10-08T01:37:46.938Z","comments":true,"path":"2021/08/10/图解网络/动图图解！代码执行send成功后，数据就发出去了吗？/","link":"","permalink":"https://xiaobaitech.github.io/2021/08/10/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8Csend%E6%88%90%E5%8A%9F%E5%90%8E%EF%BC%8C%E6%95%B0%E6%8D%AE%E5%B0%B1%E5%8F%91%E5%87%BA%E5%8E%BB%E4%BA%86%E5%90%97%EF%BC%9F/","excerpt":"今天又是被倾盆的需求淹没的一天。 有没有人知道，那种“我用3句话，就让产品为我砍了18个需求”的鸡汤课在哪报名，想报。","text":"今天又是被倾盆的需求淹没的一天。 有没有人知道，那种“我用3句话，就让产品为我砍了18个需求”的鸡汤课在哪报名，想报。 “听懂掌声“的那种课就算了，太费手了。 扯远了，回到我们今天的正题，我们了解下这篇文的目录。 代码执行send成功后，数据就发出去了吗？ 回答这个问题之前，需要了解什么是Socket 缓冲区。 Socket 缓冲区什么是 socket 缓冲区编程的时候，如果要跟某个IP建立连接，我们需要调用操作系统提供的 socket API。 socket 在操作系统层面，可以理解为一个文件。 我们可以对这个文件进行一些方法操作。 用listen方法，可以让程序作为服务器监听其他客户端的连接。 用connect，可以作为客户端连接服务器。 用send或write可以发送数据，recv或read可以接收数据。 在建立好连接之后，这个 socket 文件就像是远端机器的 “代理人” 一样。比如，如果我们想给远端服务发点什么东西，那就只需要对这个文件执行写操作就行了。 那写到了这个文件之后，剩下的发送工作自然就是由操作系统内核来完成了。 既然是写给操作系统，那操作系统就需要提供一个地方给用户写。同理，接收消息也是一样。 这个地方就是 socket 缓冲区。 用户发送消息的时候写给 send buffer（发送缓冲区）。 用户接收消息的时候，是从 recv buffer（接收缓冲区）中读取数据。 也就是说一个socket ，会带有两个缓冲区，一个用于发送，一个用于接收。因为这是个先进先出的结构，有时候也叫它们发送、接收队列。 怎么观察 socket 缓冲区如果想要查看 socket 缓冲区，可以在linux环境下执行 netstat -nt 命令。 1234# netstat -ntActive Internet connections (w/o servers)Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 60 172.22.66.69:22 122.14.220.252:59889 ESTABLISHED 这上面表明了，这里有一个协议（Proto）类型为 TCP 的连接，同时还有本地（Local Address）和远端（Foreign Address）的IP信息，状态（State）是已连接。 还有Send-Q 是发送缓冲区，下面的数字60是指，当前还有60 Byte在发送缓冲区中未发送。而 Recv-Q 代表接收缓冲区， 此时是空的，数据都被应用进程接收干净了。 TCP部分我们在使用TCP建立连接之后，一般会使用 send 发送数据。 12345678910111213141516int main(int argc, char *argv[])&#123; // 创建socket sockfd=socket(AF_INET,SOCK_STREAM, 0)) // 建立连接 connect(sockfd, 服务器ip信息, sizeof(server)) // 执行 send 发送消息 send(sockfd,str,sizeof(str),0)) // 关闭 socket close(sockfd); return 0;&#125; 上面是一段伪代码，仅用于展示大概逻辑，我们在建立好连接后，一般会在代码中执行 send 方法。那么此时，消息就会被立刻发到对端机器吗？ 执行 send 发送的字节，会立马发送吗？答案是不确定！执行 send 之后，数据只是拷贝到了socket 缓冲区。至于什么时候会发数据，发多少数据，全听操作系统安排。 在用户进程中，程序通过操作 socket 会从用户态进入内核态，而 send方法会将数据一路传到传输层。在识别到是 TCP协议后，会调用 tcp_sendmsg 方法。 1234567891011// net/ipv4/tcp.c// 以下省略了大量逻辑int tcp_sendmsg()&#123; // 如果还有可以放数据的空间 if (skb_availroom(skb) &gt; 0) &#123; // 尝试拷贝待发送数据到发送缓冲区 err = skb_add_data_nocache(sk, skb, from, copy); &#125; // 下面是尝试发送的逻辑代码,先省略 &#125; 在 tcp_sendmsg 中， 核心工作就是将待发送的数据组织按照先后顺序放入到发送缓冲区中， 然后根据实际情况（比如拥塞窗口等）判断是否要发数据。如果不发送数据，那么此时直接返回。 如果缓冲区满了会怎么办前面提到的情况里是，发送缓冲区有足够的空间，可以用于拷贝待发送数据。 如果发送缓冲区空间不足，或者满了，执行发送，会怎么样？这里分两种情况。 首先，socket在创建的时候，是可以设置是阻塞的还是非阻塞的。 1int s = socket(AF_INET, SOCK_STREAM | SOCK_NONBLOCK, IPPROTO_TCP); 比如通过上面的代码，就可以将 socket 设置为非阻塞 （SOCK_NONBLOCK）。 当发送缓冲区满了，如果还向socket执行send 如果此时 socket 是阻塞的，那么程序会在那干等、死等，直到释放出新的缓存空间，就继续把数据拷进去，然后返回。 如果此时 socket 是非阻塞的，程序就会立刻返回一个 EAGAIN 错误信息，意思是 Try again , 现在缓冲区满了，你也别等了，待会再试一次。 我们可以简单看下源码是怎么实现的。还是回到刚才的 tcp_sendmsg 发送方法中。 12345678910int tcp_sendmsg()&#123; if (skb_availroom(skb) &gt; 0) &#123; // ..如果有足够缓冲区就执行balabla &#125; else &#123; // 如果发送缓冲区没空间了，那就等到有空间，至于等的方式，分阻塞和非阻塞 if ((err = sk_stream_wait_memory(sk, &amp;timeo)) != 0) goto do_error; &#125; &#125; 里面提到的 sk_stream_wait_memory 会根据socket是否阻塞，来决定是一直等，还是等一会就返回。 123456789101112int sk_stream_wait_memory(struct sock *sk, long *timeo_p)&#123; while (1) &#123; // 非阻塞模式时，会等到超时返回 EAGAIN if (等待超时)) return -EAGAIN; // 阻塞等待时，会等到发送缓冲区有足够的空间了，才跳出 if (sk_stream_memory_free(sk) &amp;&amp; !vm_wait) break; &#125; return err;&#125; 如果接收缓冲区为空，执行 recv 会怎么样？接收缓冲区也是类似的情况。 当接收缓冲区为空，如果还向socket执行 recv 如果此时 socket 是阻塞的，那么程序会在那干等，直到接收缓冲区有数据，就会把数据从接收缓冲区拷贝到用户缓冲区，然后返回。 如果此时 socket 是非阻塞的，程序就会立刻返回一个 EAGAIN 错误信息。 下面用一张图汇总一下，方便大家保存面试的时候用哈哈哈。 如果socket缓冲区还有数据，执行close了，会怎么样？首先我们要知道，一般正常情况下，发送缓冲区和接收缓冲区 都应该是空的。 如果发送、接收缓冲区长时间非空，说明有数据堆积，这往往是由于一些网络问题或用户应用层问题，导致数据没有正常处理。 正常情况下，如果 socket 缓冲区为空，执行 close。就会触发四次挥手。 这个也是面试老八股文内容了，这里我们只需要关注第一次挥手，发的是 FIN 就够了。 如果接收缓冲区有数据时，执行close了，会怎么样？socket close 时，主要的逻辑在 tcp_close() 里实现。 先说结论，关闭过程主要有两种情况： 如果接收缓冲区还有数据未读，会先把接收缓冲区的数据清空，然后给对端发一个RST。 如果接收缓冲区是空的，那么就调用 tcp_send_fin() 开始进行四次挥手过程的第一次挥手。 1234567891011121314151617181920void tcp_close(struct sock *sk, long timeout)&#123; // 如果接收缓冲区有数据，那么清空数据 while ((skb = __skb_dequeue(&amp;sk-&gt;sk_receive_queue)) != NULL) &#123; u32 len = TCP_SKB_CB(skb)-&gt;end_seq - TCP_SKB_CB(skb)-&gt;seq - tcp_hdr(skb)-&gt;fin; data_was_unread += len; __kfree_skb(skb); &#125; if (data_was_unread) &#123; // 如果接收缓冲区的数据被清空了，发 RST tcp_send_active_reset(sk, sk-&gt;sk_allocation); &#125; else if (tcp_close_state(sk)) &#123; // 正常四次挥手， 发 FIN tcp_send_fin(sk); &#125; // 等待关闭 sk_stream_wait_close(sk, timeout);&#125; 如果发送缓冲区有数据时，执行close了，会怎么样？以前以为，这种情况下，内核会把发送缓冲区数据清空，然后四次挥手。 但是发现源码并不是这样的。 1234567891011121314151617void tcp_send_fin(struct sock *sk)&#123; // 获得发送缓冲区的最后一块数据 struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk); struct tcp_sock *tp = tcp_sk(sk); // 如果发送缓冲区还有数据 if (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) &#123; TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN; // 把最后一块数据值为 FIN TCP_SKB_CB(tskb)-&gt;end_seq++; tp-&gt;write_seq++; &#125; else &#123; // 发送缓冲区没有数据，就造一个FIN包 &#125; // 发送数据 __tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);&#125; 此时，还有些数据没发出去，内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。 socket 缓冲区是个先进先出的队列，这种情况是指，内核会等待TCP层安静地把发送缓冲区数据都发完，最后再执行 四次挥手的第一次挥手（FIN包）。 有一点需要注意的是，只有在接收缓冲区为空的前提下，我们才有可能走到 tcp_send_fin() 。而只有在进入了这个方法之后，我们才有可能考虑发送缓冲区是否为空的场景。 UDP部分UDP也有缓冲区吗说完TCP了，我们聊聊UDP。这对好基友，同时都是传输层里的重要协议。既然前面提到TCP有发送、接收缓冲区，那UDP有吗？ 以前我以为。 “每个UDP socket都有一个接收缓冲区，没有发送缓冲区，从概念上来说就是只要有数据就发，不管对方是否可以正确接收，正因为不需要缓冲数据，所以也不需要发送缓冲区。” 后来我发现我错了。 UDP socket 也是 socket，一个socket 就是会有收和发两个缓冲区。跟用什么协议关系不大。 有没有是一回事，用不用又是另外一回事。 UDP不用发送缓冲区？事实上，UDP不仅有发送缓冲区，也用发送缓冲区。 一般正常情况下，会把数据直接拷到发送缓冲区后直接发送。 还有一种情况，是在发送数据的时候，设置一个 MSG_MORE 的标记。 1ssize_t send(int sock, const void *buf, size_t len, int flags); // flag 置为 MSG_MORE 大概的意思是告诉内核，待会还有其他更多消息要一起发，先别着急发出去。此时内核就会把这份数据先用发送缓冲区缓存起来，待会应用层说ok了，再一起发。 我们可以看下源码。 12345678910111213141516int udp_sendmsg()&#123; // corkreq 为 true 表示是 MSG_MORE 的方式，仅仅组织报文，不发送； int corkreq = up-&gt;corkflag || msg-&gt;msg_flags&amp;MSG_MORE； // 将要发送的数据，按照MTU大小分割，每个片段一个skb；并且这些 // skb会放入到套接字的发送缓冲区中；该函数只是组织数据包，并不执行发送动作。 err = ip_append_data(sk, fl4, getfrag, msg-&gt;msg_iov, ulen, sizeof(struct udphdr), &amp;ipc, &amp;rt, corkreq ? msg-&gt;msg_flags|MSG_MORE : msg-&gt;msg_flags); // 没有启用 MSG_MORE 特性，那么直接将发送队列中的数据发送给IP。 if (!corkreq) err = udp_push_pending_frames(sk);&#125; 因此，不管是不是 MSG_MORE， IP都会先把数据放到发送队列中，然后根据实际情况再考虑是不是立刻发送。 而我们大部分情况下，都不会用 MSG_MORE，也就是来一个数据包就直接发一个数据包。从这个行为上来说，虽然UDP用上了发送缓冲区，但实际上并没有起到”缓冲”的作用。 最后这篇文章，我也就写了20个小时吧。画图也就画吐了而已，每天早上7点钟爬起来写一个多小时再去上班。 兄弟们都是自家人，点不点赞，在不在看什么的，没关系的，大家看开心了就好。 在看，点赞什么的，我不是特别在意，真的，真的，别不信啊。 不三连也真的没关系的。 兄弟们不要在意啊。 我是心口不一的小白，我们下期见！ 别说了，一起在知识的海洋里呛水吧点击下方名片，关注公众号:【小白debug】 文章推荐： 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 动图图解！GMP模型里为什么要有P？背后的原因让人暖心 i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"连接一个 IP 不存在的主机时，握手过程是怎样的？","slug":"图解网络/连接一个IP不存在的主机时，握手过程是怎样的","date":"2021-07-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.552Z","comments":true,"path":"2021/07/25/图解网络/连接一个IP不存在的主机时，握手过程是怎样的/","link":"","permalink":"https://xiaobaitech.github.io/2021/07/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%BF%9E%E6%8E%A5%E4%B8%80%E4%B8%AAIP%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84%E4%B8%BB%E6%9C%BA%E6%97%B6%EF%BC%8C%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 鸽了好长时间了，最近很忙。以前工作忙完，就抽空写文章。 现在忙完工作，还要一三五学驾照，二四六看家具。有同感的老铁们不要举手，拉到右下角**点个”在看”**就好了。 真的，全怪某音。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 鸽了好长时间了，最近很忙。以前工作忙完，就抽空写文章。 现在忙完工作，还要一三五学驾照，二四六看家具。有同感的老铁们不要举手，拉到右下角**点个”在看”**就好了。 真的，全怪某音。 扯远了，回到今天的主题。 方兄最近写了篇很赞的文章 写给想去字节写 Go 的你 ，里面提到了两个问题。 连接一个 IP 不存在的主机时，握手过程是怎样的？ 连接一个 IP 地址存在但端口号不存在的主机时，握手过程又是怎样的呢？ 让我回想起曾经也被面试官也问过类似的问题，意识到应该很多朋友会对这个问题感兴趣。 所以来给大家唠唠。 这两个问题可以延伸出非常多的点。 看完了，说不定能加分！ 正常情况的握手过程是怎么样的上面提到的问题，其实是指TCP的三次握手流程。这绝对是面试八股文里的老股了。 我们简单回顾下基础知识点。 在服务端启动好后会调用 listen() 方法，进入到 LISTEN 状态，然后静静等待客户端的连接请求到来。 而此时客户端主动调用 connect(IP地址) ，就会向某个IP地址发起第一次握手，发送SYN 到目的服务器。 服务器在收到第一次握手后就会响应客户端，这是第二次握手。 客户端在收到第二次握手的消息后，响应服务的一个ACK，这算第三次握手，此时客户端 就会进入 ESTABLISHED状态，认为连接已经建立完成。 通过抓包可以直观看出三次握手的流程。 连一个 IP 不存在的主机时，握手过程是怎样的那不存在的IP，分两种，局域网内和局域网外的。 我以我家里的情况举例。 家里有一台家用路由器。本质上它的功能已经集成了我们常说的路由器，交换机和无线接入点的功能了。 其中路由器和交换机在之前写过的 《硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？》里已经详细介绍过了，就不再说一遍了。无线接入点基本可以认为就是个放出 wifi 信号的组件。 家用路由器下，连着我的N台设备，包括手机和电脑，他们的IP都有个共同点。都是 192.168.31.xx 形式的。其中，我的电脑的IP是192.168.31.6 ，这个可以通过 ifconfig查到。 符合这个形式的这些个设备，本质上就是通过各种设备（wifi或交换机等）接入到上图路由器的e2端口，他们共同构成一个局域网。 因此，在我家，我们可以粗暴点认为只要是 192.168.31.xx 形式的IP，就是局域网内的IP。否则就是局域网外的IP，比如 192.0.2.2 。 目的IP在局域网内因为通过 ifconfig 可以查到我的局域网内IP是192.168.31.6 ，这里盲猜末尾+1是不存在的 IP 。试了下，192.168.31.7 还真不存在。 123456789$ ping 192.168.31.7PING 192.168.31.7 (192.168.31.7): 56 data bytesRequest timeout for icmp_seq 0Request timeout for icmp_seq 1Request timeout for icmp_seq 2Request timeout for icmp_seq 3^C--- 192.168.31.7 ping statistics ---5 packets transmitted, 0 packets received, 100.0% packet loss 于是写个程序尝试连这个IP 。下面的代码是 golang 写的，大家不看代码也没关系，放出来只是方便大家自己复现的时候用的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// tcp客户端package mainimport ( &quot;fmt&quot; &quot;io&quot; &quot;net&quot; &quot;os&quot;)func main() &#123; client, err := net.Dial(&quot;tcp&quot;, &quot;192.168.31.7:8081&quot;) if err != nil &#123; fmt.Println(&quot;err:&quot;, err) return &#125; defer client.Close() go func() &#123; input := make([]byte, 1024) for &#123; n, err := os.Stdin.Read(input) if err != nil &#123; fmt.Println(&quot;input err:&quot;, err) continue &#125; client.Write([]byte(input[:n])) &#125; &#125;() buf := make([]byte, 1024) for &#123; n, err := client.Read(buf) if err != nil &#123; if err == io.EOF &#123; return &#125; fmt.Println(&quot;read err:&quot;, err) continue &#125; fmt.Println(string(buf[:n])) &#125;&#125; 然后尝试抓包。 可以发现根本没有三次握手的包，只有一些 ARP 包，在询问“谁是 192.168.31.7，告诉一下 192.168.31.6” 。 这里有三个问题 为什么会发ARP请求？ 为什么没有TCP握手包？ ARP本身是没有重试机制的，为什么ARP请求会发那么多遍？ 首先我们看下正常情况下执行connect，也就是第一次握手 的流程。 应用层执行connect过后，会通过socket层，操作系统接口，进程会从用户态进入到内核态，此时进入 传输层，因为是TCP第一次握手，会加入TCP头，且置SYN标志。 然后进入网络层，我想要连的是 192.168.31.7 ，虽然它是我瞎编的，但IP头还是得老老实实把它加进去。 此时需要重点介绍的是邻居子系统，它在网络层和数据链路层之间。可以通过ARP协议将目的IP转为对应的MAC地址，然后数据链路层就可以用这个MAC地址组装帧头。 我们看下那么ARP协议的流程是 1.先到本地ARP表查一下有没有 192.168.31.7 对应的 mac地址，有的话就返回，这里显然是不可能会有的。 可以通过 arp -a 命令查看本机的 arp表都记录了哪些信息 1234$ arp -a? (192.168.31.1) at 88:c1:97:59:d1:c3 on en0 ifscope [ethernet]? (224.0.0.251) at 1:0:4e:0:1:fb on en0 ifscope permanent [ethernet]? (239.255.255.250) at 1:0:3e:7f:ff:fb on en0 ifscope permanent [ethernet] 2.看下 192.168.31.7 跟本机IP 192.168.31.6 在不在一个局域网下。如果在的话，就在局域网内发一个 arp 广播，内容就是 前面提到的 “谁是 192.168.31.7，告诉一下 192.168.31.6”。 3.如果目的IP跟本机IP不在同一个局域网下，那么会去获取默认网关的MAC地址，这里就是指获取家用路由器的MAC地址。然后把消息发给家用路由器，让路由器发到互联网，找到下一跳路由器，一跳一跳的发送数据，直到把消息发到目的IP上，又或者找不到目的地最终被丢弃。 4.第2和第3点都是本地没有查到 ARP 缓存记录的情况，这时候会把SYN报文放进一个队列（叫unresolved_queue）里暂存起来，然后发起ARP请求；等ARP层收到ARP回应报文之后，会再从缓存中取出 SYN 报文，组装 MAC 帧头，完成刚刚没完成的发送流程。 如果经过 ARP 流程能正常返回 MAC 地址，那皆大欢喜，直接给数据链路层，经过 ring buffer 后传到网卡，发出去。 但因为现在这个IP是瞎编的，因此不可能得到目的地址 MAC ，所以消息也一直没法到数据链路层。整个流程卡在了ARP流程中。 而抓包是在数据链路层之后进行的，因此 TCP 第一次握手的包一直没能抓到，只能抓到为了获得 192.168.31.7 的MAC地址的ARP请求。 发送数据时，是在经过数据链路层之后的 dev_queue_xmit_nit 方法执行抓包操作的，这是属于网卡驱动层的方法了。 顺带一提，接收端抓包是在 __netif_receive_skb_core 方法里执行的，也属于网卡驱动层。感兴趣的朋友们可以以这个为关键词搜索相关知识点哈 此时 因为 TCP 协议是可靠的协议，对于 TCP 层来说，第一次握手的消息，已经发出去了，但是一直没有收到 ACK。也不知道消息是出去后是遇到什么事了。为了保证可靠性，它会不断重发。 而每一次重发，都会因为同样的原因（没有目的 MAC 地址）而尬在了 ARP 那个流程里。因此，才看到好几次重复的 ARP 消息。 那回到刚刚的三个问题 为什么会发 ARP 请求？ 因为目的地址是瞎编的，本地ARP表没有目的机器的MAC地址，因此发出ARP消息。 为什么没有 TCP 握手包？ 因为协议栈的数据到了网络层后，在数据链路层前，就因为没有目的MAC地址，没法发出。因此抓包软件抓不到相关数据。 为什么 ARP 请求会发那么多遍？ 因为 TCP 协议的可靠性，会重发第一次握手的消息，但每一次都因为没有目的 MAC 地址而失败，每次都会发出ARP请求。 小结连一个 IP 不存在的主机时，如果目的IP在局域网内，则第一次握手会失败，接着不断尝试重发握手的请求。同时，本机会不断发出ARP请求，企图获得目的机器的 MAC 地址。并且，因为没能获得目的 MAC 地址，这些 TCP 握手请求最终都发不出去， 目的IP在局域网外上面提到的是，目的 IP 在局域网内的情况，下面讨论目的IP在局域网外的情况。 瞎编一个不是 192.168.31.xx 形式的 IP 作为这次要用的局域网外IP， 比如 10.225.31.11。 先抓包看一下。 这次的现象是能发出 TCP 第一次握手的 SYN包。 这里有两个问题 为什么连局域网外的 IP 现象跟连局域网内不一致？ TCP 第一次握手的重试规律好像不太对？ 为什么连局域网外的IP现象跟连局域网内不一致？这个问题的答案其实在上面 ARP 的流程里已经提到过了，如果目的 IP 跟本机 IP 不在同一个局域网下，那么会去获取默认网关的 MAC 地址，这里就是指获取家用路由器的MAC地址。 此时ARP流程成功返回家用路由器的 MAC 地址，数据链路层加入帧头，消息通过网卡发到了家用路由器上。 消息会通过互联网一直传递到某个局域网为 10.225.31.xx 的路由器上，那个路由器 发出ARP 请求，询问他们局域网内的机器有没有叫 10.225.31.11的 （结果当然没有）。 最终没能发送成功，发送端也就迟迟收不到目的机的第二次握手响应。 因此触发TCP重传。 TCP第一次握手的重试规律好像不太对？在 Linux 中，第一次握手的 SYN 重传次数，是通过 tcp_syn_retries 参数控制的。可以通过下面的方式查看 12$cat /proc/sys/net/ipv4/tcp_syn_retries6 这里的含义是指 syn重传 会发生6次。 而每次重试都会间隔一定的时间，这里的间隔一般是 1s，2s，4s，8s, 16s, 32s . 而事实上，看我的截图，是先重试4次，每次都是1s，之后才是 1s，2s，4s，8s, 16s, 32s 的重试。 这跟我们知道的不太一样。 这个是因为我用的是macOS抓的包，跟linux就不是一个系统，各自的TCP协议栈在sync重传方面的实现都可能会有一定的差异。 我还听说 oppo 和 vivo 的 syn重传 是0.5s起步的。而 windows 的 syn重传 还有自己的专利。 这些冷知识大家可以不用在意。面试的时候知道linux的就够了，剩下的可以用来装逼。毕竟面试官不在意”茴”字到底有几种写法。 连IP 地址存在但端口号不存在的主机的握手过程前面提到的是IP地址压根就不存在的情况。假如IP地址存在但端口号是瞎编的呢？ 目的IP是回环地址 现象也比较简单，已经IP地址是存在的，也就是在互联网中这个机器是存在的。 那么我们可以正常发消息到目的IP，因为对应的MAC地址和IP都是正确的，所以，数据从数据链路层到网络层都很OK。 直到传输层，TCP协议在识别到这个端口号对应的进程根本不存在时，就会把数据丢弃，响应一个RST消息给发送端。 RST是什么？我们都是到TCP正常情况下断开连接是用四次挥手，那是正常时候的优雅做法。 但异常情况下，收发双方都不一定正常，连挥手这件事本身都可能做不到，所以就需要一个机制去强行关闭连接。 RST 就是用于这种情况，一般用来异常地关闭一个连接。它在TCP包头中，在收到置了这个标志位的数据包后，连接就会被关闭，此时接收到 RST的一方，一般会看到一个 connection reset 或 connection refused 的报错。 目的IP在局域网内刚刚提到我的本机IP是 192.168.31.6 ，局域网内有台 192.168.31.1 。同样尝试连一个不存在的端口。 此时现象跟前者一致。 唯一不同的是，前者是回环地址，RST数据是从本机的传输层返回的。而这次的情况，RST数据是从目的机器的传输层返回的。 目的IP在局域网外找一个存在的外网ip，这里我拿了最近刚白嫖的阿里云服务器地址 47.102.221.141 。（炫耀） 进行连接连接，发现与前面两种情况是一致的，目的机器在收到我的请求后，立马就通过 RST标志位 断开了这次的连接。 这一点跟前面两种情况一致。 熟悉小白的朋友们都知道，每次搞事情做测试，都会用 baidu.com 。 这次也不例外，ping 一下 baidu.com ,获得它的 IP: 220.181.38.148 。 123456789101112$ ping baidu.comPING baidu.com (220.181.38.148): 56 data bytes64 bytes from 220.181.38.148: icmp_seq=0 ttl=48 time=35.728 ms64 bytes from 220.181.38.148: icmp_seq=1 ttl=48 time=38.052 ms64 bytes from 220.181.38.148: icmp_seq=2 ttl=48 time=37.845 ms64 bytes from 220.181.38.148: icmp_seq=3 ttl=48 time=37.210 ms64 bytes from 220.181.38.148: icmp_seq=4 ttl=48 time=38.402 ms64 bytes from 220.181.38.148: icmp_seq=5 ttl=48 time=37.692 ms^C--- baidu.com ping statistics ---6 packets transmitted, 6 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 35.728/37.488/38.402/0.866 ms 发消息到给百度域名背后的 IP，且瞎随机指定一个端口 8080， 抓包。 现象却不一致。没有 RST 。而且触发了第一次握手的重试消息。这是为什么？ 这是因为baidu的机器，作为线上生产的机器，会设置一系列安全策略，比如只对外暴露某些端口，除此之外的端口，都一律拒绝。 所以很多发到 8080端口的消息都在防火墙这一层就被拒绝掉了，根本到不了目的主机里，而RST是在目的主机的TCP/IP协议栈里发出的，都还没到这一层，就更不可能发RST了。因此发送端发现消息没有回应（因为被防火墙丢了），就会重传。所以才会出现上述抓包里的现象。 总结连一个 IP 不存在的主机时 如果IP在局域网内，会发送N次ARP请求获得目的主机的MAC地址，同时不能发出TCP握手消息。 如果IP在局域网外，会将消息通过路由器发出，但因为最终找不到目的地，触发TCP重试流程。 连IP 地址存在但端口号不存在的主机时 不管目的IP是回环地址还是局域网内外的IP地址，目的主机的传输层都会在收到握手消息后，发现端口不正确，发出RST消息断开连接。 当然如果目的机器设置了防火墙策略，限制他人将消息发到不对外暴露的端口，那么这种情况，发送端就会不断重试第一次握手。 最后留个问题，连一个 不存在的局域网外IP的主机时，我们可以看到TCP的重发规律是：开始时，每隔1s重发五次 TCP SYN消息，接着2s,4s,8s,16s,32s都重发一次； 对比连一个 不存在的局域网内IP的主机时，却是每隔1s重发了4次ARP请求，接着过了32s后才再发出一次ARP请求。已知ARP请求是没有重传机制的，它的重试就是TCP重试触发的，但两者规律不一致，是为什么？ 最后欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（点两下）支持一下。（**卑微疯狂暗示，拜托拜托，这对我真的很重要！**） 我是小白，我们下期见。 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】 文章推荐： 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 动图图解！GMP模型里为什么要有P？背后的原因让人暖心 i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？","slug":"图解网络/硬核图解！断网了，还能ping通回环地址吗？为什么","date":"2021-06-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.996Z","comments":true,"path":"2021/06/25/图解网络/硬核图解！断网了，还能ping通回环地址吗？为什么/","link":"","permalink":"https://xiaobaitech.github.io/2021/06/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%96%AD%E7%BD%91%E4%BA%86%EF%BC%8C%E8%BF%98%E8%83%BDping%E9%80%9A%E5%9B%9E%E7%8E%AF%E5%9C%B0%E5%9D%80%E5%90%97%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88/","excerpt":"首发于个人公众号：小白debug原文地址：硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？ 你女神爱不爱你，你问她，她可能不会告诉你。 但网通不通，你 ping 一下就知道了。","text":"首发于个人公众号：小白debug原文地址：硬核图解！断网了，还能ping通 127.0.0.1 吗？为什么？ 你女神爱不爱你，你问她，她可能不会告诉你。 但网通不通，你 ping 一下就知道了。 可能看到标题，你就知道答案了，但是你了解背后的原因吗？那如果把 127.0.0.1 换成 0.0.0.0 或 localhost 会怎么样呢？ 你知道这几个IP有什么区别吗？ 以前面试的时候就遇到过这个问题，大家看个动图了解下面试官和我当时的场景，求当时小白的心里阴影面积。 话不多说，我们直接开车。 拔掉网线，断网。 然后在控制台输入 ping 127.0.0.1。 1234567891011$ ping 127.0.0.1PING 127.0.0.1 (127.0.0.1): 56 data bytes64 bytes from 127.0.0.1: icmp_seq=0 ttl=64 time=0.080 ms64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.093 ms64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.074 ms64 bytes from 127.0.0.1: icmp_seq=3 ttl=64 time=0.079 ms64 bytes from 127.0.0.1: icmp_seq=4 ttl=64 time=0.079 ms^C--- 127.0.0.1 ping statistics ---5 packets transmitted, 5 packets received, 0.0% packet lossround-trip min/avg/max/stddev = 0.074/0.081/0.093/0.006 ms 说明，拔了网线，ping 127.0.0.1 是能ping通的。 其实这篇文章看到这里，标题前半个问题已经被回答了。但是我们可以再想深一点。 为什么断网了还能 ping 通 127.0.0.1 呢？ 这能说明你不用交网费就能上网吗？ 不能。 首先我们需要进入基础科普环节。 不懂的同学看了就懂了，懂的看了就当查漏补缺吧。 什么是127.0.0.1首先，这是个 IPV4 地址。 IPV4 地址有 32 位，一个字节有 8 位，共 4 个字节。 其中127 开头的都属于回环地址，也是 IPV4 的特殊地址，没什么道理，就是人为规定的。 而127.0.0.1是众多回环地址中的一个。之所以不是 127.0.0.2 ，而是 127.0.0.1，是因为源码里就是这么定义的，也没什么道理。 12/* Address to loopback in software to local host. */#define INADDR_LOOPBACK 0x7f000001 /* 127.0.0.1 */ IPv4 的地址是 32 位的，2的32次方，大概是40+亿。地球光人口就76亿了，40亿IP这点量，塞牙缝都不够，实际上IP也确实用完了。 所以就有了IPV6， IPv6 的地址是 128 位的，大概是2的128次方≈10的38次方。据说地球的沙子数量大概是 10的23次方，所以IPV6的IP可以认为用不完。 IPV4以8位一组，每组之间用 . 号隔开。 IPV6就以16位为一组，每组之间用 : 号隔开。如果全是0，那么可以省略不写。 在IPV4下的回环地址是 127.0.0.1，在IPV6下，表达为 ::1 。中间把连续的0给省略了，之所以不是7个 冒号，而是2个冒号: ， 是因为一个 IPV6 地址中只允许出现⼀次两个连续的冒号。 多说一句： 在IPV4下用的是 ping 127.0.0.1 命令。 在IPV6下用的是 ping6 ::1 命令。 什么是 pingping 是应用层命令，可以理解为它跟游戏或者聊天软件属于同一层。只不过聊天软件可以收发消息，还能点个赞什么的，有很多复杂的功能。而 ping 作为一个小软件，它的功能比较简单，就是尝试发送一个小小的消息到目标机器上，判断目的机器是否可达，其实也就是判断目标机器网络是否能连通。 ping应用的底层，用的是网络层的ICMP协议。 虽然ICMP协议和IP协议都属于网络层协议，但其实ICMP也是利用了IP协议进行消息的传输。 所以，大家在这里完全可以简单的理解为 ping 某个IP 就是往某个IP地址发个消息。 TCP发数据和ping的区别一般情况下，我们会使用 TCP 进行网络数据传输，那么我们可以看下它和 ping 的区别。 ping和其他应用层软件都属于应用层。 那么我们横向对比一下，比方说聊天软件，如果用的是TCP的方式去发送消息。 为了发送消息，那就得先知道往哪发。linux里万物皆文件，那你要发消息的目的地，也是个文件，这里就引出了socket 的概念。 要使用 socket , 那么首先需要创建它。 在 TCP 传输中创建的方式是 socket(AF_INET, SOCK_STREAM, 0);，其中 AF_INET 表示将使用 IPV4 里 host:port 的方式去解析待会你输入的网络地址。SOCK_STREAM 是指使用面向字节流的 TCP 协议，工作在传输层。 创建好了 socket 之后，就可以愉快的把要传输的数据写到这个文件里。调用 socket 的sendto接口的过程中进程会从用户态进入到内核态，最后会调用到 sock_sendmsg 方法。 然后进入传输层，带上TCP头。网络层带上IP头，数据链路层带上 MAC头等一系列操作后。进入网卡的发送队列 ring buffer ，顺着网卡就发出去了。 回到 ping ， 整个过程也基本跟 TCP 发数据类似，差异的地方主要在于，创建 socket 的时候用的是 socket(AF_INET,SOCK_RAW,IPPROTO_ICMP)，SOCK_RAW 是原始套接字 ，工作在网络层， 所以构建ICMP（网络层协议）的数据，是再合适不过了。ping 在进入内核态后最后也是调用的 sock_sendmsg 方法，进入到网络层后加上ICMP和IP头后，数据链路层加上MAC头，也是顺着网卡发出。因此 本质上ping 跟 普通应用发消息 在程序流程上没太大差别。 这也解释了为什么当你发现怀疑网络有问题的时候，别人第一时间是问你能ping通吗？因为可以简单理解为ping就是自己组了个数据包，让系统按着其他软件发送数据的路径往外发一遍，能通的话说明其他软件发的数据也能通。 为什么断网了还能 ping 通 127.0.0.1前面提到，有网的情况下，ping 最后是通过网卡将数据发送出去的。 那么断网的情况下，网卡已经不工作了，ping 回环地址却一切正常，我们可以看下这种情况下的工作原理。 从应用层到传输层再到网络层。这段路径跟ping外网的时候是几乎是一样的。到了网络层，系统会根据目的IP，在路由表中获取对应的路由信息，而这其中就包含选择哪个网卡把消息发出。 当发现目标IP是外网IP时，会从”真网卡”发出。 当发现目标IP是回环地址时，就会选择本地网卡。 本地网卡，其实就是个**”假网卡”，它不像”真网卡”那样有个ring buffer什么的，”假网卡”会把数据推到一个叫 input_pkt_queue 的 链表 中。这个链表，其实是所有网卡共享的，上面挂着发给本机的各种消息。消息被发送到这个链表后，会再触发一个软中断**。 专门处理软中断的工具人**”ksoftirqd”** （这是个内核线程），它在收到软中断后就会立马去链表里把消息取出，然后顺着数据链路层、网络层等层层往上传递最后给到应用程序。 ping 回环地址和通过TCP等各种协议发送数据到回环地址都是走这条路径。整条路径从发到收，都没有经过”真网卡”。之所以127.0.0.1叫本地回环地址，可以理解为，消息发出到这个地址上的话，就不会出网络，在本机打个转就又回来了。所以断网，依然能 ping 通 127.0.0.1。 ping回环地址和ping本机地址有什么区别我们在mac里执行 ifconfig 。 1234567$ ifconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 inet 127.0.0.1 netmask 0xff000000 ...en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 inet 192.168.31.6 netmask 0xffffff00 broadcast 192.168.31.255 ... 能看到 lo0，表示本地回环接口，对应的地址，就是我们前面提到的 127.0.0.1 ，也就是回环地址。 和 eth0，表示本机第一块网卡，对应的IP地址是192.168.31.6，管它叫本机IP。 之前一直认为ping本机IP的话会通过”真网卡”出去，然后遇到第一个路由器，再发回来到本机。 为了验证这个说法，可以进行抓包，但结果跟上面的说法并不相同。 可以看到 ping 本机IP 跟 ping 回环地址一样，相关的网络数据，都是走的 lo0，本地回环接口，也就是前面提到的**”假网卡”**。 只要走了本地回环接口，那数据都不会发送到网络中，在本机网络协议栈中兜一圈，就发回来了。因此 ping回环地址和ping本机地址没有区别。 127.0.0.1 和 localhost 以及 0.0.0.0 有区别吗回到文章开头动图里的提问，算是面试八股文里的老常客了。 以前第一次用 nginx 的时候，发现用这几个 IP，都能正常访问到 nginx 的欢迎网页。一度认为这几个 IP 都是一样的。 但本质上还是有些区别的。 首先 localhost 就不叫 IP，它是一个域名，就跟 &quot;baidu.com&quot;,是一个形式的东西，只不过默认会把它解析为 127.0.0.1 ，当然这可以在 /etc/hosts 文件下进行修改。 所以默认情况下，使用 localhost 跟使用 127.0.0.1 确实是没区别的。 其次就是 0.0.0.0，执行 ping 0.0.0.0 ，是会失败的，因为它在IPV4中表示的是无效的目标地址。 1234$ ping 0.0.0.0PING 0.0.0.0 (0.0.0.0): 56 data bytesping: sendto: No route to hostping: sendto: No route to host 但它还是很有用处的，回想下，我们启动服务器的时候，一般会 listen 一个 IP 和端口，等待客户端的连接。 如果此时 listen 的是本机的 0.0.0.0 , 那么它表示本机上的所有IPV4地址。 12/* Address to accept any incoming messages. */#define INADDR_ANY ((unsigned long int) 0x00000000) /* 0.0.0.0 */ 举个例子。刚刚提到的 127.0.0.1 和 192.168.31.6 ，都是本机的IPV4地址，如果监听 0.0.0.0 ，那么用上面两个地址，都能访问到这个服务器。 当然， 客户端 connect 时，不能使用 0.0.0.0 。必须指明要连接哪个服务器IP。 总结 127.0.0.1 是回环地址。localhost是域名，但默认等于 127.0.0.1。 ping 回环地址和 ping 本机地址，是一样的，走的是lo0 “假网卡”，都会经过网络层和数据链路层等逻辑，最后在快要出网卡前狠狠拐了个弯， 将数据插入到一个链表后就软中断通知 ksoftirqd 来进行收数据的逻辑，压根就不出网络。所以断网了也能 ping 通回环地址。 如果服务器 listen 的是 0.0.0.0，那么此时用127.0.0.1和本机地址都可以访问到服务。 最后最近工作上的事情太忙，本来就黑的黑眼圈，就更黑了，鸽了大家这么久实在不好意思哈。 这篇文章里，有几张大图本来都是动图，但是发现动起来之后发现字太小，点开来放大之后图又不会动了。有些影响体验，我就先改成静态图吧。 欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（点两下）支持一下。（疯狂暗示，拜托拜托，这对我真的很重要！） 我是小白，我们下期见。 参考资料《127.0.0.1 之本机网络通信过程知多少 ?！》—— 推荐关注飞哥的《开发内功修炼》 文章推荐： 动图图解！既然IP层会分片，为什么TCP层也还要分段？ 动图图解！GMP模型里为什么要有P？背后的原因让人暖心 i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 程序员防猝死指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？ 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"动图图解！GMP模型里为什么要有P？背后的原因让人暖心","slug":"golang面试题/动图图解，GMP里为什么要有P","date":"2021-06-11T14:57:55.000Z","updated":"2021-10-08T01:34:49.447Z","comments":true,"path":"2021/06/11/golang面试题/动图图解，GMP里为什么要有P/","link":"","permalink":"https://xiaobaitech.github.io/2021/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%8CGMP%E9%87%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89P/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 GM模型是什么 在 Go 1.1版本之前，其实用的就是GM模型。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 GM模型是什么 在 Go 1.1版本之前，其实用的就是GM模型。 G，协程。通常在代码里用 go 关键字执行一个方法，那么就等于起了一个G。 M，内核线程，操作系统内核其实看不见G和P，只知道自己在执行一个线程。G和P都是在用户层上的实现。 除了G和M以外，还有一个全局协程队列，这个全局队列里放的是多个处于可运行状态的G。M如果想要获取G，就需要访问一个全局队列。同时，内核线程M是可以同时存在多个的，因此访问时还需要考虑并发安全问题。因此这个全局队列有一把全局的大锁，每次访问都需要去获取这把大锁。 并发量小的时候还好，当并发量大了，这把大锁，就成为了性能瓶颈。 GMP模型是什么 基于没有什么是加一个中间层不能解决的思路，golang在原有的GM模型的基础上加入了一个调度器P，可以简单理解为是在G和M中间加了个中间层。 于是就有了现在的GMP模型里。 P 的加入，还带来了一个本地协程队列，跟前面提到的全局队列类似，也是用于存放G，想要获取等待运行的G，会优先从本地队列里拿，访问本地队列无需加锁。而全局协程队列依然是存在的，但是功能被弱化，不到万不得已是不会去全局队列里拿G的。 GM模型里M想要运行G，直接去全局队列里拿就行了；GMP模型里，M想要运行G，就得先获取P，然后从 P 的本地队列获取 G。 新建 G 时，新G会优先加入到 P 的本地队列；如果本地队列满了，则会把本地队列中一半的 G 移动到全局队列。 P 的本地队列为空时，就从全局队列里去取。 如果全局队列为空时，M 会从其他 P 的本地队列偷（stealing）一半G放到自己 P 的本地队列。 M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。 为什么P的逻辑不直接加在M上主要还是因为M其实是内核线程，内核只知道自己在跑线程，而golang的运行时（包括调度，垃圾回收等）其实都是用户空间里的逻辑。操作系统内核哪里还知道，也不需要知道用户空间的golang应用原来还有那么多花花肠子。这一切逻辑交给应用层自己去做就好，毕竟改内核线程的逻辑也不合适啊。 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（点两下）支持一下。（疯狂暗示，拜托拜托，这对我真的很重要！） 我是小白，我们下期见。 参考资料[1]《Golang 调度器 GMP 原理与调度全分析》 ——Aceld :https://learnku.com/articles/41728 [2]《GMP模型为什么要有P》 ——煎鱼 :https://mp.weixin.qq.com/s/an7dml9NLOhqOZjEGLdEEw [3]《深度解密Go语言之Scheduler》 ——qcrao :https://qcrao.com/2019/09/02/dive-into-go-scheduler/#%E4%BB%80%E4%B9%88%E6%98%AF-scheduler 文章推荐： i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 程序员防猝死指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？ 别说了，关注公众号:【小白debug】，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"我感觉，我可能要拿图灵奖了。。。","slug":"程序人生/我感觉，我可能要拿图灵奖了。。。","date":"2021-06-10T14:57:55.000Z","updated":"2021-10-08T01:34:43.483Z","comments":true,"path":"2021/06/10/程序人生/我感觉，我可能要拿图灵奖了。。。/","link":"","permalink":"https://xiaobaitech.github.io/2021/06/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E6%88%91%E6%84%9F%E8%A7%89%EF%BC%8C%E6%88%91%E5%8F%AF%E8%83%BD%E8%A6%81%E6%8B%BF%E5%9B%BE%E7%81%B5%E5%A5%96%E4%BA%86%E3%80%82%E3%80%82%E3%80%82/","excerpt":"是的，这个是标题党。 事情是这样的，最近在zhihu上回答了一个问题。一夜之间拿到了900+赞，让我相当震惊。","text":"是的，这个是标题党。 事情是这样的，最近在zhihu上回答了一个问题。一夜之间拿到了900+赞，让我相当震惊。 实话说，就是个抖机灵的回答。不知道是不是命中了什么推荐规则。没想到打开手机突然发现99+的信息，一时之间有些蒙圈。 打开评论，也是相当有趣哈哈哈。 在知乎划水这么久，第一次遇到这种场面，纪念下。 但说说心里话。 既开心又难过。 开心是因为能获得那么多赞，刷新一下手机就立马十多个赞，太爽太快乐了。 难过是因为之前辛辛苦苦花了好长时间写的文章，加一起点赞都不及随便抖机灵的答案。果然大家还是比较喜欢轻松快乐的东西，学习是反人性的。 那么多赞还发牢骚，这大概就是所谓的得了便宜还卖乖吧哈哈哈哈。 对，说的就是我这种情况。 一码归一码，虽然几乎没有涨粉，但能得到这么大的流量，总的来说还是很开心的。 另外想问下，有大佬知道知乎是什么样一个推荐规则吗？我还想看到99+小红点。。。 还有有什么可以从zhihu回答引流到【g】【zong】【hao】 的小技巧吗？感觉自己这个门外汉白瞎了这波流量。。。。 最近看了巨人的漫画大结局，很难受，追了8年了，以前每个月等更新，现在突然感觉生活少了点盼头。巨人的结局影响了我写文的速度，但是，下一篇已经在路上了。。。 首发于个人公众号：小白debug原文地址：https://mp.weixin.qq.com/s/rLLfj883lJbWr21wHAJTJA 文章推荐： 妙啊! 程序猿的第一本互联网黑话指南 程序员防猝死指南 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？","categories":[{"name":"骚话连篇","slug":"骚话连篇","permalink":"https://xiaobaitech.github.io/categories/%E9%AA%9A%E8%AF%9D%E8%BF%9E%E7%AF%87/"}],"tags":[]},{"title":"动图图解！既然IP层会分片，为什么TCP层也还要分段？","slug":"图解网络/动图图解！既然IP层会分片，为什么TCP层也还要分段？","date":"2021-05-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.012Z","comments":true,"path":"2021/05/25/图解网络/动图图解！既然IP层会分片，为什么TCP层也还要分段？/","link":"","permalink":"https://xiaobaitech.github.io/2021/05/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E5%8A%A8%E5%9B%BE%E5%9B%BE%E8%A7%A3%EF%BC%81%E6%97%A2%E7%84%B6IP%E5%B1%82%E4%BC%9A%E5%88%86%E7%89%87%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88TCP%E5%B1%82%E4%B9%9F%E8%BF%98%E8%A6%81%E5%88%86%E6%AE%B5%EF%BC%9F/","excerpt":"什么是TCP分段和IP分片我们知道网络就像一根管子，而管子吧，就会有粗细。 一个数据包想从管子的一端到另一端，得过这个管子。（废话） 但数据包的量有大有小，想过管子，数据包不能大于这根管子的粗细。 问题来了，数据包过大时怎么办？","text":"什么是TCP分段和IP分片我们知道网络就像一根管子，而管子吧，就会有粗细。 一个数据包想从管子的一端到另一端，得过这个管子。（废话） 但数据包的量有大有小，想过管子，数据包不能大于这根管子的粗细。 问题来了，数据包过大时怎么办？ 答案比较简单。会把数据包切分小块。这样数据就可以由大变小，顺利传输。 回去看下网络分层协议，数据先过传输层，再到网络层。 这个行为在传输层和网络层都有可能发生。 在传输层（TCP协议）里，叫分段。 在网络层（IP层），叫分片。（注意以下提到的IP没有特殊说明的情况下，都是指IPV4） 那么不管是分片还是分段，肯定需要按照一定的长度切分。 在TCP里，这个长度是MSS。 在IP层里，这个长度是MTU。 那MSS和MTU是什么关系呢？这个在之前的文章里简单提到过。这里单独拿出来。 MSS是什么MSS：Maximum Segment Size 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。假设 MTU= 1500 byte，那么 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果应用层有 2000 byte 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。 如何查看MSS？我们都知道TCP三次握手，而MSS会在三次握手的过程中传递给对方，用于通知对端本地最大可以接收的TCP报文数据大小（不包含TCP和IP报文首部）。 比如上图中，B将自己的MSS发送给A，建议A在发数据给B的时候，采用MSS=1420进行分段。而B在发数据给A的时候，同样会带上MSS=1372。两者在对比后，会采用小的那个值（1372）作为通信的MSS值，这个过程叫MSS协商。 另外，一般情况下MSS + 20（TCP头）+ 20（IP头）= MTU，上面抓包的图里对应的MTU分别是1372+40 和 1420+40。 同一个路径上，MTU不一定是对称的，也就是说A到B和B到A，两条路径上的MTU可以是不同的，对应的MSS也一样。 三次握手中协商了MSS就不会改变了吗？当然不是，每次执行TCP发送消息的函数时，会重新计算一次MSS，再进行分段操作。 对端不传MSS会怎么样？我们再看TCP的报头。 其实MSS是作为可选项引入的，只不过一般情况下MSS都会传，但是万一遇到了哪台机器的实现上比较调皮，不传MSS这个可选项。那对端该怎么办？ 如果没有接收到对端TCP的MSS，本端TCP默认采用MSS=536Byte。 那为什么会是536？ 1536（data） + 20（tcp头）+20（ip头）= 576Byte 前面提到了IP会切片，那会切片，也就会重组，而这个576正好是 IP 最小重组缓冲区的大小。 MTU是什么MTU: Maximum Transmit Unit，最大传输单元。 其实这个是由数据链路层提供，为了告诉上层IP层，自己的传输能力是多大。IP层就会根据它进行数据包切分。一般 MTU=1500 Byte。假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有 &gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同，同时为了分片后能在接收端把切片组装起来，还需要在分片后的IP包里加上各种信息。比如这个分片在原来的IP包里的偏移offset。 如何查看MTU在mac控制台输入 ifconfig命令，可以看到MTU的值为多大。 1234567$ ipconfiglo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384 ...en0: flags=8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ...p2p0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2304 ... 可以看到这上面有好几个MTU，可以简单理解为每个网卡的处理能力不同，所以对应的MTU也不同。当然这个值是可以修改的，但不在今天的讨论范畴内，不再展开。 在一台机器的应用层到这台机器的网卡，这条链路上，基本上可以保证，MSS &lt; MTU。 为什么MTU一般是1500这其实是由传输效率决定的。首先，虽然我们平时用的网络感觉挺稳定的，但其实这是因为TCP在背地里做了各种重传等保证了传输的可靠，其实背地里线路是动不动就丢包的，而越大的包，发生丢包的概率就越大。 那是不是包越小就越好？也不是 但是如果选择一个比较小的长度，假设选择MTU为300Byte，TCP payload = 300 - IP Header - TCP Header = 300 - 20 - 20 = 260 byte。那有效传输效率= 260 / 300 = 86% 而如果以太网长度为1500，那有效传输效率= 1460 / 1500 = 96% ，显然比 86% 高多了。 所以，包越小越不容易丢包，包越大，传输效率又越高，因此权衡之下，选了1500。 为什么IP层会分片，TCP还要分段由于本身IP层就会做分片这件事情。就算TCP不分段，到了IP层，数据包也会被分片，数据也能正常传输。 既然网络层就会分片了，那么TCP为什么还要分段？是不是有些多此一举？ 假设有一份数据，较大，且在TCP层不分段，如果这份数据在发送的过程中出现丢包现象，TCP会发生重传，那么重传的就是这一大份数据（虽然IP层会把数据切分为MTU长度的N多个小包，但是TCP重传的单位却是那一大份数据）。 如果TCP把这份数据，分段为N个小于等于MSS长度的数据包，到了IP层后加上IP头和TCP头，还是小于MTU，那么IP层也不会再进行分包。此时在传输路上发生了丢包，那么TCP重传的时候也只是重传那一小部分的MSS段。效率会比TCP不分段时更高。 类似的，传输层除了TCP外，还有UDP协议，但UDP本身不会分段，所以当数据量较大时，只能交给IP层去分片，然后传到底层进行发送。 也就是说，正常情况下，在一台机器的传输层到网络层这条链路上，如果传输层对数据做了分段，那么IP层就不会再分片。如果传输层没分段，那么IP层就可能会进行分片。 说白了，数据在TCP分段，就是为了在IP层不需要分片，同时发生重传的时候只重传分段后的小份数据。 TCP分段了，IP层就一定不会分片了吗上面提到了，在发送端，TCP分段后，IP层就不会再分片了。 但是整个传输链路中，可能还会有其他网络层设备，而这些设备的MTU可能小于发送端的MTU。此时虽然数据包在发送端已经分段过了，但是在IP层就还会再分片一次。 如果链路上还有设备有更小的MTU，那么还会再分片，最后所有的分片都会在接收端处进行组装。 因此，就算TCP分段过后，在链路上的其他节点的IP层也是有可能再分片的，而且哪怕数据被第一次IP分片过了，也是有可能被其他机器的IP层进行二次、三次、四次….分片的。 IP层怎么做到不分片上面提到的IP层在传输过程中因为各个节点间MTU可能不同，导致数据是可能被多次分片的。而且每次分片都要加上各种信息便于在接收端进行分片重组。那么IP层是否可以做到不分片？ 如果有办法知道整个链路上，最小的MTU是多少，并且以最小MTU长度发送数据，那么不管数据传到哪个节点，都不会发生分片。 整个链路上，最小的MTU，就叫PMTU（path MTU）。 有一个获得这个PMTU的方法，叫 Path MTU Discovery。 12$cat /proc/sys/net/ipv4/ip_no_pmtu_disc0 默认为0，意思是开启PMTU发现的功能。现在一般机器上都是开启的状态。 原理比较简单，首先我们先回去看下IP的数据报头。 这里有个标红的标志位DF（Don’t Fragment），当它置为1，意味着这个IP报文不分片。 当链路上某个路由器，收到了这个报文，当IP报文长度大于路由器的MTU时，路由器会看下这个IP报文的DF 如果为0（允许分片），就会分片并把分片后的数据传到下一个路由器 如果为1，就会把数据丢弃，同时返回一个ICMP包给发送端，并告诉它 “达咩!” 数据不可达，需要分片，同时带上当前机器的MTU 理解了上面的原理后，我们再看下PMTU发现是怎么实现的。 应用通过TCP正常发送消息，传输层TCP分段后，到网络层加上IP头，DF置为1，消息再到更底层执行发送 此时链路上有台路由器由于各种原因MTU变小了 IP消息到这台路由器了，路由器发现消息长度大于自己的MTU，且消息自带DF不让分片。就把消息丢弃。同时返回一个ICMP错误给发送端，同时带上自己的MTU。 发送端收到这个ICMP消息，会更新自己的MTU，同时记录到一个PMTU表中。 因为TCP的可靠性，会尝试重传这个消息，同时以这个新MTU值计算出MSS进行分段，此时新的IP包就可以顺利被刚才的路由器转发。 如果路径上还有更小的MTU的路由器，那上面发生的事情还会再发生一次。 总结 数据在TCP分段，在IP层就不需要分片，同时发生重传的时候只重传分段后的小份数据 TCP分段时使用MSS，IP分片时使用MTU MSS是通过MTU计算得到，在三次握手和发送消息时都有可能产生变化。 IP分片是不得已的行为，尽量不在IP层分片，尤其是链路上中间设备的IP分片。因此，在IPv6中已经禁止中间节点设备对IP报文进行分片，分片只能在链路的最开头和最末尾两端进行。 建立连接后，路径上节点的MTU值改变时，可以通过PMTU发现更新发送端MTU的值。这种情况下，PMTU发现通过浪费N次发送机会来换取的PMTU，TCP因为有重传可以保证可靠性，在UDP就相当于消息直接丢了。 文章推荐： 动图图解！GMP模型里为什么要有P？背后的原因让人暖心 i/o timeout，希望你不要踩到这个net/http包的坑 妙啊! 程序猿的第一本互联网黑话指南 程序员防猝死指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？ 最后画动图，太难了。。。看完求个赞，下次图会动得更凶。 欢迎大家加我微信（公众号里右下角“联系我”），互相围观朋友圈砍一刀啥的哈哈。 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（点两下）支持一下。（疯狂暗示，拜托拜托，这对我真的很重要！） 我是小白，我们下期见。 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"i/o timeout ， 希望你不要踩到这个net/http包的坑","slug":"golang面试题/io_timeout，希望你不要踩到这个http包的坑","date":"2021-05-18T14:57:55.000Z","updated":"2021-10-08T01:35:47.243Z","comments":true,"path":"2021/05/18/golang面试题/io_timeout，希望你不要踩到这个http包的坑/","link":"","permalink":"https://xiaobaitech.github.io/2021/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/io_timeout%EF%BC%8C%E5%B8%8C%E6%9C%9B%E4%BD%A0%E4%B8%8D%E8%A6%81%E8%B8%A9%E5%88%B0%E8%BF%99%E4%B8%AAhttp%E5%8C%85%E7%9A%84%E5%9D%91/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 问题我们来看一段日常代码。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 问题我们来看一段日常代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net&quot; &quot;net/http&quot; &quot;time&quot;)var tr *http.Transportfunc init() &#123; tr = &amp;http.Transport&#123; MaxIdleConns: 100, Dial: func(netw, addr string) (net.Conn, error) &#123; conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时 if err != nil &#123; return nil, err &#125; err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时 if err != nil &#123; return nil, err &#125; return conn, nil &#125;, &#125;&#125;func main() &#123; for &#123; _, err := Get(&quot;http://www.baidu.com/&quot;) if err != nil &#123; fmt.Println(err) break &#125; &#125;&#125;func Get(url string) ([]byte, error) &#123; m := make(map[string]interface&#123;&#125;) data, err := json.Marshal(m) if err != nil &#123; return nil, err &#125; body := bytes.NewReader(data) req, _ := http.NewRequest(&quot;Get&quot;, url, body) req.Header.Add(&quot;content-type&quot;, &quot;application/json&quot;) client := &amp;http.Client&#123; Transport: tr, &#125; res, err := client.Do(req) if res != nil &#123; defer res.Body.Close() &#125; if err != nil &#123; return nil, err &#125; resBody, err := ioutil.ReadAll(res.Body) if err != nil &#123; return nil, err &#125; return resBody, nil&#125; 做的事情，比较简单，就是循环去请求 http://www.baidu.com/ , 然后等待响应。 看上去貌似没啥问题吧。 代码跑起来，也确实能正常收发消息。 但是这段代码跑一段时间，就会出现 i/o timeout 的报错。 这其实是最近排查了的一个问题，发现这个坑可能比较容易踩上，我这边对代码做了简化。 实际生产中发生的现象是，golang服务在发起http调用时，虽然http.Transport设置了3s超时，会偶发出现i/o timeout的报错。 但是查看下游服务的时候，发现下游服务其实 100ms 就已经返回了。 排查 就很奇怪了，明明服务端显示处理耗时才100ms，且客户端超时设的是3s, 怎么就出现超时报错 i/o timeout 呢？ 这里推测有两个可能。 因为服务端打印的日志其实只是服务端应用层打印的日志。但客户端应用层发出数据后，中间还经过客户端的传输层，网络层，数据链路层和物理层，再经过服务端的物理层，数据链路层，网络层，传输层到服务端的应用层。服务端应用层处耗时100ms，再原路返回。那剩下的3s-100ms可能是耗在了整个流程里的各个层上。比如网络不好的情况下，传输层TCP使劲丢包重传之类的原因。 网络没问题，客户端到服务端链路整个收发流程大概耗时就是100ms左右。客户端处理逻辑问题导致超时。 一般遇到问题，大部分情况下都不会是底层网络的问题，大胆怀疑是自己的问题就对了，不死心就抓个包看下。 分析下，从刚开始三次握手（画了红框的地方）。 到最后出现超时报错 i/o timeout （画了蓝框的地方）。 从time那一列从7到10，确实间隔3s。而且看右下角的蓝框，是51169端口发到80端口的一次Reset连接。 80端口是服务端的端口。换句话说就是客户端3s超时主动断开链接的。 但是再仔细看下第一行三次握手到最后客户端超时主动断开连接的中间，其实有非常多次HTTP请求。 回去看代码设置超时的方式。 1234567891011121314tr = &amp;http.Transport&#123; MaxIdleConns: 100, Dial: func(netw, addr string) (net.Conn, error) &#123; conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时 if err != nil &#123; return nil, err &#125; err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时 if err != nil &#123; return nil, err &#125; return conn, nil &#125;,&#125; 也就是说，这里的3s超时，其实是在建立连接之后开始算的，而不是单次调用开始算的超时。 看注释里写的是 SetDeadline sets the read and write deadlines associated with the connection. 超时原因大家知道HTTP是应用层协议，传输层用的是TCP协议。 HTTP协议从1.0以前，默认用的是短连接，每次发起请求都会建立TCP连接。收发数据。然后断开连接。 TCP连接每次都是三次握手。每次断开都要四次挥手。 其实没必要每次都建立新连接，建立的连接不断开就好了，每次发送数据都复用就好了。 于是乎，HTTP协议从1.1之后就默认使用长连接。具体相关信息可以看之前的 这篇文章。 那么golang标准库里也兼容这种实现。 通过建立一个连接池，针对每个域名建立一个TCP长连接，比如http://baidu.com和http://golang.com 就是两个不同的域名。 第一次访问http://baidu.com 域名的时候会建立一个连接，用完之后放到空闲连接池里，下次再要访问http://baidu.com 的时候会重新从连接池里把这个连接捞出来复用。 插个题外话：这也解释了之前这篇文章里最后的疑问，为什么要强调是同一个域名：一个域名会建立一个连接，一个连接对应一个读goroutine和一个写goroutine。正因为是同一个域名，所以最后才会泄漏3个goroutine，如果不同域名的话，那就会泄漏 1+2*N 个协程，N就是域名数。 假设第一次请求要100ms，每次请求完http://baidu.com 后都放入连接池中，下次继续复用，重复29次，耗时2900ms。 第30次请求的时候，连接从建立开始到服务返回前就已经用了3000ms，刚好到设置的3s超时阈值，那么此时客户端就会报超时 i/o timeout 。 虽然这时候服务端其实才花了100ms，但耐不住前面29次加起来的耗时已经很长。 也就是说只要通过 http.Transport 设置了 err = conn.SetDeadline(time.Now().Add(time.Second * 3)) ，并且你用了长连接，哪怕服务端处理再快，客户端设置的超时再长，总有一刻，你的程序会报超时错误。 正确姿势原本预期是给每次调用设置一个超时，而不是给整个连接设置超时。 另外，上面出现问题的原因是给长连接设置了超时，且长连接会复用。 基于这两点，改一下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package mainimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;time&quot;)var tr *http.Transportfunc init() &#123; tr = &amp;http.Transport&#123; MaxIdleConns: 100, // 下面的代码被干掉了 //Dial: func(netw, addr string) (net.Conn, error) &#123; // conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时 // if err != nil &#123; // return nil, err // &#125; // err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时 // if err != nil &#123; // return nil, err // &#125; // return conn, nil //&#125;, &#125;&#125;func Get(url string) ([]byte, error) &#123; m := make(map[string]interface&#123;&#125;) data, err := json.Marshal(m) if err != nil &#123; return nil, err &#125; body := bytes.NewReader(data) req, _ := http.NewRequest(&quot;Get&quot;, url, body) req.Header.Add(&quot;content-type&quot;, &quot;application/json&quot;) client := &amp;http.Client&#123; Transport: tr, Timeout: 3*time.Second, // 超时加在这里，是每次调用的超时 &#125; res, err := client.Do(req) if res != nil &#123; defer res.Body.Close() &#125; if err != nil &#123; return nil, err &#125; resBody, err := ioutil.ReadAll(res.Body) if err != nil &#123; return nil, err &#125; return resBody, nil&#125;func main() &#123; for &#123; _, err := Get(&quot;http://www.baidu.com/&quot;) if err != nil &#123; fmt.Println(err) break &#125; &#125;&#125; 看注释会发现，改动的点有两个 http.Transport里的建立连接时的一些超时设置干掉了。 在发起http请求的时候会场景http.Client，此时加入超时设置，这里的超时就可以理解为单次请求的超时了。同样可以看下注释 Timeout specifies a time limit for requests made by this Client. 到这里，代码就改好了，实际生产中问题也就解决了。 实例代码里，如果拿去跑的话，其实还会下面的错 1Get http://www.baidu.com/: EOF 这个是因为调用得太猛了，http://www.baidu.com 那边主动断开的连接，可以理解为一个限流措施，目的是为了保护服务器，毕竟每个人都像这么搞，服务器是会炸的。。。 解决方案很简单，每次HTTP调用中间加个sleep间隔时间就好。 到这里，其实问题已经解决了，下面会在源码层面分析出现问题的原因。对读源码不感兴趣的朋友们可以不用接着往下看，直接拉到文章底部右下角，做点正能量的事情（点两下）支持一下。（疯狂暗示，拜托拜托，这对我真的很重要！） 源码分析用的go版本是1.12.7。 从发起一个网络请求开始跟。 123456789101112131415161718192021222324252627282930313233343536373839404142res, err := client.Do(req)func (c *Client) Do(req *Request) (*Response, error) &#123; return c.do(req)&#125;func (c *Client) do(req *Request) &#123; // ... if resp, didTimeout, err = c.send(req, deadline); err != nil &#123; // ... &#125; // ... &#125; func send(ireq *Request, rt RoundTripper, deadline time.Time) &#123; // ... resp, err = rt.RoundTrip(req) // ... &#125; // 从这里进入 RoundTrip 逻辑/src/net/http/roundtrip.go: 16func (t *Transport) RoundTrip(req *Request) (*Response, error) &#123; return t.roundTrip(req)&#125;func (t *Transport) roundTrip(req *Request) (*Response, error) &#123; // 尝试去获取一个空闲连接，用于发起 http 连接 pconn, err := t.getConn(treq, cm) // ...&#125;// 重点关注这个函数，返回是一个长连接func (t *Transport) getConn(treq *transportRequest, cm connectMethod) (*persistConn, error) &#123; // 省略了大量逻辑，只关注下面两点 // 有空闲连接就返回 pc := &lt;-t.getIdleConnCh(cm) // 没有创建连接 pc, err := t.dialConn(ctx, cm) &#125; 这里上面很多代码，其实只是为了展示这部分代码是怎么跟踪下来的，方便大家去看源码的时候去跟一下。 最后一个上面的代码里有个 getConn 方法。在发起网络请求的时候，会先取一个网络连接，取连接有两个来源。 如果有空闲连接，就拿空闲连接 1234567/src/net/http/tansport.go:810func (t *Transport) getIdleConnCh(cm connectMethod) chan *persistConn &#123; // 返回放空闲连接的chan ch, ok := t.idleConnCh[key] // ... return ch&#125; 没有空闲连接，就创建长连接。 123456789/src/net/http/tansport.go:1357func (t *Transport) dialConn() &#123; //... conn, err := t.dial(ctx, &quot;tcp&quot;, cm.addr()) // ... go pconn.readLoop() go pconn.writeLoop() // ...&#125; 当第一次发起一个http请求时，这时候肯定没有空闲连接，会建立一个新连接。同时会创建一个读goroutine和一个写goroutine。 注意上面代码里的t.dial(ctx, &quot;tcp&quot;, cm.addr())，如果像文章开头那样设置了 http.Transport的 1234567891011Dial: func(netw, addr string) (net.Conn, error) &#123; conn, err := net.DialTimeout(netw, addr, time.Second*2) //设置建立连接超时 if err != nil &#123; return nil, err &#125; err = conn.SetDeadline(time.Now().Add(time.Second * 3)) //设置发送接受数据超时 if err != nil &#123; return nil, err &#125; return conn, nil&#125;, 那么这里就会在下面的dial里被执行到 12345func (t *Transport) dial(ctx context.Context, network, addr string) (net.Conn, error) &#123; // ... c, err := t.Dial(network, addr) // ...&#125; 这里面调用的设置超时，会执行到 123456789101112131415161718192021222324/src/net/net.gofunc (c *conn) SetDeadline(t time.Time) error &#123; //... c.fd.SetDeadline(t) //...&#125;//...func setDeadlineImpl(fd *FD, t time.Time, mode int) error &#123; // ... runtime_pollSetDeadline(fd.pd.runtimeCtx, d, mode) return nil&#125;//go:linkname poll_runtime_pollSetDeadline internal/poll.runtime_pollSetDeadlinefunc poll_runtime_pollSetDeadline(pd *pollDesc, d int64, mode int) &#123; // ... // 设置一个定时器事件 rtf = netpollDeadline // 并将事件注册到定时器里 modtimer(&amp;pd.rt, pd.rd, 0, rtf, pd, pd.rseq)&#125; 上面的源码，简单来说就是，当第一次调用请求的，会建立个连接，这时候还会注册一个定时器事件，假设时间设了3s，那么这个事件会在3s后发生，然后执行注册事件的逻辑。而这个注册事件就是netpollDeadline。 注意这个netpollDeadline，待会会提到。 设置了超时事件，且超时事件是3s后之后，发生。再次期间正常收发数据。一切如常。 直到3s过后，这时候看读goroutine，会等待网络数据返回。 1234567/src/net/http/tansport.go:1642func (pc *persistConn) readLoop() &#123; //... for alive &#123; _, err := pc.br.Peek(1) // 阻塞读取服务端返回的数据 //...&#125; 然后就是一直跟代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051src/bufio/bufio.go: 129func (b *Reader) Peek(n int) ([]byte, error) &#123; // ... b.fill() // ... &#125;func (b *Reader) fill() &#123; // ... n, err := b.rd.Read(b.buf[b.w:]) // ...&#125;/src/net/http/transport.go: 1517func (pc *persistConn) Read(p []byte) (n int, err error) &#123; // ... n, err = pc.conn.Read(p) // ...&#125;// /src/net/net.go: 173func (c *conn) Read(b []byte) (int, error) &#123; // ... n, err := c.fd.Read(b) // ...&#125;func (fd *netFD) Read(p []byte) (n int, err error) &#123; n, err = fd.pfd.Read(p) // ...&#125;/src/internal/poll/fd_unix.go: func (fd *FD) Read(p []byte) (int, error) &#123; //... if err = fd.pd.waitRead(fd.isFile); err == nil &#123; continue &#125; // ...&#125;func (pd *pollDesc) waitRead(isFile bool) error &#123; return pd.wait(&#x27;r&#x27;, isFile)&#125;func (pd *pollDesc) wait(mode int, isFile bool) error &#123; // ... res := runtime_pollWait(pd.runtimeCtx, mode) return convertErr(res, isFile)&#125; 直到跟到 runtime_pollWait，这个可以简单认为是等待服务端数据返回。 12345678910111213//go:linkname poll_runtime_pollWait internal/poll.runtime_pollWaitfunc poll_runtime_pollWait(pd *pollDesc, mode int) int &#123; // 1.如果网络正常返回数据就跳出 for !netpollblock(pd, int32(mode), false) &#123; // 2.如果有出错情况也跳出 err = netpollcheckerr(pd, int32(mode)) if err != 0 &#123; return err &#125; &#125; return 0&#125; 整条链路跟下来，就是会一直等待数据，等待的结果只有两个 有可以读的数据 出现报错 这里面的报错，又有那么两种 连接关闭 超时 123456789func netpollcheckerr(pd *pollDesc, mode int32) int &#123; if pd.closing &#123; return 1 // errClosing &#125; if (mode == &#x27;r&#x27; &amp;&amp; pd.rd &lt; 0) || (mode == &#x27;w&#x27; &amp;&amp; pd.wd &lt; 0) &#123; return 2 // errTimeout &#125; return 0&#125; 其中提到的超时，就是指这里面返回的数字2，会通过下面的函数，转化为 ErrTimeout， 而 ErrTimeout.Error() 其实就是 i/o timeout。 123456789101112func convertErr(res int, isFile bool) error &#123; switch res &#123; case 0: return nil case 1: return errClosing(isFile) case 2: return ErrTimeout // ErrTimeout.Error() 就是 &quot;i/o timeout&quot; &#125; println(&quot;unreachable: &quot;, res) panic(&quot;unreachable&quot;)&#125; 那么问题来了。上面返回的超时错误，也就是返回2的时候的条件是怎么满足的？ 123if (mode == &#x27;r&#x27; &amp;&amp; pd.rd &lt; 0) || (mode == &#x27;w&#x27; &amp;&amp; pd.wd &lt; 0) &#123; return 2 // errTimeout&#125; 还记得刚刚提到的 netpollDeadline吗？ 这里面放了定时器3s到点时执行的逻辑。 123456789101112131415161718func timerproc(tb *timersBucket) &#123; // 计时器到设定时间点了，触发之前注册函数 f(arg, seq) // 之前注册的是 netpollDeadline&#125;func netpollDeadline(arg interface&#123;&#125;, seq uintptr) &#123; netpolldeadlineimpl(arg.(*pollDesc), seq, true, true)&#125;/src/runtime/netpoll.go: 428func netpolldeadlineimpl(pd *pollDesc, seq uintptr, read, write bool) &#123; //... if read &#123; pd.rd = -1 rg = netpollunblock(pd, &#x27;r&#x27;, false) &#125; //...&#125; 这里会设置pd.rd=-1，是指 poller descriptor.read deadline ，含义网络轮询器文件描述符的读超时时间， 我们知道在linux里万物皆文件，这里的文件其实是指这次网络通讯中使用到的socket。 这时候再回去看发生超时的条件就是if (mode == &#39;r&#39; &amp;&amp; pd.rd &lt; 0) 。 至此。我们的代码里就收到了 io timeout 的报错。 总结 不要在 http.Transport中设置超时，那是连接的超时，不是请求的超时。否则可能会出现莫名 io timeout报错。 请求的超时在创建client里设置。 如果文章对你有帮助，看下文章底部右下角，做点正能量的事情（点两下）支持一下。（疯狂暗示，拜托拜托，这对我真的很重要！） 我是小白，我们下期见。 文章推荐： 妙啊! 程序猿的第一本互联网黑话指南 程序员防猝死指南 我感觉，我可能要拿图灵奖了。。。 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？ 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"妙啊！程序猿的第一本互联网黑话指南","slug":"程序人生/妙啊！程序猿的第一本互联网黑话指南","date":"2021-05-10T14:57:55.000Z","updated":"2021-10-08T01:34:34.029Z","comments":true,"path":"2021/05/10/程序人生/妙啊！程序猿的第一本互联网黑话指南/","link":"","permalink":"https://xiaobaitech.github.io/2021/05/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E5%A6%99%E5%95%8A%EF%BC%81%E7%A8%8B%E5%BA%8F%E7%8C%BF%E7%9A%84%E7%AC%AC%E4%B8%80%E6%9C%AC%E4%BA%92%E8%81%94%E7%BD%91%E9%BB%91%E8%AF%9D%E6%8C%87%E5%8D%97/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 很烦，小侄子最近不给我打电话了。 放下作为叔叔的面子，拨通电话。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 很烦，小侄子最近不给我打电话了。 放下作为叔叔的面子，拨通电话。 他说，他最近很烦。 我以为他长大了，谈恋爱了。 他说，最近他们学校，换了个校长。 喜欢在早上升国旗之后发表演讲。 “发表演讲挺好的啊，德智体美。” 他说他听不懂。比如校长今天早上提到说： “我们需要大力推进新型教育场景，尝试建立一些新的教学模型，用心打磨细节。 并重点关注其他教育形式的可能性。利用传统教育形式去驱动新型教育形式，打通底层逻辑，形成闭环。用传统教育理念赋能新型教育场景。让传统和新型教育形式作为一整套组合拳，加速学生更好更快的发展。” 好家伙，这么长的一句话，信息量竟然为0。 再仔细一想。 心里一惊，原来是同行啊，这老哥，一定是互联网出来的。 光听到赋能这个词，我就知道是哪个厂出来的了。 我劝小侄子，这个想听懂，得有一定的互联网阅历才行啊。 小侄子却表示：“叔叔，你不是在互联网公司上班吗？你教教我吧” 不行，这对于年幼的他，还太早了。 直到他告诉我，“我们班长现在已经学会这种超酷的说话方式了，现在班里的女生都超爱听他说话” 这？？？ 不，这能忍？就算是这样的我，也有想要守护的东西。我必须教会。 那晚我打了3小时视频电话，畅快淋漓，让我差点忘了手机还欠费47块这件事。 三天后，侄子跟我说，好是挺好的，就是有点废纸，现在班里的女同学都喜欢找他要签名。 嗯，不是很环保。 考虑到身边还有很多连互联网黑话都不会说的胖友们，在这里简单写一份程序员必知必会的互联网黑话指南。赠与有缘人。 诚实质朴如你，实在无法低下高傲的头颅的话，希望你也能听懂别人在不讲人话的时候，到底背后是几层意思。 我不允许我的胖友们听不懂！更不允许你们被蒙在鼓里！ 领导开口闭口都是商业模式，闭环？整个会听下来，就记住了赋能，抓住，推进，深入这些词？ 产品让你跟她对齐一下？ 其他部门同事说再不马上处理某个问题，她就要上升了，而这时候你以为她是要上天？ hr跟你说公司扁平化管理，一年有两次加薪机会的时候，你只听到了加薪，却听漏了这只是机会？ 看完下面，你会对上面的场景有不一样的认识。 首先对于国内互联网大厂，我们盘一下常说的一些话。 比如抓手，是指手可以抓得到的地方，一般是指项目的切入点。 当提到项目需要努力寻找抓手的时候，说明项目现在比较蒙圈，还没有好的切入点，还在各种试错。 划重点了，项目怎么做都没想清楚，建议各位老哥 LeetCode 刷起来吧。 当你在职级答辩的时候，也可能被问到某件事情的抓手是什么。 一般是问你这个问题的切入点在哪，从哪里开始解决， 一般是要你说下从现象到本质的判断过程。 比如，机器内存暴涨导致报警，这时候现象切入点是某个进程，再定位代码更新部分，最后定位问题。 而一般项目的抓手都是从某个垂直领域里的细分领域里发力， 垂直领域和细分领域的区别大概可以理解为编程和用golang编程之间的区别。 领域不够垂直，不够细分，大概就是说，啥都干了点，不够专，不够精。 赋能是个啥，第一次接触这个词的时候，我还去搜了一下定义 好家伙，竟然拿一堆别人看不懂的词去解释一个别人看不懂的词，属实让人意外了。 后来搞明白了。说白了，别人没有某个东西，而你有，你主动找他跟你合作。重点在于主动这个词，有忽悠内味了。 还有，如果运营产品们喜欢探讨项目的盈利模式，你就要知道，他们其实心里也没底这玩意到底能不能赚钱。如果赚钱了，就会找出各种理由解释“这个项目为什么能赚钱”，这就是所谓的各种方法论了。 当然，如果项目赚钱了，又不给你发钱，就可以说是延迟满足感。 类似的不讲人话的词还有很多。 开个会，叫对齐一下。 找你领导，叫上升。 最容易pian到投资的领域，叫风口。 同时用多种方法去搞钱，就叫组合拳。 跟别的公司产生了合作，那就出现了生态，合作的公司多了，就叫生态链。 生态链产生闭环，这里就划重点了，意思是开始赚钱了。 还有另外一个需要敲黑板，划重点的考点。 当老板提到要向社会输送人才，就是要开始解雇咸鱼了。。不管读多少遍，我还是觉得说这话的人是真的厉害，这才是语！言！艺！术！请各位老哥把牛皮打在公屏上。 作为不讲人话的高发场地，面试那张方寸小桌，经常会出现一些让人觉得高深莫测的词语。 比如当你听到hr介绍公司弹性工作制，不打卡，也就是指下班时间不定，也没有加班这一说。 扁平化管理，在公司层面可能有各种积极意义。但对你个人而言，基本上约等于一般没有晋升。 能独立完成工作任务，当然就是产品的开发全都你一个人干。 很多时候hr会看着招聘简介上的信息问你问题。 问你有没有做过高并发相关，如果你给机器扩容过，大胆说有。 用了主备机器，就说是高可用。 用了缓存，那就是高性能了。 用了 Mysql，妥了，持久化。 虽然我很普通，但我很自信。 这时候你可能就会产生疑问了，这是不是国内互联网大厂才有的通病？ 我去外企是不是就好了？ 那欢迎来到快乐星球了。 上班等电梯的时候，你会听到旁边的 Lucy 端着她的美式卡布奇诺很惊讶的对 Emily 说 “Emiliy 你知道吗？我跟你说，昨天，Alice 他的手机在 meeting 的时候摔得粉粉碎，真的粉粉碎哦” “哇哦，what a pity“ 早上，老板会让大家开个 daily meeting。说一下大家今天的 todo list。还有 project 的进展。 可能这个 project 的 schedule 有些问题，尤其是buffer不多。另外，cost也偏高。 项目组没法 confirm 手上的 resource 能完全 take 得了。 anyway，我们可以先 argue 一下，再 follow up 最终的 output，先 run 起来，看work 不 work。 more importantly ，我们要尝试 cover 掉所有的 difficulty。 瞧瞧，瞬间觉得抓手闭环亲切了许多。 在这里我要正能量一波，否则对不起我这全日制本科的学历。 本来一些类似hr，kindle专有名词用英语，可以提升沟通效率，但是大量在不必要的场景下用这些中英文混杂的话，真的让人难受。 沟通，最 important 的是 efficiency，understand？ 以前在网上看到过一个话题叫我想一巴掌扇si那个中英夹杂讲话的朋友！ 当初年轻，高低也想说上那么两句。 现在成熟了，只会努力克制不要拿百宝袋里的四次元大嘴巴子扇人。 让更不成熟的年轻人去扇吧，要带响的哦。 国内的大厂和外企都不爱讲人话？ 那我去小厂，总归可以了吧？ 小了， 格局小了。 你忘了大厂给社会输送的人才了吗？ 你猜他们都去哪了？ 还是没学会怎么说黑话？ 那就用数量堆叠的方式，让人在无数莫名其妙的动词名词形容词下沦陷。 让他一时之间眼花缭乱，抓不住任何重点。 反正，某厂周报，就是这么干的。 会说话就多说点吧。 我是小白，我们下期见。 文章推荐： 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 程序员防猝死指南 TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解 硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？ 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"骚话连篇","slug":"骚话连篇","permalink":"https://xiaobaitech.github.io/categories/%E9%AA%9A%E8%AF%9D%E8%BF%9E%E7%AF%87/"}],"tags":[]},{"title":"硬核！阿里面试就是不一样！30张图带你搞懂路由器，集线器，交换机，网桥，光猫有啥区别？","slug":"图解网络/硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？","date":"2021-04-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.945Z","comments":true,"path":"2021/04/25/图解网络/硬核图解！30张图带你搞懂！路由器，集线器，交换机，网桥，光猫有啥区别？/","link":"","permalink":"https://xiaobaitech.github.io/2021/04/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3%EF%BC%8130%E5%BC%A0%E5%9B%BE%E5%B8%A6%E4%BD%A0%E6%90%9E%E6%87%82%EF%BC%81%E8%B7%AF%E7%94%B1%E5%99%A8%EF%BC%8C%E9%9B%86%E7%BA%BF%E5%99%A8%EF%BC%8C%E4%BA%A4%E6%8D%A2%E6%9C%BA%EF%BC%8C%E7%BD%91%E6%A1%A5%EF%BC%8C%E5%85%89%E7%8C%AB%E6%9C%89%E5%95%A5%E5%8C%BA%E5%88%AB%EF%BC%9F/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 故事就从一个车轱辘说起吧。先来看一个车轱辘。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 故事就从一个车轱辘说起吧。先来看一个车轱辘。 辐条从车轱辘边缘，一直汇聚到 中心的轴，这个轴在英文里叫hub。 而我们今天要讲到的集线器，英文里也叫hub。 都叫hub，多少有点关系，看下这面这个图大概能明白，其实两者有点像。 大概想表达的意思是，它是汇聚网线的中心，因此就叫集线器。 所以可以理解，大家常逛的 Github，Docker Hub, 还有P**hub ，都是为了表达它们是某类资源的中心了吧。 那么集线器是什么呢？那就要从电脑是怎么互联的这个话题说起。 小学的时候，有一种网吧，它其实是不能上外网的。也就是不能打开度娘，不能搜索资料。 不能上网的网吧还能叫网吧？ 能。虽然不能上外网，但网吧老板可以把很多台机子连起来，实现网吧内互联，形成一个局域网（Local Area Network，简称LAN）。 网吧内互联之后，就可以放上各种游戏，比如CS，实现网吧内对线。 这种网吧有种好处，没有那么多键盘侠。 毕竟你不知道什么时候键着键着，对方就顺着网线找过来了。 对战直接从线上转移到线下了。 因此大家打游戏都很和谐，客气，场面十分感人就是了。 那么网吧内的电脑是怎么互联呢？ 一根网线互联电脑从最简单的场景说起，假设网吧内只有两台电脑 随便连根网线就能实现互联吗？ 当然不是。 还记得网络分层吗? 数据如果要进行传输，会从A电脑经过这些网络分层把消息组装好，再到B电脑层层解包。 网线，只是代替了上面的灰色部分，实现物理层上互联。 如果想要两台电脑互联成功，还需要确保每一层所需要的步骤都要做到位，这样数据才能确保正确投送并返回。 我们自顶向下，从细节开始说一下实现互联需要做什么。 应用层该层的网络功能由应用本身保证。 假设两台电脑是打算用游戏进行联网，那么该应用层的功能由游戏程序保证。 传输层绝大部分游戏用的传输层协议都是TCP，我们可以看下TCP报头。 这里面我们需要关注的是源和目的端口，这个可以定位到这台电脑上哪个进程在收发数据。 这两个端口信息一般是游戏内部已经填好。 AB两台电脑，其中一台作为服务端启动，比如A，起了个服务器进程。 服务器会开放一个固定的端口，比如27015。这就是目的端口。 这时候A和B都可以搜索到这个服务器。启动一个客户端进程，连接进入A的服务器进程。 而源端口，则由A和B自己生成。 网络层上图除了端口，我们还看到一个192.168.0.105，这个就是A的IP地址。 我们看一下IP层的报文头。 这里面需要关注是源和目的IP地址。 如果两台电脑想通过一根网线进行消息通信，那么他们需要在一个局域网内。 这意味着，他们的子网掩码需要一致。局域网内，假设子网掩码是 225.225.225.0，会认为 192.168.0.x 这些IP都属于一个局域网。所以当A的IP地址是192.168.0.105 时，那么B的IP地址可以配成192.168.0.106 。 关于IP这一块是啥，后面会细讲，大家如果没明白我说的是啥，不要急。 组装好网络层报头后，数据包传入到数据链路据层。 数据链路层以上解决了网络层的互联，而在数据链路层，数据包里需要拼接上MAC报头。先看下MAC报头长什么样子。 其中需要关心的是标红的源和目的MAC地址。MAC地址可以粗略理解是这台电脑网卡的唯一标识。大概长这样 128:f9:d3:62:7d:31 源和目的地址，在发送消息的时候就会被填上。 但是A只知道自己的MAC地址，怎么才能知道B的MAC地址呢？ 这时候需要ARP协议。 ARP（Address Resolution Protocal），即地址解析协议。用于将IP地址解析为以太网的MAC地址的协议。 在局域网中，当主机A有数据要发送给主机B时，A必须知道B的IP地址。 但是仅仅有IP地址还是不够的，因为IP数据报文还需要在数据链路层封装成帧才能通过物理网络发送。因为发送端还必须有接收端的MAC地址，所以需要一个从IP地址到MAC地址的映射。ARP就是干这事情的协议。 A查本地ARP表发现B的IP和MAC映射关系不存在 A通过ARP广播的形式向局域网发出消息，询问某IP对应的MAC地址是多少。比如A此时知道B的IP，但并不知道B的MAC地址是多少，就会尝试在局域网内发起ARP广播，询问局域网下所有机器，哪个机器的IP与B的IP一致。 B收到这个ARP消息，发现A要问的IP与自己的IP一致，就会把自己的MAC地址作为应答返回给A。 此时A就知道了B的MAC地址，顺便把消息记录到本地ARP表里，下次直接用表里的关系就行，不需要每次都去问。 物理层从数据链路层到物理层，数据会被转为01比特流。 此时需要把比特流传到另一台电脑。 通过一根网线，两段水晶头插入网口，把两台电脑连起来。 但对网线有一些要求。 这根网线两端的水晶头需要采用交叉互联法。 水晶头里有8根线，注意上图里的颜色，是有顺序的。第1、2根线起着收信号的作用，而第3、6脚发信号的作用。将一端的1号和3号线、2号和6号线互换一下位置，就能够在物理层实现一端发送的信号，另一端能收到。 当然，现在有些网卡有自适应的功能，就算是直连互联法的线，也能有交叉互联法的效果。如果你用的是这种网卡，就当我物理层这块什么都没说吧。 互联此时，在确保关闭防火墙的前提下，可以尝试从A电脑中ping一下B，再从B电脑中ping一下A。如无意外，都能ping通。 A给B发个消息，从应用层到数据链路层，会分别加上A和B的各种’’身份信息”。比如在传输层会加上A和B的应用端口号，在网络层加上源和目的IP，在数据链路层会加上源和目的网卡的MAC头部信息。 B收到消息后逐层解包，验证，最后顺利到达应用层。实现AB两台机器消息互通。 至此游戏就能正常联机对线，两台电脑互联成功！ 什么是集线器两个人打cs，总会觉得无聊，但是每台电脑又只有一个网线口。 想要邀请更多的人一起玩，怎么办？ 那就要回到文章开头提到的集线器（hub）了。 这是个工作在物理层的设备。 有多个网口，很好的解决了电脑上只有一个网口的问题，可以做到多台电脑的网线都插入到集线器上。 同时工作原理也非常简单，会把某个端口收到的数据，输入到中继电路。 中继电路的基本功能是将输入的信号广播到集线器的所有端口上。 简单来说就是无脑复制N份到其余N个端口上。 数据复制到N个端口后。对应转发到N台机器里。 集线器内部结构说到这里，已经对集线器有个大概认识了。 接下来，我们看下集线器的内部结构。 从A网口进入集线器的消息，此时还是电信号。这里经过一个PHY模块。 要理解PHY模块的作用，首先要先了解每个网口，都可能接着网线（废话），而每根网线的传输的格式都是有可能不同的。而PHY的作用，就是把这些格式转化为一个通用的格式。 举个例子。PHY就好比一个翻译器，有的人说英文，有的人说日文。但是PHY，会把它统一转为普通话，给内部电路处理。内部电路处理完之后，再经过PHY模块，转为英语，或日文从对应网口里输出。 经过PHY的处理后，以电信号的形式输入到中继电路，被无脑广播，再次经过PHY模块后变成BCD网口的格式输出。 这里面的电信号，是会受噪声干扰，导致信号形变出错的。 但就算是错了，也还是会原封不动的广播出去，这就是上面提到无脑的精髓所在。 那信号如果出错了怎么办？ 只能让接收方收到消息后进行校验。 还记得上文里提到的数据链路层的MAC报头里最末尾有个FCS吗？ FCS里存放的是发送方通过循环冗余校验CRC计算得到的值。 接收方用收到的数据算一次CRC，与FCS里的值进行对比。 如果一致，那证明数据没问题。如果出错，则直接丢弃。 当然，丢弃包并不会影响数据的传输， 因为丢弃的包不会触发确认响应。因此协议栈的 TCP 模块会检测到丢包， 并对该包进行重传。 如果消息没出错，但是因为无脑广播，C也能收到A发给B的数据包。 此时 C 会在接受到数据包后一层层的”剥开”。 正常情况下，在数据链路层时，识别到目的 MAC 地址跟 C 的不一致时，也会把数据丢弃。 什么是交换机目前只有 ABC 三台机器，每次都是广播发消息倒还好。 如果机器越来越多，每台机器发一条消息，都会被广播，就有点顶不住了。 举个例子。 假设N台机器，其中两台机器A和B，A发到B和B发给A，共两条消息。 如果这N台机器，用的是集线器。还是AB之间互发消息，每条消息都是广播的话，就是(N-1)+(N-1)条消息，差距有些大，对网络资源浪费就有些严重了。 那么，有没有可能做到，A发给B的消息，就不要转发给C呢？ 可以的，把集线器换成交换机。 交换机，又叫switch，跟集线器长得很像。 但是功能更强一些，从网络分层上来说，属于数据链路层，比集线器所在的物理层还要高一层。 所有发到交换机的数据，都会先进入交换机的缓存区。接着消息再被转发到对应机器上。 注意这里用的是转发，而不是集线器的广播，交换机是怎么做到转发的呢？ MAC地址表交换机内部维护了一张MAC地址表。 记录了 端口号和MAC地址的对应关系。 这个表的数据是交换机不断学习的结果。 当A发消息到交换机时，交换机发现消息是从1号端口进来的，则会在MAC地址表上，记录A的MAC地址对应1号端口。 如果A没有很长时间没发消息到这个1号端口，那这条记录就会过期并被删除。 那么，当时间足够长，ABC 都发过消息给交换机后，地址表就会有完整的关系信息。 A准备发送消息给B，此时A会把B的MAC地址，放入要发送的数据里。数据顺着网线发出。 交换机从端口收到数据，会把数据里的源和目的MAC地址提出来，跟MAC地址表进行对比。 发现B的MAC地址正好在2号端口，那么就把数据转发给2号端口。 此时B电脑从网线收到来自交换机2号端口的数据。 两种特殊情况正常流程很清楚了，看两个特殊情况： 交换机查询地址表时，发现目的 MAC 地址的目标端口和这个包的源端口，是同一个端口，怎么办？ 先说结论，会直接丢弃这个包。 我们看下，假设它不丢弃，会发生什么情况。 A发了个消息给B，中间经过一个集线器，此时消息会被广播到B和交换机。 此时B收到第一条A发给它的消息 交换机从1号端口收到A的消息后，解包，获得目的MAC地址是BB-BB-BB-BB-BB-BB。查MAC地址表，发现要发到1号端口。此时，源和目的端口都是同一个，如果交换机不丢弃这个消息，B会收到第二条A发给它的消息。 A只发了一次消息，B却收到两条消息，明显不对。 因此，当交换机查询地址表时，发现目标端口和源端口，是同一个端口时，会丢弃这个包。 MAC地址表里找不到对应的MAC地址，怎么办？ 这可能是因为具有该地址的设备，还没有向交换机发送过包，或者这个设备一段时间没有工作，导致地址被从地址表中删除了。 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上，都能收到这个包。 此时，交换机就会跟集线器一样进行广播。 发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入地址表，下次也就不需要把包 发到所有端口了。 交换机内部结构再看下交换机内部结构。 其实对比可以发现，交换机和集线器内部结构很像。 重点需要提到的是MAC模块。消息以电信号的形式从网口进入，到了PHY会被转成通用格式的电信号。而MAC模块的作用是把这个电信号转为数字信号，这样就能提取出MAC包头，并通过MAC数据帧末尾的FCS校验这个包有没有问题，如果没问题，则把数据放到内存缓冲区里，否则直接丢弃。 另外，这个MAC模块，虽然这么叫。但其实交换机MAC模块不具有 MAC 地址。因此交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。 放入到内存缓冲区后，还会把MAC地址和端口号记录到MAC地址表中。同时检查目的MAC地址在不在MAC地址表中，在的话则会转发到对应端口。否则广播。 交换机与网桥的区别网桥，本质上可以理解为两个网线口的交换机，正好可以把两台电脑给连起来，也叫桥接。而交换机，则是多网线口的网桥，可以把多台电脑给连（桥接）起来。 其他功能方面，大差不差，不必太过纠结。 交换机和二层交换机和三层交换机有什么区别这一部分提到的交换机，其实就是二层交换机，也就是工作在第二层（数据链路层）的交换机，二者没区别。 而三层交换机，是工作在第三层（网络层）的交换机，其实就是接下来要提到的路由器。 什么是路由器有了交换机之后，小网吧里的电脑就都可以被连起来了。交换机网口不够？那就再接个交换机。 但世界上电脑这么多，交换机里的MAC地址表难道全都要记住吗? 显然做不到。为了解决这个问题。 于是就有了路由器，工作在网络层，比数据链路层更高一层。 网络层引入了IP的概念。 什么是IP比如前面提到的 192.168.0.105 就是一个IP，同一个局域网内还可能会有一个IP是192.168.0.106。有没有发现，它们都是192.168.0.xxx。 像极了 上海市.黄浦区.南京东路.105号，这样的地址。现实生活中，我们可以通过一个地址定位到要去哪。到了 上海市.黄浦区.南京东路.105号楼里，我们就可以再去找某个叫身份证为xiaobaixxxxx的人。 那互联网世界里，我们也就可以通过IP地址，定位到某个广域网段，再通过广域网内部的局域网的MAC地址定位到具体某个电脑。 上海市.黄浦区.南京东路.105号可以帮助我们定位到在南京东路上的第105号楼的位置。但还有些路，比如南京西路，可能不止105号，可能要到257号。 实际上一个IP由网络号和主机号组成，共32位组成。如果拿了前面24位做网络号，那主机号就剩8位了，2的8次方=256，最多表示表示256号楼。因此为了多表示几个楼，可以向网络号多挪几位过来作为主机号。 那么具体多少位作为网络号呢？可以在IP后面加一个数字，用来表明这一点。 于是就有了 192.168.0.105/24这种表示方法，表明前24位192.168.0.0是网络号，105是主机号。 有了网段，就可以一次性表示一大批地址。就不需要像交换机那样苦哈哈的一条一条MAC地址记录在表里。 路由表路由器的作用，可以帮助我们在互联网世界里转发消息到对应的IP。 对比一下。 交换机，是通过 MAC 头部中，接收方 MAC 地址，来判断转发目标的。 路由器，则是根据 IP 头部中， IP 地址来判断的。 由于使用的地址不同，记录转发信息的表也会不同。 类似交换机的MAC地址表，路由器也维护了一张路由表。 而路由表，是用于告诉路由器，什么样的消息该转发到什么端口。 假设A要发消息到D。也就是192.168.0.105/24要发消息到192.168.1.11/24。 那么A会把消息经过交换机发到路由器。 路由器通过192.168.0.105/24获得其网络号是 192.168.0.0 ，而目的地的网络号是192.168.1.0，二者网络号不同，处于不同局域网。 查路由表，发现192.168.1.0,在e2端口，那么就会把消息从e2端口发出，到达交换机，交换机发现MAC地址是它局域网下的D机器，就把消息打过去。 当然，如果路由表里找不到，那就打到默认网关吧，也就是从e1口发出，发到IP192.0.2.1。这个路由器的路由表不知道该去哪，说不定其他路由器知道。 路由器的内部结构 路由器内部，分为控制平面和数据平面，说白了就是对应软件部分和硬件部分。 硬件部分跟交换机很像。数据从A网口进入，此时数据还是网线上格式的电信号，会被PHY模块转为通用信号格式，再被MAC模块转为数字信号，通过FCS进行错误校验，同时校验MAC地址是否是自己，通过校验则进入内存缓冲区，否则丢弃。 再进入软件部分，由路由选择处理器，通过一定规则（软件逻辑），查询路由表判断转发目标和对应转发口，再经由硬件部分的交换结构转发出去。 如果路由表中无法找到匹配记录，路由器会丢弃这个包，并通过ICMP消息告知发送方。 路由器和交换机的主要区别MAC模块的区别路由器和交换机不同点在于，它的每个网口下，都有一个MAC地址和IP地址。 正因为路由器具有 MAC 地址，因此它能够成为数据链路层的的发送方和接收方。 怎么理解这句话？ 前面提到交换机，是不具备MAC地址的，而MAC报头是需要填上目的MAC地址的。因此交换机从来都不是数据的目的地，它只简单转发数据帧到目的地。 但路由器，是有MAC地址的，因此MAC报头就可以写上，下一站目的地就是xx路由。 到了路由器后，路由器可以再次组装下一站的目的MAC地址是再下一个路由，通过这一点，让数据在路由和路由之间传输。 而同时因为交换机不具有MAC地址，因此也不会校验收到的数据帧的MAC地址是不是自己的，全部收下做转发。而路由器则会校验数据帧的MAC报头里的目的MAC地址是不是自己，是的话才会收入内存缓冲区，否则丢弃。 找不到转发目的地时的处理方式有区别如果在路由表中无法找到匹配的记录，路由器会丢弃这个包，并通过 ICMP消息告知发送方。 而交换机在MAC地址表里找不到转发端口时会选择广播。 这里的处理方式两者是不同的，原因在于网络规模的大小。 交换机连接的网络最多也就是几千台设备的规模，这个规模并 不大。如果只有几千台设备，遇到不知道应该转发到哪里的包，交换机可以将包发送到所有的端口上，虽然这个方法很简单粗暴，但不会引发什么 问题。 但路由器工作的网络环境就是互联网，全世界所有的设备都连接在互联网上，规模非常大，并且这个规模还在持续扩大中。如果此时它的操作跟交换机一样，将不知道应该转发到哪里的包发送到整个网络上，那就会产生大量的网络包，造成网络拥塞。因此，路由器遇到不知道该转发到哪里的包， 就会直接丢弃。 路由器和光猫有什么区别不管是交换机还是路由器，前面都是提到网口输入的是电信号。但现在流行的是光纤传输，传输的是光信号。 而光猫（modem），是一种调制解调器，其实就是用于光电信号转换的设备。 接收数据时，可以将光纤里的光信号转化为电信号，发给路由器，路由器内部再转成数字信号，并在此基础上做各种处理。 相反，也会把路由器传来的电信号转为光信号，发到光纤，并进入互联网。 总结 两台电脑可以通过一根网线直接连接，进行通信。 机器一多，可以把网线都接到集线器（物理层）上，但是集线器会不管三七二十一进行广播。 不想广播，可以用（二层）交换机（数据链路层），又叫多端口网桥，它比较聪明，会自我学习生产MAC地址表，知道消息发到哪，那就不需要广播啦 互联网电脑这么多，交换机MAC地址表总不能全放下吧。改用路由器（网络层），也叫三层交换机，通过网段的方式定位要把消息转发到哪，就不需要像交换机那样苦哈哈一条条记录MAC地址啦。 路由器和光猫之间是好搭档，光猫负责把光纤里的光信号转换成电信号给路由器。 现在一般情况下，家里已经不用集线器和交换机了，大部分路由器也支持交换机的功能。所以可以看到，家里的台式机电脑一般就连到一个路由器，再连个光猫就够能快乐上网了。 最后以前整个班的同学家里都不见得有一台电脑，都喜欢偷偷跑去网吧玩电脑。改革开放的春风，把电脑吹进了每家每户，也把网吧给吹成了网咖。 从前的我晚上偷偷上网，现在的我，接到报警，也能在大半夜爬起来网上冲浪。 没想到我以这种方式保持了当初最纯粹的质朴。 我是小白，看下右下角，你懂我意思的。 夏天快来了，我们下期见。 参考资料网络是怎么连接的 - 户根勤 趣谈网络协议- 极客时间 文章推荐： 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 程序员防猝死指南 硬核图解，TCP粘包是什么？为什么UDP不粘包？ 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"TCP粘包  数据包：我只是犯了每个数据包都会犯的错 |硬核图解","slug":"图解网络/TCP粘包！数据包：我只是犯了每个数据包都会犯的错，硬核图解","date":"2021-03-26T14:57:55.000Z","updated":"2021-10-08T01:37:48.034Z","comments":true,"path":"2021/03/26/图解网络/TCP粘包！数据包：我只是犯了每个数据包都会犯的错，硬核图解/","link":"","permalink":"https://xiaobaitech.github.io/2021/03/26/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E7%B2%98%E5%8C%85%EF%BC%81%E6%95%B0%E6%8D%AE%E5%8C%85%EF%BC%9A%E6%88%91%E5%8F%AA%E6%98%AF%E7%8A%AF%E4%BA%86%E6%AF%8F%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%8C%85%E9%83%BD%E4%BC%9A%E7%8A%AF%E7%9A%84%E9%94%99%EF%BC%8C%E7%A1%AC%E6%A0%B8%E5%9B%BE%E8%A7%A3/","excerpt":"事情从一个健身教练说起吧。","text":"事情从一个健身教练说起吧。 李东，自称亚健康终结者，尝试使用互联网+的模式拓展自己的业务。在某款新开发的聊天软件琛琛上发布广告。 键盘说来就来。疯狂发送”李东”，回车发送！，”亚健康终结者”，再回车发送！ 还记得四层网络协议长什么样子吗？ 四层网络模型每层各司其职，消息在进入每一层时都会多加一个报头，每多一个报头可以理解为数据报多戴一顶帽子。这个报头上面记录着消息从哪来，到哪去，以及消息多长等信息。比如，**mac头部记录的是硬件的唯一地址，IP头记录的是从哪来和到哪去，传输层头记录到是到达目的主机后具体去哪个进程**。 在从消息发到网络的时候给消息带上报头，消息和纷繁复杂的网络中通过这些信息在路由器间流转，最后到达目的机器上，接受者再通过这些报头，一步一步还原出发送者最原始要发送的消息。 为什么要将数据切片软件琛琛是属于应用层上的。 而”李东”，”亚健康终结者”这两条消息在进入传输层时使用的是传输层上的 TCP 协议。消息在进入传输层（TCP）时会被切片为一个个数据包。这个数据包的长度是MSS。 可以把网络比喻为一个水管，是有一定的粗细的，这个粗细由网络接口层（数据链路层）提供给网络层，一般认为是的MTU（1500），直接传入整个消息，会超过水管的最大承受范围，那么，就需要进行切片，成为一个个数据包，这样消息才能正常通过“水管”。 MTU 和 MSS 有什么区别 MTU: Maximum Transmit Unit，最大传输单元。 由网络接口层（数据链路层）提供给网络层最大一次传输数据的大小；一般 MTU=1500 Byte。假设IP层有 &lt;= 1500 byte 需要发送，只需要一个 IP 包就可以完成发送任务；假设 IP 层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，分片后的 IP Header ID 相同。 MSS：Maximum Segment Size 。 TCP 提交给 IP 层最大分段大小，不包含 TCP Header 和 TCP Option，只包含 TCP Payload ，MSS 是 TCP 用来限制应用层最大的发送字节数。假设 MTU= 1500 byte，那么 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果应用层有 2000 byte 发送，那么需要两个切片才可以完成发送，第一个 TCP 切片 = 1460，第二个 TCP 切片 = 540。 什么是粘包那么当李东在手机上键入”李东””亚健康终结者”的时候，在 TCP 中把消息分成 MSS 大小后，消息顺着网线顺利发出。 网络稳得很，将消息分片传到了对端手机 B 上。经过 TCP 层消息重组。变成”李东亚健康终结者”这样的字节流（stream）。 但由于聊天软件琛琛是新开发的，而且开发者叫小白，完了，是个臭名昭著的造 bug 工程师。经过他的代码，在处理字节流的时候消息从”李东”，”亚健康终结者”变成了”李东亚”，”健康终结者”。”李东”作为上一个包的内容与下一个包里的”亚”粘在了一起被错误地当成了一个数据包解析了出来。这就是所谓的粘包。 一个号称健康终结者的健身教练，大概运气也不会很差吧，就祝他客源滚滚吧。 为什么会出现粘包那就要从 TCP 是啥说起。 TCP，Transmission Control Protocol。传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。 其中跟粘包关系最大的就是基于字节流这个特点。 字节流可以理解为一个双向的通道里流淌的数据，这个数据其实就是我们常说的二进制数据，简单来说就是一大堆 01 串。这些 01 串之间没有任何边界。 应用层传到 TCP 协议的数据，不是以消息报为单位向目的主机发送，而是以字节流的方式发送到下游，这些数据可能被切割和组装成各种数据包，接收端收到这些数据包后没有正确还原原来的消息，因此出现粘包现象。 为什么要组装发送的数据上面提到 TCP 切割数据包是为了能顺利通过网络这根水管。相反，还有一个组装的情况。如果前后两次 TCP 发的数据都远小于 MSS，比如就几个字节，每次都单独发送这几个字节，就比较浪费网络 io 。 比如小白爸让小白出门给买一瓶酱油，小白出去买酱油回来了。小白妈又让小白出门买一瓶醋回来。小白前后结结实实跑了两趟，影响了打游戏的时间。 优化的方法也比较简单。当小白爸让小白去买酱油的时候，小白先等待，继续打会游戏，这时候如果小白妈让小白买瓶醋回来，小白可以一次性带着两个需求出门，再把东西带回来。 上面说的其实就是TCP的 Nagle 算法优化，目的是为了避免发送小的数据包。 在 Nagle 算法开启的状态下，数据包在以下两个情况会被发送： 如果包长度达到MSS（或含有Fin包），立刻发送，否则等待下一个包到来；如果下一包到来后两个包的总长度超过MSS的话，就会进行拆分发送； 等待超时（一般为200ms），第一个包没到MSS长度，但是又迟迟等不到第二个包的到来，则立即发送。 由于启动了Nagle算法， msg1 小于 mss ，此时等待200ms内来了一个 msg2 ，msg1 + msg2 &gt; MSS，因此把 msg2 分为 msg2(1) 和 msg2(2)，msg1 + msg2(1) 包的大小为MSS。此时发送出去。 剩余的 msg2(2) 也等到了 msg3， 同样 msg2(2) + msg3 &gt; MSS，因此把 msg3 分为 msg3(1) 和 msg3(2)，msg2(2) + msg3(1) 作为一个包发送。 剩余的 msg3(2) 长度不足mss，同时在200ms内没有等到下一个包，等待超时，直接发送。 此时三个包虽然在图里颜色不同，但是实际场景中，他们都是一整个 01 串，如果处理开发者把第一个收到的 msg1 + msg2(1) 就当做是一个完整消息进行处理，就会看上去就像是两个包粘在一起，就会导致粘包问题。 关掉 Nagle 算法就不会粘包了吗？Nagle 算法其实是个有些年代的东西了，诞生于 1984 年。对于应用程序一次发送一字节数据的场景，如果没有 Nagle 的优化，这样的包立马就发出去了，会导致网络由于太多的包而过载。 但是今天网络环境比以前好太多，Nagle 的优化帮助就没那么大了。而且它的延迟发送，有时候还可能导致调用延时变大，比如打游戏的时候，你操作如此丝滑，但却因为 Nagle 算法延迟发送导致慢了一拍，就问你难受不难受。 所以现在一般也会把它关掉。 看起来，Nagle 算法的优化作用貌似不大，还会导致**粘包”问题”。那么是不是关掉这个算法就可以解决掉这个粘包”问题”**呢？ 1TCP_NODELAY = 1 接受端应用层在收到 msg1 时立马就取走了，那此时 msg1 没粘包问题 **msg2 **到了后，应用层在忙，没来得及取走，就呆在 TCP Recv Buffer 中了 **msg3 **此时也到了，跟 msg2 和 msg3 一起放在了 TCP Recv Buffer 中 这时候应用层忙完了，来取数据，图里是两个颜色作区分，但实际场景中都是 01 串，此时一起取走，发现还是粘包。 因此，就算关闭 Nagle 算法，接收数据端的应用层没有及时读取 TCP Recv Buffer 中的数据，还是会发生粘包。 怎么处理粘包粘包出现的根本原因是不确定消息的边界。接收端在面对**”无边无际”的二进制流的时候，根本不知道收了多少 01 才算一个消息。一不小心拿多了就说是粘包**。其实粘包根本不是 TCP 的问题，是使用者对于 TCP 的理解有误导致的一个问题。 只要在发送端每次发送消息的时候给消息带上识别消息边界的信息，接收端就可以根据这些信息识别出消息的边界，从而区分出每个消息。 常见的方法有 加入特殊标志 可以通过特殊的标志作为头尾，比如当收到了0xfffffe或者回车符，则认为收到了新消息的头，此时继续取数据，直到收到下一个头标志0xfffffe或者尾部标记，才认为是一个完整消息。类似的像 HTTP 协议里当使用 chunked 编码 传输时，使用若干个 chunk 组成消息，最后由一个标明长度为 0 的 chunk 结束。 加入消息长度信息 这个一般配合上面的特殊标志一起使用，在收到头标志时，里面还可以带上消息长度，以此表明在这之后多少 byte 都是属于这个消息的。如果在这之后正好有符合长度的 byte，则取走，作为一个完整消息给应用层使用。在实际场景中，HTTP 中的Content-Length就起了类似的作用，当接收端收到的消息长度小于 Content-Length 时，说明还有些消息没收到。那接收端会一直等，直到拿够了消息或超时，关于这一点上一篇文章里有更详细的说明。 可能这时候会有朋友会问，采用0xfffffe标志位，用来标志一个数据包的开头，你就不怕你发的某个数据里正好有这个内容吗？ 是的，怕，所以一般除了这个标志位，发送端在发送时还会加入各种校验字段（校验和或者对整段完整数据进行 CRC 之后获得的数据）放在标志位后面，在接收端拿到整段数据后校验下确保它就是发送端发来的完整数据。 UDP 会粘包吗跟 TCP 同为传输层的另一个协议，UDP，User Datagram Protocol。用户数据包协议，是面向无连接，不可靠的，基于数据报的传输层通信协议。 基于数据报是指无论应用层交给 UDP 多长的报文，UDP 都照样发送，即一次发送一个报文。至于如果数据包太长，需要分片，那也是IP层的事情，大不了效率低一些。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。而接收方在接收数据报的时候，也不会像面对 TCP 无穷无尽的二进制流那样不清楚啥时候能结束。正因为基于数据报和基于字节流的差异，TCP 发送端发 10 次字节流数据，而这时候接收端可以分 100 次去取数据，每次取数据的长度可以根据处理能力作调整；但 UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完，且发了多少，就取多少，确保每次都是一个完整的数据报。 我们先看下IP报头 注意这里面是有一个 16 位的总长度的，意味着 IP 报头里记录了整个 IP 包的总长度。接着我们再看下 UDP 的报头。 在报头中有16bit用于指示 UDP 数据报文的长度，假设这个长度是 n ，以此作为数据边界。因此在接收端的应用层能清晰地将不同的数据报文区分开，从报头开始取 n 位，就是一个完整的数据报，从而避免粘包和拆包的问题。 当然，就算没有这个位（16位 UDP 长度），因为 IP 的头部已经包含了数据的总长度信息，此时如果 IP 包（网络层）里放的数据使用的协议是 UDP（传输层），那么这个总长度其实就包含了 UDP 的头部和 UDP 的数据。 因为 UDP 的头部长度固定为 8 字节（ 1 字节= 8 位，8 字节= 64 位，上图中除了数据和选项以外的部分），那么这样就很容易的算出 UDP 的数据的长度了。因此说 UDP 的长度信息其实是冗余的。 1UDP Data 的长度 = IP 总长度 - IP Header 长度 - UDP Header 长度 可以再来看下 TCP 的报头 TCP首部里是没有长度这个信息的，跟UDP类似，同样可以通过下面的公式获得当前包的TCP数据长度。 1TCP Data 的长度 = IP 总长度 - IP Header 长度 - TCP Header 长度。 跟 UDP 不同在于，TCP 发送端在发的时候就不保证发的是一个完整的数据报，仅仅看成一连串无结构的字节流，这串字节流在接收端收到时哪怕知道长度也没用，因为它很可能只是某个完整消息的一部分。 为什么长度字段冗余还要加到 UDP 首部中关于这一点，查了很多资料，《 TCP-IP 详解（卷2）》里说可能是因为要用于计算校验和。也有的说是因为UDP底层使用的可以不是IP协议，毕竟 IP 头里带了总长度，正好可以用于计算 UDP 数据的长度，万一 UDP 的底层不是IP层协议，而是其他网络层协议，就不能继续这么计算了。 但我觉得，最重要的原因是，IP 层是网络层的，而 UDP 是传输层的，到了传输层，数据包就已经不存在IP头信息了，那么此时的UDP数据会被放在 UDP 的 Socket Buffer 中。当应用层来不及取这个 UDP 数据报，那么两个数据报在数据层面其实都是一堆 01 串。此时读取第一个数据报的时候，会先读取到 UDP 头部，如果这时候 UDP 头不含 UDP 长度信息，那么应用层应该取多少数据才算完整的一个数据报呢？ 因此 UDP 头的这个长度其实跟 TCP 为了防止粘包而在消息体里加入的边界信息是起一样的作用的。 面试的时候咱就把这些全说出去，显得咱好像经过了深深的思考一样，面试官可能会觉得咱特别爱思考，加分加分。 如果我说错了，请把我的这篇文章转发给更多的人，让大家记住这个满嘴胡话的人，在关注之后狠狠的私信骂我，拜托了！ IP 层有粘包问题吗IP 层会对大包进行切片，是不是也有粘包问题？ 先说结论，不会。首先前文提到了，粘包其实是由于使用者无法正确区分消息边界导致的一个问题。 先看看 IP 层的切片分包是怎么回事。 如果消息过长，IP层会按 MTU 长度把消息分成 N 个切片，每个切片带有自身在包里的位置（offset）和同样的IP头信息。 各个切片在网络中进行传输。每个数据包切片可以在不同的路由中流转，然后在最后的终点汇合后再组装。 在接收端收到第一个切片包时会申请一块新内存，创建IP包的数据结构，等待其他切片分包数据到位。 等消息全部到位后就把整个消息包给到上层（传输层）进行处理。 可以看出整个过程，IP 层从按长度切片到把切片组装成一个数据包的过程中，都只管运输，都不需要在意消息的边界和内容，都不在意消息内容了，那就不会有粘包一说了。 IP 层表示：我只管把发送端给我的数据传到接收端就完了，我也不了解里头放了啥东西。 听起来就像 “我不管产品的需求傻不傻X，我实现了就行，我不问，也懒得争了”，这思路值得每一位优秀的划水程序员学习，respect。 总结粘包这个问题的根因是由于开发人员没有正确理解 TCP 面向字节流的数据传输方式，本身并不是 TCP 的问题，是开发者的问题。 TCP 不管发送端要发什么，都基于字节流把数据发到接收端。这个字节流里可能包含上一次想要发的数据的部分信息。接收端根据需要在消息里加上识别消息边界的信息。不加就可能出现粘包问题。 TCP 粘包跟Nagle算法有关系，但关闭 Nagle 算法并不解决粘包问题。 UDP 是基于数据报的传输协议，不会有粘包问题。 IP 层也切片，但是因为不关心消息里有啥，因此有不会有粘包问题。 TCP 发送端可以发 10 次字节流数据，接收端可以分 100 次去取；UDP 发送端发了 10 次数据报，那接收端就要在 10 次收完。 数据包也只是按着 TCP 的方式进行组装和拆分，如果数据包有错，那数据包也只是犯了每个数据包都会犯的错而已。 最后，李东工作没了，而小白表示 文章推荐： 给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题 硬核！漫画图解HTTP知识点+面试题 程序员防猝死指南 别说了，一起在知识的海洋里呛水吧关注公众号:【小白debug】","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"程序员划水指南","slug":"程序人生/程序员防猝死指南","date":"2021-03-10T14:57:55.000Z","updated":"2021-10-08T01:34:27.941Z","comments":true,"path":"2021/03/10/程序人生/程序员防猝死指南/","link":"","permalink":"https://xiaobaitech.github.io/2021/03/10/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E7%A8%8B%E5%BA%8F%E5%91%98%E9%98%B2%E7%8C%9D%E6%AD%BB%E6%8C%87%E5%8D%97/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 快过年了，跟我可爱的小侄子通了个电话，上来就说，”叔叔你头发怎么变少了”，我很痛心，我的小侄子，年纪轻轻的，眼神已经这么不好使了。但转念一想，这也是他对我的一种关心，作为叔叔，也该回应一把，今年过年给他带一本《少儿编程》回去当礼物吧。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 快过年了，跟我可爱的小侄子通了个电话，上来就说，”叔叔你头发怎么变少了”，我很痛心，我的小侄子，年纪轻轻的，眼神已经这么不好使了。但转念一想，这也是他对我的一种关心，作为叔叔，也该回应一把，今年过年给他带一本《少儿编程》回去当礼物吧。 但转念又一想，也许我真的头发变少了呢，我强壮的体魄不再足以支撑我肮脏的灵魂了呢，或许真的应了那句古语，程序员固有一死，要么骚死，要么累死？ 我好残忍，我竟然想让我的小侄走上这么一条不归路。 可是我这一身编程本领好想传授予人，我还想不想那么快一”猝”而就。我还想看着小侄子长大成人，然后在面试他的时候偷偷放水，再把他招进部门结对编程，我一定要活久一点。我想一定还有跟我一样有未了心愿的程序员，于是今天我将祭出所有划水技能，希望赠与有缘人。 换行业这是最直接的解决方案，那么问题来了，应该去哪个行业呢？程序员下岗后一般再就业的岗位不是送外卖就是送快递，这两个工作从工作强度和工作时长来说，丝毫不比程序员轻松。这就片面了。 有时间送快递和外卖的话，那不如老老实实考个公务员吧。程序员怎么成为公务员？这里正好有一个github项目，就教你如何成为一个公务员。 1https://github.com/coder2gwy/coder2gwy 连怎么安排学习时间，怎么请假都安排得明明白白，贼吉尔细心。 跳槽到965的公司从程序员跳槽到公务员或者是教师这条路子比较艰难，虽然我相信大部分程序员在考试上面都比常人要更擅长些。 一旦选择考公务员，等于放弃自己学习多年的技能，什么mysql，redis，java，设计模式这些，都将成为过眼云烟，选择成本巨大。就算成了，也可能会后悔，或许会在某个四下无人的下午三点，用当年的程序员杯子装着这周xx办主任送的茶叶泡的茶，写着 《下班总结》，感叹这个世界少了一个出色的程序员。 那么跳槽到一个965的公司，可能可以帮助你更好地划水。那么问题来了，怎么样找到995的公司？ 还记得n年前的那个996icu吗？ 1https://github.com/996icu/996.ICU 里面贴心地给出了一份996的公司名单，如果你坚决拒绝996，那么从拒绝这份名单里的公司offer开始。 1https://github.com/996icu/996.ICU/tree/master/blacklist 同时给出了这些公司996的证据，真正做到”拒绝张嘴就来”和有理有据，非常符合程序员讲事实摆道理的性格。 建议大家根据钱包厚度和身体承受能力进行选择，996下班不可怕，可怕的是，半夜一个报警就可以爬起来愉快网上冲浪了。以前高中的时候还要翻墙出去网吧通宵，现在在家里就能做到！ 同时也给出了一份965的公司名单。 1https://github.com/996icu/996.ICU/tree/master/whitelist 但是值得一提，这些公司都比较少，同时不排除哪一天不会变成996。毕竟制度是人定的，公司也是要盈利的，哪天换了个领导冲kpi，大家也只能一起冲冲冲了。 结论上来说，996的公司比965的公司多太多，大部分有志青年都在996的公司里，既然无法避免，那就要学会怎么在工作中划水。 学会划水如果你已经在996的公司里，同时你的钱包需要你通过这种方式出卖劳动，那么显然换行业，跳槽，都不太适合，毕竟轻松意味着钱少。那么怎么在996公司里防猝死呢？划水成为唯一答案，划水其实也是一种技术，是分等级的，下面分享几个实用的划水技巧。 初级划水技能初级划水技能是属于每个程序员都要学会的基础技能。 不要让自己看起来很闲不管是因为你是真的很闲，还是因为你效率高很快把活干完了。如果你看起来很闲，老板就容易会认为你工作不饱和，从而不断加活，直到你看起来一直在忙为止。既然如此，如果你一直看起来很忙，那么这样的问题可以被很好的避免。而vscode是程序员最常用的编辑器，我们可以在此基础上找到很多划水神器。 模拟写代码1https://github.com/zy445566/vscode-plugin-swimming 代码写的快，提早完工被压榨怎么办？你需要一个模拟写代码工具，让VSCode模拟写代码，划水、摸鱼神器，让代码自己重写一遍。 看小说工具上学那会偷偷摸摸看小说时会在小说本上套上一层课本封面，以此来掩盖上课划水的行为。同样的道理，下面这个插件感觉跟上课看小说的经历有点像，他让开发者可以在 VSCode 上边写代码边看小说。 下次等产品经理路过你身旁的时候，以为你写了一堆密密麻麻的的代码，都不好意思再给你加需求。 1https://github.com/zrk1993/read-vscode-e 听音乐插件做事做全套，还要在vscode装上听音乐的插件。 1https://github.com/nondanee/vsc-netease-music 炒股 1https://github.com/roblourens/vscode-stocks 中级划水技能项目时间预估 每次需求迭代，产品都会让开发给出一个开发时间。 我接触过的百分之90的程序员都是老实的小伙子，是多少就报多少，有些为了方便产品快速看效果，还会压缩自己的时间，这种情况在新人程序员里尤为明显。 但有些不讲武德的产品，会动不动做一点 小小的改动，同时因为改动较小，之前提到的时间一般不会更改。 如果你所在的项目中产品不止一个人，就可能出现多个产品给你提需求的情况，改动不大，但挺急。 一个程序员越老实，就越不会表达，选择闷头苦干，有些甚至牺牲节假日时间在家干活。 因此为了更好的应对这些非常常见的情况，建议再估计工时的时候，都多预估至少20~50%的时间当做buffer。 如果你提前做好需求，请务必不要提前给产品看，这只会方便他在看到实物后做出更多的变更。 如何巧妙的推掉需求 很多产品在做每一期迭代开发需求的时候，会有无穷无尽的想法，而且恨不得都全部实现，最好今天就能给到。 大部分老实的程序员，会选择尽可能满足这些可爱的需求。这些永远没办法做完的需求，才是耗尽程序员心力的重要因素。 你需要给每个需求和变更排期，给需求留足buffer，确保线上出问题的时候你还有时间去处理。 让产品给这些需求排优先级，从高到低，算好每个需求的人日，做不了一定要提出来，剩下的让不同产品去pk优先级，确保你不过劳。 减少不必要的沟通很多不明真相的产品、运营、其他部门的开发会通过各种途径找到你，大部分时候他们找你都是为了向你询问一些无关痛痒的问题。 有些时候当他们询问的问题触及技术细节的时候，新人程序员都会想要试图产生程序实现原理细节。 请记住一句话，千万不要跟不是搞技术的人聊实现细节，如果可以，最好别跟任何人聊技术实现细节，不仅会把他们的思路带跑偏，还会越解释越迷糊。 另外还有一些人遇到一些疑问，会用企业微信或钉钉找到你，如果这个人说的事情不是紧急的事情，同时没有直接找到你面前，尽量选择过半小时后再处理。 你要相信他们自己解决问题的能力，大部分不重要或跟你关系不大的问题，会因为你的延缓处理自动消失。 大部分真正需要你解决的问题，半小时后还会再找你一次。 另外，哪怕不听音乐，带上耳机，可以减少10%的无效沟通，懂的自然懂。 提升办事效率 提升办事效率是为了减少自己无用时间的支出，从而不至于让自己没有时间在工作之余锻炼休闲。 提升效率这个事情其实比较简单。 选择适合自己的办公软件。比如印象笔记或有道云笔记来记录工作要点和备忘，用番茄学习时间来强迫自己专心写代码，同时还能装个眼睛护士定时提醒自己要放松一下眼睛。 另外我个人强烈建议大家多喝水。 另外推荐几个 VSCode 效率插件 1https://www.infoq.cn/article/c4wbmkc7sslz28gyazll mac 效率神器 1https://github.com/Louiszhai/tool 高级划水技能划水的最高技巧是提升技术水平，可以减少排查问题的时间，提升工作效率，更好的预估时间（意味着可以更精确地给自己多估两天排期）。 只有提升自身硬实力，才能打破这个死循环。 下面介绍一个golang程序员学习提升的项目,里面有超全的golang面试问题整理，用问题驱动去学习。 同时还有一张完整的入门进阶知识图谱，值得star一个啊。关于其他编程语言的学习路线，欢迎各位私信我学习地址。 1https://github.com/xiaobaiTech/golangFamily 学会管理自己的时间要学习时间管理，就要像这个领域里最顶尖的大师学习。 而这个领域里我只认罗老师，罗老师去年荣获时间管理大师称号。在业务能力上罗老师绝对是个优秀的好歌手好演员，各领域开花，忙是不可避免的，工作强度不会比程序员弱。在此基础上，还能做到宛如影分身之术一般时间管理能力，除了熬出两个黑眼圈外，身体却十分硬朗。仔细一想，罗老师是在承受着身体和心理都在长时间承受高强度的压力，但却不影响他身心健康。 我们可以好好分析一下，罗老师为什么能在硬朗这件事情上做的如此出类拔萃。个人拙见，有三点 热爱自己的事业 我们可以看下，罗老师的日程表。 这工作强度映射到程序员身上，也差不多跟连续开会写代码997差不多了吧，然而他却硬朗得很。 他到底是怎么做到的呢？一言以蔽之，热爱。解bug的过程可能是难受压抑紧张的，但是解bug成功带来的成就感真的很爽。 如果不热爱这份工作，那么成就感没了，只剩下难受和压抑了，不快乐的人，说不定哪天说没就没了。 锻炼身体他热爱跳舞，被称为“亚洲舞王”。虽然这个称呼有点夸张，但是他不是天赋型选手，跳舞能力是花时间练出来的。 而跳舞这件事情，和健身类似，让身体动起来了，出汗了，你自然就爽了。 大家应该都有一种感觉，运动，会让你出汗，会让身体巨酸巨累，但是这个过程中，会让心情变得畅快不压抑，还能让你因为敲代码而变得瘦弱的肱二头肌变得粗壮一些。 事业之外还有自己的爱好这个世界上只有一种真正的英雄主义，就是在认清生活的真相之后，还能热爱生活。 很多程序员在大学刚毕业的时候，都想着自己以后能做一个牛逼哄哄的软件，然后跟乔布斯一样改变这个世界，但是往往又在几年后选择成为一条咸鱼，每天疲惫于跟产品经理斗智斗勇，只要能砍掉哪怕一个需求，那也是一次重大胜利。 我们都只是普通人，产品经理没错，程序猿也没错，当一条咸鱼也挺香的，但是在工作中当咸鱼可以，唯唯诺诺可以，但下了班，你必须重拳出击。 你得有自己的爱好，可以是爬山旅游，篮球游泳。如果这些都太索然无味，你还可以去酒吧跟各种臭妹妹坏弟弟喝上一杯。 最后要每天看一遍凉凉的新闻，坚定自己划水的信念。 鲁迅曾经说过，划水最好的时候两个时间，一个是十年前，一个是现在。你懂我意思吧？ 没懂? 点个在看，你的每一次扩散都可能拯救一个累垮边缘的程序猿！","categories":[{"name":"骚话连篇","slug":"骚话连篇","permalink":"https://xiaobaitech.github.io/categories/%E9%AA%9A%E8%AF%9D%E8%BF%9E%E7%AF%87/"}],"tags":[]},{"title":"硬核！漫画图解HTTP基础+面试题","slug":"图解网络/硬核！漫画图解HTTP知识点+面试题","date":"2021-02-25T14:57:55.000Z","updated":"2021-10-08T01:37:47.892Z","comments":true,"path":"2021/02/25/图解网络/硬核！漫画图解HTTP知识点+面试题/","link":"","permalink":"https://xiaobaitech.github.io/2021/02/25/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E7%A1%AC%E6%A0%B8%EF%BC%81%E6%BC%AB%E7%94%BB%E5%9B%BE%E8%A7%A3HTTP%E7%9F%A5%E8%AF%86%E7%82%B9+%E9%9D%A2%E8%AF%95%E9%A2%98/","excerpt":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。","text":"文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub https://github.com/xiaobaiTech/golangFamily , 有大厂面试完整考点和成长路线，欢迎Star。 什么是HTTPHTTP 全称超⽂文本传输协议，也就是HyperText Transfer Protocol。其中我们常见的文本，图片，视频这些东西都可以用超文本进行表示，而我常看的猫片，也属于超文本，所以大家不要再说我偷偷看猫片了，我只是在看超文本。HTTP只是定义了一套传输超文本的规则，只要符合了这一套规则，不管你是用iphone，还是用老爷机，都可以实现猫片的传输。 七层网络 大概了解了HTTP后，给大家看看它在它们家族里的地位。HTTP位于应用层，跟它类似的协议还有常见的FTP协议，常见的某影天堂的下载链接曾经经常是以FTP开头的。 HTTP报文格式 有点抽象？不知道小白说的啥？那实操一下，用wireshark抓包看一下猫片里的请求报文和响应报文具体长什么样子吧 请求报文1234567891011121314GET /cmaskboss/164203142_30_1.enhance.webmask HTTP/1.1Host: upos-sz-staticks3.bilivideo.comConnection: keep-aliveUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.150 Safari/537.36Accept: */*Origin: https://www.bilibili.comSec-Fetch-Site: cross-siteSec-Fetch-Mode: corsSec-Fetch-Dest: emptyReferer: https://www.bilibili.com/Accept-Encoding: identityAccept-Language: zh-CN,zh;q=0.9Range: bytes=0-16 这上面第一行的GET 就是请求方法，/cmaskboss/164203142_30_1.enhance.webmask 则是 URL , 而HTTP/1.1则是协议版本。接下来从Host开始到最后一行Range，都是Headers头。 响应报文1234567891011121314151617181920212223HTTP/1.1 206 Partial ContentContent-Type: application/octet-streamContent-Length: 17Connection: keep-aliveServer: TengineETag: &quot;92086de1e6d1d4791fb950a0ac7e30ba&quot;Date: Sat, 30 Jan 2021 09:31:31 GMTLast-Modified: Sun, 04 Oct 2020 01:54:28 GMTExpires: Mon, 01 Mar 2021 09:31:31 GMTAge: 1018695Content-Range: bytes 0-16/353225Accept-Ranges: bytesX-Application-Context: applicationx-kss-request-id: 75bcbfa8ab194e3c825e89c81a912692x-kss-BucketOwner: MjAwMDAyMDEwNw==X-Info-StorageClass: -Content-MD5: kght4ebR1HkfuVCgrH4wug==X-Cache-Status: HIT from KS-CLOUD-JH-MP-01-03X-Cache-Status: HIT from KS-CLOUD-TJ-UN-14-13X-Cache-Status: HIT from KS-CLOUD-LF-UN-11-25Access-Control-Allow-Origin: https://www.bilibili.comAccess-Control-Allow-Headers: Origin,X-Requested-With,Content-Type,Accept,rangeX-Cdn-Request-ID: 7e2c783ca7d392624118593ec1dc66bc 类似请求报文，HTTP/1.1是协议版本，206是状态码，Partial Content 则是状态描述符。接下来从Content-Type开始到最后一行X-Cdn-Request-ID都是Headers信息。 报文信息解读其实上面的抓包信息，在浏览器里按F12就能看到，之所以要用wireshark可能只是装X效果比较好吧。按下F12看到的响应数据就跟下图展示的那样。 1.请求数据 2.响应数据 3.Request URLURL是什么URL 代表着是统一资源定位符（Uniform Resource Locator）。作用是为了告诉使用者 某个资源在 Web 上的地址。这个资源可以是一个 HTML 页面，一个 CSS 文档，一幅图像或一个猫片等等。上面我们请求猫片的URL就是 https://upos-sz-staticks3.bilivideo.com/cmaskboss/164203142_30_1.enhance.webmask 这里面细分，又可以分为好几个部分。 协议部分 表示该URL的协议部分为http还是https，会用//为分隔符。上面的URL表示网页用的是HTTPS协议，而上面提到的X影天堂用的则是ftp协议的下载链接。 域名部分 域名是upos-sz-staticks3.bilivideo.com，在发送请求前，会向DNS服务器解析IP，如果已经知道ip，还可以跳过DNS解析那一步，直接把IP当做域名部分使用。 端口部分 域名后面有些时候会带有端口，和域名之间用:分隔，端口不是一个URL的必须的部分。当网址为http://时，默认端口为80 当网址为https://时，默认端口为443，以上两种都可以省略端口号。上面的URL其实省略了443端口号。 虚拟目录 从域名的第一个/开始到最后一个/为止，是虚拟目录的部分。虚拟目录也不是URL必须的部分，本例中的虚拟目录是/cmaskboss/ 文件名部分 从域名最后一个/开始到?为止，是文件名部分；如果没有?，则是从域名最后一个/开始到#为止，是文件名部分；如果没有?和#，那么就从域名的最后一个/从开始到结束，都是文件名部分。本例中的文件名是164203142_30_1.enhance.webmask，文件名也不是一个URL的必须部分。 URL 和 URI 的区别 URL:Uniform Resource Locator 统一资源定位符； URI: Uniform Resource Identifier 统一资源标识符； 其实一直有个误解，很多人以为URI是URL的子集，其实应该反过来。URL是URI的子集才对。简单解释下。假设”小白”(URI)是一种资源，而”在迪丽亦巴的怀里”表明了一个位置。如果你想要找到（locate）小白，那么你可以到”在迪丽亦巴怀里”找到小白，而”在迪丽亦巴怀里的/小白”才是我们常说的URL。而”在迪丽亦巴怀里的/小白”（URL）显然是”小白”（URI）的子集，毕竟，”小白”还可能是”在牛亦菲怀里的/小白”（其他URL）。 4.Request MethodHTTP 定义了一组请求方法，以表明要对给定资源执行的操作。指示针对给定资源要执行的期望动作.。虽然他们也可以是名词，但这些请求方法有时被称为HTTP动词.。每一个请求方法都实现了不同的语义。 这次请求猫片的请求里用的是GET，意味着获取。但其实HTTP定义了多种请求方法，来满足各种需求。除了Get，还有几个POST、HEAD、OPTIONS、PUT、DELETE、TRACE 和 CONNECT。 常见的各个请求方法的具体功能如下： GET请求指定的页面信息，并返回消息主体(body)+头信息(header)。 HEAD：HEAD和GET本质是一样的，区别在于HEAD只返回头信息(header)，不返回消息主体(body)。大家不要以为它没用，它跟GET和POST一样，在http/1.0的时候就存在了，实属三元老之一了。主要用途 如果想要判断某个资源是否存在，虽然用GET也能做到，但这里用HEAD还省下拿body的消耗，返回状态码200就是有404就是无 如果请求的是一个比较大的资源，比如一个超大视频和文件，你只想知道它到底有多大，而不需要整个下载下来，这时候使用HEAD请求，返回的headers会带有文件的大小（content-lenght）。 POST向服务器提交数据。这个方法用途广泛，几乎目前所有的提交操作都是靠这个完成。POST跟GET最常用，但最大的区别在于，POST每次调用都可能会修改数据，是非幂等的，而GET类似于只读，是幂等的。 PUT：这个方法比较少见。在HTTP规范中POST是非等幂的，多次调用会产生不同的结果。比如：创建一个用户,由于网络原因或是其他原因多创建了几次,那么将会有多个用户被创建。而PUT id/xiaobai 则会创建一个id为 xiaobai 的用户，多次调用还是会创建的结果是一样的，所以PUT是等幂的。但是一般为了避免造成心智负担，实战中也会使用POST替代PUT。 DELETE：删除某一个资源。基本上这个也很少见，一般实战中如果是删除操作，也是使用POST来替代。 OPTIONS：options是什么它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP响应头部中带上给各种“Allow”的头，表明某个请求在对应的服务器中都支持哪种请求方法。比如下图： 这里面需要关注的点有两个 Request Header里的关键字段 Response Header里的关键字段 Options堪称是网络协议中的老实人，就好像老实人刚谈了个女朋友，每次牵手前都要问下人家 “我可以牵你的手吗？”， “我可以抱你吗？”，得到了答应后才会下手。差点被这老实人气质感动得留下了不争气的泪水。 什么时候需要使用options在跨域（记住这个词，待会解释）的情况下，浏览器发起复杂请求前会自动发起 options 请求。跨域共享标准规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 options 方法发起一个预检请求，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。 这里提到了两个关键词： 跨域 复杂请求 什么是简单请求和复杂请求。某些请求不会触发 CORS 预检请求，这样的请求一般称为”简单请求”，而会触发预检的请求则为”复杂请求”。 1.简单请求 请求方法为GET、HEAD、POST 只有以下Headers字段 Accept Accept-Language Content-Language Content-Type DPR/Downlink/Save-Data/Viewport-Width/Width (这些不常见，放在一起) Content-Type 只有以下三种 application/x-www-form-urlencoded multipart/form-data text/plain 请求中的任意 XMLHttpRequestUpload 对象均没有注册任何事件监听器； 请求中没有使用 ReadableStream 对象。 2.复杂请求 不满足简单请求的，都是复杂请求 由此可见，因为上述请求在获取网上资源的请求Headers里带有 Access-Control-Request-Headers: range , 而range正好不在简单请求的条件2中提到的Headers范围里，因此属于复杂请求，于是触发预检options请求。 什么是跨域刚刚提到了一个词叫跨域，那什么是跨域呢？在了解跨域之前，首先要了解一个概念：同源。所谓同源是指，域名、协议、端口均相同。 不明白没关系，举个例子。 需要特别注意的是，localhost和127.0.0.1虽然都指向本机，但也不属于同源。 而非同源之间网页调用就是我们所说的跨域。在浏览器同源策略限制下，向不同源发送XHR请求，浏览器认为该请求不受信任，禁止请求，具体表现为请求后不正常响应。 options带来什么问题由此可见，复杂请求的条件其实非常容易满足，而一旦满足复杂请求的条件，则浏览器便会发送2次请求（一次预检options，一次复杂请求），这一次options就一来一回（一个RTT），显然会导致延迟和不必要的网络资源浪费，高并发情况下则可能为服务器带来严重的性能消耗。 如何优化options每次复杂请求前都会调用一次options，这其实非常没有必要。因为大部分时候相同的请求，短时间内获得的结果是不会变的，是否可以通过浏览器缓存省掉这一次查询？ Access-Control-Max-Age就是优化这个流程中使用的一个Header。它的作用是当你每次请求options方法时，服务端返回调用支持的方法（Access-Control-Allow-Methods ）和Headers（Access-Control-Allow-Headers）有哪些，同时告诉你，它在接下来 Access-Control-Max-Age时间（单位是秒）里都支持，则这段时间内，不再需要使用options进行请求。特别注意的是，当Access-Control-Max-Age的值为-1时，表示禁用缓存，每一次请求都需要发送预检请求，即用OPTIONS请求进行检测。 5.Status Code状态码是什么HTTP Status Code是常说的HTTP状态码。当用户访问一个网页时，浏览器会向网页所在服务器发出请求。服务器则会根据请求作出响应，而状态码则是响应的一部分，代表着本次请求的结果。所有状态码的第一个数字代表了响应的大概含义，组合上第二第三个数字则可以表示更具体的原因。如果请求失败了，通过这个状态码，大概初步判断出这次请求失败的原因。以下是五类状态码的含义。 状态码流程可以根据以下流程图了解下各类状态码间的关系。 2xx和3xx之间的流程关系 4xx的状态流程 5xx的状态流程 常见状态码介绍 200 OK 这是最常见的状态码。代表请求已成功，数据也正常返回。而请求猫片虽然响应成功了，但却不是200，而是206，是为什么呢，接下去继续看看。 206 Partial Content 这个状态码在上面请求的响应结果。服务器已经成功处理了部分 GET 请求。类似于看视频或者迅雷这类的 HTTP下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。 307 Temporary Redirect 内部重定向。重定向的意思是，当你输入一个网址的时候，浏览器会自动帮你跳转到另外一个网址上。比如，当你在浏览器输入框输入http://www.baidu.com/时。由于使用http并不安全，百度会自动帮你跳转到它对应的https网页上。而此时，需要重定向的地址，会通过Response Headers的Location返回 404 Not Found 请求失败，请求所希望得到的资源未被在服务器上发现。出现这个错误的最有可能的原因是服务器端没有这个页面，或者是Request Method与注册URL的Method不一致，比如我有一个URL在服务端注册的Request Method 为 POST，但调用的时候却错误用了GET，则也会出现404错误。 499 Client has closed connection 网络请求过程中，由于服务端处理时间过长，客户端超时。一般常见于，后端服务器处理时间过长，而客户端也设置了一个超时等待时间，客户端等得“不耐烦”了，主动关掉连接时报出。 502 Bad Gateway 服务器方面无法给予正常的响应。一般常见于服务器崩溃后，nginx 无法正常收到服务端的响应，给客户端返回502状态码。 504 Gateway Timeout 网络请求过程中，由于服务端处理时间过长，网关超时。一般常见于，后端服务器逻辑处理时间过长，甚至长于 nginx设置的最长等待时间时报错。它跟 499 状态码非常像，区别在于499 表示的是客户端超时，504是网关超时。如果是499超时，可以考虑修改客户端的代码调整超时时间，如果是504，则考虑调整nginx的超时配置。 6. HeadersContent-LengthContent-Length是HTTP的消息长度, 用十进制数字表示。Content-Length首部指出报文中消息的当前实际字节大小。如果消息文本进行了gzip压缩的话， Content-Length指的就是压缩后的大小而不是原始大小。 正常情况下Content-Length是不需要手动去设置的，大部分语言的网络库都会自动封装好，但是如果在一些特殊情况下，出现Content-Length与实际要发送的消息大小不一致，就会出现一些问题。 如果Content-Length &lt; 实际长度 下面启动一个HTTP服务器，所有语言都一样，示例里使用了golang。 12345678910111213141516171819202122232425262728package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;log&quot; &quot;net/http&quot;)// w表示response对象，返回给客户端的内容都在对象里处理// r表示客户端请求对象，包含了请求头，请求参数等等func index(w http.ResponseWriter, r *http.Request) &#123; b, _ := ioutil.ReadAll(r.Body) fmt.Printf(&quot;request body=%#v, content_length=%v \\nheaders=%v&quot;,string(b), r.ContentLength, r.Header) // 往w里写入内容，就会在浏览器里输出 fmt.Fprintf(w, string(b))&#125;func main() &#123; // 设置路由，如果访问/，则调用index方法 http.HandleFunc(&quot;/&quot;, index) // 启动web服务，监听9090端口 err := http.ListenAndServe(&quot;:9999&quot;, nil) if err != nil &#123; log.Fatal(&quot;ListenAndServe: &quot;, err) &#125;&#125; 在控制台输入 12345$ $ curl -L -X POST &#x27;http://127.0.0.1:9999&#x27; -H &#x27;Content-Type: application/json&#x27; -H &#x27;Content-Length: 5&#x27; -d &#x27;1234567&#x27; | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 12 100 5 100 7 828 1160 --:--:-- --:--:-- --:--:-- 140012345 输入的body是 1234567，共7个数字，但是输入的 Content-Length为 5。到了服务器那，收到了 12345，共5个数字，数量上跟输入的Content-Length一致。 由此可见当Content-Length &lt; 实际长度， 消息会被截断。 如果Content-Length &gt; 实际长度 还是上面的服务端代码，但是控制台输入以下命令 1234$ curl -L -X POST &#x27;http://127.0.0.1:9999&#x27; -H &#x27;Content-Type: application/json&#x27; -H &#x27;Content-Length: 100&#x27; -d &#x27;1234567&#x27; | jq % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 7 0 0 0 7 0 0 --:--:-- 0:01:19 --:--:-- 0 这次情况不太一样，会发现请求一直阻塞没有返回。这是因为输入的body是 1234567，共7个数字，但是输入的 Content-Length为 100。也就是服务端一直认为这次的body长度为100，但是目前只收到了部分消息（长度为7），剩余的长度为93的消息由于各种原因还在路上，因此选择傻傻等待剩下的消息，就造成了上面提到的阻塞。 Range 视频播放需要支持用户调整播放进度，支持让用户选择直接跳到中间部分开始播放。为了实现这个功能，需要通过HTTP Range Requests 协议用于指定需要获取视频片段。而 Request Header里的range头则是用于指定要请求文件的起始和结束位置。 如果服务器不支持，直接忽略 Range 头，浏览器会正常按流式加载整个视频文件，以状态码 200 响应即可。另外，当我们在 html 中放一个 video 标签，浏览器会直接发起一个 Range: bytes=0- 的请求，向服务器请求从开始到结尾的完整文件。 如果服务器支持 Range Requests，会读取视频文件，并将他的第 162653～242638 字节提取出来，响应码为 206，则浏览器会在接收到足够字节（比如当前播放进度往后推20s）时结束掉请求，以节省网络流量；当播放进度继续往前，缓存不够时，浏览器会发起一个新的 Range Requests 请求，请求的 Range 直接从缓存结尾的字节开始，只加载剩余的部分文件。同时返回的Response Headers中有一个 content-range 的字段域，用于告诉了客户端发送了多少数据。content-range 描述了响应覆盖的范围和整个实体长度。一般格式：Content-Range：开始字节位置-结束字节位置／文件大小（byte）。 Connection长连接和短连接 Connection: close 表示请求响应完成之后立即关闭连接，这是HTTP/1.0请求的默认值。每次请求都经过“创建tcp连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; 释放连接”这样的过程 Connection: keep-alive 表示连接不立即关闭，可以继续响应下一个请求。HTTP/1.1的请求默认使用一个持久连接。可以做到只建立一次连接，多次资源请求都复用该连接，完成后关闭。流程上是 建立tcp连接 -&gt; 请求资源 -&gt; 响应资源 -&gt; … （保持连接）… -&gt; 第n次请求资源 -&gt; 第n次响应资源 -&gt; 释放连接。 在http1.1中Request Header和Reponse Header中都有可能出现一个Connection: keep-alive 头信息。Request Header里的Connection: keep-alive 头是为了告诉服务端，客户端想要以长连接形式进行通信。而Response Header里的Connection: keep-alive 头是服务端告诉客户端，我的服务器支持以长连接的方式进行通信。如果不能使用长连接，会返回 Connection: close ，相当于告诉客户端“我不支持长连接，你死了这条心，老老实实用短连接吧” 。 HTTP为什么要使用长连接我们知道 HTTP 建立在 TCP 传输层协议之上，而 TCP 的建立需要三次握手，关闭需要四次挥手，这些步骤都需要时间，带给 HTTP 的就是请求响应时延。如果使用短连接，那么每次数据传输都需要经历一次上面提到的几个步骤，如果能只连接一次，保持住这个连接不断开，期间通信就可以省下建立连接和断开连接的过程，对于提升HTTP性能有很大的帮助。 可以看到，在使用 Connection: close 通信时，每次都需要重新经历一次握手挥手。可以通过 Connection: keep-alive 省下这部分的资源消耗。 长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户来说，较适用长连接。但是在长连接的应用场景下，需要有一方主动关闭连接。如果客户端和服务端之间的连接一直不关闭的话，连接数则会越来越多，严重的时候会造成资源占用过高。 解决方案也比较简单。如果这些连接其实长时间内并没有任何数据传输的话，那其实属于空闲连接，这时候可以在服务端设置空闲连接的存活时间，超过一定时间后由服务端主动断掉，从而保证无用连接及时释放。 CookiesCookies是什么 Cookie 是浏览器访问服务器后，服务器传给浏览器的一段数据。里面一般带有该浏览器的身份信息。 浏览器需要保存这段数据，不得轻易删除。 此后每次浏览器访问该服务器，都必须带上这段数据。服务器用使用这段数据确认浏览器身份信息。 Cookie的作用Cookie 一般有两个作用。 1.识别用户身份。 举个例子。用户 A 用浏览器访问了“猫猫网”，“猫猫网”的服务器就会立刻给 A 返回一段Cookie数据，内含「uid=a」。 当 A 再次访问“猫猫网”下的其他页面时，比如跳转到“猫猫交友评论”，就会附带上「uid=a」这段数据。 同理，用户 B 用浏览器访问“猫猫网” 时，就给 B 分配了一段Cookie数据，内含「uid=b」。B 之后访问“猫猫网”的时候，就会一直带上「uid=b」这段数据。 因此“猫猫网”的服务器通过Cookie数据就能区分 A 和 B 两个用户了。 2.持久化用户信息。 因为cookies的数据会被用户浏览器保存到本地下。因此可以利用这一特点保持一些简单的用户数据。 比如一些博客网站，可以通过cookies记录下用户的性别年龄等信息，以此进行一些个性化展示。 当然上面提到的都是一些比较粗糙的场景，是为了方便大家理解cookies的功能。实际使用cookies会非常谨慎。 Referrer Policy 和 Referrer Referrer是什么Referrer 是HTTP请求header的报文头，用于指明当前流量的来源参考页面，常被用于分析用户来源等信息。通过这个信息，我们可以知道访客是怎么来到当前页面的。比如在上面的请求截图里，可以看出我是使用https://www.bilibili.com/访问的视频资源。 Referrer Policy 是什么 Referrer 字段，会用来指定该请求是从哪个页面跳转页来的，里面的信息是浏览器填的。 而 Referrer Policy 则是用于控制Referrer信息传不传、传哪些信息、在什么时候传的策略。 为什么要这么麻烦呢？因为有些网站一些用户敏感信息，比如 sessionid 或是 token 放在地址栏里，如果当做Referrer字段全部传递的话，那第三方网站就会拿到这些信息，会有一定的安全隐患。所以就有了 Referrer Policy，用于过滤 Referrer 报头内容。 比如在上面的请求截图里，可以看出我是使用strict-origin-when-cross-origin策略，含义是跨域时将当前页面URL过滤掉参数及路径部分，仅将协议、域名和端口（如果有的话）当作 Referrer。否则 Referrer 还是传递当前页的全路径。同时当发生降级（比如从 https:// 跳转到 http:// ）时，不传递 Referrer 报头。 Cache-control什么是cache-controlcache-control，用于控制浏览器缓存。简而言之，当某人访问网站时，其浏览器将在本地保存某些资源，例如图像和网站数据。当该用户重新访问同一网站时，缓存控制设置的规则会确定该用户是否从本地缓存中加载这些资源，或者浏览器是否必须向服务器发送新资源的请求。 什么是浏览器缓存浏览器缓存是指浏览器本地保存网站资源，以便不必再次通过网络从服务器获取它们。例如，“猫猫网”的背景图像可以保存到本地缓存中，这样在用户第二次访问该页面时，该图像将从用户的本地文件加载，剩下网络获取资源的时间，页面加载速度就会更快。 但是浏览器也不会永远把这些网站资源放在本地，否则本地磁盘就会炸，所以会限定保存资源的时间，这叫生存时间（TTL）。如果 TTL 过期后用户请求缓存的资源，浏览器必须再次通过网络与服务器建立连接并重新下载这个资源。 常见的缓存控制策略 cache-control: private具有“private”指令的响应只能由客户端缓存，不能由中间代理（例如 CDN或代理）缓存。这些资源通常是包含私密数据的资源，例如显示用户个人信息的网站。 cache-control: public相反，“public”指令表示资源可以由任何缓存存储。 cache-control: no-store带有“no-store”指令的响应无法缓存到任何位置，也永不缓存。也就是说，用户每次请求此数据时，都必须将请求发送到源站服务器以获取新副本。此指令通常保留给包含极其敏感数据的资源，例如银行帐户信息。 cache-control: max-age此指令指定了生存时间，也就是资源在下载后可以缓存多少秒钟。例如，如果将最大期限设置为 1800，则首次从服务器请求资源后的 1800 秒（30 分钟）内，后续请求都会向用户提供该资源的缓存版本。如果 30 分钟后用户再次请求资源，则客户端需要向服务器重新请求该资源。 cache-control: no-cache 从网页截图里可以看出，使用的缓存控制指令是cache-control: no-cache。它表示，只有先检查资源没有更新版本后，才可使用所请求资源的缓存版本。那么问题来了，怎么判断资源是否有更新版本呢？这就需要 ETag。 ETag Etag是 Entity tag的缩写，是服务端的一个资源版本的令牌标识。在 HTTP 响应头中将其传送到客户端。每当资源更新时，此令牌会更新。 比如，浏览器第一次请求资源的时候，服务端返回了这个资源的ETag: &quot;095933fff2323351d3b495f2f879616f1762f752&quot;。 当浏览器再次请求这个资源的时候，浏览器会将If-None-Match: &quot;095933fff2323351d3b495f2f879616f1762f752&quot; 传输给服务端，服务端拿到该ETAG，对比资源是否发生变化。 如果资源未发生改变，则返回304HTTP状态码，不返回具体的资源。 否则表示资源已经更新，浏览器需要下载新版本以提供给用户。 此过程可确保用户始终获得资源的最新版本，并且无需进行不必要的下载。 最后看个猫片都能学到这么多硬核知识。接下来我打算去舞蹈区看看有没有适合你们的知识点。 我是小白，有空？一起在知识的海洋里呛水啊，懂我意思？ 参考资料- [1] 计算机网络自动向下 - [2] 极客时间-趣谈网络协议 - [3] 极客时间-透视HTTP - [4] 图解HTTP - [5] 漫画形象-小肥柴","categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"}],"tags":[]},{"title":"给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题。","slug":"golang面试题/给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题","date":"2020-11-12T14:57:55.000Z","updated":"2021-10-08T01:34:54.256Z","comments":true,"path":"2020/11/12/golang面试题/给大家丢脸了，用了三年golang，我还是没答对这道内存泄漏题/","link":"","permalink":"https://xiaobaitech.github.io/2020/11/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%BB%99%E5%A4%A7%E5%AE%B6%E4%B8%A2%E8%84%B8%E4%BA%86%EF%BC%8C%E7%94%A8%E4%BA%86%E4%B8%89%E5%B9%B4golang%EF%BC%8C%E6%88%91%E8%BF%98%E6%98%AF%E6%B2%A1%E7%AD%94%E5%AF%B9%E8%BF%99%E9%81%93%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%A2%98/","excerpt":"","text":"问题123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;io/ioutil&quot; &quot;net/http&quot; &quot;runtime&quot;)func main() &#123; num := 6 for index := 0; index &lt; num; index++ &#123; resp, _ := http.Get(&quot;https://www.baidu.com&quot;) _, _ = ioutil.ReadAll(resp.Body) &#125; fmt.Printf(&quot;此时goroutine个数= %d\\n&quot;, runtime.NumGoroutine())&#125; 上面这道题在不执行resp.Body.Close()的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine? 怎么答 不进行resp.Body.Close()，泄漏是一定的。但是泄漏的goroutine个数就让我迷糊了。由于执行了6遍，每次泄漏一个读和写goroutine，就是12个goroutine，加上main函数本身也是一个goroutine，所以答案是13. 然而执行程序，发现答案是3，出入有点大，为什么呢？ 解释 我们直接看源码。golang 的 http 包。 1234567891011121314http.Get()-- DefaultClient.Get----func (c *Client) do(req *Request)------func send(ireq *Request, rt RoundTripper, deadline time.Time)-------- resp, didTimeout, err = send(req, c.transport(), deadline) // 以上代码在 go/1.12.7/libexec/src/net/http/client:174 func (c *Client) transport() RoundTripper &#123; if c.Transport != nil &#123; return c.Transport &#125; return DefaultTransport&#125; 说明 http.Get 默认使用 DefaultTransport 管理连接。DefaultTransport 是干嘛的呢？ 12// It establishes network connections as needed// and caches them for reuse by subsequent calls. DefaultTransport 的作用是根据需要建立网络连接并缓存它们以供后续调用重用。那么 DefaultTransport 什么时候会建立连接呢？接着上面的代码堆栈往下翻 1234567891011func send(ireq *Request, rt RoundTripper, deadline time.Time) --resp, err = rt.RoundTrip(req) // 以上代码在 go/1.12.7/libexec/src/net/http/client:250func (t *Transport) RoundTrip(req *http.Request)func (t *Transport) roundTrip(req *Request)func (t *Transport) getConn(treq *transportRequest, cm connectMethod)func (t *Transport) dialConn(ctx context.Context, cm connectMethod) (*persistConn, error) &#123; ... go pconn.readLoop() // 启动一个读goroutine go pconn.writeLoop() // 启动一个写goroutine return pconn, nil&#125; 一次建立连接，就会启动一个读goroutine和写goroutine。这就是为什么一次http.Get()会泄漏两个goroutine的来源。 泄漏的来源知道了，也知道是因为没有执行close 那为什么不执行 close 会泄漏呢？ 回到刚刚启动的读goroutine 的 readLoop() 代码里 12345678910111213141516171819202122232425262728293031func (pc *persistConn) readLoop() &#123; alive := true for alive &#123; ... // Before looping back to the top of this function and peeking on // the bufio.Reader, wait for the caller goroutine to finish // reading the response body. (or for cancelation or death) select &#123; case bodyEOF := &lt;-waitForBodyRead: pc.t.setReqCanceler(rc.req, nil) // before pc might return to idle pool alive = alive &amp;&amp; bodyEOF &amp;&amp; !pc.sawEOF &amp;&amp; pc.wroteRequest() &amp;&amp; tryPutIdleConn(trace) if bodyEOF &#123; eofc &lt;- struct&#123;&#125;&#123;&#125; &#125; case &lt;-rc.req.Cancel: alive = false pc.t.CancelRequest(rc.req) case &lt;-rc.req.Context().Done(): alive = false pc.t.cancelRequest(rc.req, rc.req.Context().Err()) case &lt;-pc.closech: alive = false &#125; ... &#125;&#125; 简单来说readLoop就是一个死循环，只要alive为true，goroutine就会一直存在 select 里是 goroutine 有可能退出的场景： body 被读取完毕或body关闭 request 主动 cancel request 的 context Done 状态 true 当前的 persistConn 关闭 其中第一个 body 被读取完或关闭这个 case: 12345alive = alive &amp;&amp; bodyEOF &amp;&amp; !pc.sawEOF &amp;&amp; pc.wroteRequest() &amp;&amp; tryPutIdleConn(trace) bodyEOF 来源于到一个通道 waitForBodyRead，这个字段的 true 和 false 直接决定了 alive 变量的值（alive=true那读goroutine继续活着，循环，否则退出goroutine）。 那么这个通道的值是从哪里过来的呢？12345678910111213141516171819202122// go/1.12.7/libexec/src/net/http/transport.go: 1758 body := &amp;bodyEOFSignal&#123; body: resp.Body, earlyCloseFn: func() error &#123; waitForBodyRead &lt;- false &lt;-eofc // will be closed by deferred call at the end of the function return nil &#125;, fn: func(err error) error &#123; isEOF := err == io.EOF waitForBodyRead &lt;- isEOF if isEOF &#123; &lt;-eofc // see comment above eofc declaration &#125; else if err != nil &#123; if cerr := pc.canceled(); cerr != nil &#123; return cerr &#125; &#125; return err &#125;, &#125; 如果执行 earlyCloseFn ，waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出。 如果执行 fn ，其中包括正常情况下 body 读完数据抛出 io.EOF 时的 case，waitForBodyRead 通道输入的是 true，那 alive 会是 true，那么 readLoop() 这个 goroutine 就不会退出，同时还顺便执行了 tryPutIdleConn(trace) 。 123456// tryPutIdleConn adds pconn to the list of idle persistent connections awaiting// a new request.// If pconn is no longer needed or not in a good state, tryPutIdleConn returns// an error explaining why it wasn&#x27;t registered.// tryPutIdleConn does not close pconn. Use putOrCloseIdleConn instead for that.func (t *Transport) tryPutIdleConn(pconn *persistConn) error tryPutIdleConn 将 pconn 添加到等待新请求的空闲持久连接列表中，也就是之前说的连接会复用。 那么问题又来了，什么时候会执行这个 fn 和 earlyCloseFn 呢？12345678910111213func (es *bodyEOFSignal) Close() error &#123; es.mu.Lock() defer es.mu.Unlock() if es.closed &#123; return nil &#125; es.closed = true if es.earlyCloseFn != nil &amp;&amp; es.rerr != io.EOF &#123; return es.earlyCloseFn() // 关闭时执行 earlyCloseFn &#125; err := es.body.Close() return es.condfn(err)&#125; 上面这个其实就是我们比较收悉的 resp.Body.Close() ,在里面会执行 earlyCloseFn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 false，alive 也会是 false，那 readLoop() 这个 goroutine 就会退出，goroutine 不会泄露。 1234567891011121314b, err = ioutil.ReadAll(resp.Body)--func ReadAll(r io.Reader) ----func readAll(r io.Reader, capacity int64) ------func (b *Buffer) ReadFrom(r io.Reader)// go/1.12.7/libexec/src/bytes/buffer.go:207func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) &#123; for &#123; ... m, e := r.Read(b.buf[i:cap(b.buf)]) // 看这里，是body在执行read方法 ... &#125;&#125; 这个read，其实就是 bodyEOFSignal 里的 1234567891011121314151617181920func (es *bodyEOFSignal) Read(p []byte) (n int, err error) &#123; ... n, err = es.body.Read(p) if err != nil &#123; ... // 这里会有一个io.EOF的报错，意思是读完了 err = es.condfn(err) &#125; return&#125;func (es *bodyEOFSignal) condfn(err error) error &#123; if es.fn == nil &#123; return err &#125; err = es.fn(err) // 这了执行了 fn es.fn = nil return err&#125; 上面这个其实就是我们比较收悉的读取 body 里的内容。 ioutil.ReadAll() ,在读完 body 的内容时会执行 fn，也就是此时 readLoop() 里的 waitForBodyRead 通道输入的是 true，alive 也会是 true，那 readLoop() 这个 goroutine 就不会退出，goroutine 会泄露，然后执行 tryPutIdleConn(trace) 把连接放回池子里复用。总结 所以结论呼之欲出了，虽然执行了 6 次循环，而且每次都没有执行 Body.Close() ,就是因为执行了ioutil.ReadAll()把内容都读出来了，连接得以复用，因此只泄漏了一个读goroutine和一个写goroutine，最后加上main goroutine，所以答案就是3个goroutine。 从另外一个角度说，正常情况下我们的代码都会执行 ioutil.ReadAll()，但如果此时忘了 resp.Body.Close()，确实会导致泄漏。但如果你调用的域名一直是同一个的话，那么只会泄漏一个 读goroutine 和一个写goroutine，这就是为什么代码明明不规范但却看不到明显内存泄漏的原因。 那么问题又来了，为什么上面要特意强调是同一个域名呢？改天，回头，以后有空再说吧。 文章推荐： 连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。 昨天那个在for循环里append元素的同事，今天还在么？ golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？ golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？ golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？ golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？ golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？ golang面试题：json包变量不加tag会怎么样？ golang面试题：怎么避免内存逃逸？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。","slug":"golang面试题/连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。","date":"2020-10-12T14:57:55.000Z","updated":"2021-10-08T01:34:57.178Z","comments":true,"path":"2020/10/12/golang面试题/连nil切片和空切片一不一样都不清楚？那BAT面试官只好让你回去等通知了。/","link":"","permalink":"https://xiaobaitech.github.io/2020/10/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%BF%9Enil%E5%88%87%E7%89%87%E5%92%8C%E7%A9%BA%E5%88%87%E7%89%87%E4%B8%80%E4%B8%8D%E4%B8%80%E6%A0%B7%E9%83%BD%E4%B8%8D%E6%B8%85%E6%A5%9A%EF%BC%9F%E9%82%A3BAT%E9%9D%A2%E8%AF%95%E5%AE%98%E5%8F%AA%E5%A5%BD%E8%AE%A9%E4%BD%A0%E5%9B%9E%E5%8E%BB%E7%AD%89%E9%80%9A%E7%9F%A5%E4%BA%86%E3%80%82/","excerpt":"","text":"问题123456789101112131415161718package mainimport ( &quot;fmt&quot; &quot;reflect&quot; &quot;unsafe&quot;)func main() &#123; var s1 []int // nil切片 s2 := make([]int,0) // 空切片 s4 := make([]int,0) // 空切片 fmt.Printf(&quot;s1 pointer:%+v, s2 pointer:%+v, s4 pointer:%+v, \\n&quot;, *(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2)),*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4))) fmt.Printf(&quot;%v\\n&quot;, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s1))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data) fmt.Printf(&quot;%v\\n&quot;, (*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s2))).Data==(*(*reflect.SliceHeader)(unsafe.Pointer(&amp;s4))).Data)&#125; nil切片和空切片指向的地址一样吗？这个代码会输出什么？ 怎么答 nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 123s1 pointer:&#123;Data:0 Len:0 Cap:0&#125;, s2 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, s4 pointer:&#123;Data:824634207952 Len:0 Cap:0&#125;, false //nil切片和空切片指向的数组地址不一样true //两个空切片指向的数组地址是一样的，都是824634207952 解释 之前在前面的文章里提到过切片的数据结构为 12345type SliceHeader struct &#123; Data uintptr //引用数组指针地址 Len int // 切片的目前使用长度 Cap int // 切片的容量&#125; nil切片和空切片最大的区别在于指向的数组引用地址是不一样的。 所有的空切片指向的数组引用地址都是一样的 文章推荐： 昨天那个在for循环里append元素的同事，今天还在么？ 对已经关闭的的 chan 进行读写，会怎么样？为什么？ 对未初始化的的chan进行读写，会怎么样？为什么？ golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？ golang面试题：json包变量不加tag会怎么样？ golang面试题：怎么避免内存逃逸？？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 如果你想每天学习一个知识点，关注我的【公】【众】【号】【小白debug】。","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"昨天那个在for循环里append元素的同事，今天还在么？","slug":"golang面试题/昨天那个在for循环里append元素的同事，今天还在么？","date":"2020-09-12T14:57:55.000Z","updated":"2021-10-08T01:35:02.884Z","comments":true,"path":"2020/09/12/golang面试题/昨天那个在for循环里append元素的同事，今天还在么？/","link":"","permalink":"https://xiaobaitech.github.io/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%98%A8%E5%A4%A9%E9%82%A3%E4%B8%AA%E5%9C%A8for%E5%BE%AA%E7%8E%AF%E9%87%8Cappend%E5%85%83%E7%B4%A0%E7%9A%84%E5%90%8C%E4%BA%8B%EF%BC%8C%E4%BB%8A%E5%A4%A9%E8%BF%98%E5%9C%A8%E4%B9%88%EF%BC%9F/","excerpt":"","text":"问题1234567891011package mainimport &quot;fmt&quot;func main() &#123; s := []int&#123;1,2,3,4,5&#125; for _, v:=range s &#123; s =append(s, v) fmt.Printf(&quot;len(s)=%v\\n&quot;,len(s)) &#125;&#125; 这个代码会造成死循环吗？ 怎么答 不会死循环，for range其实是golang的语法糖，在循环开始前会获取切片的长度 len(切片)，然后再执行len(切片)次数的循环。 解释 for range的源码是123456789// The loop we generate:// for_temp := range// len_temp := len(for_temp)// for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;// value_temp = for_temp[index_temp]// index = index_temp// value = value_temp// original body// &#125; 上面的代码会被编译器认为是 12345678910111213func main() &#123; s := []int&#123;1,2,3,4,5&#125; for_temp := s len_temp := len(for_temp) for index_temp := 0; index_temp &lt; len_temp; index_temp++ &#123; value_temp := for_temp[index_temp] _ = index_temp value := value_temp // 以下是 original body s =append(s, value) fmt.Printf(&quot;len(s)=%v\\n&quot;,len(s)) &#125;&#125; 代码运行输出12345len(s)=6len(s)=7len(s)=8len(s)=9len(s)=10 所以说，那个同事用的是golang吗？ 文章推荐： golang面试官：for select时，如果通道已经关闭会怎么样？如果只有一个case呢？ golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？ golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？ golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？ golang面试题：json包变量不加tag会怎么样？ golang面试题：怎么避免内存逃逸？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 如果你想每天学习一个知识点？","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"怎么避免内存逃逸？","slug":"golang面试题/能说说uintptr和unsafe.Pointer的区别吗","date":"2020-09-12T14:57:55.000Z","updated":"2021-10-08T01:35:00.050Z","comments":true,"path":"2020/09/12/golang面试题/能说说uintptr和unsafe.Pointer的区别吗/","link":"","permalink":"https://xiaobaitech.github.io/2020/09/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%83%BD%E8%AF%B4%E8%AF%B4uintptr%E5%92%8Cunsafe.Pointer%E7%9A%84%E5%8C%BA%E5%88%AB%E5%90%97/","excerpt":"","text":"问题怎么避免内存逃逸？ 怎么答在runtime/stubs.go:133有个函数叫noescape。noescape可以在逃逸分析中隐藏一个指针。让这个指针在逃逸分析中不会被检测为逃逸。 12345678910 // noescape hides a pointer from escape analysis. noescape is // the identity function but escape analysis doesn&#x27;t think the // output depends on the input. noescape is inlined and currently // compiles down to zero instructions. // USE CAREFULLY! //go:nosplit func noescape(p unsafe.Pointer) unsafe.Pointer &#123; x := uintptr(p) return unsafe.Pointer(x ^ 0)&#125; 举例 通过一个例子加深理解，接下来尝试下怎么通过 go build -gcflags=-m 查看逃逸的情况。1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;unsafe&quot;)type A struct &#123; S *string&#125;func (f *A) String() string &#123; return *f.S&#125;type ATrick struct &#123; S unsafe.Pointer&#125;func (f *ATrick) String() string &#123; return *(*string)(f.S)&#125;func NewA(s string) A &#123; return A&#123;S: &amp;s&#125;&#125;func NewATrick(s string) ATrick &#123; return ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;&#125;func noescape(p unsafe.Pointer) unsafe.Pointer &#123; x := uintptr(p) return unsafe.Pointer(x ^ 0)&#125;func main() &#123; s := &quot;hello&quot; f1 := NewA(s) f2 := NewATrick(s) s1 := f1.String() s2 := f2.String() _ = s1 + s2&#125; 执行go build -gcflags=-m main.go 123456789101112131415161718192021222324252627$go build -gcflags=-m main.go# command-line-arguments./main.go:11:6: can inline (*A).String./main.go:19:6: can inline (*ATrick).String./main.go:23:6: can inline NewA./main.go:31:6: can inline noescape./main.go:27:6: can inline NewATrick./main.go:28:29: inlining call to noescape./main.go:36:6: can inline main./main.go:38:14: inlining call to NewA./main.go:39:19: inlining call to NewATrick./main.go:39:19: inlining call to noescape./main.go:40:17: inlining call to (*A).String./main.go:41:17: inlining call to (*ATrick).String/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build763863171/b001/_gomod_.go:6:6: can inline init.0./main.go:11:7: leaking param: f to result ~r0 level=2./main.go:19:7: leaking param: f to result ~r0 level=2./main.go:24:16: &amp;s escapes to heap./main.go:23:13: moved to heap: s./main.go:27:18: NewATrick s does not escape./main.go:28:45: NewATrick &amp;s does not escape./main.go:31:15: noescape p does not escape./main.go:38:14: main &amp;s does not escape./main.go:39:19: main &amp;s does not escape./main.go:40:10: main f1 does not escape./main.go:41:10: main f2 does not escape./main.go:42:9: main s1 + s2 does not escape 其中主要看中间一小段 1234./main.go:24:16: &amp;s escapes to heap //这个是NewA中的，逃逸了./main.go:23:13: moved to heap: s./main.go:27:18: NewATrick s does not escape // NewATrick里的s的却没逃逸./main.go:28:45: NewATrick &amp;s does not escape 解释 上段代码对A和ATrick同样的功能有两种实现：他们包含一个 string ，然后用 String() 方法返回这个字符串。但是从逃逸分析看ATrick 版本没有逃逸。 noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。 内置的 uintptr 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 指针地址 的 int 类型。代码的最后一行返回 unsafe.Pointer 也是一个 int。 noescape() 在 runtime 包中使用 unsafe.Pointer 的地方被大量使用。如果作者清楚被 unsafe.Pointer 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。 面试中秀一秀是可以的，如果在实际项目中如果使用这种unsafe包大概率会被同事打死。不建议使用！ 毕竟包的名字就叫做 unsafe, 而且源码中的注释也写明了 USE CAREFULLY! 。 文章推荐： golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试官：for select时，如果通道已经关闭会怎么样？如果select中只有一个case呢？","slug":"golang面试题/for select时，如果通道已经关闭会怎么样？如果只有一个case呢？","date":"2020-08-11T14:57:55.000Z","updated":"2021-10-08T01:35:05.817Z","comments":true,"path":"2020/08/11/golang面试题/for select时，如果通道已经关闭会怎么样？如果只有一个case呢？/","link":"","permalink":"https://xiaobaitech.github.io/2020/08/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/for%20select%E6%97%B6%EF%BC%8C%E5%A6%82%E6%9E%9C%E9%80%9A%E9%81%93%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AAcase%E5%91%A2%EF%BC%9F/","excerpt":"","text":"问题for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？ 怎么答 for循环select时，如果其中一个case通道已经关闭，则每次都会执行到这个case。 如果select里边只有一个case，而这个case被关闭了，则会出现死循环。 解释1.for循环里被关闭的通道 c通道是一个缓冲为0的通道，在main开始时，启动一个协程对c通道写入10，然后就关闭掉这个通道。 在main中通过 x, ok := &lt;-c 接受通道c里的值，从输出结果里看出，确实从通道里读出了之前塞入通道的10，但是在通道关闭后，这个通道一直能读出内容。 2.怎么样才能不读关闭后通道 x, ok := &lt;-c 返回的值里第一个x是通道内的值，ok是指通道是否关闭，当通道被关闭后，ok则返回false，因此可以根据这个进行操作。读一个已经关闭的通道为什么会出现false，可以看我之前的 对已经关闭的的chan进行读写，会怎么样？为什么？ 。 当返回的ok为false时，执行c = nil 将通道置为nil，相当于读一个未初始化的通道，则会一直阻塞。至于为什么读一个未初始化的通道会出现阻塞，可以看我的另一篇 对未初始化的的chan进行读写，会怎么样？为什么？ 。select中如果任意某个通道有值可读时，它就会被执行，其他被忽略。则select会跳过这个阻塞case，可以解决不断读已关闭通道的问题。 3.如果select里只有一个已经关闭的case，会怎么样？ 可以看出只有一个case的情况下，则会死循环。 那如果像上面一个case那样，把通道置为nil就能解决问题了吗？ 4.select里只有一个已经关闭的case，置为nil，会怎么样？ 第一次读取case能读到通道里的10 第二次读取case能读到通道已经关闭的信息。此时将通道置为nil 第三次读取case时main协程会被阻塞，此时整个进程没有其他活动的协程了，进程deadlock 总结 select中如果任意某个通道有值可读时，它就会被执行，其他被忽略。 如果没有default字句，select将有可能阻塞，直到某个通道有值可以运行，所以select里最好有一个default，否则将有一直阻塞的风险。 文章推荐： golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？ golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？ golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？ golang面试题：json包变量不加tag会怎么样？ golang面试题：怎么避免内存逃逸？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 如果你想每天学习一个知识点？","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？","slug":"golang面试题/golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？","date":"2020-07-11T14:57:55.000Z","updated":"2021-10-08T01:35:09.476Z","comments":true,"path":"2020/07/11/golang面试题/golang 面试题：reflect（反射包）如何获取字段 tag？为什么 json 包不能导出私有变量的 tag？/","link":"","permalink":"https://xiaobaitech.github.io/2020/07/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%20%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Areflect%EF%BC%88%E5%8F%8D%E5%B0%84%E5%8C%85%EF%BC%89%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E5%AD%97%E6%AE%B5%20tag%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%20json%20%E5%8C%85%E4%B8%8D%E8%83%BD%E5%AF%BC%E5%87%BA%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%20tag%EF%BC%9F/","excerpt":"","text":"问题json包里使用的时候，会结构体里的字段边上加tag，有没有什么办法可以获取到这个tag的内容呢？ 举例tag信息可以通过反射（reflect包）内的方法获取，通过一个例子加深理解。 123456789101112131415161718192021222324252627282930package mainimport ( &quot;fmt&quot; &quot;reflect&quot;)type J struct &#123; a string //小写无tag b string `json:&quot;B&quot;` //小写+tag C string //大写无tag D string `json:&quot;DD&quot; otherTag:&quot;good&quot;` //大写+tag&#125;func printTag(stru interface&#123;&#125;) &#123; t := reflect.TypeOf(stru).Elem() for i := 0; i &lt; t.NumField(); i++ &#123; fmt.Printf(&quot;结构体内第%v个字段 %v 对应的json tag是 %v , 还有otherTag？ = %v \\n&quot;, i+1, t.Field(i).Name, t.Field(i).Tag.Get(&quot;json&quot;), t.Field(i).Tag.Get(&quot;otherTag&quot;)) &#125;&#125;func main() &#123; j := J&#123; a: &quot;1&quot;, b: &quot;2&quot;, C: &quot;3&quot;, D: &quot;4&quot;, &#125; printTag(&amp;j)&#125; 输出 1234结构体内第1个字段 a 对应的json tag是 , 还有otherTag？ = 结构体内第2个字段 b 对应的json tag是 B , 还有otherTag？ = 结构体内第3个字段 C 对应的json tag是 , 还有otherTag？ = 结构体内第4个字段 D 对应的json tag是 DD , 还有otherTag？ = good 解释 printTag方法传入的是j的指针。 reflect.TypeOf(stru).Elem()获取指针指向的值对应的结构体内容。 NumField()可以获得该结构体含有几个字段。 遍历结构体内的字段，通过t.Field(i).Tag.Get(&quot;json&quot;)可以获取到tag为json的字段。 如果结构体的字段有多个tag，比如叫otherTag,同样可以通过t.Field(i).Tag.Get(&quot;otherTag&quot;)获得。 再补一句上篇文章 提到json包不能导出私有变量的tag是因为取不到反射信息的说法，但是直接取t.Field(i).Tag.Get(&quot;json&quot;)却可以获取到私有变量的json字段，是为什么呢？ 其实准确的说法是，json包里不能导出私有变量的tag是因为json包里认为私有变量为不可导出的Unexported，所以跳过获取名为json的tag的内容。具体可以看/src/encoding/json/encode.go:1070的代码。 1234567891011121314151617func typeFields(t reflect.Type) []field &#123; // 注释掉其他逻辑... // 遍历结构体内的每个字段 for i := 0; i &lt; f.typ.NumField(); i++ &#123; sf := f.typ.Field(i) isUnexported := sf.PkgPath != &quot;&quot; // 注释掉其他逻辑... if isUnexported &#123; // 如果是不可导出的变量则跳过 continue &#125; // 如果是可导出的变量（public），则获取其json字段 tag := sf.Tag.Get(&quot;json&quot;) // 注释掉其他逻辑... &#125; // 注释掉其他逻辑... &#125;","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？","slug":"golang面试题/golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？","date":"2020-06-11T14:57:55.000Z","updated":"2021-10-08T01:35:14.875Z","comments":true,"path":"2020/06/11/golang面试题/golang面试题：对已经关闭的的chan进行读写，会怎么样？为什么？/","link":"","permalink":"https://xiaobaitech.github.io/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E5%B7%B2%E7%BB%8F%E5%85%B3%E9%97%AD%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"问题对已经关闭的的chan进行读写，会怎么样？为什么？ 怎么答 读已经关闭的chan能一直读到东西，但是读到的内容根据通道内关闭前是否有元素而不同。 如果chan关闭前，buffer内有元素还未读,会正确读到chan内的值，且返回的第二个bool值（是否读成功）为true。 如果chan关闭前，buffer内有元素已经被读完，chan内无值，接下来所有接收的值都会非阻塞直接成功，返回 channel 元素的零值，但是第二个bool值一直为false。 写已经关闭的chan会panic 举例1.写已经关闭的chan 注意这个send on closed channel，待会会提到。 2.读已经关闭的chan 多问一句1.为什么写已经关闭的chan就会panic呢？ 当c.closed != 0则为通道关闭，此时执行写，源码提示直接panic，输出的内容就是上面提到的&quot;send on closed channel&quot;。 2. 为什么读已关闭的chan会一直能读到值？ c.closed != 0 &amp;&amp; c.qcount == 0指通道已经关闭，且缓存为空的情况下（已经读完了之前写到通道里的值） 如果接收值的地址ep不为空 那接收值将获得是一个该类型的零值 typedmemclr 会根据类型清理相应地址的内存 这就解释了上面代码为什么关闭的chan会返回对应类型的零值 文章推荐： 对未初始化的的chan进行读写，会怎么样？为什么？ golang 面试题：​reflect（反射包）如何获取字段 tag​？为什么 json 包不能导出私有变量的 tag？ golang面试题：json包变量不加tag会怎么样？ golang面试题：怎么避免内存逃逸？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 如果你想每天学习一个知识点？","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？","slug":"golang面试题/golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？","date":"2020-06-11T14:57:55.000Z","updated":"2021-10-08T03:21:18.099Z","comments":true,"path":"2020/06/11/golang面试题/golang面试题：对未初始化的的chan进行读写，会怎么样？为什么？/","link":"","permalink":"https://xiaobaitech.github.io/2020/06/11/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AF%B9%E6%9C%AA%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E7%9A%84chan%E8%BF%9B%E8%A1%8C%E8%AF%BB%E5%86%99%EF%BC%8C%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F/","excerpt":"","text":"问题对未初始化的的chan进行读写，会怎么样？为什么？ 怎么答读写未初始化的chan都会阻塞。 举例1.写未初始化的chan123456package main// 写未初始化的chanfunc main() &#123; var c chan int c &lt;- 1&#125; 123456// 输出结果fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan send (nil chan)]:main.main() /Users/admin18/go/src/repos/main.go:6 +0x36 注意这个chan send (nil chan)，待会会提到。 2.写读未初始化的chan12345678package mainimport &quot;fmt&quot;// 读未初始化的chanfunc main() &#123; var c chan int num, ok := &lt;-c fmt.Printf(&quot;读chan的协程结束, num=%v, ok=%v\\n&quot;, num, ok)&#125; 123456// 输出结果fatal error: all goroutines are asleep - deadlock!goroutine 1 [chan receive (nil chan)]:main.main() /Users/admin18/go/src/repos/main.go:6 +0x46 注意这个chan receive (nil chan)，待会也会提到。 多问一句关于chan的面试题非常多，这个是比较常见的其中一个。但多问一句：为什么对未初始化的chan就会阻塞呢？ 1.对于写的情况 123456789101112//在 src/runtime/chan.go中func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool &#123; if c == nil &#123; // 不能阻塞，直接返回 false，表示未发送成功 if !block &#123; return false &#125; gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(&quot;unreachable&quot;) &#125; // 省略其他逻辑&#125; 未初始化的chan此时是等于nil，当它不能阻塞的情况下，直接返回 false，表示写 chan 失败 当chan能阻塞的情况下，则直接阻塞 gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) , 然后调用throw(s string)抛出错误,其中waitReasonChanSendNilChan就是刚刚提到的报错&quot;chan send (nil chan)&quot; 2. 对于读的情况 123456789101112//在 src/runtime/chan.go中func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) &#123; //省略逻辑... if c == nil &#123; if !block &#123; return &#125; gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(&quot;unreachable&quot;) &#125; //省略逻辑...&#125; 未初始化的chan此时是等于nil，当它不能阻塞的情况下，直接返回 false，表示读 chan 失败 当chan能阻塞的情况下，则直接阻塞 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) , 然后调用throw(s string)抛出错误,其中waitReasonChanReceiveNilChan就是刚刚提到的报错&quot;chan receive (nil chan)&quot;","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：json包变量不加tag会怎么样？","slug":"golang面试题/golang面试题：json包变量不加tag会怎么样？","date":"2020-05-18T14:57:55.000Z","updated":"2021-10-08T01:35:36.146Z","comments":true,"path":"2020/05/18/golang面试题/golang面试题：json包变量不加tag会怎么样？/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/18/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9Ajson%E5%8C%85%E5%8F%98%E9%87%8F%E4%B8%8D%E5%8A%A0tag%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F/","excerpt":"","text":"问题json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？ 怎么答 如果变量首字母小写，则为private。无论如何不能转，因为取不到反射信息。 如果变量首字母大写，则为public。 不加tag，可以正常转为json里的字段，json内字段名跟结构体内字段原名一致。 加了tag，从struct转json的时候，json的字段名就是tag里的字段名，原字段名已经没用。 举例通过一个例子加深理解。 12345678910111213141516171819202122package mainimport ( &quot;encoding/json&quot; &quot;fmt&quot;)type J struct &#123; a string //小写无tag b string `json:&quot;B&quot;` //小写+tag C string //大写无tag D string `json:&quot;DD&quot;` //大写+tag&#125;func main() &#123; j := J &#123; a: &quot;1&quot;, b: &quot;2&quot;, C: &quot;3&quot;, D: &quot;4&quot;, &#125; fmt.Printf(&quot;转为json前j结构体的内容 = %+v\\n&quot;, j) jsonInfo, _ := json.Marshal(j) fmt.Printf(&quot;转为json后的内容 = %+v\\n&quot;, string(jsonInfo))&#125; 输出 12转为json前j结构体的内容 = &#123;a:1 b:2 C:3 D:4&#125;转为json后的内容 = &#123;&quot;C&quot;:&quot;3&quot;,&quot;DD&quot;:&quot;4&quot;&#125; 解释 结构体里定义了四个字段，分别对应 小写无tag，小写+tag，大写无tag，大写+tag。 转为json后首字母小写的不管加不加tag都不能转为json里的内容，而大写的加了tag可以取别名，不加tag则json内的字段跟结构体字段原名一致。 文章推荐： golang面试题：怎么避免内存逃逸？？ golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：字符串转成byte数组，会发生内存拷贝吗？","slug":"golang面试题/golang面试题：字符串转成byte数组，会发生内存拷贝吗？","date":"2020-05-17T14:57:55.000Z","updated":"2021-10-08T01:35:33.517Z","comments":true,"path":"2020/05/17/golang面试题/golang面试题：字符串转成byte数组，会发生内存拷贝吗？/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/17/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%88%90byte%E6%95%B0%E7%BB%84%EF%BC%8C%E4%BC%9A%E5%8F%91%E7%94%9F%E5%86%85%E5%AD%98%E6%8B%B7%E8%B4%9D%E5%90%97%EF%BC%9F/","excerpt":"","text":"问题字符串转成byte数组，会发生内存拷贝吗？ 怎么答字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。频繁的内存拷贝操作听起来对性能不大友好。有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？ 代码实现123456789101112131415package mainimport ( &quot;fmt&quot; &quot;reflect&quot; &quot;unsafe&quot;)func main() &#123; a :=&quot;aaa&quot; ssh := *(*reflect.StringHeader)(unsafe.Pointer(&amp;a)) b := *(*[]byte)(unsafe.Pointer(&amp;ssh)) fmt.Printf(&quot;%v&quot;,b)&#125; 解释 StringHeader 是字符串在go的底层结构。 1234type StringHeader struct &#123; Data uintptr Len int&#125; SliceHeader 是切片在go的底层结构。 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 那么如果想要在底层转换二者，只需要把 StringHeader 的地址强转成 SliceHeader 就行。那么go有个很强的包叫 unsafe 。 1.unsafe.Pointer(&amp;a)方法可以得到变量a的地址。 2.(*reflect.StringHeader)(unsafe.Pointer(&amp;a)) 可以把字符串a转成底层结构的形式。 3.(*[]byte)(unsafe.Pointer(&amp;ssh)) 可以把ssh底层结构体转成byte的切片的指针。 4.再通过 *转为指针指向的实际内容。 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：怎么避免内存逃逸？","slug":"golang面试题/golang面试题：怎么避免内存逃逸？","date":"2020-05-16T14:57:55.000Z","updated":"2021-10-08T01:35:30.854Z","comments":true,"path":"2020/05/16/golang面试题/golang面试题：怎么避免内存逃逸？/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/16/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/","excerpt":"","text":"问题怎么避免内存逃逸？ 怎么答在runtime/stubs.go:133有个函数叫noescape。noescape可以在逃逸分析中隐藏一个指针。让这个指针在逃逸分析中不会被检测为逃逸。 12345678910 // noescape hides a pointer from escape analysis. noescape is // the identity function but escape analysis doesn&#x27;t think the // output depends on the input. noescape is inlined and currently // compiles down to zero instructions. // USE CAREFULLY! //go:nosplit func noescape(p unsafe.Pointer) unsafe.Pointer &#123; x := uintptr(p) return unsafe.Pointer(x ^ 0)&#125; 举例 通过一个例子加深理解，接下来尝试下怎么通过 go build -gcflags=-m 查看逃逸的情况。1234567891011121314151617181920212223242526272829303132333435package mainimport ( &quot;unsafe&quot;)type A struct &#123; S *string&#125;func (f *A) String() string &#123; return *f.S&#125;type ATrick struct &#123; S unsafe.Pointer&#125;func (f *ATrick) String() string &#123; return *(*string)(f.S)&#125;func NewA(s string) A &#123; return A&#123;S: &amp;s&#125;&#125;func NewATrick(s string) ATrick &#123; return ATrick&#123;S: noescape(unsafe.Pointer(&amp;s))&#125;&#125;func noescape(p unsafe.Pointer) unsafe.Pointer &#123; x := uintptr(p) return unsafe.Pointer(x ^ 0)&#125;func main() &#123; s := &quot;hello&quot; f1 := NewA(s) f2 := NewATrick(s) s1 := f1.String() s2 := f2.String() _ = s1 + s2&#125; 执行go build -gcflags=-m main.go 123456789101112131415161718192021222324252627$go build -gcflags=-m main.go# command-line-arguments./main.go:11:6: can inline (*A).String./main.go:19:6: can inline (*ATrick).String./main.go:23:6: can inline NewA./main.go:31:6: can inline noescape./main.go:27:6: can inline NewATrick./main.go:28:29: inlining call to noescape./main.go:36:6: can inline main./main.go:38:14: inlining call to NewA./main.go:39:19: inlining call to NewATrick./main.go:39:19: inlining call to noescape./main.go:40:17: inlining call to (*A).String./main.go:41:17: inlining call to (*ATrick).String/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build763863171/b001/_gomod_.go:6:6: can inline init.0./main.go:11:7: leaking param: f to result ~r0 level=2./main.go:19:7: leaking param: f to result ~r0 level=2./main.go:24:16: &amp;s escapes to heap./main.go:23:13: moved to heap: s./main.go:27:18: NewATrick s does not escape./main.go:28:45: NewATrick &amp;s does not escape./main.go:31:15: noescape p does not escape./main.go:38:14: main &amp;s does not escape./main.go:39:19: main &amp;s does not escape./main.go:40:10: main f1 does not escape./main.go:41:10: main f2 does not escape./main.go:42:9: main s1 + s2 does not escape 其中主要看中间一小段 1234./main.go:24:16: &amp;s escapes to heap //这个是NewA中的，逃逸了./main.go:23:13: moved to heap: s./main.go:27:18: NewATrick s does not escape // NewATrick里的s的却没逃逸./main.go:28:45: NewATrick &amp;s does not escape 解释 上段代码对A和ATrick同样的功能有两种实现：他们包含一个 string ，然后用 String() 方法返回这个字符串。但是从逃逸分析看ATrick 版本没有逃逸。 noescape() 函数的作用是遮蔽输入和输出的依赖关系。使编译器不认为 p 会通过 x 逃逸， 因为 uintptr() 产生的引用是编译器无法理解的。 内置的 uintptr 类型是一个真正的指针类型，但是在编译器层面，它只是一个存储一个 指针地址 的 int 类型。代码的最后一行返回 unsafe.Pointer 也是一个 int。 noescape() 在 runtime 包中使用 unsafe.Pointer 的地方被大量使用。如果作者清楚被 unsafe.Pointer 引用的数据肯定不会被逃逸，但编译器却不知道的情况下，这是很有用的。 面试中秀一秀是可以的，如果在实际项目中如果使用这种unsafe包大概率会被同事打死。不建议使用！ 毕竟包的名字就叫做 unsafe, 而且源码中的注释也写明了 USE CAREFULLY! 。 文章推荐： golang面试题：简单聊聊内存逃逸？ golang面试题：字符串转成byte数组，会发生内存拷贝吗？ golang面试题：翻转含有中文、数字、英文字母的字符串 golang面试题：拷贝大切片一定比小切片代价大吗？ golang面试题：能说说uintptr和unsafe.Pointer的区别吗？ 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"拷贝大切片一定比小切片代价大吗？","slug":"golang面试题/golang面试题：拷贝大切片一定比小切片代价大吗？","date":"2020-05-13T14:57:55.000Z","updated":"2021-10-08T01:35:27.881Z","comments":true,"path":"2020/05/13/golang面试题/golang面试题：拷贝大切片一定比小切片代价大吗？/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/13/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E6%8B%B7%E8%B4%9D%E5%A4%A7%E5%88%87%E7%89%87%E4%B8%80%E5%AE%9A%E6%AF%94%E5%B0%8F%E5%88%87%E7%89%87%E4%BB%A3%E4%BB%B7%E5%A4%A7%E5%90%97%EF%BC%9F/","excerpt":"","text":"问题拷贝大切片一定比小切片代价大吗？ 怎么答并不是，所有切片的大小相同；三个字段（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 拷贝大切片跟小切片的代价应该是一样的。 解释 SliceHeader 是切片在go的底层结构。 12345type SliceHeader struct &#123; Data uintptr Len int Cap int&#125; 大切片跟小切片的区别无非就是 Len 和 Cap的值比小切片的这两个值大一些，如果发生拷贝，本质上就是拷贝上面的三个字段。 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：简单聊聊内存逃逸？","slug":"golang面试题/golang面试题：简单聊聊内存逃逸？","date":"2020-05-12T14:57:55.000Z","updated":"2021-10-08T01:35:25.377Z","comments":true,"path":"2020/05/12/golang面试题/golang面试题：简单聊聊内存逃逸？/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/12/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8A%E5%86%85%E5%AD%98%E9%80%83%E9%80%B8%EF%BC%9F/","excerpt":"","text":"问题知道golang的内存逃逸吗？什么情况下会发生内存逃逸？ 怎么答```逃逸``` 了，必须在```堆上分配```。123456789101112131415161718192021222324252627282930 能引起变量逃逸到堆上的**典型情况**：- **在方法内把局部变量指针返回** 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。## 举例- 通过一个例子加深理解，接下来尝试下怎么通过 ```go build -gcflags=-m``` 查看逃逸的情况。```gopackage mainimport &quot;fmt&quot;type A struct &#123; s string&#125;// 这是上面提到的 &quot;在方法内把局部变量指针返回&quot; 的情况func foo(s string) *A &#123; a := new(A) a.s = s return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆&#125;func main() &#123; a := foo(&quot;hello&quot;) b := a.s + &quot; world&quot; c := b + &quot;!&quot; fmt.Println(c)&#125; 执行go build -gcflags=-m main.go 123456789101112131415go build -gcflags=-m main.go# command-line-arguments./main.go:7:6: can inline foo./main.go:13:10: inlining call to foo./main.go:16:13: inlining call to fmt.Println/var/folders/45/qx9lfw2s2zzgvhzg3mtzkwzc0000gn/T/go-build409982591/b001/_gomod_.go:6:6: can inline init.0./main.go:7:10: leaking param: s./main.go:8:10: new(A) escapes to heap./main.go:16:13: io.Writer(os.Stdout) escapes to heap./main.go:16:13: c escapes to heap./main.go:15:9: b + &quot;!&quot; escapes to heap./main.go:13:10: main new(A) does not escape./main.go:14:11: main a.s + &quot; world&quot; does not escape./main.go:16:13: main []interface &#123;&#125; literal does not escape&lt;autogenerated&gt;:1: os.(*File).close .this does not escape ./main.go:8:10: new(A) escapes to heap 说明 new(A) 逃逸了,符合上述提到的常见情况中的第一种。 ./main.go:14:11: main a.s + &quot; world&quot; does not escape 说明 b 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。 ./main.go:15:9: b + &quot;!&quot; escapes to heap 说明 c 变量逃逸，通过fmt.Println(a ...interface&#123;&#125;)打印的变量，都会发生逃逸，感兴趣的朋友可以去查查为什么。 以上操作其实就叫逃逸分析。下篇文章，跟大家聊聊怎么用一个比较trick的方法使变量不逃逸。方便大家在面试官面前秀一波。","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]},{"title":"golang面试题：翻转含有中文、数字、英文字母的字符串","slug":"golang面试题/golang面试题：翻转含有中文、数字、英文字母的字符串","date":"2020-05-10T14:57:55.000Z","updated":"2021-10-08T01:35:20.496Z","comments":true,"path":"2020/05/10/golang面试题/golang面试题：翻转含有中文、数字、英文字母的字符串/","link":"","permalink":"https://xiaobaitech.github.io/2020/05/10/golang%E9%9D%A2%E8%AF%95%E9%A2%98/golang%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E7%BF%BB%E8%BD%AC%E5%90%AB%E6%9C%89%E4%B8%AD%E6%96%87%E3%80%81%E6%95%B0%E5%AD%97%E3%80%81%E8%8B%B1%E6%96%87%E5%AD%97%E6%AF%8D%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"问题翻转含有中文、数字、英文字母的字符串&quot;你好abc啊哈哈&quot; 代码实现1234567891011121314151617package mainimport&quot;fmt&quot;func main() &#123; src := &quot;你好abc啊哈哈&quot; dst := reverse([]rune(src)) fmt.Printf(&quot;%v\\n&quot;, string(dst))&#125;func reverse(s []rune) []rune &#123; for i, j := 0, len(s)-1; i &lt; j; i, j = i+1, j-1 &#123; s[i], s[j] = s[j], s[i] &#125; return s&#125; 解释 rune关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），可表示更多的字符。 由于rune可表示的范围更大，所以能处理一切字符，当然也包括中文字符。在平时计算中文字符，可用rune。 因此将字符串转为rune的切片，再进行翻转，完美解决。 关注公众号:【小白debug】","categories":[{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"}],"tags":[]}],"categories":[{"name":"图解网络","slug":"图解网络","permalink":"https://xiaobaitech.github.io/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/"},{"name":"golang面试题","slug":"golang面试题","permalink":"https://xiaobaitech.github.io/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"name":"骚话连篇","slug":"骚话连篇","permalink":"https://xiaobaitech.github.io/categories/%E9%AA%9A%E8%AF%9D%E8%BF%9E%E7%AF%87/"}],"tags":[]}