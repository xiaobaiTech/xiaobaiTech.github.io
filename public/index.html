<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.xiaobaidebug.top/image/aaaaaaa%E5%A4%B4%E5%83%8F.png">
  <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.xiaobaidebug.top/image/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.xiaobaidebug.top/image/favicon.png">
  <link rel="mask-icon" href="https://cdn.xiaobaidebug.top/image/aaaaaaa%E5%A4%B4%E5%83%8F.png" color="#222">
  <meta name="google-site-verification" content="vn6zFIUUArCZNOGOlwdwIPa1V8_eawg4XBwixAWh-k8">
  <meta name="baidu-site-verification" content="code-HiXZw7ueDb">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xiaobaidebug.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="有时骚话连篇，有时硬核图解">
<meta property="og:type" content="website">
<meta property="og:title" content="小白debug">
<meta property="og:url" content="https://xiaobaidebug.top/index.html">
<meta property="og:site_name" content="小白debug">
<meta property="og:description" content="有时骚话连篇，有时硬核图解">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xiaobaidebug.top/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>小白debug</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?072e633280c5372714c0cf8e873ca480";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小白debug</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一起在知识的海洋里呛水</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/xiaobaiTech" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/10/17/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/17/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/UDP%E5%B0%B1%E4%B8%80%E5%AE%9A%E6%AF%94TCP%E5%BF%AB%E5%90%97/" class="post-title-link" itemprop="url">动图图解 | UDP就一定比TCP快吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-10-17 22:57:55" itemprop="dateCreated datePublished" datetime="2022-10-17T22:57:55+08:00">2022-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:50:27" itemprop="dateModified" datetime="2022-10-30T10:50:27+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<p>话说，<strong>UDP比TCP快吗？</strong></p>
<p>相信就算不是八股文老手，也会下意识的脱口而出：”<strong>是</strong>“。</p>
<p>这要追问为什么，估计大家也能说出个大概。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663680963848.png"></p>
<p>但这也让人好奇，<strong>用UDP就一定比用TCP快吗？什么情况下用UDP会比用TCP慢？</strong></p>
<p>我们今天就来聊下这个话题。</p>
<br>

<h3 id="使用socket进行数据传输"><a href="#使用socket进行数据传输" class="headerlink" title="使用socket进行数据传输"></a>使用socket进行数据传输</h3><p>作为一个程序员，假设我们需要在A电脑的进程发一段数据到B电脑的进程，我们一般会在代码里使用socket进行编程。</p>
<p>socket就像是一个<strong>电话或者邮箱</strong>（邮政的信箱）。当你想要发送消息的时候，拨通电话或者将信息塞到邮箱里，socket内核会自动完成将数据传给对方的这个过程。</p>
<p>基于socket我们可以选择使用TCP或UDP协议进行通信。</p>
<p>对于TCP这样的可靠性协议，每次消息发出后都能明确知道对方收没收到，就<strong>像打电话一样</strong>，只要”喂喂”两下就能知道对方有没有在听。</p>
<p>而UDP就像是<strong>给邮政的信箱寄信一样</strong>，你寄出去的信，根本就不知道对方有没有正常收到，丢了也是有可能的。</p>
<blockquote>
<p>这让我想起了大概17年前，当时还没有现在这么发达的网购，想买一本《掌机迷》杂志，还得往信封里塞钱，然后一等就是一个月，好几次都怀疑信是不是丢了。我至今印象深刻，因为那是我和我哥攒了好久的钱。。。</p>
</blockquote>
<br>

<p>回到socket编程的话题上。</p>
<p>创建socket的方式就像下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET, 具体协议,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>注意上面的”<strong>具体协议</strong>“，如果传入的是<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP协议</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p>
<p>如果传入的是<code>SOCK_DGRAM</code>，是指使用<strong>数据报</strong>传输数据，也就是<strong>UDP协议</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663557075676.png" alt="UDP是什么"></p>
<p>返回的<code>fd</code>是指socket句柄，可以理解为socket的<strong>身份证号</strong>。通过这个<code>fd</code>你可以在内核中找到<strong>唯一</strong>的socket结构。</p>
<p>如果想要通过这个socket发消息，只需要操作这个fd就行了，比如执行 <code>send(fd, msg, ...)</code>，内核就会通过这个fd句柄找到socket然后进行发数据的操作。</p>
<p><strong>如果一切顺利</strong>，此时对方执行接收消息的操作，也就是 <code>recv(fd, msg, ...)</code>，就能拿到你发的消息。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663602070263.gif" alt="udp发送接收过程"></p>
<h3 id="对于异常情况的处理"><a href="#对于异常情况的处理" class="headerlink" title="对于异常情况的处理"></a>对于异常情况的处理</h3><p><strong>但如果不顺利呢？</strong></p>
<p>比如消息发到一半，丢包了呢?</p>
<blockquote>
<p>丢包的原因有很多，之前写过的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7126710506936598558">《用了TCP协议，就一定不会丢包吗？》</a>有详细聊到过，这里就不再展开。</p>
</blockquote>
<p>那UDP和TCP的态度就不太一样了。</p>
<br>

<p>UDP表示，”哦，是吗？然后呢？关我x事”</p>
<p>TCP态度就截然相反了，”啊？那可不行，是不是我发太快了呢？是不是链路太堵被别人影响到了呢？不过你放心，我肯定给你补发”</p>
<p>TCP老实人石锤了。我们来看下这个老实人在背后都默默做了哪些事情。</p>
<h4 id="重传机制"><a href="#重传机制" class="headerlink" title="重传机制"></a>重传机制</h4><p>对于TCP，它会给发出的消息打上一个<strong>编号（sequence）</strong>，接收方收到后回一个**确认(ack)**。发送方可以通过<code>ack</code>的数值知道接收方收到了哪些<code>sequence</code>的包。</p>
<p>如果长时间等不到对方的确认，TCP就会重新发一次消息，这就是所谓的<strong>重传机制</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663597929404.png" alt="TCP重传"></p>
<br>

<h4 id="流量控制机制"><a href="#流量控制机制" class="headerlink" title="流量控制机制"></a>流量控制机制</h4><p>但重传这件事本身对性能影响是比较严重的，所以是<strong>下下策</strong>。</p>
<p>于是TCP就需要思考有没有办法可以尽量<strong>避免重传</strong>。</p>
<p>因为数据发送方和接收方处理数据能力可能不同，因此如果可以根据双方的能力去调整发送的数据量就好了，于是就有了<strong>发送和接收窗口</strong>，基本上从名字就能看出它的作用，比如<strong>接收窗口的大小</strong>就是指，接收方当前<strong>能接收的数据量大小</strong>，<strong>发送窗口的大小</strong>就指发送方当前能发的数据量大小。TCP根据窗口的大小去控制自己发送的数据量，这样就能大大减少丢包的概率。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663597968469.png" alt="流量控制机制"></p>
<br>

<h4 id="滑动窗口机制"><a href="#滑动窗口机制" class="headerlink" title="滑动窗口机制"></a>滑动窗口机制</h4><p>接收方的接收到数据之后，会不断处理，<strong>处理能力也不是一成不变的</strong>，有时候处理的快些，那就可以收多点数据，处理的慢点那就希望对方能少发点数据。毕竟发多了就有可能处理不过来导致丢包，丢包会导致重传，这可是下下策。因此我们需要动态的去调节这个接收窗口的大小，于是就有了<strong>滑动窗口机制</strong>。</p>
<p>看到这里大家可能就有点迷了，<strong>流量控制和滑动窗口机制貌似很像，它们之间是啥关系？</strong>我总结一下。其实现在TCP是<strong>通过滑动窗口机制来实现流量控制机制的</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663597995829.png" alt="滑动窗口机制"></p>
<br>

<h4 id="拥塞控制机制"><a href="#拥塞控制机制" class="headerlink" title="拥塞控制机制"></a>拥塞控制机制</h4><p>但这还不够，有时候发生丢包，<strong>并不是因为发送方和接收方的处理能力问题导致的</strong>。而是跟<strong>网络环境</strong>有关，大家可以将网络想象为一条公路。马路上可能堵满了别人家的车，只留下一辆车的空间。那就算你家有5辆车，目的地也正好有5个停车位，你也没办法同时全部一起上路。于是TCP希望能感知到外部的网络环境，根据网络环境及时调整自己的发包数量，比如马路只够两辆车跑，那我就只发两辆车。但外部环境这么复杂，TCP是怎么感知到的呢？</p>
<p>TCP会先慢慢试探的发数据，不断加码数据量，越发越多，先发一个，再发2个，4个…。直到出现丢包，这样TCP就知道现在当前网络大概吃得消几个包了，这既是所谓的<strong>拥塞控制机制</strong>。</p>
<p>不少人会疑惑流量控制和拥塞控制的关系。我这里小小的总结下。<strong>流量控制</strong>针对的是<strong>单个连接</strong>数据处理能力的控制，<strong>拥塞控制</strong>针对的是<strong>整个网络环境</strong>数据处理能力的控制。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663598420295.png" alt="1663598420295"></p>
<br>

<h4 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h4><p>但上面提到的都是怎么<strong>降低</strong>重传的概率，似乎重传这个事情就是无法避免的，<strong>那如果确实发生了，有没有办法降低它带来的影响呢？</strong></p>
<p>有。当我们需要发送一个超大的数据包时，如果这个数据包丢了，那就得重传同样大的数据包。但如果我能将其分成一小段一小段，那就算真丢了，那我也就只需要重传那一小段就好了，大大减小了重传的压力，这就是TCP的<strong>分段机制</strong>。</p>
<p>而这个所谓的一小段的长度，在传输层叫<strong>MSS</strong>（<strong>Maximum Segment Size</strong>），数据包长度大于MSS则会分成N个小于等于MSS的包。</p>
<p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%88%86%E5%8C%85.gif" alt="MSS分包"></p>
<p>而在网络层，如果数据包还大于<strong>MTU（Maximum Transmit Unit）</strong>，那还会继续分包。</p>
<p><img src="https://cdn.xiaobaidebug.top/image/mtu%E5%88%86%E5%8C%85.gif" alt="MTU分包"></p>
<p>一般情况下，<code>MSS=MTU-40Byte</code>，所以<strong>TCP分段后，到了IP层大概率就不会再分片了</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/image/MSS%E5%92%8CMTU%E7%9A%84%E5%8C%BA%E5%88%AB2.png" alt="MSS和MTU的区别"></p>
<br>

<h4 id="乱序重排机制"><a href="#乱序重排机制" class="headerlink" title="乱序重排机制"></a>乱序重排机制</h4><p>既然数据包会被分段，链路又这么复杂还会丢包，那数据包乱序也就显得不奇怪了。比如发数据包1,2,3。1号数据包走了其他网络路径，2和3数据包先到，1数据包后到，于是数据包顺序就成了2,3,1。这一点TCP也考虑到了，依靠数据包的<code>sequence</code>，接收方就能知道数据包的先后顺序。</p>
<p>后发的数据包先到是吧，那就先放到专门的<strong>乱序队列</strong>中，等数据都到齐后，重新整理好乱序队列的数据包顺序后再给到用户，这就是<strong>乱序重排机制</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5.drawio.png" alt="乱序队列等待数据包的到来"></p>
<br>

<h4 id="连接机制"><a href="#连接机制" class="headerlink" title="连接机制"></a>连接机制</h4><p>前面提到，UDP是无连接的，而TCP是面向连接的。</p>
<p>这里提到的<strong>连接</strong>到底是啥？</p>
<p>TCP通过上面提到的各种机制实现了数据的可靠性。这些机制背后是通过一个个数据结构来实现的逻辑。而为了实现这套逻辑，操作系统内核需要在两端代码里维护一套复杂的状态机（三次握手，四次挥手，RST，closing等异常处理机制），<strong>这套状态机其实就是所谓的”连接”<strong>。这其实就是TCP的</strong>连接机制</strong>，而UDP用不上这套状态机，因此它是”无连接”的。</p>
<br>

<p>网络环境链路很长，还复杂，数据丢包是很常见的。</p>
<p>我们平常用TCP做各种数据传输，完全对这些事情无感知。</p>
<p><strong>哪有什么岁月静好，是TCP替你负重前行。</strong></p>
<p>这就是TCP三大特性”面向连接、可靠的、基于字节流”中”<strong>可靠</strong>“的含义。</p>
<p>不信你改用UDP试试，丢包那就是真丢了，丢到你怀疑人生。</p>
<br>

<h3 id="用UDP就一定比用TCP快吗？"><a href="#用UDP就一定比用TCP快吗？" class="headerlink" title="用UDP就一定比用TCP快吗？"></a>用UDP就一定比用TCP快吗？</h3><p>这时候UDP就不服了：”<strong>正因为没有这些复杂的TCP可靠性机制，所以我很快啊</strong>“</p>
<p>嗯，这也是大部分人认为UDP比TCP快的原因。</p>
<p><strong>实际上大部分情况下也确实是这样的。这话没毛病。</strong></p>
<br>

<p>那问题就来了。</p>
<p><strong>有没有用了UDP但却比TCP慢的情况呢？</strong></p>
<p>其实也有。</p>
<p>在回答这个问题前，我需要先说下<strong>UDP的用途</strong>。</p>
<p>实际上，<strong>大部分</strong>人也不会尝试<strong>直接拿裸udp</strong>放到生产环境中去做项目。</p>
<p>那UDP的价值在哪？</p>
<p>在我看来，UDP的存在，本质是内核提供的一个<strong>最小网络传输功能</strong>。</p>
<p>很多时候，大家虽然号称自己用了UDP，但实际上都很<strong>忌惮</strong>它的丢包问题，所以大部分情况下都会在UDP的基础上做各种不同程度的<strong>应用层</strong>可靠性保证。比如王者农药用的<code>KCP</code>，以及最近很火的<code>QUIC（HTTP3.0）</code>，其实都<strong>在UDP的基础上做了重传逻辑</strong>，实现了一套<strong>类似</strong>TCP那样的可靠性机制。</p>
<p>教科书上最爱提UDP适合用于<strong>音视频传输</strong>，因为这些场景允许丢包。但其实也不是什么包都能丢的，比如重要的关键帧啥的，该重传还得重传。除此之外，还有一些<strong>乱序处理机制</strong>。举个例子吧。</p>
<p>打音视频电话的时候，你可能遇到过丢失中间某部分信息的情况，但应该从来没遇到过乱序的情况吧。</p>
<p>比如对方打网络电话给你，说了：”<strong>我好想给小白来个点赞在看！</strong>“</p>
<p>这时候网络信号不好，你可能会听到”我….点赞在看”。</p>
<p>但却从来没遇到过”在看小白好想赞”这样的<strong>乱序</strong>场景吧？</p>
<p>所以说，<strong>虽然选择了使用UDP，但一般还是会在应用层上做一些重传机制的</strong>。</p>
<p>于是问题就来了，<strong>如果现在我需要传一个特别大的数据包</strong>。</p>
<p>在<code>TCP</code>里，它内部会根据<code>MSS</code>的大小<strong>分段</strong>，这时候进入到IP层之后，每个包大小都不会超过<code>MTU</code>，因此IP层一般不会再进行分片。这时候发生丢包了，只需要<strong>重传每个MSS分段</strong>就够了。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663602192374.gif" alt="TCP分段"></p>
<p>但对于<code>UDP</code>，其本身并不会分段，如果数据过大，到了IP层，就会进行分片。此时发生丢包的话，再次重传，就会<strong>重传整个大数据包</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663602173391.gif" alt="UDP不分段"></p>
<p>对于上面这种情况，<strong>使用UDP就比TCP要慢</strong>。</p>
<p>当然，解决起来也不复杂。这里的关键点在于是否实现了数据分段机制，<strong>使用UDP的应用层如果也实现了分段机制的话，那就不会出现上述的问题了</strong>。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>TCP为了实现可靠性，引入了重传机制、流量控制、滑动窗口、拥塞控制、分段以及乱序重排机制。而UDP则没有实现，因此一般来说TCP比UDP慢。</li>
<li>TCP是面向连接的协议，而UDP是无连接的协议。这里的”<strong>连接</strong>“其实是，操作系统内核在两端代码里维护的一套复杂状态机。</li>
<li>大部分项目，会在基于UDP的基础上，模仿TCP，实现不同程度的可靠性机制。比如王者农药用的KCP其实就在基于UDP在应用层里实现了一套<strong>重传</strong>机制。</li>
<li>对于UDP+重传的场景，如果要传<strong>超大数据包</strong>，并且没有实现<strong>分段机制</strong>的话，那数据就会在IP层分片，一旦丢包，那就需要重传整个超大数据包。而TCP则不需要考虑这个，内部会自动分段，丢包重传分段就行了。这种场景下，其实TCP更快。</li>
</ul>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p>
<p>我有个不成熟的请求。</p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" />

<br>

<p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p>
<p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p>
<p>我这么善良质朴的愿望，能被满足吗？</p>
<p>如果实在叫不出口的话，能帮我<strong>点下关注</strong>和右下角的<strong>点赞+收藏</strong>吗？</p>
<p>如果评论区没人叫我靓仔，文章也没人点赞，我感觉我下篇文章要开始收费了，价钱我都想好了，8块8，毕竟男人都拒绝不了这种价格以8结尾的项目。</p>
<p>你说是吧，易峰。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/09/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E8%BF%98%E8%A6%81%E6%9C%89websocket%E5%8D%8F%E8%AE%AE/" class="post-title-link" itemprop="url">为什么有HTTP协议，还要有websocket协议</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-09-18 22:57:55" itemprop="dateCreated datePublished" datetime="2022-09-18T22:57:55+08:00">2022-09-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:50:19" itemprop="dateModified" datetime="2022-10-30T10:50:19+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<br>

<p>平时我们打开网页，比如购物网站某宝。都是点一下<strong>列表商品</strong>，跳转一下网页就到了<strong>商品详情</strong>。</p>
<p>从HTTP协议的角度来看，就是点一下网页上的某个按钮，<strong>前端发一次HTTP请求，网站返回一次HTTP响应</strong>。</p>
<p>这种由客户端主动请求，服务器响应的方式也满足大部分网页的功能场景。</p>
<p>但有没有发现，这种情况下，服务器从来就不会<strong>主动</strong>给客户端发一次消息。</p>
<p>就像你喜欢的女生从来不会主动找你一样。</p>
<br>

<p>但如果现在，你在刷网页的时候<strong>右下角</strong>突然弹出一个<strong>小广告</strong>，提示你【<strong>一个人在家偷偷才能玩哦</strong>】。</p>
<p><strong>求知，好学，勤奋</strong>，这些刻在你DNA里的东西都动起来了。</p>
<p>你点开后发现。</p>
<p>长相平平无奇的古某提示你”道士9条狗，全服横着走”。</p>
<p>影帝某辉老师跟你说”系兄弟就来砍我”。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220827161615614.png"></p>
<p>来都来了，你就选了个角色进到了游戏界面里。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%88%9B%E5%BB%BA%E8%A7%92%E8%89%B2%E9%A1%B5%E9%9D%A2.jpeg" alt="创建角色页面"></p>
<p>这时候，上来就是一个小怪，从远处走来，然后疯狂拿木棒子抽你。</p>
<p><strong>你全程没点任何一次鼠标</strong>。服务器就自动将怪物的移动数据和攻击数据源源不断发给你了。</p>
<p>这….太暖心了。</p>
<p>感动之余，问题就来了，</p>
<p>像这种<strong>看起来服务器主动发消息给客户端的场景</strong>，是怎么做到的？</p>
<p>在真正回答这个问题之前，我们先来聊下一些相关的知识背景。</p>
<br>

<h3 id="使用HTTP不断轮询"><a href="#使用HTTP不断轮询" class="headerlink" title="使用HTTP不断轮询"></a>使用HTTP不断轮询</h3><p>其实问题的痛点在于，<strong>怎么样才能在用户不做任何操作的情况下，网页能收到消息并发生变更。</strong></p>
<p>最常见的解决方案是，<strong>网页的前端代码里不断定时发HTTP请求到服务器，服务器收到请求后给客户端响应消息。</strong></p>
<p>这其实时一种<strong>伪</strong>服务器推的形式。</p>
<p>它其实并不是服务器主动发消息到客户端，而是客户端自己不断偷偷请求服务器，只是用户无感知而已。</p>
<p>用这种方式的场景也有很多，最常见的就是<strong>扫码登录</strong>。</p>
<p>比如某信公众号平台，登录页面二维码出现之后，<strong>前端</strong>网页根本不知道用户扫没扫，于是不断去向<strong>后端</strong>服务器询问，看有没有人扫过这个码。而且是以大概1到2秒的间隔去不断发出请求，这样可以保证用户在扫码后能在1到2s内得到及时的反馈，不至于<strong>等太久</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%BD%BF%E7%94%A8HTTP%E5%AE%9A%E6%97%B6%E8%BD%AE%E8%AF%A23.drawio.png" alt="使用HTTP定时轮询"></p>
<p>但这样，会有两个比较明显的问题</p>
<ul>
<li>当你打开F12页面时，你会发现满屏的HTTP请求。虽然很小，但这其实也消耗带宽，同时也会增加下游服务器的负担。</li>
<li>最坏情况下，用户在扫码后，需要等个1~2s，正好才触发下一次http请求，然后才跳转页面，用户会感到<strong>明显的卡顿</strong>。</li>
</ul>
<p>使用起来的体验就是，二维码出现后，手机扫一扫，然后在手机上点个确认，这时候<strong>卡顿等个1~2s</strong>，页面才跳转。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220824090204629.png" alt="不断轮询查看是否有扫码"></p>
<p>那么问题又来了，<strong>有没有更好的解决方案？</strong></p>
<p>有，而且实现起来成本还非常低。</p>
<br>

<h3 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h3><p>我们知道，HTTP请求发出后，一般会给服务器留一定的时间做响应，比如3s，规定时间内没返回，就认为是超时。</p>
<p>如果我们的HTTP请求<strong>将超时设置的很大</strong>，比如30s，<strong>在这30s内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。</strong></p>
<p>这样就减少了HTTP请求的个数，并且由于大部分情况下，用户都会在某个30s的区间内做扫码操作，所以响应也是及时的。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E9%95%BF%E8%BD%AE%E8%AF%A2.drawio.png" alt="长轮询"></p>
<p>比如，某度云网盘就是这么干的。所以你会发现一扫码，手机上点个确认，电脑端网页就<strong>秒跳转</strong>，体验很好。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220824085627057.png" alt="长轮询的方式来替代"></p>
<p>真一举两得。</p>
<p>像这种发起一个请求，在较长时间内等待服务器响应的机制，就是所谓的<strong>长轮询机制</strong>。我们常用的消息队列RocketMQ中，消费者去取数据时，也用到了这种方式。</p>
<p><img src="https://cdn.xiaobaidebug.top/RocketMQ%E7%9A%84%E6%B6%88%E8%B4%B9%E8%80%85%E9%80%9A%E8%BF%87%E9%95%BF%E8%BD%AE%E8%AF%A2%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE.drawio.png" alt="RocketMQ的消费者通过长轮询获取数据"></p>
<p>像这种，在用户不感知的情况下，服务器将数据推送给浏览器的技术，就是所谓的<strong>服务器推送</strong>技术，它还有个毫不沾边的英文名，<strong>comet</strong>技术，大家听过就好。</p>
<br>

<p>上面提到的两种解决方案，本质上，其实还是客户端主动去取数据。</p>
<p>对于像扫码登录这样的<strong>简单场景</strong>还能用用。</p>
<p>但如果是网页游戏呢，游戏一般会有大量的数据需要从服务器主动推送到客户端。</p>
<p>这就得说下<strong>websocket</strong>了。</p>
<br>

<h3 id="websocket是什么"><a href="#websocket是什么" class="headerlink" title="websocket是什么"></a>websocket是什么</h3><p>我们知道TCP连接的两端，<strong>同一时间里</strong>，<strong>双方</strong>都可以<strong>主动</strong>向对方发送数据。这就是所谓的<strong>全双工</strong>。</p>
<p>而现在使用最广泛的<code>HTTP1.1</code>，也是基于TCP协议的，<strong>同一时间里</strong>，客户端和服务器<strong>只能有一方主动</strong>发数据，这就是所谓的<strong>半双工</strong>。</p>
<p>也就是说，好好的全双工TCP，被HTTP用成了半双工。</p>
<p>为什么？</p>
<p>这是由于HTTP协议设计之初，考虑的是看看网页文本的场景，能做到<strong>客户端发起请求再由服务器响应</strong>，就够了，根本就没考虑网页游戏这种，客户端和服务器之间都要互相主动发大量数据的场景。</p>
<p>所以为了更好的支持这样的场景，我们需要另外一个<strong>基于TCP的新协议</strong>。</p>
<p>于是新的应用层协议<strong>websocket</strong>就被设计出来了。</p>
<p>大家别被这个名字给带偏了。虽然名字带了个socket，但其实socket和websocket之间，就跟雷峰和雷峰塔一样，二者接近<strong>毫无关系</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/websocket%E5%9C%A8%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE.drawio.png" alt="websocket在四层网络协议中的位置"></p>
<br>

<h3 id="怎么建立websocket连接"><a href="#怎么建立websocket连接" class="headerlink" title="怎么建立websocket连接"></a>怎么建立websocket连接</h3><p>我们平时刷网页，一般都是在浏览器上刷的，一会刷刷图文，这时候用的是<strong>HTTP协议</strong>，一会打开网页游戏，这时候就得切换成我们新介绍的<strong>websocket协议</strong>。</p>
<p>为了兼容这些使用场景。浏览器在<strong>TCP三次握手</strong>建立连接之后，都<strong>统一使用HTTP协议</strong>先进行一次通信。</p>
<ul>
<li>如果此时是<strong>普通的HTTP请求</strong>，那后续双方就还是老样子继续用普通HTTP协议进行交互，这点没啥疑问。</li>
<li>如果这时候是<strong>想建立websocket连接</strong>，就会在HTTP请求里带上一些<strong>特殊的header头</strong>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection: Upgrade</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n</span><br></pre></td></tr></table></figure>

<p>这些header头的意思是，浏览器想<strong>升级协议（Connection: Upgrade）</strong>，并且<strong>想升级成websocket协议（Upgrade: websocket）</strong>。</p>
<p>同时带上一段<strong>随机生成的base64码（Sec-WebSocket-Key）</strong>，发给服务器。</p>
<p>如果服务器正好支持升级成websocket协议。就会走websocket握手流程，同时根据客户端生成的base64码，用某个<strong>公开的</strong>算法变成另一段字符串，放在HTTP响应的 <code>Sec-WebSocket-Accept</code> 头里，同时带上<code>101状态码</code>，发回给浏览器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 101 Switching Protocols\r\n</span><br><span class="line">Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n</span><br><span class="line">Upgrade: websocket\r\n</span><br><span class="line">Connection: Upgrade\r\n</span><br></pre></td></tr></table></figure>

<blockquote>
<p>http状态码=200（正常响应）的情况，大家见得多了。101确实不常见，它其实是指<strong>协议切换</strong>。</p>
</blockquote>
<p><img src="https://cdn.xiaobaidebug.top/base64%E8%BD%AC%E4%B8%BA%E6%96%B0%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.drawio.png" alt="base64转为新的字符串"></p>
<p>之后，浏览器也用同样的<strong>公开算法</strong>将<code>base64码</code>转成另一段字符串，如果这段字符串跟服务器传回来的<strong>字符串一致</strong>，那验证通过。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%AF%B9%E6%AF%94%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%94%9F%E6%88%90%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2.drawio.png" alt="对比客户端和服务端生成的字符串"></p>
<p>就这样经历了一来一回两次HTTP握手，websocket就建立完成了，后续双方就可以使用webscoket的数据格式进行通信了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%BB%BA%E7%AB%8Bwebsocket%E8%BF%9E%E6%8E%A5.drawio.png" alt="建立websocket连接.drawio"></p>
<br>

<h3 id="websocket抓包"><a href="#websocket抓包" class="headerlink" title="websocket抓包"></a>websocket抓包</h3><p>我们可以用wireshark抓个包，实际看下数据包的情况。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220825222212533.png" alt="客户端请求升级为websocket"></p>
<p>上面这张图，注意画了红框的第<code>2445</code>行报文，是websocket的<strong>第一次握手</strong>，意思是发起了一次带有<code>特殊Header</code>的HTTP请求。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%9C%AA%E5%91%BD%E5%90%8D%E7%BB%98%E5%9B%BEddddd.drawio.png" alt="服务器同意升级为websocket协议"></p>
<p>上面这个图里画了红框的<code>4714</code>行报文，就是服务器在得到第一次握手后，响应的<strong>第二次握手</strong>，可以看到这也是个HTTP类型的报文，返回的状态码是101。同时可以看到返回的报文header中也带有各种<code>websocket</code>相关的信息，比如<code>Sec-WebSocket-Accept</code>。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220825222810052.png" alt="两次HTTP请求之后正式使用websocket通信"></p>
<p>上面这张图就是全貌了，从截图上的注释可以看出，websocket和HTTP一样都是基于TCP的协议。经历了三次TCP握手之后，利用HTTP协议升级为websocket协议。</p>
<p>你在网上可能会看到一种说法：”websocket是基于HTTP的新协议”，<strong>其实这并不对</strong>，因为websocket只有在建立连接时才用到了HTTP，<strong>升级完成之后就跟HTTP没有任何关系了</strong>。</p>
<p>这就好像你喜欢的女生通过你要到了你大学室友的微信，然后他们自己就聊起来了。你能说这个女生是通过你去跟你室友沟通的吗？不能。你跟HTTP一样，都只是个<strong>工具人</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/1663378093150.png"></p>
<p>这就有点”<strong>借壳生蛋</strong>“的那意思。</p>
<p><img src="https://cdn.xiaobaidebug.top/HTTP%E5%92%8Cwebsocket%E7%9A%84%E5%85%B3%E7%B3%BB.drawio.png" alt="HTTP和websocket的关系"></p>
<br>

<h3 id="websocket的消息格式"><a href="#websocket的消息格式" class="headerlink" title="websocket的消息格式"></a>websocket的消息格式</h3><p>上面提到在完成协议升级之后，两端就会用webscoket的数据格式进行通信。</p>
<p>数据包在websocket中被叫做<strong>帧</strong>。</p>
<p>我们来看下它的数据格式长什么样子。</p>
<p><img src="https://cdn.xiaobaidebug.top/websocket%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F2.drawio.png" alt="websocket报文格式"></p>
<p>这里面字段很多，但我们只需要关注下面这几个。</p>
<p><strong>opcode字段</strong>：这个是用来标志这是个<strong>什么类型</strong>的数据帧。比如。</p>
<ul>
<li>等于1时是指text类型（<code>string</code>）的数据包</li>
<li>等于2是二进制数据类型（<code>[]byte</code>）的数据包</li>
<li>等于8是关闭连接的信号</li>
</ul>
<p><strong>payload字段</strong>：存放的是我们<strong>真正想要传输的数据的长度</strong>，单位是<strong>字节</strong>。比如你要发送的数据是<code>字符串&quot;111&quot;</code>，那它的长度就是<code>3</code>。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220826101644204.png"></p>
<p>另外，可以看到，我们存放<strong>payload长度的字段有好几个</strong>，我们既可以用最前面的<code>7bit</code>, 也可以用后面的<code>7+16bit或7+64bit。</code></p>
<p>那么问题就来了。</p>
<p>我们知道，在数据层面，大家都是01二进制流。我怎么知道<strong>什么情况下应该读7bit，什么情况下应该读7+16bit呢？</strong></p>
<p>websocket会用最开始的7bit做标志位。不管接下来的数据有多大，都<strong>先读最先的7个bit</strong>，根据它的取值决定还要不要再读个16bit或64bit。</p>
<ul>
<li>如果<code>最开始的7bit</code>的值是 0~125，那么它就表示了 <strong>payload 全部长度</strong>，只读最开始的<code>7个bit</code>就完事了。</li>
</ul>
<p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%9C%A80%E5%88%B0125%E4%B9%8B%E9%97%B42.png" alt="payload长度在0到125之间"></p>
<ul>
<li>如果是<code>126（0x7E）</code>。那它表示payload的长度范围在 <code>126~65535</code> 之间，接下来还需要<strong>再读16bit</strong>。这16bit会包含payload的真实长度。</li>
</ul>
<p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%9C%A8126%E5%88%B065535%E4%B9%8B%E9%97%B42.png" alt="payload长度在126到65535之间"></p>
<ul>
<li>如果是<code>127（0x7F）</code>。那它表示payload的长度范围<code>&gt;=65536</code>，接下来还需要<strong>再读64bit</strong>。这64bit会包含payload的长度。这能放2的64次方byte的数据，换算一下好多个TB，肯定够用了。</li>
</ul>
<p><img src="https://cdn.xiaobaidebug.top/payload%E9%95%BF%E5%BA%A6%E5%A4%A7%E4%BA%8E%E7%AD%89%E4%BA%8E65536%E7%9A%84%E6%83%85%E5%86%B5.png" alt="payload长度大于等于65536的情况"></p>
<p><strong>payload data字段</strong>：这里存放的就是真正要传输的数据，在知道了上面的payload长度后，就可以根据这个值去截取对应的数据。</p>
<p>大家有没有发现一个小细节，websocket的数据格式也是  <strong>数据头（内含payload长度） + payload data</strong> 的形式。</p>
<p><img src="https://cdn.xiaobaidebug.top/0bec52deb6276987.jpeg"></p>
<p>之前写的<a target="_blank" rel="noopener" href="https://juejin.cn/post/7121882245605883934">《既然有HTTP协议，为什么还要有RPC》</a>提到过，TCP协议本身就是全双工，但直接使用<strong>纯裸TCP</strong>去传输数据，会有<strong>粘包</strong>的”问题”。为了解决这个问题，上层协议一般会用<strong>消息头+消息体</strong>的格式去重新包装要发的数据。</p>
<p>而<strong>消息头</strong>里一般含有<strong>消息体的长度</strong>，通过这个长度可以去截取真正的消息体。</p>
<p>HTTP协议和大部分RPC协议，以及我们今天介绍的websocket协议，都是这样设计的。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%976.drawio.png" alt="消息边界长度标志"></p>
<br>

<h3 id="websocket的使用场景"><a href="#websocket的使用场景" class="headerlink" title="websocket的使用场景"></a>websocket的使用场景</h3><p>websocket完美继承了TCP协议的<strong>全双工</strong>能力，并且还贴心的提供了解决粘包的方案。它适用于<strong>需要服务器和客户端（浏览器）频繁交互</strong>的大部分场景。比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。</p>
<p>回到文章开头的问题，在使用websocket协议的网页游戏里，怪物移动以及攻击玩家的行为是<strong>服务器逻辑</strong>产生的，对玩家产生的伤害等数据，都需要由<strong>服务器主动发送给客户端</strong>，客户端获得数据后展示对应的效果。</p>
<p><img src="https://cdn.xiaobaidebug.top/websocket%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF.drawio.png" alt="websocket的使用场景"></p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>TCP协议本身是<strong>全双工</strong>的，但我们最常用的HTTP1.1，虽然是基于TCP的协议，但它是<strong>半双工</strong>的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的websocket协议。</li>
<li>在HTTP1.1里。只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用<strong>定时轮询或者长轮询</strong>的方式实现<strong>服务器推送</strong>(comet)的效果。</li>
<li>对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用websocket协议。</li>
<li>websocket和socket几乎没有任何关系，只是叫法相似。</li>
<li>正因为各个浏览器都支持HTTP协议，所以websocket会先利用HTTP协议加上一些特殊的header头进行握手升级操作，升级成功后就跟HTTP没有任何关系了，之后就用websocket的数据格式进行收发数据。</li>
</ul>
<hr>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p>
<p>我有个不成熟的请求。</p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" />

<br>

<p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p>
<p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p>
<p>我这么善良质朴的愿望，能被满足吗？</p>
<p>如果实在叫不出口的话，能帮我<strong>点下关注</strong>和右下角的<strong>点赞+在看</strong>吗？</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/08/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%83%BDping%E9%80%9A%EF%BC%8C%E5%B0%B1%E4%BB%A3%E8%A1%A8TCP%E4%B8%80%E5%AE%9A%E8%83%BD%E8%BF%9E%E9%80%9A%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/18/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E8%83%BDping%E9%80%9A%EF%BC%8C%E5%B0%B1%E4%BB%A3%E8%A1%A8TCP%E4%B8%80%E5%AE%9A%E8%83%BD%E8%BF%9E%E9%80%9A%E5%90%97%EF%BC%9F/" class="post-title-link" itemprop="url">能ping通，TCP就一定能连通吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-18 22:57:55" itemprop="dateCreated datePublished" datetime="2022-08-18T22:57:55+08:00">2022-08-18</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:47:39" itemprop="dateModified" datetime="2022-10-30T10:47:39+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<br>

<p>平时，我们想要知道，自己的机器到目的机器之间，<strong>网络通不通</strong>，一般会执行<strong>ping命令</strong>。</p>
<p>一般对于状况良好的网络来说，你能看到它对应的<code>loss</code>丢包率为<code>0%</code>，也就是所谓的<strong>能ping通</strong>。如果看到丢包率<code>100%</code>，也就是<strong>ping不通</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/ping%E6%AD%A3%E5%B8%B8.png" alt="ping正常"></p>
<p><img src="https://cdn.xiaobaidebug.top/ping%E4%B8%8D%E9%80%9A.png" alt="ping不通"></p>
<br>

<p>那么问题来了，假设我能<strong>ping</strong>通某台机器，那这时候如果我改用<strong>TCP协议</strong>去发数据到目的机器，<strong>也一定能通吗？</strong></p>
<p>或者换个问法，<strong>ping和tcp协议走的网络路径是一样的吗？</strong></p>
<br>

<p>这时候第一反应就是<strong>不一定</strong>，因为ping完之后中间链路里的<strong>某个路由器可能会挂了（断电了）</strong>，再用TCP去连就会走别的路径。</p>
<p>也没错。但假设，<strong>中间链路没发生任何变化呢？</strong></p>
<p>我先直接说答案。</p>
<p><strong>不一定，走的网络路径还是有可能是不同的。</strong></p>
<p>今天就来聊聊为什么。</p>
<br>

<p>我之前写过一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/Gml_xxvGjq224L7zCoXm5w">《断网了，还能ping通 127.0.0.1 吗？》</a>,里面提到过<strong>ping数据包和tcp数据包的区别</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/ping%E5%92%8C%E6%99%AE%E9%80%9A%E5%8F%91%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%B3%E7%B3%BB67.drawio.png" alt="ping和TCP发消息的区别"></p>
<br>

<p>我们知道网络是分层的，每一层都有对应协议。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%AF%B9%E5%BA%94%E7%9A%84%E6%B6%88%E6%81%AF%E4%BD%93%E5%8F%98%E5%8C%96%E5%88%86%E6%9E%90.png" alt="五层网络协议对应的消息体变化分析"></p>
<p>而这网络层就像搭积木一样，上层协议都是基于下层协议搭出来的。</p>
<p><strong>不管是ping（用了ICMP协议）还是tcp本质上都是基于网络层IP协议的数据包，而到了物理层，都是二进制01串，都走网卡发出去了。</strong></p>
<p>如果网络环境没发生变化，目的地又一样，那按道理说他们走的网络路径应该是一样的，什么情况下会不同呢？</p>
<p>我们就从<strong>路由</strong>这个话题聊起吧。</p>
<br>

<h3 id="网络路径"><a href="#网络路径" class="headerlink" title="网络路径"></a>网络路径</h3><p>在我们的想象中，当我们想在两台机器之间传输数据。本机和目的机器之间会建立一条连接，像<strong>一条管道</strong>一样，数据从这头到那头。这条管道其实是我们为了方便理解而抽象出来的概念。</p>
<p>实际上，我们将数据包从本地网卡发出之后，会经过各种<strong>路由器（或者交换机）</strong>，才能到达目的机器。</p>
<p>这些路由器数量众多，相互之间可以互连，连起来之后就像是一张大网，所以叫**”网络”**可以说是非常的形象。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E5%99%A8%E6%9E%84%E6%88%90%E7%9A%84%E7%BD%91%E7%BB%9C.drawio.png" alt="路由器构成的网络"></p>
<blockquote>
<p>考虑到交换机有的功能，路由器基本上都支持，所以我们这边只讨论路由器。</p>
</blockquote>
<p>那么现在问题来了，<strong>路由器收到数据后，怎么知道应该走哪条路径，传给哪个路由器？</strong></p>
<br>

<h3 id="路径由什么决定？"><a href="#路径由什么决定？" class="headerlink" title="路径由什么决定？"></a>路径由什么决定？</h3><p>在上面的那么大一张网络中，随便一个路由器都有可能走任何一个路径，将数据发到另外一个路由器上，</p>
<p>但路由和路由之间距离，带宽啥的可能都不同。</p>
<p>于是就很需要知道，<strong>两点之间走哪条路才是最优路径</strong>。</p>
<p>于是问题就变成了这样一个<strong>图状结构</strong>。每条边都带有<strong>成本或权重</strong>，算这上面<strong>任意两点的最短距离</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84Dijkstra.drawio.png" alt="路由器和Dijkstra"></p>
<p>这时候想必大家回忆压不住要上来了。</p>
<p>这题我熟，这就是大学时候刷的<strong>Dijkstra算法</strong>。菊花厂的OJ笔试题集里也经常出现，现在终于明白为什么他们家的笔试题里图类题目比别的大厂貌似要多一些了吧，因为菊花厂就是搞通信的，做路由器的老玩家了。</p>
<br>

<h4 id="路由表的生成"><a href="#路由表的生成" class="headerlink" title="路由表的生成"></a>路由表的生成</h4><p>基于<strong>Dijkstra算法</strong>，封装出了一个新的协议，<strong>OSPF协议</strong>（<strong>O</strong>pen <strong>S</strong>hortest <strong>P</strong>ath <strong>F</strong>irst, 开放最短路径优先）。</p>
<p>有了OSPF，路由器就得到了网络图里自己到其他点之间的<strong>最短距离</strong>，于是就知道了<strong>数据包要到某个点，该走哪条最优路径</strong>。</p>
<p>将这些信息汇成一张表，也就是我们常说的<strong>路由表</strong>。</p>
<p>路由表里记录了到什么IP需要走什么端口，以及走这条路径的成本（<code>metric</code>）。</p>
<p>可以通过 <code>route</code> 命令查看到。</p>
<p><img src="https://cdn.xiaobaidebug.top/route2.png" alt="route表"></p>
<br>

<h4 id="路由表决定数据包路径"><a href="#路由表决定数据包路径" class="headerlink" title="路由表决定数据包路径"></a>路由表决定数据包路径</h4><p>数据包在发送的过程中，会在<strong>网络层</strong>加入<strong>目标地址IP</strong>。</p>
<p>路由器会根据这个<strong>IP</strong>跟<strong>路由表</strong>去做匹配。</p>
<p>然后路由表，会告诉路由器，什么样的消息该转发到什么端口。</p>
<p>举个例子。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%B7%AF%E7%94%B1%E4%BA%92%E8%81%94%E6%97%B6%E6%96%B0%E7%89%88.drawio.png" alt="通过路由表转发数据"></p>
<p>假设A要发消息到D。也就是<code>192.168.0.105/24</code>要发消息到<code>192.168.1.11/24</code>。</p>
<p>那么A会把消息经发到路由器。</p>
<p>路由器已知目的地IP<code>192.168.1.11/24</code> ，去跟<strong>路由表</strong>做匹配，发现<code>192.168.1.0/24</code>, 就在e2端口，那么就会把消息从e2端口发出，（可能还会经过交换机）最后把消息打到目的机器。</p>
<p>当然，如果路由表里找不到，那就打到<strong>默认网关</strong>吧，也就是从e1口发出，发到IP<code>192.0.2.1</code>。<strong>这个路由器的路由表不知道该去哪，说不定其他路由器知道</strong>。</p>
<br>

<h4 id="路由表的匹配规则"><a href="#路由表的匹配规则" class="headerlink" title="路由表的匹配规则"></a>路由表的匹配规则</h4><p>上面的例子里，是只匹配上了路由表里的<strong>一项</strong>，所以只能是它了。</p>
<p>但是，条条大路通罗马。实际上能到目的地的路径肯定有很多。</p>
<p><strong>如果路由表里有很多项都被匹配上了，会怎么选？</strong></p>
<br>

<p>如果多个路由项都能到目的地，那就优先选<strong>匹配长度更长</strong>的那个。比如，还是目的地<code>192.168.1.11</code>，发现路由表里的<strong>192.168.1</strong>.0/<strong>24</strong> 和 <strong>192.168</strong>.0.0/<strong>16</strong>都能匹配上，但明显<strong>前者匹配长度更长</strong>，所以最后会走 <strong>192.168.1</strong>.0/<strong>24</strong>对应的转发端口。</p>
<p><strong>但如果两个表项的匹配长度都一样呢？</strong></p>
<p>那就会看生成这个路由表项的<strong>协议</strong>是啥，选优先级高的，优先级越高也就是所谓的<strong>管理距离</strong>（<strong>AD</strong>，<strong>A</strong>dministrative<strong>D</strong>istance）越小。比如说优先选<strong>手动配</strong>的静态（<strong>static</strong>）路由，次优选<strong>OSPF</strong>动态学习过来的表项。</p>
<p>如果还是相同，就看<strong>度量值metrics</strong>，其实也就是<strong>路径成本cost</strong>，成本越小，越容易被选中。</p>
<p><strong>路由器能选的路线有很多，但按道理，最优的只有”一条”，所以到这里为止，我们都可以认为，对于同一个目的地，ping和TCP走的路径是相同的。</strong></p>
<p>但是。</p>
<p><strong>如果连路径成本都一样呢？</strong>也就是说有多条最优路径呢。</p>
<p><strong>那就都用</strong>。</p>
<p>这也就是所谓的<strong>等价多路径，ECMP</strong>（<strong>E</strong>qual <strong>C</strong>ost <strong>M</strong>ulti<strong>P</strong>ath）。</p>
<p>我们可以通过<code>traceroute</code>看下链路是否存在等价多路径的情况。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220805122619206.png"></p>
<p>可以看到，中间某几行，有<strong>好几个IP</strong>，也就是说这一跳里同时可以选好几个目的机器，说明这段路径<strong>支持ECMP</strong>。</p>
<br>

<h4 id="ECMP有什么用"><a href="#ECMP有什么用" class="headerlink" title="ECMP有什么用"></a>ECMP有什么用</h4><p>利用等价多路径，我们<strong>可以增加链路带宽</strong>。</p>
<p>举个例子。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%B2%A1%E6%9C%89ECMP%E6%97%B6%E5%8F%AA%E8%83%BD%E9%80%89%E6%8B%A9%E6%9F%90%E4%B8%80%E6%9D%A1%E8%B7%AF%E5%BE%84.drawio4.png" alt="没有ECMP时只能选择某一条路径"></p>
<p>从A点到B点，如果这两条路径成本不同，带宽都是<code>1千兆</code>。那数据包肯定就选成本低的那条路了，如果这条路出故障了，就走下面那条路。但不管怎么样，<strong>同一时间，只用到了一条路径</strong>。另外一条闲置就有些浪费了，有没有办法可以利用起来呢？</p>
<p>有，将它们两条路径的成本设置成一样，那它们就成了等价路由，然后中间的路由器开启<strong>ECMP</strong>特性，就可以同时利用这两条链路了。带宽就从原来的<code>1千兆</code>变成了<code>2千兆</code>。数据就可以在两条路径中随意选择了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%88%A9%E7%94%A8ECMP%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E4%BD%BF%E7%94%A8%E4%B8%A4%E6%9D%A1%E9%93%BE%E8%B7%AF.drawi3o.png" alt="利用ECMP可以同时使用两条链路"></p>
<p>但这也带来了另外一个问题。<strong>加剧了数据包乱序</strong>。</p>
<p>原来我只使用一条网络路径，数据依次发出，如无意外，也是依次到达。</p>
<p>现在两个数据包走两条路径，先发的数据包可能后到。这就乱序了。</p>
<p>那么问题又又来了。</p>
<br>

<h4 id="乱序会有什么问题？"><a href="#乱序会有什么问题？" class="headerlink" title="乱序会有什么问题？"></a>乱序会有什么问题？</h4><p>对于我们最最最常使用的TCP协议来说，它是个可靠性网络的协议，这里提到的<strong>可靠</strong>，不仅是保证数据要能送到目的地，还要保证<strong>数据顺序</strong>要跟原来发送端的一样。</p>
<p>实现也很简单，<strong>TCP为每个数据包（segment）做上编号</strong>。数据到了接收端后，根据<strong>数据包编号</strong>发现是<strong>乱序数据包</strong>，就会扔到<strong>乱序队列</strong>中对数据包进行排序。如果前面的数据包还没到，哪怕后面的数据包先到了，也得在乱序队列中一直等，到齐后才能被上层拿到。</p>
<p>举个例子，发送端发出三个数据包，<code>编号1,2,3</code>，假设在<strong>传输层</strong><code>2和3</code>先到了，<code>1</code>还没到。那此时<strong>应用层</strong>是没办法拿到<code>2和3</code>的数据包的，必须得等<code>1</code>来了之后，<strong>应用层才能一次性拿到这三个包</strong>。因为这三个包原来可能表示的是一个完整的消息，少了1, 那么<strong>消息就不完整</strong>，应用层拿到了也毫无意义。</p>
<p>像这种，由于<strong>前面的数据丢失</strong>导致<strong>后面的数据没办法及时给到应用层</strong>的现象，就是我们常说的<strong>TCP队头阻塞</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%B9%B1%E5%BA%8F%E9%98%9F%E5%88%97%E7%AD%89%E5%BE%85%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%88%B0%E6%9D%A5.drawio.png" alt="乱序队列等待数据包的到来"></p>
<p>乱序发生时<code>2和3</code>需要待在乱序队列中，而<strong>乱序队列其实用的也是接收缓冲区的内存</strong>，而<strong>接收缓冲区是有大小限制的</strong>。通过下面的命令可以看到接收缓冲区的大小。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看接收缓冲区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sysctl net.ipv4.tcp_rmem</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096(min)	87380(default)	6291456(max)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓冲区会在min和max之间动态调整</span></span><br></pre></td></tr></table></figure>

<p>乱序的情况越多，接收缓冲区的内存就被占用的越多，对应的<strong>接收窗口</strong>就会变小，那正常能收的数据就变少了，<strong>网络吞吐就变差</strong>了，也就是性能变差了。</p>
<p>因此，我们需要尽量保证所有<strong>同一个TCP连接下的所有TCP包都走相同路径，这样才能最大程度避免丢包</strong>。</p>
<br>

<h4 id="ECMP的路径选择策略"><a href="#ECMP的路径选择策略" class="headerlink" title="ECMP的路径选择策略"></a>ECMP的路径选择策略</h4><p><strong>当初开启ECMP就是为了提升性能，现在反而加重了乱序，降低了TCP传输性能。</strong></p>
<p>这怎么能忍。</p>
<p>为了解决这个问题，我们需要有一个合理的路径选择策略。为了避免同一个连接里的数据包乱序，我们需要保证同一个连接里的数据包，都走同样的路径。</p>
<p>这好办。我们可以通过连接的<strong>五元组</strong>（发送方的<strong>IP</strong>和<strong>端口</strong>，接收方的<strong>IP</strong>和<strong>端口</strong>，以及通信<strong>协议</strong>）信息定位到唯一一条连接。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%85%83%E7%BB%84.drawio.png" alt="五元组"></p>
<p>然后对五元组信息生成哈希键，让同一个哈希键的数据走同一条路径，问题就完美解决了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%BA%94%E5%85%83%E7%BB%84%E6%98%A0%E5%B0%84%E6%88%90hash%E9%94%AE.drawio.png" alt="五元组映射成hash键"></p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AE%E4%BA%94%E5%85%83%E7%BB%84%E9%80%89%E6%8B%A9ECMP%E8%B7%AF%E5%BE%84.3.png" alt="根据五元组选择ECMP路径"></p>
<br>

<h3 id="TCP和Ping走的网络路径一样吗"><a href="#TCP和Ping走的网络路径一样吗" class="headerlink" title="TCP和Ping走的网络路径一样吗"></a>TCP和Ping走的网络路径一样吗</h3><p>现在我们回到文章开头的问题。</p>
<p>对于同样的发送端和接收端，<strong>TCP和Ping走的网络路径一样吗？</strong></p>
<p>不一定一样，因为<strong>五元组</strong>里的信息里有一项是<strong>通信协议</strong>。ping用的是<strong>ICMP协议</strong>，跟<strong>TCP协议</strong>不同，并且ping不需要用到端口，所以五元组不同，生成的<strong>哈希键不同</strong>，通过ECMP选择到的路径也可能不同。</p>
<p><img src="https://cdn.xiaobaidebug.top/TCP%E5%92%8Cping%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82.drawio.png" alt="TCP和ping的五元组差异"></p>
<br>

<h3 id="同样都用TCP协议，数据包走的网络路径一样吗"><a href="#同样都用TCP协议，数据包走的网络路径一样吗" class="headerlink" title="同样都用TCP协议，数据包走的网络路径一样吗"></a>同样都用TCP协议，数据包走的网络路径一样吗</h3><p>还是同样的发送端和接收端，同样是TCP协议，不同TCP连接走的网络路径是一样的吗？</p>
<p>跟上面的问题一样，其实<strong>还是五元组的问题</strong>，同样都是TCP协议，对于同样的发送端和接收端，他们的IP和接收端的端口肯定是一样的，但<strong>发送方的端口是可以随时变化</strong>的，因此通过ECMP走的路径也可能不同。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%B8%8D%E5%90%8CTCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E4%BA%94%E5%85%83%E7%BB%84%E5%B7%AE%E5%BC%82.drawio.png" alt="不同TCP连接的五元组差异"></p>
<br>

<p>但问题又来了。</p>
<p><strong>我知道这个有什么用呢？我做业务开发，又没有设置网络路由的权限。</strong></p>
<br>

<h3 id="利用这个知识点排查问题"><a href="#利用这个知识点排查问题" class="headerlink" title="利用这个知识点排查问题"></a>利用这个知识点排查问题</h3><p>对于业务开发，这绝对不是个没用的知识点。</p>
<p>如果某天，你发现，你能ping通目的机器，但用TCP去连，却<strong>偶尔连不上</strong>目的机器。而且两端机器都挺空闲，没什么性能上的瓶颈。实在<strong>走投无路</strong>了。</p>
<p>你就可以想想，会不会是网络中用到了<code>ECMP</code>，其中一条链路有问题导致的。</p>
<p><img src="https://cdn.xiaobaidebug.top/ping%E8%83%BD%E6%88%90%E5%8A%9F%E4%BD%86%E9%83%A8%E5%88%86TCP%E8%BF%9E%E6%8E%A5%E5%A4%B1%E8%B4%A5.drawio.png" alt="ping能成功但部分TCP连接失败"></p>
<p>排查方法也很简单。</p>
<p>你是知道本机的IP以及目的机器的IP和端口号的，也知道自己用的是TCP连接。</p>
<p>只要你在<strong>报错的时候打印下错误信息，你就知道了发送端的端口号了。</strong></p>
<p>这样<strong>五元组</strong>是啥你就知道了。</p>
<p>下一步就是<strong>指定发送端的端口号重新发起TCP请求，同样的五元组，走同样的路径，按理说如果链路有问题，就肯定会复现。</strong></p>
<p>如果不想改自己的代码，你可以用<strong>nc命令指定客户端端口</strong>看下能不能正常建立TCP连接。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -p 6666 baidu.com 80</span><br></pre></td></tr></table></figure>

<p><code>-p 6666</code>是指定发出请求的客户端端口是<code>6666</code>，后面跟着的是<strong>连接的域名</strong>和<strong>80端口</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220805141757559.png" alt="通过nc成功建立tcp连接"></p>
<p>假设用了<code>6666端口</code>的五元组去连接<strong>总是失败</strong>，改用<code>6667或其他端口</code><strong>却能成功</strong>，你可以带着这个信息去找找负责网络的同事。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>路由器可以通过OSPF协议生成路由表，利用数据包里的IP地址去跟路由表做匹配，选择最优路径后进行转发。</li>
<li>当路由表一个都匹配不上时会走默认网关。当匹配上多个的时候，会先看<strong>匹配长度</strong>，如果一样就看<strong>管理距离</strong>，还一样就看<strong>路径成本</strong>。如果连路径成本都一样，那<strong>等价路径</strong>。如果路由开启了ECMP，那就可以同时利用这几条路径做传输。</li>
<li>ECMP可以提高链路带宽，同时利用五元组做哈希键进行路径选择，保证了同一条连接的数据包走同一条路径，减少了乱序的情况。</li>
<li>可以通过traceroute命令查看到链路上是否有用到ECMP的情况。</li>
<li>开启了ECMP的网络链路中，TCP和ping命令可能走的路径不同，甚至同样是TCP，不同连接之间，走的路径也不同，因此出现了连接时好时坏的问题，实在是走投无路了，可以考虑下是不是跟ECMP有关。</li>
<li>当然，<strong>遇到问题多怀疑自己，要相信绝大部分时候真的跟ECMP无关</strong>。</li>
</ul>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《网络排查案例课》 ——极客时间</p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>兄弟们。</p>
<p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p>
<p>但我今天不想。</p>
<p>因为越是这样，评论区里叫我diao毛的兄弟就越多。</p>
<p><strong>上海快40°的天气，你们竟然能说出如此冰冷的话。</strong></p>
<p>但是。</p>
<p>只要你们还能给我文章右下角来个<strong>点赞和在看</strong>的话。</p>
<p>这口气，我还能忍。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi-20220806162638482.gif"></p>
<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/08/13/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%94%B6%E5%88%B0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/13/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B2%A1%E6%94%B6%E5%88%B0%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%AF%B7%E6%B1%82%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E4%B8%80%E7%9B%B4%E7%AD%89%E5%BE%85%E5%90%97%EF%BC%9F/" class="post-title-link" itemprop="url">TCP四次挥手中如果服务端没收到第四次挥手请求，服务端会一直等待吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-13 22:57:55" itemprop="dateCreated datePublished" datetime="2022-08-13T22:57:55+08:00">2022-08-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:45:50" itemprop="dateModified" datetime="2022-10-30T10:45:50+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<p>搬运一个在某乎的回答，水一篇文章吧。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220813113924022.png"></p>
<p><img src="https://cdn.xiaobaidebug.top/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B7.png" alt="TCP四次挥手"></p>
<p>正常情况下。只要数据传输完了，<strong>不管是客户端还是<a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E6%9C%8D%E5%8A%A1%E7%AB%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:2613763971%7D">服务端</a>，都可以主动发起四次挥手</strong>，释放连接。</p>
<p>就跟上图画的一样，假设，这次四次挥手是由客户端主动发起的，那它就是<strong>主动方</strong>。服务器是被动接收客户端的挥手请求的，叫<strong>被动方</strong>。</p>
<p>客户端和服务器，一开始，都是处于<code>ESTABLISHED</code>状态。</p>
<p><strong>第一次挥手</strong>：一般情况下，主动方执行<code>close()</code>或 <code>shutdown()</code>方法，会发个<code>FIN报文</code>出来，表示”<strong>我不再发送数据了</strong>“。</p>
<p><strong>第二次挥手</strong>：在收到主动方的<code>FIN</code>报文后，被动方立马回应一个<code>ACK</code>，意思是”我收到你的FIN了，也知道你不再发数据了”。</p>
<p>上面提到的是<strong>主动方</strong>不再发送数据了。但如果这时候，<strong>被动方</strong>还有数据要发，那就继续发。注意，虽然第二次和第三次挥手之间，被动方是能发数据到主动方的，但主动方能不能正常收就不一定了，这个待会说。</p>
<p><strong>第三次挥手</strong>：在被动方在感知到第二次挥手之后，会做了一系列的收尾工作，最后也调用一个 <code>close()</code>, 这时候就会发出第三次挥手的 <code>FIN-ACK</code>。</p>
<p><strong>第四次挥手</strong>：主动方回一个<code>ACK</code>，意思是收到了。</p>
<p>其中第一次挥手和第三次挥手，都是我们在应用程序中主动触发的（比如调用<code>close()</code>方法），也就是我们平时写代码需要关注的地方。</p>
<p>第二和第四次挥手，都是内核协议栈自动帮我们完成的，我们写代码的时候碰不到这地方，因此也不需要太关心。</p>
<p>另外不管是主动还是被动，每方发出了一个 <code>FIN</code> 和一个<code>ACK</code> 。也收到了一个 <code>FIN</code> 和一个<code>ACK</code> 。</p>
<p>回到题主的问题。</p>
<p><strong>TCP四次挥手中如果服务端没收到第四次挥手请求，服务端会一直等待吗？</strong></p>
<p>第四次挥手是第三次挥手触发的。如果第四次挥手服务端一直没收到，那服务端会认为是不是自己的第三次挥手丢了，于是服务端不断重试发第三次挥手（FIN）.重发次数由系统的tcp_orphan_retries参数控制。重试多次还没成功，服务端直接断开链接。<strong>所以结论是服务端不会一直等待第四次挥手。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/TCP%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%A2%E5%A4%B1.drawio.png" alt="TCP第四次挥手丢失"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/sys/net/ipv4/tcp_orphan_retries</span></span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>另外，你会发现<code>tcp_orphan_retries</code>参数是0，但其实并不是不重试的意思。为0时，默认值为8. 也就是重试8次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Calculate maximal number or retries on an orphaned socket. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">tcp_orphan_retries</span><span class="params">(struct sock *sk, <span class="keyword">int</span> alive)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> retries = sysctl_tcp_orphan_retries; <span class="comment">/* May be zero. */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We know from an ICMP that something is wrong. */</span></span><br><span class="line">	<span class="keyword">if</span> (sk-&gt;sk_err_soft &amp;&amp; !alive)</span><br><span class="line">		retries = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* However, if socket sent something recently, select some safe</span></span><br><span class="line"><span class="comment">	 * number of retries. 8 corresponds to &gt;100 seconds with minimal</span></span><br><span class="line"><span class="comment">	 * RTO of 200msec. */</span></span><br><span class="line">	<span class="keyword">if</span> (retries == <span class="number">0</span> &amp;&amp; alive)</span><br><span class="line">		retries = <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">return</span> retries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然如果服务端重试发第三次挥手FIN的过程中，还是同样的端口和IP,起了个新的客户端，这时候服务端重试的FIN被收到后，客户端就会认为是不正常的数据包，直接发个RST给服务端，这时候两端连接也会断开。</p>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>查资料的时候发现<strong>小林大佬已经写过，而且写的巨好</strong>，感兴趣的可以看下他的这篇文章。</p>
<p><strong>《 如何优化 TCP?》</strong><a target="_blank" rel="noopener" href="https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96">https://xiaolincoding.com/network/3_tcp/tcp_optimize.html#%E4%B8%BB%E5%8A%A8%E6%96%B9%E7%9A%84%E4%BC%98%E5%8C%96</a></p>
<p>链接太长，懒得复制的话，点击<strong>阅读原文</strong>可以直接跳转。</p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>新的文章快写好了，就缺个开头了。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220813115736303.png"></p>
<p><strong>我有个不成熟的请求。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/u=2281575747,3550568508&fm=253&fmt=auto&app=120&f=JPEG.jpeg"></p>
<br>

<p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p>
<p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p>
<p>我这么善良质朴的愿望，能被满足吗？</p>
<p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi-20220806162638482.gif"></p>
<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/08/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%8D%E6%98%AF%E6%88%91%E4%B8%8D%E5%9B%9E%E4%BD%A0%E6%B6%88%E6%81%AF%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E4%BC%9A%E4%B8%A2%E5%8C%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/01/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E4%B8%8D%E6%98%AF%E6%88%91%E4%B8%8D%E5%9B%9E%E4%BD%A0%E6%B6%88%E6%81%AF%EF%BC%8C%E6%98%AF%E5%9B%A0%E4%B8%BA%E7%BD%91%E7%BB%9C%E4%BC%9A%E4%B8%A2%E5%8C%85/" class="post-title-link" itemprop="url">用了TCP协议，就一定不会丢包吗？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-08-01 22:57:55" itemprop="dateCreated datePublished" datetime="2022-08-01T22:57:55+08:00">2022-08-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:48:24" itemprop="dateModified" datetime="2022-10-30T10:48:24+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<br>

<p>表面上我是个<strong>技术博主</strong>。</p>
<p>但没想到今天成了个<strong>情感博主</strong>。</p>
<p>我是没想到有一天，我会通过技术知识，来挽救粉丝即将破碎的感情。</p>
<p>掏心窝子的说。这件事情多少是沾点<strong>功德无量</strong>了。</p>
<p>事情是这样的。</p>
<p>最近就有个读者加了我的绿皮聊天软件，女生，<strong>头像挺好看</strong>的，就在我以为她要我拉她<strong>进群发成人专升本广告</strong>的时候。</p>
<p>画风突然不对劲。</p>
<p>她说她男朋友也是个<strong>程序员</strong>，异地恋，也关注了我，天天研究什么<strong>TCP，UDP网络</strong>。一研究就是一晚上，一晚上都不回她消息的那种。</p>
<p>话里有话，懂。</p>
<p>不出意外的出了意外，她发出了灵魂拷问</p>
<p><strong>“你们程序员真的有那么忙吗？忙到连消息都不知道回。”</strong></p>
<p>没想到上来就是一记直拳。</p>
<p>但是，这一拳，我接住了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%A4%AA%E5%BC%B1%E4%BA%86.jpg"></p>
<p>我很想告诉她”<strong>分了吧，下一题</strong>“。</p>
<p><strong>但我不能</strong>。因为这样我就伤害了我的读者兄弟。</p>
<p>沉默了一下。</p>
<p><img src="https://cdn.xiaobaidebug.top/cpu%E7%96%BC.png"></p>
<p>单核cpu都快转冒烟了，才颤颤巍巍在九宫格键盘上发出消息。</p>
<p>再回慢一点，我就感觉，我要对不起我这全日制本科学历了。</p>
<p><strong>“其实，他已经回了你消息了，但你知道吗？网络是会丢包的。”</strong></p>
<p>“我来帮他解释下，这个话题就要从<strong>数据包的发送流程</strong>聊起”</p>
<br>

<h3 id="数据包的发送流程"><a href="#数据包的发送流程" class="headerlink" title="数据包的发送流程"></a>数据包的发送流程</h3><p>首先，我们两个手机的绿皮聊天软件客户端，要通信，中间会通过它们家服务器。大概长这样。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%89%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件三端通信"></p>
<p>但为了<strong>简化模型</strong>，我们把中间的服务器给省略掉，假设这是个端到端的通信。且为了保证消息的可靠性，我们盲猜它们之间用的是<strong>TCP协议</strong>进行通信。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%A4%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件两端通信"></p>
<br>

<p>为了发送数据包，两端首先会通过<strong>三次握手</strong>，建立TCP连接。</p>
<p>一个数据包，从聊天框里发出，消息会从<strong>聊天软件</strong>所在的<strong>用户空间</strong>拷贝到<strong>内核空间</strong>的<strong>发送缓冲区（send buffer）</strong>，数据包就这样顺着<strong>传输层、网络层，进入到数据链路层，在这里数据包会经过流控（qdisc），再通过RingBuffer发到物理层的网卡</strong>。数据就这样顺着<strong>网卡</strong>发到了<strong>纷繁复杂</strong>的网络世界里。这里头数据会经过n多个<strong>路由器和交换机</strong>之间的跳转，最后到达<strong>目的机器的网卡</strong>处。</p>
<p>此时目的机器的网卡会通知<strong>DMA</strong>将数据包信息放到<code>RingBuffer</code>中，再触发一个<strong>硬中断</strong>给<code>CPU</code>，<code>CPU</code>触发<strong>软中断</strong>让<code>ksoftirqd</code>去<code>RingBuffer</code>收包，于是一个数据包就这样顺着<strong>物理层，数据链路层，网络层，传输层</strong>，最后从内核空间拷贝到用户空间里的<strong>聊天软件</strong>里。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E7%BD%91%E7%BB%9C%E5%8F%91%E5%8C%85%E6%94%B6%E5%8C%85%E5%85%A8%E6%99%AF%E5%9B%BE.drawio.png" alt="网络发包收包全景图"></p>
<blockquote>
<p>画了那么大一张图，只水了200字做解释，我多少是有些心痛的。</p>
</blockquote>
<br>

<p>到这里，抛开一些细节，大家大概知道了一个数据包从<strong>发送到接收</strong>的宏观过程。</p>
<br>

<p>可以看到，这上面全是密密麻麻的<strong>名词</strong>。</p>
<p>整条链路下来，有不少地方可能会发生丢包。</p>
<p>但为了不让大家<strong>保持蹲姿太久</strong>影响身体健康，我这边只重点讲下几个<strong>常见容易发生丢包的场景</strong>。</p>
<br>



<h3 id="建立连接时丢包"><a href="#建立连接时丢包" class="headerlink" title="建立连接时丢包"></a>建立连接时丢包</h3><p>TCP协议会通过<strong>三次握手</strong>建立连接。大概长下面这样。</p>
<p><img src="https://cdn.xiaobaidebug.top/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BF%AE%E6%AD%A3%E7%89%882.png" alt="TCP三次握手"></p>
<p>在服务端，第一次握手之后，会先建立个<strong>半连接</strong>，然后再发出第二次握手。这时候需要有个地方可以<strong>暂存</strong>这些半连接。这个地方就叫<strong>半连接队列</strong>。</p>
<p>如果之后第三次握手来了，半连接就会升级为全连接，然后暂存到另外一个叫<strong>全连接队列</strong>的地方，坐等程序执行<code>accept()</code>方法将其取走使用。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%973-20220723214200932.png" alt="半连接队列和全连接队列"></p>
<p>是队列就有长度，有长度就有可能会满，如果它们<strong>满了</strong>，那新来的包就会被<strong>丢弃</strong>。</p>
<p>可以通过下面的方式查看是否存在这种丢包行为。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 全连接队列溢出次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -s | grep overflowed</span></span><br><span class="line">    4343 times the listen queue of a socket overflowed</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash"> 半连接队列溢出次数</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> netstat -s | grep -i <span class="string">&quot;SYNs to LISTEN sockets dropped&quot;</span></span></span><br><span class="line">    109 times the listen queue of a socket overflowed </span><br></pre></td></tr></table></figure>

<p>从现象来看就是连接建立失败。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220723222050516.png"></p>
<p>这个话题在之前写的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/n17NjGRab1u5eXkOCro1gg">《没有accept，能建立TCP连接吗？》</a>有更详细的聊过，感兴趣的可以回去看下。</p>
<br>

<h3 id="流量控制丢包"><a href="#流量控制丢包" class="headerlink" title="流量控制丢包"></a>流量控制丢包</h3><p>应用层能发网络数据包的软件有那么多，如果所有数据不加控制一股脑冲入到网卡，网卡会吃不消，那怎么办？让数据按一定的规则排个队依次处理，也就是所谓的<strong>qdisc</strong>(<strong>Q</strong>ueueing <strong>Disc</strong>iplines，排队规则)，这也是我们常说的<strong>流量控制</strong>机制。</p>
<p>排队，得先有个队列，而队列有个<strong>长度</strong>。</p>
<p>我们可以通过下面的<code>ifconfig</code>命令查看到，里面涉及到的<code>txqueuelen</code>后面的数字<code>1000</code>，其实就是流控队列的长度。</p>
<p>当发送数据过快，流控队列长度<code>txqueuelen</code>又不够大时，就容易出现<strong>丢包</strong>现象。</p>
<p><img src="https://cdn.xiaobaidebug.top/qdisc%E4%B8%A2%E5%8C%85.drawio.png" alt="qdisc丢包"></p>
<p>可以通过下面的<code>ifconfig</code>命令，查看TX下的dropped字段，当它大于0时，则<strong>有可能</strong>是发生了流控丢包。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0</span></span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.21.66.69  netmask 255.255.240.0  broadcast 172.21.79.255</span><br><span class="line">        inet6 fe80::216:3eff:fe25:269f  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:16:3e:25:26:9f  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 6962682  bytes 1119047079 (1.0 GiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 9688919  bytes 2072511384 (1.9 GiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure>

<p>当遇到这种情况时，我们可以尝试修改下流控队列的长度。比如像下面这样将eth0网卡的流控队列长度从1000提升为1500.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig eth0 txqueuelen 1500</span></span><br></pre></td></tr></table></figure>





<br>

<h3 id="网卡丢包"><a href="#网卡丢包" class="headerlink" title="网卡丢包"></a>网卡丢包</h3><p>网卡和它的驱动导致丢包的场景也比较常见，原因很多，比如<strong>网线质量差，接触不良</strong>。除此之外，我们来聊几个常见的场景。</p>
<br>

<h4 id="RingBuffer过小导致丢包"><a href="#RingBuffer过小导致丢包" class="headerlink" title="RingBuffer过小导致丢包"></a>RingBuffer过小导致丢包</h4><p>上面提到，在接收数据时，会将数据暂存到<code>RingBuffer</code>接收缓冲区中，然后等着内核触发软中断慢慢收走。如果这个<strong>缓冲区过小</strong>，而这时候发送的数据又过快，就有可能发生溢出，此时也会产生<strong>丢包</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/RingBuffer%E6%BB%A1%E4%BA%86%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%8C%85.drawio.png" alt="RingBuffer满了导致丢包"></p>
<p>我们可以通过下面的命令去查看是否发生过这样的事情。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ifconfig</span></span><br><span class="line">eth0:  RX errors 0  dropped 0  overruns 0  frame 0</span><br></pre></td></tr></table></figure>

<p>查看上面的<code>overruns</code>指标，它记录了由于<code>RingBuffer</code>长度不足导致的溢出次数。</p>
<br>

<p>当然，用<code>ethtool</code>命令也能查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ethtool -S eth0|grep rx_queue_0_drops</span></span><br></pre></td></tr></table></figure>

<p>但这里需要注意的是，因为一个网卡里是可以有<strong>多个RingBuffer</strong>的，所以上面的<code>rx_queue_0_drops</code>里的0代表的是<strong>第0个RingBuffer</strong>的丢包数，对于多队列的网卡，这个0还可以改成其他数字。但我的家庭条件不允许我看其他队列的丢包数，所以上面的命令对我来说是够用了。。。</p>
<p>当发现有这类型丢包的时候，可以通过下面的命令查看当前网卡的配置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">ethtool -g eth0</span></span><br><span class="line">Ring parameters for eth0:</span><br><span class="line">Pre-set maximums:</span><br><span class="line">RX:		4096</span><br><span class="line">RX Mini:	0</span><br><span class="line">RX Jumbo:	0</span><br><span class="line">TX:		4096</span><br><span class="line">Current hardware settings:</span><br><span class="line">RX:		1024</span><br><span class="line">RX Mini:	0</span><br><span class="line">RX Jumbo:	0</span><br><span class="line">TX:		1024</span><br></pre></td></tr></table></figure>

<p>上面的输出内容，含义是<strong>RingBuffer最大支持4096的长度，但现在实际只用了1024。</strong></p>
<p>想要修改这个长度可以执行<code>ethtool -G eth1 rx 4096 tx 4096</code>将发送和接收RingBuffer的长度都改为4096。</p>
<p><strong>RingBuffer</strong>增大之后，可以减少因为容量小而导致的丢包情况。</p>
<br>

<h4 id="网卡性能不足"><a href="#网卡性能不足" class="headerlink" title="网卡性能不足"></a>网卡性能不足</h4><p>网卡作为硬件，<strong>传输速度是有上限的</strong>。当网络传输速度过大，达到网卡上限时，就会发生丢包。这种情况一般常见于压测场景。</p>
<p>我们可以通过<code>ethtool</code>加网卡名，获得当前网卡支持的最大速度。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ethtool eth0</span></span><br><span class="line">Settings for eth0:</span><br><span class="line">	Speed: 10000Mb/s</span><br></pre></td></tr></table></figure>

<p>可以看到，我这边用的网卡能支持的最大传输速度<strong>speed=1000Mb/s</strong>。</p>
<p>也就是俗称的千兆网卡，但注意这里的单位是<strong>Mb</strong>，这里的<strong>b是指bit，而不是Byte。1Byte=8bit</strong>。所以10000Mb/s还要除以8，也就是理论上网卡最大传输速度是<code>1000/8 = 125MB/s</code>。</p>
<p>我们可以通过<code>sar命令</code>从网络接口层面来分析数据包的收发情况。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> sar -n DEV 1</span></span><br><span class="line">Linux 3.10.0-1127.19.1.el7.x86_64  	2022年07月27日 	_x86_64_	(1 CPU)</span><br><span class="line"></span><br><span class="line">08时35分39秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s    rxcmp/s   txcmp/s  rxmcst/s</span><br><span class="line">08时35分40秒      eth0      6.06      4.04      0.35    121682.33   0.00    0.00     0.00</span><br></pre></td></tr></table></figure>

<p>其中 <strong>txkB/s是指当前每秒发送的字节（byte）总数，rxkB/s是指每秒接收的字节（byte）总数</strong>。</p>
<p>当两者加起来的值约等于<code>12~13w字节</code>的时候，也就对应大概<code>125MB/s</code>的传输速度。此时达到网卡性能极限，就会开始丢包。</p>
<p>遇到这个问题，优先看下你的服务是不是真有这么大的<strong>真实流量</strong>，如果是的话可以考虑下拆分服务，或者就忍痛充钱升级下配置吧。</p>
<br>

<h3 id="接收缓冲区丢包"><a href="#接收缓冲区丢包" class="headerlink" title="接收缓冲区丢包"></a>接收缓冲区丢包</h3><p>我们一般使用<code>TCP socket</code>进行网络编程的时候，内核都会分配一个<strong>发送缓冲区</strong>和一个<strong>接收缓冲区</strong>。</p>
<p>当我们想要发一个数据包，会在代码里执行<code>send(msg)</code>，这时候数据包并不是一把梭直接就走网卡飞出去的。而是将数据拷贝到内核<strong>发送缓冲区</strong>就完事<strong>返回</strong>了，至于<strong>什么时候发数据，发多少数据</strong>，这个后续由内核自己做决定。之前写过的《<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/87BZzLmcntA1snJIIhUR0w">代码执行send成功后，数据就发出去了吗？</a>》里有比较详细的介绍。</p>
<p><img src="https://cdn.xiaobaidebug.top/tcp_sendmsg%E9%80%BB%E8%BE%913.png" alt="tcp_sendmsg逻辑"></p>
<p>而<strong>接收缓冲区</strong>作用也类似，从外部网络收到的数据包就暂存在这个地方，然后坐等用户空间的应用程序将数据包取走。</p>
<p>这两个缓冲区是有大小限制的，可以通过下面的命令去查看。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看接收缓冲区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl net.ipv4.tcp_rmem</span></span><br><span class="line">net.ipv4.tcp_rmem = 4096	87380	6291456</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看发送缓冲区</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl net.ipv4.tcp_wmem</span></span><br><span class="line">net.ipv4.tcp_wmem = 4096	16384	4194304</span><br></pre></td></tr></table></figure>

<p>不管是接收缓冲区还是发送缓冲区，都能看到三个数值，分别对应缓冲区的<strong>最小值，默认值和最大值 （min、default、max）。缓冲区会在min和max之间动态调整。</strong></p>
<br>

<p><strong>那么问题来了，如果缓冲区设置过小会怎么样？</strong></p>
<p>对于<strong>发送缓冲区</strong>，执行send的时候，如果是阻塞调用，那就会等，等到缓冲区有空位可以发数据。</p>
<p><img src="https://cdn.xiaobaidebug.top/send%E9%98%BB%E5%A1%9E.gif" alt="send阻塞"></p>
<p>如果是非阻塞调用，就会<strong>立刻返回</strong>一个 <code>EAGAIN</code> 错误信息，意思是  <code>Try again</code> 。让应用程序下次再重试。这种情况下一般不会发生丢包。</p>
<p><img src="https://cdn.xiaobaidebug.top/send%E9%9D%9E%E9%98%BB%E5%A1%9E.gif" alt="send非阻塞"></p>
<p>当接受缓冲区满了，事情就不一样了，它的TCP接收窗口会变为0，也就是所谓的<strong>零窗口</strong>，并且会通过数据包里的<code>win=0</code>，告诉发送端，”球球了，顶不住了，别发了”。一般这种情况下，发送端就该停止发消息了，但如果这时候确实还有数据发来，就会发生<strong>丢包</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/recv_buffer%E4%B8%A2%E5%8C%85.drawio.png" alt="recv_buffer丢包"></p>
<p>我们可以通过下面的命令里的<code>TCPRcvQDrop</code>查看到有没有发生过这种丢包现象。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/net/netstat</span><br><span class="line">TcpExt: SyncookiesSent TCPRcvQDrop SyncookiesFailed</span><br><span class="line">TcpExt: 0              157              60116</span><br></pre></td></tr></table></figure>

<p>但是说个伤心的事情，我们一般也看不到这个<code>TCPRcvQDrop</code>，因为这个是<code>5.9版本</code>里引入的打点，而我们的服务器用的一般是<code>2.x~3.x</code>左右版本。你可以通过下面的命令查看下你用的是什么版本的linux内核。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /proc/version</span></span><br><span class="line">Linux version 3.10.0-1127.19.1.el7.x86_64</span><br></pre></td></tr></table></figure>



<br>

<h3 id="两端之间的网络丢包"><a href="#两端之间的网络丢包" class="headerlink" title="两端之间的网络丢包"></a>两端之间的网络丢包</h3><p>前面提到的是两端机器内部的网络丢包，除此之外，两端之间那么长的一条链路都属于外部网络，这中间有各种路由器和交换机还有光缆啥的，丢包也是很经常发生的。</p>
<p>这些丢包行为发生在中间链路的某些个机器上，我们当然是没权限去登录这些机器。但我们可以通过一些命令观察整个链路的连通情况。</p>
<br>

<h4 id="ping命令查看丢包"><a href="#ping命令查看丢包" class="headerlink" title="ping命令查看丢包"></a>ping命令查看丢包</h4><p>比如我们知道目的地的域名是 <code>baidu.com</code>。想知道你的机器到baidu服务器之间，有没有产生丢包行为。可以使用ping命令。</p>
<p><img src="https://cdn.xiaobaidebug.top/ping%E6%9F%A5%E7%9C%8B%E4%B8%A2%E5%8C%85.png" alt="ping查看丢包"></p>
<p>倒数第二行里有个<code>100% packet loss</code>，意思是**丢包率100%**。</p>
<p>但这样其实你只能知道<strong>你的机器和目的机器之间有没有丢包。</strong></p>
<p><strong>那如果你想知道你和目的机器之间的这条链路，哪个节点丢包了，有没有办法呢?</strong></p>
<p>有。</p>
<br>

<h4 id="mtr命令"><a href="#mtr命令" class="headerlink" title="mtr命令"></a>mtr命令</h4><p>mtr命令可以查看到你的机器和目的机器之间的每个节点的丢包情况。</p>
<p>像下面这样执行命令。</p>
<p><img src="https://cdn.xiaobaidebug.top/mtr_icmp.png" alt="mtr_icmp"></p>
<p>其中**-r是指report**，以报告的形式打印结果。</p>
<p>可以看到<code>Host</code>那一列，出现的都是链路中间每一跳的机器，<code>Loss</code>的那一列就是指这一跳对应的丢包率。</p>
<p>需要注意的是，中间有一些是host是<code>???</code>，那个是因为<strong>mtr默认用的是ICMP包</strong>，有些节点限制了<strong>ICMP包</strong>，导致不能正常展示。</p>
<p>我们可以在mtr命令里加个<code>-u</code>，也就是使用<strong>udp包</strong>，就能看到**部分???**对应的IP。</p>
<p><img src="https://cdn.xiaobaidebug.top/mtr-udp.png" alt="mtr-udp"></p>
<p>把<strong>ICMP包和UDP包的结果</strong>拼在一起看，就是<strong>比较完整</strong>的链路图了。</p>
<p>还有个小细节，<code>Loss</code>那一列，我们在icmp的场景下，关注<strong>最后一行</strong>，如果是0%，那不管前面loss是100%还是80%都无所谓，那些都是<strong>节点限制</strong>导致的<strong>虚报</strong>。</p>
<p>但如果<strong>最后一行是20%，再往前几行都是20%左右</strong>，那说明丢包就是从最接近的那一行开始产生的，长时间是这样，那很可能这一跳出了点问题。如果是公司内网的话，你可以带着这条线索去找对应的网络同事。如果是外网的话，那耐心点等等吧，别人家的开发会比你更着急。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220727215553645.png"></p>
<br>

<h3 id="发生丢包了怎么办"><a href="#发生丢包了怎么办" class="headerlink" title="发生丢包了怎么办"></a>发生丢包了怎么办</h3><p>说了这么多。只是想告诉大家，<strong>丢包是很常见的，几乎不可避免的一件事情</strong>。</p>
<p>但问题来了，发生丢包了怎么办？</p>
<p>这个好办，用<strong>TCP协议</strong>去做传输。</p>
<p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p>
<p>建立了TCP连接的两端，发送端在发出数据后会等待接收端回复<code>ack包</code>，<code>ack包</code>的目的是为了告诉对方自己确实收到了数据，但如果中间链路发生了丢包，那发送端会迟迟收不到确认ack，于是就会进行<strong>重传</strong>。以此来保证每个数据包都确确实实到达了接收端。</p>
<p>假设现在网断了，我们还用聊天软件发消息，聊天软件会使用TCP不断尝试重传数据，<strong>如果重传期间网络恢复了</strong>，那数据就能正常发过去。但如果多次重试直到超时都还是失败，这时候你将收获一个<strong>红色感叹号</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220727223315319.png"></p>
<p>这时候问题又来了。</p>
<p>假设<strong>某绿皮聊天软件用的就是TCP协议。</strong></p>
<p>那文章开头提到的女生，她男朋友回她的消息时为什么还会丢包？毕竟丢包了会<strong>重试</strong>，重试失败了还会出现<strong>红色感叹号。</strong></p>
<br>

<p>于是乎，问题就变成了，<strong>用了TCP协议，就一定不会丢包吗？</strong></p>
<br>

<h3 id="用了TCP协议就一定不会丢包吗"><a href="#用了TCP协议就一定不会丢包吗" class="headerlink" title="用了TCP协议就一定不会丢包吗"></a>用了TCP协议就一定不会丢包吗</h3><p>我们知道TCP位于<strong>传输层</strong>，在它的上面还有各种<strong>应用层协议</strong>，比如常见的HTTP或者各类RPC协议。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE5.drawio.png" alt="四层网络协议"></p>
<p>TCP保证的可靠性，是<strong>传输层的可靠性</strong>。也就是说，<strong>TCP只保证数据从A机器的传输层可靠地发到B机器的传输层。</strong></p>
<p>至于数据到了接收端的传输层之后，能不能保证到应用层，TCP并不管。</p>
<p>假设现在，我们输入一条消息，从聊天框发出，走到<strong>传输层TCP协议的发送缓冲区</strong>，不管中间有没有丢包，最后通过重传都保证发到了对方的<strong>传输层TCP接收缓冲区</strong>，此时接收端回复了一个<code>ack</code>，发送端收到这个<code>ack</code>后就会将自己<strong>发送缓冲区</strong>里的消息给扔掉。到这里TCP的任务就结束了。</p>
<p>TCP任务是结束了，但聊天软件的任务没结束。</p>
<p><strong>聊天软件还需要将数据从TCP的接收缓冲区里读出来，如果在读出来这一刻，手机由于内存不足或其他各种原因，导致软件崩溃闪退了。</strong></p>
<p>发送端以为自己发的消息已经发给对方了，但接收端却并没有收到这条消息。</p>
<p>于是乎，<strong>消息就丢了。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%BD%BF%E7%94%A8TCP%E5%8D%8F%E8%AE%AE%E5%8D%B4%E5%8F%91%E7%94%9F%E4%B8%A2%E5%8C%85.d2.png" alt="使用TCP协议却发生丢包"></p>
<p><strong>虽然概率很小，但它就是发生了</strong>。</p>
<p>合情合理，逻辑自洽。</p>
<br>

<p>所以从这里，我铿锵有力的得出结论，<strong>我的读者已经回了这位女生消息了，只是因为发生了丢包所以女生才没能收到，而丢包的原因是女生的手机聊天软件在接收消息的那一刻发生了闪退。</strong></p>
<p>到这里。女生知道自己错怪她男朋友了，哭着表示，一定要让她男朋友给她买一台不闪退的最新款iphone。</p>
<p>额。。。</p>
<p>兄弟们觉得我做得对的，请在评论区扣个”<strong>正能量</strong>“。</p>
<br>

<h3 id="这类丢包问题怎么解决？"><a href="#这类丢包问题怎么解决？" class="headerlink" title="这类丢包问题怎么解决？"></a>这类丢包问题怎么解决？</h3><p>故事到这里也到尾声了，感动之余，我们来<strong>聊点掏心窝子的话</strong>。</p>
<p><strong>其实前面说的都对，没有一句是假话</strong>。</p>
<p>但某绿皮聊天软件这么成熟，怎么可能没考虑过这一点呢。</p>
<p>大家应该还记得我们文章开头提到过，<strong>为了简单</strong>，就将服务器那一方给省略了，从三端通信变成了两端通信，所以才有了这个丢包问题。</p>
<p><strong>现在我们重新将服务器加回来。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/%E8%81%8A%E5%A4%A9%E8%BD%AF%E4%BB%B6%E4%B8%89%E7%AB%AF%E9%80%9A%E4%BF%A12.drawio.png" alt="聊天软件三端通信"></p>
<p>大家有没有发现，有时候我们在手机里聊了一大堆内容，然后登录电脑版，它能将最近的聊天记录都同步到电脑版上。也就是说服务器<strong>可能</strong>记录了我们最近发过什么数据，假设<strong>每条消息都有个id</strong>，服务器和聊天软件每次都拿<strong>最新消息的id</strong>进行对比，就能知道两端消息是否一致，就像<strong>对账</strong>一样。</p>
<p>对于<strong>发送方</strong>，只要定时跟服务端的内容对账一下，就知道哪条消息没发送成功，直接重发就好了。</p>
<p>如果<strong>接收方</strong>的聊天软件崩溃了，重启后跟服务器稍微通信一下就知道少了哪条数据，同步上来就是了，所以也不存在上面提到的丢包情况。</p>
<p>可以看出，<strong>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</strong></p>
<br>

<p>那么问题叒来了，<strong>两端通信的时候也能对账，为什么还要引入第三端服务器？</strong></p>
<p>主要有三个原因。</p>
<ul>
<li><p>第一，如果是两端通信，你聊天软件里有<code>1000个</code>好友，你就得建立<code>1000个</code>连接。但如果引入服务端，你只需要跟服务器建立<code>1个</code>连接就够了，<strong>聊天软件消耗的资源越少，手机就越省电</strong>。</p>
</li>
<li><p>第二，就是<strong>安全问题</strong>，如果还是两端通信，随便一个人找你对账一下，你就把聊天记录给同步过去了，这并不合适吧。如果对方别有用心，信息就泄露了。引入第三方服务端就可以很方便的做各种<strong>鉴权</strong>校验。</p>
</li>
<li><p>第三，是<strong>软件版本问题</strong>。软件装到用户手机之后，软件更不更新就是由用户说了算了。如果还是两端通信，且两端的<strong>软件版本跨度太大</strong>，很容易产生各种兼容性问题，但引入第三端服务器，就可以强制部分过低版本升级，否则不能使用软件。但对于大部分兼容性问题，给服务端加兼容逻辑就好了，不需要强制用户更新软件。</p>
</li>
</ul>
<p>所以看到这里大家应该明白了，我把服务端去掉，并不单纯是<strong>为了简单</strong>。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>数据从发送端到接收端，链路很长，任何一个地方都可能发生丢包，几乎可以说<strong>丢包不可避免</strong>。</p>
</li>
<li><p>平时没事也不用关注丢包，大部分时候TCP的重传机制保证了消息可靠性。</p>
</li>
<li><p>当你发现服务异常的时候，比如接口延时很高，总是失败的时候，可以用ping或者mtr命令看下是不是中间链路发生了丢包。</p>
</li>
<li><p>TCP只保证传输层的消息可靠性，并不保证应用层的消息可靠性。如果我们还想保证应用层的消息可靠性，就需要应用层自己去实现逻辑做保证。</p>
</li>
</ul>
<br>

<p>最后给大家留个问题吧，<strong>mtr命令是怎么知道每一跳的IP地址的</strong>？</p>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《Linux 内核技术实战》– 极客时间</p>
<p>《云网络丢包故障定位全景指南》–极客重生</p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我一想到读者里还有不少兄弟还是单身，我就夜不能寐。</p>
<p>手心手背都是肉，<strong>一碗水要端平</strong>。</p>
<p>犹豫了很久，为她指了条明路。</p>
<p>“我读者里有很多<strong>微信不丢包</strong>的兄弟，他们都喜欢在我的文章底下<strong>点赞和再看</strong>。你可以考虑下他们”</p>
<p>“还有经常在我评论区<strong>叫我靓仔</strong>的那些个兄弟，一看就是深情种，<strong>请重点考虑</strong>“。</p>
<p>只能帮到这里了，懂？</p>
<br>

<p>我知道，这时候肯定就有兄弟要说我了，**”故事汇都不敢这么编！”**</p>
<p><img src="https://cdn.xiaobaidebug.top/u=3537235361,1595811612&fm=253&fmt=auto&app=138&f=GIF.gif"></p>
<p>嗯。</p>
<p>他们不敢，我敢。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/19/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E5%8D%8F%E8%AE%AE%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E6%9C%89RPC%E5%8D%8F%E8%AE%AE%EF%BC%9F/" class="post-title-link" itemprop="url">既然有HTTP协议，为什么还要有RPC</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-19 22:57:55" itemprop="dateCreated datePublished" datetime="2022-07-19T22:57:55+08:00">2022-07-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:47:53" itemprop="dateModified" datetime="2022-10-30T10:47:53+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3%E7%BD%91%E7%BB%9C/" itemprop="url" rel="index"><span itemprop="name">图解网络</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<br>

<p>我想起了我刚工作的时候，第一次接触RPC协议，当时就很懵，<strong>我HTTP协议用的好好的，为什么还要用RPC协议？</strong></p>
<p>于是就到网上去搜。</p>
<p>不少解释显得非常官方，我相信大家在各种平台上也都看到过，解释了又好像没解释，都在<strong>用一个我们不认识的概念去解释另外一个我们不认识的概念</strong>，懂的人不需要看，不懂的人看了还是不懂。</p>
<p>这种看了，又好像没看的感觉，云里雾里的很难受，<strong>我懂</strong>。</p>
<p>为了避免大家有强烈的<strong>审丑疲劳</strong>，今天我们来尝试重新换个方式讲一讲。</p>
<br>

<h3 id="从TCP聊起"><a href="#从TCP聊起" class="headerlink" title="从TCP聊起"></a>从TCP聊起</h3><p>作为一个程序员，假设我们需要在A电脑的进程发一段数据到B电脑的进程，我们一般会在代码里使用socket进行编程。</p>
<p>这时候，我们可选项一般也就<strong>TCP和UDP二选一。TCP可靠，UDP不可靠。</strong>除非是马总这种神级程序员（早期QQ大量使用UDP），否则，只要稍微对可靠性有些要求，普通人一般无脑选TCP就对了。</p>
<p>类似下面这样。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fd = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>其中<code>SOCK_STREAM</code>，是指使用<strong>字节流</strong>传输数据，说白了就是<strong>TCP协议</strong>。</p>
<p>在定义了socket之后，我们就可以愉快的对这个socket进行操作，比如用<code>bind()</code>绑定IP端口，用<code>connect()</code>发起建连。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%E6%B5%81%E7%A8%8B3.gif" alt="握手建立连接流程"></p>
<p>在连接建立之后，我们就可以使用<code>send()</code>发送数据，<code>recv()</code>接收数据。</p>
<p>光这样一个纯裸的TCP连接，就可以做到收发数据了，那是不是就够了？</p>
<p>不行，这么用会有问题。</p>
<br>

<h3 id="使用纯裸TCP会有什么问题"><a href="#使用纯裸TCP会有什么问题" class="headerlink" title="使用纯裸TCP会有什么问题"></a>使用纯裸TCP会有什么问题</h3><p>八股文常背，TCP是有三个特点，<strong>面向连接</strong>、<strong>可靠</strong>、基于<strong>字节流</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/tcp%E6%98%AF%E4%BB%80%E4%B9%885.drawio.png" alt="TCP是什么"></p>
<p>这三个特点真的概括的<strong>非常精辟</strong>，这个八股文我们没白背。</p>
<p>每个特点展开都能聊一篇文章，而今天我们需要关注的是<strong>基于字节流</strong>这一点。</p>
<p>字节流可以理解为一个双向的通道里流淌的数据，这个<strong>数据</strong>其实就是我们常说的二进制数据，简单来说就是一大堆 <strong>01 串</strong>。纯裸TCP收发的这些 01 串之间是<strong>没有任何边界</strong>的，你根本不知道到哪个地方才算一条完整消息。</p>
<p><img src="https://cdn.xiaobaidebug.top/01%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AD%97%E8%8A%82%E6%B5%81.drawio.png" alt="01二进制字节流"></p>
<p>正因为这个没有<strong>任何边界</strong>的特点，所以当我们选择使用TCP发送**”夏洛”和”特烦恼”<strong>的时候，接收端收到的就是</strong>“夏洛特烦恼”<strong>，这时候接收端没发区分你是想要表达</strong>“夏洛”+”特烦恼”<strong>还是</strong>“夏洛特”+”烦恼”**。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E5%AF%B9%E6%AF%94_%E5%A4%8F%E6%B4%9B%E7%89%B9%E7%83%A6%E6%81%BC.drawio.png" alt="消息对比"></p>
<p>这就是所谓的<strong>粘包问题</strong>，之前也写过一篇专门的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">文章</a>聊过这个问题。</p>
<p>说这个的目的是为了告诉大家，纯裸TCP是不能直接拿来用的，你需要在这个基础上加入一些<strong>自定义的规则</strong>，用于区分<strong>消息边界</strong>。</p>
<p>于是我们会把每条要发送的数据都包装一下，比如加入<strong>消息头</strong>，<strong>消息头里写清楚一个完整的包长度是多少</strong>，根据这个长度可以继续接收数据，截取出来后它们就是我们真正要传输的<strong>消息体</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%B6%88%E6%81%AF%E8%BE%B9%E7%95%8C%E9%95%BF%E5%BA%A6%E6%A0%87%E5%BF%976.drawio.png" alt="消息边界长度标志"></p>
<p>而这里头提到的<strong>消息头</strong>，还可以放各种东西，比如消息体是否被压缩过和消息体格式之类的，只要上下游都约定好了，互相都认就可以了，这就是所谓的<strong>协议。</strong></p>
<p>每个使用TCP的项目都可能会定义一套类似这样的协议解析标准，他们可能<strong>有区别，但原理都类似</strong>。</p>
<p><strong>于是基于TCP，就衍生了非常多的协议，比如HTTP和RPC。</strong></p>
<br>

<h3 id="HTTP和RPC"><a href="#HTTP和RPC" class="headerlink" title="HTTP和RPC"></a>HTTP和RPC</h3><p>我们回过头来看网络的分层图。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE5.drawio.png" alt="四层网络协议"></p>
<p><strong>TCP是传输层的协议</strong>，而基于TCP造出来的HTTP和<strong>各类</strong>RPC协议，它们都只是定义了不同消息格式的<strong>应用层协议</strong>而已。</p>
<p><strong>HTTP</strong>协议（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer <strong>P</strong>rotocol），又叫做<strong>超文本传输协议</strong>。我们用的比较多，平时上网在浏览器上敲个网址就能访问网页，这里用到的就是HTTP协议。</p>
<p><img src="https://cdn.xiaobaidebug.top/HTTP%E8%B0%83%E7%94%A8.drawio.png" alt="HTTP调用"></p>
<p>而<strong>RPC</strong>（<strong>R</strong>emote <strong>P</strong>rocedure <strong>C</strong>all），又叫做<strong>远程过程调用</strong>。它本身并不是一个具体的协议，而是一种<strong>调用方式</strong>。</p>
<p>举个例子，我们平时调用一个<strong>本地方法</strong>就像下面这样。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = localFunc(req)</span><br></pre></td></tr></table></figure>

<p>如果现在这不是个本地方法，而是个<strong>远端服务器</strong>暴露出来的一个方法<code>remoteFunc</code>，如果我们还能像调用本地方法那样去调用它，这样就可以<strong>屏蔽掉一些网络细节</strong>，用起来更方便，岂不美哉？</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = remoteFunc(req)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.xiaobaidebug.top/RPC%E6%98%AF%E4%B8%80%E7%A7%8D%E8%B0%83%E7%94%A8%E6%96%B9%E5%BC%8F.drawio.png" alt="RPC可以像调用本地方法那样调用远端方法"></p>
<p>基于这个思路，大佬们造出了非常多款式的RPC协议，比如比较有名的<code>gRPC</code>，<code>thrift</code>。</p>
<p>值得注意的是，虽然大部分RPC协议底层使用TCP，但实际上<strong>它们不一定非得使用TCP，改用UDP或者HTTP，其实也可以做到类似的功能。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%9F%BA%E4%BA%8ETCP%E5%8D%8F%E8%AE%AE%E7%9A%84HTTP%E5%92%8CRPC%E5%8D%8F%E8%AE%AE.drawio.png" alt="基于TCP协议的HTTP和RPC协议"></p>
<br>

<p>到这里，我们回到文章标题的问题。</p>
<p><strong>既然有HTTP协议，为什么还要有RPC？</strong></p>
<p>其实，<code>TCP</code>是<strong>70年</strong>代出来的协议，而<code>HTTP</code>是<strong>90年代</strong>才开始流行的。而直接使用裸TCP会有问题，可想而知，这中间这么多年有多少自定义的协议，而这里面就有<strong>80年代</strong>出来的<code>RPC</code>。</p>
<p>所以我们该问的不是<strong>既然有HTTP协议为什么要有RPC</strong>，而是<strong>为什么有RPC还要有HTTP协议</strong>。</p>
<br>

<h4 id="那既然有RPC了，为什么还要有HTTP呢？"><a href="#那既然有RPC了，为什么还要有HTTP呢？" class="headerlink" title="那既然有RPC了，为什么还要有HTTP呢？"></a>那既然有RPC了，为什么还要有HTTP呢？</h4><p>现在电脑上装的各种<strong>联网</strong>软件，比如xx管家，xx卫士，它们都作为<strong>客户端（client）</strong>需要跟<strong>服务端（server）</strong>建立连接收发消息，此时都会用到应用层协议，在这种**client/server (c/s)**架构下，它们可以使用自家造的RPC协议，因为它只管连自己公司的服务器就ok了。</p>
<p>但有个软件不同，<strong>浏览器（browser）</strong>，不管是chrome还是IE，它们不仅要能访问自家公司的<strong>服务器（server）</strong>，还需要访问其他公司的网站服务器，因此它们需要有个统一的标准，不然大家没法交流。于是，HTTP就是那个时代用于统一 <strong>browser/server (b/s)</strong> 的协议。</p>
<p>也就是说在多年以前，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。</strong>很多软件同时支持多端，比如某度云盘，既要支持<strong>网页版</strong>，还要支持<strong>手机端和pc端</strong>，如果通信协议都用HTTP的话，那服务器只用同一套就够了。而RPC就开始退居幕后，一般用于公司内部集群里，各个微服务之间的通讯。</p>
<p>那这么说的话，<strong>都用HTTP得了，还用什么RPC？</strong></p>
<p>仿佛又回到了文章开头的样子，那这就要从它们之间的区别开始说起。</p>
<br>

<h3 id="HTTP和RPC有什么区别"><a href="#HTTP和RPC有什么区别" class="headerlink" title="HTTP和RPC有什么区别"></a>HTTP和RPC有什么区别</h3><p>我们来看看RPC和HTTP区别比较明显的几个点。</p>
<br>

<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>首先要向某个服务器发起请求，你得先建立连接，而建立连接的前提是，你得知道<strong>IP地址和端口</strong>。这个找到服务对应的IP端口的过程，其实就是<strong>服务发现</strong>。</p>
<p>在<strong>HTTP</strong>中，你知道服务的域名，就可以通过<strong>DNS服务</strong>去解析得到它背后的IP地址，默认80端口。</p>
<p>而<strong>RPC</strong>的话，就有些区别，一般会有专门的<strong>中间服务</strong>去保存服务名和IP信息，比如<strong>consul或者etcd，甚至是redis</strong>。想要访问某个服务，就去这些中间服务去获得IP和端口信息。由于dns也是服务发现的一种，所以也有基于dns去做服务发现的组件，比如<strong>CoreDNS</strong>。</p>
<p>可以看出服务发现这一块，两者是有些区别，但不太能分高低。</p>
<br>

<h4 id="底层连接形式"><a href="#底层连接形式" class="headerlink" title="底层连接形式"></a>底层连接形式</h4><p>以主流的<strong>HTTP1.1</strong>协议为例，其默认在建立底层TCP连接之后会一直保持这个连接（<strong>keep alive</strong>），之后的请求和响应都会复用这条连接。</p>
<p>而<strong>RPC</strong>协议，也跟HTTP类似，也是通过建立TCP长链接进行数据交互，但不同的地方在于，RPC协议一般还会再建个<strong>连接池</strong>，在请求量大的时候，建立多条连接放在池内，要发数据的时候就从池里取一条连接出来，<strong>用完放回去，下次再复用</strong>，可以说非常环保。</p>
<p><img src="https://cdn.xiaobaidebug.top/connection_pool3.drawio.png" alt="connection_pool"></p>
<p><strong>由于连接池有利于提升网络请求性能，所以不少编程语言的网络库里都会给HTTP加个连接池</strong>，比如<strong>go</strong>就是这么干的。</p>
<p>可以看出这一块两者也没太大区别，所以也不是关键。</p>
<br>

<h4 id="传输的内容"><a href="#传输的内容" class="headerlink" title="传输的内容"></a>传输的内容</h4><p>基于TCP传输的消息，说到底，无非都是<strong>消息头header和消息体body。</strong></p>
<p><strong>header</strong>是用于标记一些特殊信息，其中最重要的是<strong>消息体长度</strong>。</p>
<p><strong>body</strong>则是放我们真正需要传输的内容，而这些内容只能是二进制01串，毕竟计算机只认识这玩意。所以TCP传字符串和数字都问题不大，因为字符串可以转成编码再变成01串，而数字本身也能直接转为二进制。但结构体呢，我们得想个办法将它也转为二进制01串，这样的方案现在也有很多现成的，比如<strong>json，protobuf。</strong></p>
<p>这个将结构体转为二进制数组的过程就叫<strong>序列化</strong>，反过来将二进制数组复原成结构体的过程叫<strong>反序列化</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.drawio.png" alt="序列化和反序列化"></p>
<br>

<p>对于主流的HTTP1.1，虽然它现在叫<strong>超文本</strong>协议，支持音频视频，但HTTP设计初是用于做网页<strong>文本</strong>展示的，所以它传的内容以字符串为主。header和body都是如此。在body这块，它使用<strong>json</strong>来<strong>序列化</strong>结构体数据。</p>
<p>我们可以随便截个图直观看下。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220716212628672.png" alt="HTTP报文"></p>
<p>可以看到这里面的内容非常多的<strong>冗余</strong>，显得<strong>非常啰嗦</strong>。最明显的，像<code>header</code>里的那些信息，其实如果我们约定好头部的第几位是content-type，就<strong>不需要每次都真的把”content-type”这个字段都传过来</strong>，类似的情况其实在<code>body</code>的json结构里也特别明显。</p>
<p>而RPC，因为它定制化程度更高，可以采用体积更小的protobuf或其他序列化协议去保存结构体数据，同时也不需要像HTTP那样考虑各种浏览器行为，比如302重定向跳转啥的。<strong>因此性能也会更好一些，这也是在公司内部微服务中抛弃HTTP，选择使用RPC的最主要原因。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/HTTP%E5%8E%9F%E7%90%86.drawio.png" alt="HTTP原理"></p>
<p><img src="https://cdn.xiaobaidebug.top/RPC%E5%8E%9F%E7%90%86.drawio.png" alt="RPC原理"></p>
<p>当然上面说的HTTP，其实<strong>特指的是现在主流使用的HTTP1.1</strong>，<code>HTTP2</code>在前者的基础上做了很多改进，所以<strong>性能可能比很多RPC协议还要好</strong>，甚至连<code>gRPC</code>底层都直接用的<code>HTTP2</code>。</p>
<p>那么问题又来了。</p>
<br>

<h5 id="为什么既然有了HTTP2，还要有RPC协议？"><a href="#为什么既然有了HTTP2，还要有RPC协议？" class="headerlink" title="为什么既然有了HTTP2，还要有RPC协议？"></a>为什么既然有了HTTP2，还要有RPC协议？</h5><p>这个是由于HTTP2是2015年出来的。那时候很多公司内部的RPC协议都已经跑了好些年了，基于历史原因，一般也没必要去换了。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>纯裸TCP是能收发数据，但它是个<strong>无边界</strong>的数据流，上层需要定义<strong>消息格式</strong>用于定义<strong>消息边界</strong>。于是就有了各种协议，HTTP和各类RPC协议就是在TCP之上定义的应用层协议。</li>
<li><strong>RPC本质上不算是协议，而是一种调用方式</strong>，而像gRPC和thrift这样的具体实现，才是协议，它们是实现了RPC调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时RPC有很多种实现方式，<strong>不一定非得基于TCP协议</strong>。</li>
<li>从发展历史来说，<strong>HTTP主要用于b/s架构，而RPC更多用于c/s架构。但现在其实已经没分那么清了，b/s和c/s在慢慢融合。</strong>很多软件同时支持多端，所以对外一般用HTTP协议，而内部集群的微服务之间则采用RPC协议进行通讯。</li>
<li>RPC其实比HTTP出现的要早，且比目前主流的HTTP1.1<strong>性能</strong>要更好，所以大部分公司内部都还在使用RPC。</li>
<li><strong>HTTP2.0</strong>在<strong>HTTP1.1</strong>的基础上做了优化，性能可能比很多RPC协议都要好，但由于是这几年才出来的，所以也不太可能取代掉RPC。</li>
</ul>
<br>

<p>最后留个问题吧，大家有没有发现，不管是HTTP还是RPC，它们都有个特点，那就是消息都是客户端请求，服务端响应。<strong>客户端没问，服务端肯定就不答</strong>，这就有点僵了，但现实中肯定有需要<strong>下游主动发送消息给上游</strong>的场景，比如打个网页游戏，站在那啥也不操作，怪也会主动攻击我，这种情况该怎么办呢？</p>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41609070">https://www.zhihu.com/question/41609070</a></p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p>
<p>但还是算了。因为我最近一直在想一个问题，希望兄弟们能在<strong>评论区</strong>告诉我答案。</p>
<p>最近手机借给别人玩了一下午，现在老是给我推荐<strong>练习时长两年半的练习生</strong>视频。</p>
<p>每个视频都在声嘶力竭的告诉我，<strong>鸡你太美</strong>。</p>
<p>所以我很想问，兄弟们。</p>
<p><strong>鸡，到底美不美？</strong></p>
<p>头疼。</p>
<br>

<p><strong>右下角的点赞和再看还是可以走一波的。</strong></p>
<p>先这样。</p>
<p>我是小白，我们下期见。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/07/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E8%AF%A5%E8%80%83%E8%99%91%E7%A6%BB%E8%81%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/04/%E7%A8%8B%E5%BA%8F%E4%BA%BA%E7%94%9F/%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%A0%E8%AF%A5%E8%80%83%E8%99%91%E7%A6%BB%E8%81%8C/" class="post-title-link" itemprop="url">什么情况下你该考虑离职</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-04 22:57:55" itemprop="dateCreated datePublished" datetime="2022-07-04T22:57:55+08:00">2022-07-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:43:47" itemprop="dateModified" datetime="2022-10-30T10:43:47+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%AA%9A%E8%AF%9D%E8%BF%9E%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">骚话连篇</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<p>兄弟们！</p>
<p>出来讲骚话啊。</p>
<p><img src="https://cdn.xiaobaidebug.top/9e31678cgy1fn3oszal1xj20hr0m70u4.jpg"></p>
<br>

<p>大家都是打工人，尤其是我们互联网打工人，一般很少在一家公司待十年八年的。</p>
<p>一两年一跳很正常。</p>
<p>尤其是现在很多公司都没有普调，<strong>薪水入职即巅峰</strong>，所以在很长一段时间里，要涨薪只能靠跳槽，这话没啥毛病。</p>
<p>但问题来了。</p>
<p><strong>什么情况下你该考虑离职？</strong></p>
<br>

<p>之前听马老师提到过，一般离职就<strong>两个原因</strong>，<strong>钱给少了</strong>和<strong>心受委屈了</strong>。</p>
<p>可以说概括的相当精辟了，但这个偏<strong>主观</strong>因素多一点。</p>
<p>今天我想说的是离职的<strong>第三个原因：见势不妙</strong>。这个偏<strong>客观</strong>因素多一点。</p>
<p>很多时候，如果业务越做越凉，是有迹可循的。今天我们就来<strong>沉浸式</strong>体验一下这个过程。</p>
<p>看完你大概能知道<strong>什么情况下你该考虑离职了。</strong></p>
<br>

<h3 id="业务起步"><a href="#业务起步" class="headerlink" title="业务起步"></a>业务起步</h3><p>很多公司在某些业务上小赚了一笔之后，都会考虑开辟新的业务线，以期待这个新的业务线会成为新的收入增长点。而这时候，老板们就会观察当前行业的风口，大一点的公司还会有专门的部门做各种研究。</p>
<p>在多次ppt会议之后，最后也不知道是谁成功忽悠了谁。总之，老板显得有些深思熟虑，并在ppt的某页上重点画了一个圈，你以为这是个重点经济增长圈？</p>
<p>但其实，它只是个饼，圆一点的饼。</p>
<p>于是，一个新的业务线就这样，带着<strong>宏伟使命和伟大愿景</strong>来了。</p>
<p>干活，首先得先<strong>摇人</strong>，新的事业线<strong>放出了大量的HC</strong>（head count，人头数），那段时间，HR电话都打爆了。</p>
<p>而你也是在这次摇人中，加入到了这个具有伟大使命和宏大愿景的业务线里。</p>
<p>这之后，老板开了好几次<strong>动员会</strong>，一遍又一遍的重复着他做这番事业的初心，这个事情的社会价值，以及你们未来会是一个有多少万个小目标的公司。</p>
<p>老板这么说不要紧，那关键是你看到的网页新闻也是这么说。</p>
<p>公司放出更多HC疯狂<strong>扩招</strong>，显示出他们的决心。</p>
<p>各种晨会周会上，老板不断强调我们要<strong>加强内推</strong>，多搞点简历过来，太缺人了。</p>
<p><strong>“这件事，太有搞头了！”</strong></p>
<p>你心想，你就是下一个风口上的猪。闭上眼睛，你都能看到，自己以后跟各界互联网大佬手搭着肩，在ktv里哭着唱朋友一生一起走的画面了。</p>
<br>

<h3 id="业务中期"><a href="#业务中期" class="headerlink" title="业务中期"></a>业务中期</h3><p><strong>搞钱的事，怎么能在一棵树上干吊着呢？要多搞几棵树吊吊。</strong></p>
<p>于是本着<strong>养蛊</strong>的思路，公司开了更多同类型的细分业务，比如教育还能细分为小学教育，初中教育，再细分还能分为语文数学英语。这时候你会发现，业务变得越来越多了，你手上的需求也越来越多了。</p>
<p>你每天都在多线程切换，除了写代码，等待你的还有开不完的会，搞不完的oncall，有时候新来的产品还会天真无邪的找你一对一咨询各种产品细节。白天一晃而过，晚上8点之后，你才能开始安心写代码。</p>
<p>在这种高压环境下待个一年，恍如隔世，照个镜子，<strong>原来人间已经过了三年</strong>。相对论诚不欺我，爱因斯坦棺材板的压不住了。</p>
<p>一般这种时候，你负责的<strong>老服务会越来越多，但新服务和新需求还在不停开发中。</strong>你在写新需求的同时还得处理各种老服务的问题和咨询。</p>
<p>产品开始吐槽你们开发越来越慢，为了加快需求的吞吐量，项目组<strong>从双周迭代改为了单周迭代</strong>。</p>
<p>这直接就是煽风点火了。</p>
<p>只要老服务出啥问题了，你原本绷紧的开发排期就得变得更脆。只要有一个需求延期了，那你后面就等着加班到天明吧。</p>
<p>很多项目在不断试错的过程中，过程中需要查看各种业务指标数据，产品、运营都会轮番要你写脚本算数据，只为说明他们拍大腿想出来的需求，是有数据支撑的，是reasonable的。</p>
<p>教育行业就更古怪，连教研老师都能给你提需求。</p>
<p>这种情况，在每个季度结束的时候会变得特别严重，你在用生命在为他们完成kpi，你可真是互联网活雷锋。</p>
<p>雷锋做好事还知道写日记，你做的这些个事情，到底要不要写进周报好呢？</p>
<p>下班的路上，你拖着疲惫的身体，背着个电脑，开着小电瓶，在路灯的晃射下，你看到了路边的狗，你都一度怀疑，是不是连它，都能给你提需求。</p>
<p>你回想起，刚毕业的那会，那时候你虽然很穷，但你很快乐，现在不一样了，<strong>你还是很穷，但你不快乐了</strong>。</p>
<p>你总有开不完的会，做不完的需求，你一度想着<strong>要不离职算了</strong>。但每次这种时候，大老板就正好<strong>调整一波组织架构</strong>，然后发表下他这次调整架构的思考和决心，会议的最后再次回到诉说初心，然后展望愿景和理想的环节。</p>
<p>这是这一年里，<strong>第4次</strong>调整组织架构和方向了，你开始在想老板是不是连自己都没想清楚，但你看老板回答各种问题时，那笃定睿智的神情，你又感觉你行了，坚持下吧，说不定这次真的能行呢！</p>
<br>

<h3 id="业务后期"><a href="#业务后期" class="headerlink" title="业务后期"></a>业务后期</h3><p>古人说，公司内的消息要在公司外的八卦平台上才能看到。</p>
<p>古人诚不欺你，某天，你在某知名互联网茶水间app某脉上看到了自家公司正在裁员的消息，而裁员的对象，正好是你所在的业务线方向。</p>
<p>虽然<strong>身边陆续有同事在开始慢慢离职</strong>，之前合作对接过的几个开发老哥内部账号也变成了离职状态。</p>
<p>甚至连竞品的股价都开始在暴跌。</p>
<p>但你都没在意，因为你现在做的事情挺多的，哪有时间管这些。</p>
<p>唯一让你感到痛心疾首的是，<strong>坐门口的爱穿黑丝的小姐姐，突然有天也不见了</strong>。</p>
<p>那天傍晚，你的领导找组里的小伙伴们出去吃顿饭。吃到一半，你左手韭菜，右手羊腰子，<strong>领导却站起来说他要离职的事情</strong>，你突然愣神。反应过来时，大家正说着祝福的话，举起酒杯，好言相送，你看着杯子里的加多宝，又再一次陷入了慌神。</p>
<p>老领导走了，新领导上来第一件事就是盘点项目组的资源使用情况，每个服务使用了多少cpu和内存，能缩容就缩容。是的，他要搞<strong>降本提效</strong>。</p>
<p>降着降着，可能发现原来<strong>人</strong>才是最大的支出。于是你发现，不少业务线都消失了，不少人也走了。你手上接了越来越多别人交接过来的项目，从前五个人干的活，现在让你一个人干，你有些吃不消。老板说后面肯定会招人。但你很清楚，<strong>很长时间部门好像都没有面试了</strong>，以前周会每次都会提一下让大家内推一些简历，现在也不再提了。再后来，你听说业务线<strong>HC被锁了</strong>，不再招人，<strong>甚至连转岗都不让转了</strong>。</p>
<br>

<p>再后来，你发现业务的需求越来越少了，你以为终于可以闲下来摸鱼了，但这时候你的新领导开始推大家<strong>开始重构服务</strong>了，他说”之前我们跑太快了，一直在堆屎山，现在业务的活少了，正是我们重新思考架构，降本提效的好时候！”。</p>
<p>于是你们又开始了一轮新的折腾，你听老员工说: “<strong>以前完成业务的需求，给业务提供价值就是老板的KPI，那现在业务都没了，老板不折腾下重构，那哪来的kpi</strong>“。</p>
<p>知道真相的你眼泪掉下来。</p>
<p>这时候，你终于想走了，可一想到<strong>再坚持下就发年终奖了</strong>，这么辛苦都过来了，再忍几个月吧。</p>
<p>发年终奖可是个大开支啊，降本提效可是老板的kpi啊，于是你发现身边的同事慢慢变少。</p>
<p>直到那天你收到老板发来的消息：”<strong>空吗？我们来聊下绩效</strong>“。</p>
<p>如无意外，他觉得你绩效不好，要你签一份**<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/fuQAAjOMYW1tzyujh7GOHQ">PIP</a>协议<strong>，你很清楚</strong>这玩意签了就等于承认自己不行，离职连N+x都没有**。但你也无力反抗，你很清楚什么叫”欲加之罪，何患无辞”。</p>
<br>

<h3 id="什么时候该离职"><a href="#什么时候该离职" class="headerlink" title="什么时候该离职"></a>什么时候该离职</h3><p>你开始脑袋放空，过往发生的每一件事都像碎片那样串联了起来。明明有那么多迹象告诉你，快跑。但你都视而不见。</p>
<p><strong>“早知道我半年前就跑了”</strong></p>
<p>可是问题来了。</p>
<p>如果再让你回到半年前，你身处在一个<strong>温水煮青蛙</strong>的环境，你怎么知道该不该跑。</p>
<p>我们重新梳理一遍过往发生的事情。</p>
<p><strong>大环境舆论热议风口 → 开新业务，领导鼓励拉人内推  →  业务变多，开发很累但人员不断在补充  → 架构不断调整  →  工作主要以完成需求支持业务为主  →  大环境变差，政策变更，竞品或自家股票暴跌  →  业务可见的萎缩 ，不再强调内推  → 架构调整，信心鼓励 → 活很多，但就是不招人 →  hc锁死，人员只出不进→ 领导跑路，换新领导  → 资源盘点，提倡降本提效 → 业务量变少，重构之类的活排上日程 → 身边的人陆续离职 →  年终奖将近，身边出现大批人员离职  →  轮到你了  →  留下来的人接手离职人员的活，过得更苦了  →   团队裁员或部门打包转岗。</strong></p>
<p>这里其实涉及到<strong>一个业务线从0到0.7再到0的完整过程</strong>，任何一个时间节点，在会议上都是一片欣欣向荣的场面，就算是最后团队裁员，说的也是充满信心的话。</p>
<p><strong>但你不必看老板们说什么，你看老板们做什么就够了，行动永远比话语诚实。</strong></p>
<ul>
<li><p><strong>公司业务组织架构疯狂调整</strong>，一年能折腾个三四次，说明老板都没想清楚一件事要怎么做，所以想要拍大腿疯狂试错。不赚钱的业务才会不断折腾，<strong>赚钱的业务永远以稳定盈利为主要目标</strong>。这时候你就该明白这个业务线大概率不太能做出来了，<strong>如果你加入这个公司的目的是妄想暴富的话，那该醒过来了，该考虑刷题了</strong>。</p>
</li>
<li><p><strong>领导离职</strong>。这个要分情况，如果项目赚钱了，那可能只是宫斗，这种情况不考虑。但如果是不赚钱的项目，不管是领导是主动还是被动离职，这都不是什么好事情。如果是主动离职，如果一件事有搞头，你会想要跑吗？领导永远比你更接近第一手消息，而且能做到领导位置，那肯定目光和判断力要比你更强，连他都觉得没搞头，那你还不快跑？被动离职，这个更明显，搞事业，最忌讳中途换帅，但凡有点希望，也不至于这么搞。这时候你该明白，老板的老板已经慢慢失去耐心。这时候，<strong>八股文该背起来了</strong>。</p>
</li>
<li><p><strong>HC锁死</strong>，说明从公司层面上，就不会再继续加大投入人力，对这个业务已经慢慢失去信心。如果现在离年终奖还远，<strong>简历改起来啊，你该考虑转岗或跑路了</strong>。</p>
</li>
<li><p><strong>锁死转岗</strong>，这种时候多发生在后半年，大部分有<strong>求生经验</strong>的人，不想失去年终奖，于是选择活水到其他业务线，这样还能保住年终奖，走不走明年再做打算。但这样的转岗太多了，会导致原来就可能要凉的业务线凉的更快，于是大老板就会选择冻结转岗。这时候如果离年终还远，那球球了，<strong>投简历吧</strong>。如果临近年终，那我劝你苟住，但如果不得不得跑，对面公司出于人道主义关怀，可能会有一笔<strong>签字费</strong>作为损失年终奖的激励or补偿，记得谈一谈。</p>
</li>
</ul>
<p><strong>如果你在转岗锁死前，能成功转岗或离职，那你一般损失会小一些。</strong>在这之后，走运些的老哥能被辞退拿个N+X赔偿，体面离开，但这个纯纯看运气。不走运的，等待你的只有超多离职老哥留下的活，以及老板的<strong>PUA或PIP关怀套餐</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/006m97Kgly1ft9rx3wg9uj309j09qmxm-20220704214907793.jpg"></p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我之前写过一篇关于PIP的文章，发在了某乎上，让我意外的是，最近时不时会有老哥看到后私信问我该怎么办，貌似最近大行情变差了，用这种方式劝退的公司越来越多了。</p>
<p>这是个<strong>屁股决定脑袋</strong>的世界，在老板视角里，用pip劝退员工可以省下赔款，如果他不能辞退足够多的人，他的绩效和年终就不好看，自己的利益当然比他人的利益重要。在员工视角里，用pip劝退员工的老板真实丧良心，但记住，没有人可以逼你签任何协议。<strong>大家做的都没错，都是各自系统的最优解。</strong></p>
<br>

<p>很多行业，你去之前都说是风口，去了之后就凉了，你以为你拿的是主角的剧本，结果连跑龙套都算不上。你也不想当行业冥灯，可人生如戏。</p>
<p><strong>还真是应了《桃花扇》里的那句唱词 “眼看他起高楼，眼看他宴宾客，眼看他楼塌了”。</strong></p>
<p>深夜网抑云，破防了兄弟们。</p>
<p>但发牢骚并不能解决问题，该<strong>想想自己能从这次经历中学到什么？</strong></p>
<p>一个要凉的业务，它总是会有一些苗头和规律的。今天这篇文章就是讲的这个，不过我相信，就算我告诉你，你也不会信的，<strong>每个人都总觉得自己是例外，</strong>每个人都觉得自己不会在厕所里边吃边哭。</p>
<p>就像每个舔狗追女神的时候，总感觉自己在她心里是不一样的。这里涉及到一个叫<strong>沉没成本</strong>的概念，不再展开。</p>
<p>你执意要去山的对面看看海，我很想告诉你山的对面没有海，但我知道，<strong>就算我说了，你也是不会信的，你需要亲自去看看。</strong></p>
<br>

<h3 id="多说两句"><a href="#多说两句" class="headerlink" title="多说两句"></a>多说两句</h3><p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p>
<p>但我今天不想。</p>
<p>点一个<strong>赞</strong>，愿世界和平。</p>
<p>点一个<strong>在看</strong>，愿所有的伤痛都由发pip的那个人承担。</p>
<p><img src="https://cdn.xiaobaidebug.top/006APoFYly8gqby8ik6hgj30fa0hstft.jpg"></p>
<p>我是小白，我们下期见。</p>
<br>



<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E5%B0%8F%E7%99%BDdebug%E5%8A%A8%E5%9B%BE%E4%BA%8C%E7%BB%B4%E7%A0%81-20210908204913011.gif"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" width = "50%"   align=center />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/06/30/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/30/%E5%9B%BE%E8%A7%A3mysql/%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E7%9A%84count()%E6%96%B9%E6%B3%95%E8%BF%99%E4%B9%88%E6%85%A2%EF%BC%9F/" class="post-title-link" itemprop="url">为什么mysql的count()方法这么慢？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-30 22:57:55" itemprop="dateCreated datePublished" datetime="2022-06-30T22:57:55+08:00">2022-06-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:50:37" itemprop="dateModified" datetime="2022-10-30T10:50:37+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3mysql/" itemprop="url" rel="index"><span itemprop="name">图解mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<p><img src="https://cdn.xiaobaidebug.top/9a9f7046fbb668643c3466b50354a569.gif"></p>
<p>兄弟们。</p>
<p>浅浅的<strong>炫个富</strong>吧。</p>
<p>说出来你们可能不信。</p>
<p>手机你们有吗？我有。</p>
<p><strong>短信</strong>，知道吧？一条一毛钱，<strong>我天天发</strong>。</p>
<p>你敢想吗？</p>
<p>所以说，年轻人，有钱是真的好。</p>
<p>今天，我们就以短信为话题聊起。</p>
<p>短信，它又叫SMS。</p>
<br>

<p>比如说，你有一张**短信表(sms)**，里面放了各种需要发送的短信信息。</p>
<p><img src="https://cdn.xiaobaidebug.top/sms%E5%BB%BA%E8%A1%A8sql.png" alt="sms建表sql"></p>
<p><img src="https://cdn.xiaobaidebug.top/sms%E8%A1%A8.drawio.png" alt="sms表"></p>
<p>需要注意的是<strong>state字段，为0的时候说明这时候短信还未发送。</strong></p>
<p>此时还会有一个<strong>异步线程</strong>不断的捞起<strong>未发送（state=0）</strong>的短信数据，执行发短信操作，发送成功之后state字段会被<strong>置为1（已发送）</strong>。也就是说<strong>未发送的数据会不断变少</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E7%9F%AD%E4%BF%A1.drawio.png" alt="异步线程发送短信"></p>
<br>

<p>假设由于某些原因，你现在需要做一些监控，比如监控的内容是，<strong>你的sms数据表里还有没有state=0（未发送）的短信，方便判断一下堆积的未发送短信大概在什么样的一个量级。</strong></p>
<p>为了获取<strong>满足某些条件的行数是多少</strong>，我们一般会使用<strong>count()方法</strong>。</p>
<p>这时候为了获取未发送的短信数据，我们很自然就想到了使用下面的sql语句进行查询。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> sms <span class="keyword">where</span> state <span class="operator">=</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>然后再把获得数据作为打点发给监控服务。</p>
<br>

<p>当数据表小的时候，这是没问题的，但当数据量大的时候，比如未发送的短信到了<strong>百万量级</strong>的时候，你就会发现，<strong>上面的sql查询时间会变得很长，最后timeout报错，查不出结果了</strong>。</p>
<br>

<p>为什么？</p>
<br>

<p>我们先从<strong>count()方法的原理</strong>聊起。</p>
<br>

<h3 id="count-的原理"><a href="#count-的原理" class="headerlink" title="count()的原理"></a>count()的原理</h3><p>count()方法的目的是计算当前sql语句查询得到的<strong>非NULL的行数</strong>。</p>
<p>我们知道mysql是分为<strong>server层和存储引擎层的</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/Mysql%E6%9E%B6%E6%9E%8456.drawio-20220613163829373.png" alt="Mysql架构"></p>
<p>存储引擎层里可以选择各种引擎进行存储，最常见的是innodb、myisam。具体使用哪个存储引擎，可以通过建表sql里的<code>ENGINE</code>字段进行指定。比如这篇文章开头的建表sql里用了<code>ENGINE=InnoDB</code>，那这张表用的就是innodb引擎。</p>
<p><strong>虽然在server层都叫count()方法，但在不同的存储引擎下，它们的实现方式是有区别的。</strong></p>
<p>比如同样是<strong>读全表数据</strong>  <code>select count(*) from sms；</code>语句。</p>
<p>使用 <strong>myisam引擎</strong>的数据表里有个记录当前表里有几行数据的字段，直接读这个字段返回就好了，因此速度快得飞起。</p>
<p>而使用<strong>innodb引擎</strong>的数据表，则会选择<strong>体积最小的索引树</strong>，然后通过遍历叶子节点的个数挨个加起来，这样也能得到全表数据。</p>
<p>因此回到文章开头的问题里，当数据表行数变大后，<strong>单次count就需要扫描大量的数据</strong>，因此很可能就会出现超时报错。</p>
<br>



<p>那么问题就来了。</p>
<br>

<h4 id="为什么innodb不能像myisam那样实现count-方法"><a href="#为什么innodb不能像myisam那样实现count-方法" class="headerlink" title="为什么innodb不能像myisam那样实现count()方法"></a><strong>为什么innodb不能像myisam那样实现count()方法</strong></h4><p>myisam和innodb这两个引擎，有几个比较明显的区别，这个是八股文常考了。</p>
<p>其中<strong>最大的区别在于myisam不支持事务，而innodb支持事务。</strong></p>
<p>而事务，有四层隔离级别，其中<strong>默认隔离级别就是可重复读隔离级别（RR）</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%9B%9B%E5%B1%82%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.png" alt="四层隔离级别"></p>
<p>innodb引擎通过MVCC实现了<strong>可重复隔离级别</strong>，事务开启后，多次执行同样的<strong>select快照读</strong>，要能读到同样的数据。</p>
<p>于是我们看个例子。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BA%E4%BB%80%E4%B9%88innodb%E4%B8%8D%E5%8D%95%E7%8B%AC%E8%AE%B0%E5%BD%95%E8%A1%A8%E8%A1%8C%E6%95%B0.drawio.png" alt="为什么innodb不单独记录表行数"></p>
<p>对于两个事务A和B，一开始sms表假设就<strong>2条</strong>数据，那事务A一开始确实是读到2条数据。事务B在这期间插入了1条数据，按道理数据库其实有3条数据了，但由于可重复读的隔离级别，事务A依然还是只能读到2条数据。</p>
<p>因此由于事务隔离级别的存在，<strong>不同的事务在同一时间下，看到的表内数据行数是不一致的</strong>，因此innodb，没办法，也没必要像myisam那样单纯的加个count字段信息在数据表上。</p>
<p>那如果不可避免要使用count()，有没有办法让它快一点？</p>
<br>

<h3 id="各种count-方法的原理"><a href="#各种count-方法的原理" class="headerlink" title="各种count()方法的原理"></a>各种count()方法的原理</h3><p>count()的括号里，可以放各种奇奇怪怪的东西，想必大家应该看过，比如放个星号*，放个1，放个索引列啥的。</p>
<p>我们来分析下他们的执行流程。</p>
<p><strong>count方法的大原则是server层会从innodb存储引擎里读来一行行数据，并且只累计非null的值</strong>。但这个过程，根据count()方法括号内的传参，有略有不同。</p>
<br>

<h4 id="count"><a href="#count" class="headerlink" title="count(*)"></a>count(*)</h4><p>server层拿到innodb返回的行数据，<strong>不对里面的行数据做任何解析和判断</strong>，默认取出的值肯定都不是null，直接行数+1。</p>
<br>

<h4 id="count-1"><a href="#count-1" class="headerlink" title="count(1)"></a>count(1)</h4><p>server层拿到innodb返回的行数据，每行放个1进去，默认不可能为null，直接行数+1.</p>
<br>

<h4 id="count-某个列字段"><a href="#count-某个列字段" class="headerlink" title="count(某个列字段)"></a>count(某个列字段)</h4><p>由于指明了要count某个字段，innodb在取数据的时候，会把这个字段<strong>解析出来</strong>返回给server层，所以会<strong>比count(1)和count(*)多了个解析字段出来的流程。</strong></p>
<ul>
<li>如果这个列字段是<strong>主键id</strong>，主键是不可能为null的，所以server层也不用判断是否为null，innodb每返回一行，行数结果就+1.</li>
<li>如果这个列是<strong>普通索引字段</strong>，innodb一般会<strong>走普通索引</strong>，每返回一行数据，server层就会判断这个字段是否为null，不是null的情况下+1。当然如果建表sql里字段定义为not null的话，那就不用做这一步判断直接+1。</li>
<li>如果这个列<strong>没有加过索引</strong>，那innodb可能会全表扫描，返回的每一行数据，server层都会判断这个字段是否为null，不是null的情况下+1。同上面的情况一样，字段加了not null也就省下这一步判断了。</li>
</ul>
<p>理解了原理后我们大概可以知道他们的性能排序是</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">count</span>(<span class="operator">*</span>) ≈ <span class="built_in">count</span>(<span class="number">1</span>) <span class="operator">&gt;</span> <span class="built_in">count</span>(主键id) <span class="operator">&gt;</span> <span class="built_in">count</span>(普通索引列) <span class="operator">&gt;</span> <span class="built_in">count</span>(未加索引列)</span><br></pre></td></tr></table></figure>

<p><strong>所以说count(*)，已经是最快的了。</strong></p>
<br>

<p>知道真相的我眼泪掉下来。</p>
<img src="https://cdn.xiaobaidebug.top/u=3123397807,3516361318&fm=253&fmt=auto&app=138&f=JPEG.jpeg" style="zoom:50%;" />

<p>那有没有其他更好的办法？</p>
<br>

<h3 id="允许粗略估计行数的场景"><a href="#允许粗略估计行数的场景" class="headerlink" title="允许粗略估计行数的场景"></a>允许粗略估计行数的场景</h3><p>我们回过头来细品下文章开头的需求，我们只是希望知道数据库里还有多少短信是堆积在那没发的，具体是1k还是2k其实都是差不多量级，等到了百万以上，具体数值已经不重要了，我们知道它现在堆积得很离谱，就够了。 因此这个场景，其实是允许使用<strong>比较粗略</strong>的估计的。</p>
<p><strong>那怎么样才能获得粗略的数值呢？</strong></p>
<p>还记得我们平时为了查看sql执行计划用的<strong>explain命令</strong>不。</p>
<p>其中有个<strong>rows</strong>，会用来<strong>估计</strong>接下来执行这条sql需要扫描和检查多少行。它是通过采样的方式计算出来的，虽然会有一定的偏差，但它能反映一定的数量级。</p>
<p><img src="https://cdn.xiaobaidebug.top/explain%E9%87%8C%E7%9A%84rows.png" alt="explain里的rows"></p>
<p>有些语言的orm里可能没有专门的explain语法，但是肯定有执行raw sql的功能，你<strong>可以把explain语句当做raw sql传入，从返回的结果里将rows那一列读出来使用。</strong></p>
<p>一般情况下，explain的sql如果能走索引，那会比不走索引的情况更准 。单个字段的索引会比多个字段组成的复合索引要准。索引区分度越高，rows的值也会越准。</p>
<p>这种情况几乎满足大部分的监控场景。但总有一些场景，它要求必须得到精确的行数，这种情况该怎么办呢？</p>
<br>

<h3 id="必须精确估计行数的场景"><a href="#必须精确估计行数的场景" class="headerlink" title="必须精确估计行数的场景"></a>必须精确估计行数的场景</h3><p>这种场景就比较头疼了，但也不是不能做。</p>
<p>我们可以单独拉一张新的数据库表，只为保存各种场景下的count。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `count_table` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `cnt_what` <span class="type">char</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;各种需要计算的指标&#x27;</span>,</span><br><span class="line">  `cnt` tinyint <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;cnt指标值&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">  KEY `idx_cnt_what` (`cnt_what`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.xiaobaidebug.top/%E4%BF%9D%E5%AD%98%E5%90%84%E7%A7%8D%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84count.drawio.png" alt="count_table表保存各种场景下的count"></p>
<p>当需要获取某个场景下的cout值时，可以使用下面的sql进行直接读取，<strong>快得飞起</strong>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> cnt <span class="keyword">from</span> count_table <span class="keyword">where</span> cnt_what <span class="operator">=</span> &quot;未发送的短信数量&quot;; </span><br></pre></td></tr></table></figure>

<br>

<p><strong>那这些count的结果值从哪来呢？</strong></p>
<p>这里分成两种情况。</p>
<br>

<h4 id="实时性要求较高的场景"><a href="#实时性要求较高的场景" class="headerlink" title="实时性要求较高的场景"></a>实时性要求较高的场景</h4><p>如果你对这个cnt计算结果的实时性要求很高，那你需要<strong>将更新cnt的sql加入到对应变更行数的事务中</strong>。</p>
<p>比如我们有两个事务A和B，分别是增加未发送短信和减少未发送短信。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%B0%86%E6%9B%B4%E6%94%B9%E8%A1%A8%E8%A1%8C%E6%95%B0%E7%9A%84%E6%93%8D%E4%BD%9C%E6%94%BE%E5%85%A5%E5%88%B0%E4%BA%8B%E5%8A%A1%E9%87%8C.drawio.png" alt="将更改表行数的操作放入到事务里"></p>
<p>这样做的<strong>好处</strong>是事务内的cnt行数依然符合隔离级别，事务回滚的时候，cnt的值也会跟着回滚。</p>
<p><strong>坏处</strong>也比较明显，多个线程对同一个cnt进行写操作，会触发悲观锁，多个线程之间需要互相等待。对于<strong>高频写的场景</strong>，性能会有折损。</p>
<br>

<h4 id="实时性没那么高的场景"><a href="#实时性没那么高的场景" class="headerlink" title="实时性没那么高的场景"></a>实时性没那么高的场景</h4><p>如果实时性要求不高的话，比如可以一天一次，那你可以通过全表扫描后做计算。</p>
<p>举个例子，比如上面的短信表，可以<strong>按id排序</strong>，每次取出1w条数据，<strong>记下这一批里最大的id，然后下次从最大id开始再拿1w条数据出来，不断循环。</strong></p>
<p>对于未发送的短信，就只需要在捞出的那1w条数据里，筛选出state=0的条数。</p>
<p><img src="https://cdn.xiaobaidebug.top/batch%E5%88%86%E6%89%B9%E8%8E%B7%E5%8F%96%E7%9F%AD%E4%BF%A1%E8%A1%A8.drawio.png" alt="batch分批获取短信表"></p>
<p>当然如果有条件，这种场景最好的方式还是<strong>消费binlog将数据导入到hive里</strong>，然后在hive里做查询，不少公司也已经有现成的组件可以做这种事情，不用自己写脚本，岂不美哉。</p>
<p><img src="https://cdn.xiaobaidebug.top/mysql%E5%90%8C%E6%AD%A5hive.drawio.png" alt="mysql同步hive"></p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>mysql用count方法<strong>查全表数据</strong>，在不同的存储引擎里实现不同，myisam有专门字段记录全表的行数，直接读这个字段就好了。而innodb则需要一行行去算。</p>
</li>
<li><p>性能方面 <code>count(*) ≈ count(1) &gt; count(主键id) &gt; count(普通索引列) &gt; count(未加索引列)</code>，但哪怕是性能最好的count(*)，由于实现上就需要一行行去算，所以数据量大的时候就是不给力。</p>
</li>
<li><p>如果确实需要获取行数，且<strong>可以接受不那么精确的行数（只需要判断大概的量级）</strong>的话，那可以用explain里的rows，这可以满足大部分的监控场景，实现简单。</p>
</li>
<li><p><strong>如果要求行数准确</strong>，可以建个新表，里面专门放表行数的信息。</p>
<ul>
<li>如果对<strong>实时性要求比较高</strong>的话，可以将更新行数的sql放入到对应事务里，这样既能满足事务隔离性，还能快速读取到行数信息。</li>
<li>如果对<strong>实时性要求不高</strong>，接受一小时或者一天的更新频率，那既可以自己写脚本遍历全表后更新行数信息。也可以将通过监听binlog将数据导入hive，需要数据时直接通过hive计算得出。</li>
</ul>
</li>
</ul>
<br>

<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>《丁奇mysql45讲》</p>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>兄弟们，最近有点没出息，沉迷在刘亦菲的新剧里，都快忘了写文这件事了。</p>
<p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p>
<p>但今天，我感觉我不配。</p>
<p>所以先这样。</p>
<br>

<p>但右下角的点赞和再看还是可以走一波的。</p>
<p>我是小白，我们下期见。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/06/14/%E5%9B%BE%E8%A7%A3mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E8%A6%81%E8%87%AA%E5%A2%9E%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%8D%E8%87%AA%E5%A2%9E%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%A2%9E%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/14/%E5%9B%BE%E8%A7%A3mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E9%94%AE%E4%B8%80%E5%AE%9A%E8%A6%81%E8%87%AA%E5%A2%9E%E7%9A%84%E5%90%97%EF%BC%9F%E4%B8%8D%E8%87%AA%E5%A2%9E%E8%A1%8C%E4%B8%8D%E8%A1%8C%EF%BC%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%BA%E6%99%AF%E4%B8%8B%E4%B8%8D%E5%BB%BA%E8%AE%AE%E8%87%AA%E5%A2%9E%EF%BC%9F/" class="post-title-link" itemprop="url">数据库主键一定要自增的吗？有哪些场景下不建议自增？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-14 22:57:55" itemprop="dateCreated datePublished" datetime="2022-06-14T22:57:55+08:00">2022-06-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:44:18" itemprop="dateModified" datetime="2022-10-30T10:44:18+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9B%BE%E8%A7%A3mysql/" itemprop="url" rel="index"><span itemprop="name">图解mysql</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【面试】获面试题集。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<br>

<p>我们平时建表的时候，一般会像下面这样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB  <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p>出于习惯，我们一般会加一列<strong>id作为主键</strong>，而这个主键一般边上都有个<code>AUTO_INCREMENT</code>, 意思是这个主键是自增的。自增就是i++，也就是每次都加1。</p>
<p>但问题来了。</p>
<p><strong>主键id不自增行不行？</strong></p>
<p><strong>为什么要用自增id做主键？</strong></p>
<p><strong>离谱点，没有主键可以吗？</strong></p>
<p><strong>什么情况下不应该自增？</strong></p>
<br>

<p>被这么一波追问，念头都不通达了？</p>
<p>这篇文章，我会尝试回答这几个问题。</p>
<br>

<h3 id="主键不自增行不行"><a href="#主键不自增行不行" class="headerlink" title="主键不自增行不行"></a>主键不自增行不行</h3><p>当然是可以的。比如我们可以把建表sql里的<code>AUTO_INCREMENT</code>去掉。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `id` <span class="type">int</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p>然后执行 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`name`)  <span class="keyword">VALUES</span>	(<span class="string">&#x27;debug&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>这时候会报错<code>Field &#39;id&#39; doesn&#39;t have a default value</code>。也就是说如果你不让主键自增的话，那你在写数据的时候需要自己指定id的值是多少，想要主键id是多少就写多少进去，不写就报错。</p>
<p>改成下面这样就好了</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `<span class="keyword">user</span>` (`id`,`name`)  <span class="keyword">VALUES</span>	(<span class="number">10</span>, <span class="string">&#x27;debug&#x27;</span>);</span><br></pre></td></tr></table></figure>





<br>

<h3 id="为什么要用自增主键"><a href="#为什么要用自增主键" class="headerlink" title="为什么要用自增主键"></a>为什么要用自增主键</h3><p>我们在数据库里保存的数据就跟excel表一样，一行行似的。</p>
<p><img src="https://cdn.xiaobaidebug.top/user%E8%A1%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E5%A7%8B%E7%8A%B6%E6%80%812.drawio.png" alt="user表"></p>
<p>而在底层，这一行行数据，就是保存在一个个<strong>16k大小的页</strong>里。</p>
<p>每次都去遍历所有的行性能会不好，于是为了加速搜索，我们可以<strong>根据主键id，从小到大排列这些行数据</strong>，将这些数据页用<strong>双向链表</strong>的形式组织起来，再将这些页里的部分信息提取出来放到一个新的16kb的数据页里，再加入<strong>层级的概念</strong>。于是，一个个数据页就被组织起来了，成为了一棵<strong>B+树索引</strong>。</p>
<p><img src="https://cdn.xiaobaidebug.top/B%E5%8A%A0%E6%A0%91%E7%BB%93%E6%9E%847.drawio.png" alt="B+树结构"></p>
<p>而当我们在建表sql里声明了<code>PRIMARY KEY (id)</code>时，mysql的innodb引擎，就会为主键id生成一个<strong>主键索引</strong>，里面就是通过B+树的形式来维护这套索引。</p>
<p>到这里，我们有<strong>两个点</strong>是需要关注的：</p>
<ul>
<li>数据页大小是<strong>固定16k</strong></li>
<li>数据页内，以及数据页之间，数据主键id都是从<strong>小到大排序</strong>的</li>
</ul>
<p>由于数据页大小<strong>固定了是16k</strong>，当我们需要插入一条新的数据，数据页会被慢慢<strong>放满</strong>，当超过16k时，这个数据页就有可能会进行<strong>分裂</strong>。</p>
<p>针对B+树<strong>叶子节点</strong>，<strong>如果主键是自增的</strong>，那它产生的id每次都比前一次要大，所以每次都会将数据加在B+树<strong>尾部</strong>，B+树的叶子节点本质上是<strong>双向链表</strong>，查找它的首部和尾部，**时间复杂度O(1)**。而如果此时最末尾的数据页满了，那创建个新的页就好。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%8F%B6%E5%AD%90%E6%BB%A1%E4%BA%86%E4%BD%86%E9%9D%9E%E5%8F%B6%E5%AD%90%E6%9C%AA%E6%BB%A1.drawio-20220606092636547.png" alt="主键id自增的情况"></p>
<p><strong>如果主键不是自增的</strong>，比方说上次分配了id=7，这次分配了id=3，为了让新加入数据后<strong>B+树的叶子节点还能保持有序</strong>，它就需要往叶子结点的中间找，查找过程的<strong>时间复杂度是O(lgn)<strong>，如果这个页正好也满了，这时候就需要进行</strong>页分裂</strong>了。并且页分裂操作本身是需要加<strong>悲观锁</strong>的。总体看下来，自增的主键遇到页分裂的可能性更少，因此性能也会更高。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E4%B8%BB%E9%94%AEid%E4%B8%8D%E8%87%AA%E5%A2%9E%E7%9A%84%E6%83%85%E5%86%B5.drawio.png" alt="主键id不自增的情况"></p>
<br>

<h3 id="没有主键可以吗"><a href="#没有主键可以吗" class="headerlink" title="没有主键可以吗"></a>没有主键可以吗</h3><p>mysql表如果没有主键索引，查个数据都得全表扫描，那既然它这么重要，我今天就不当人了，<strong>不声明主键，可以吗？</strong></p>
<p>嗯，你完全可以不声明主键。</p>
<p>你确实可以在建表sql里写成这样。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">  `name` <span class="type">char</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;名字&#x27;</span></span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4;</span><br></pre></td></tr></table></figure>

<p>看起来确实是没有主键的样子。然而实际上，mysql的innodb引擎内部会帮你生成一个名为<code>ROW_ID</code>列，它是个6字节的隐藏列，你平时也看不到它，但实际上，它也是自增的。有了这层兜底机制保证，<strong>数据表肯定会有主键和主键索引</strong>。</p>
<p>跟ROW_ID被隐藏的列还有<code>trx_id</code>字段，用于记录当前这一行数据行是被<strong>哪个事务</strong>修改的，和一个<code>roll_pointer</code>字段，这个字段是用来指向当前这个数据行的上一个版本，通过这个字段，可以为这行数据形成一条版本链，从而实现<strong>多版本并发控制（MVCC）</strong>。有没有很眼熟，这个在之前写的<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/SR0ZL1zAc_0QIQvpDCOANw">文章</a>里出现过。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E9%9A%90%E8%97%8F%E7%9A%84row_id%E5%88%97.drawio.png" alt="隐藏的row_id列"><br></p>
<h3 id="有没有建议主键不自增的场景"><a href="#有没有建议主键不自增的场景" class="headerlink" title="有没有建议主键不自增的场景"></a>有没有建议主键不自增的场景</h3><p>前面提到了主键自增可以带来很多好处，事实上<strong>大部分场景下，我们都建议主键设为自增。</strong></p>
<p>那有没有不建议主键自增的场景呢？</p>
<br>

<h4 id="mysql分库分表下的id"><a href="#mysql分库分表下的id" class="headerlink" title="mysql分库分表下的id"></a>mysql分库分表下的id</h4><p>聊到分库分表，那我就需要说明下，<strong>递增和自增的区别</strong>了，<strong>自增</strong>就是每次都+1，而<strong>递增</strong>则是新的id比上一个id要大就行了，具体大多少，没关系。</p>
<p>之前写过一篇<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/HShytuc9Sw3p3kwCfbRbXw">文章</a>提到过，mysql在水平分库分表时，一般有两种方式。</p>
<p>一种分表方式是通过<strong>对id取模进行分表</strong>，这种要求递增就好，不要求严格自增，因为取模后数据会被分散到多个分表中，就算id是严格自增的，在分散之后，都只能保证每个分表里id只能是递增的。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E5%8F%96%E6%A8%A1%E5%88%86%E8%A1%A8.drawio.png" alt="根据id取模分表"></p>
<p>另一种分表方式是<strong>根据id的范围进行分表（分片）</strong>，它会划出一定的范围，比如以2kw为一个分表的大小，那0<del>2kw就放在这张分表中，2kw</del>4kw放在另一张分表中，数据不断增加，分表也可以不断增加，<strong>非常适合动态扩容</strong>，但它要求<strong>id自增</strong>，如果<strong>id递增</strong>，数据则会出现<strong>大量空洞</strong>。举个例子，比如第一次分配id=2，第二次分配id=2kw，这时候第一张表的范围就被打满了，后面再分配一个id，比如是3kw，就只能存到2kw<del>4kw（第二张）的分表中。那我在0</del>2kw这个范围的分表，也就存了<strong>两条数据</strong>，这太浪费了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E6%A0%B9%E6%8D%AEid%E8%8C%83%E5%9B%B4%E5%88%86%E8%A1%A8.png" alt="根据id范围分表"></p>
<p>但不管哪种分表方式，一般是<strong>不可能继续用原来表里的自增主键的</strong>，原因也比较好理解，原来的每个表如果都从0开始自增的话，那好几个表就会出现好几次重复的id，根据id唯一的原则，这显然不合理。</p>
<br>

<p>所以我们在分库分表的场景下，插入的id都是专门的id服务生成的，如果是要严格自增的话，那一般会通过redis来获得，当然不会是一个id请求获取一次，一般会<strong>按批次去获得，比如一次性获得100个。快用完了再去获取下一批100个。</strong></p>
<p>但这个方案有个问题，它严重依赖redis，如果redis挂了，那整个功能就傻了。</p>
<p>有没有不依赖于其他第三方组件的方法呢？</p>
<br>

<h5 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h5><p>有，比如<strong>Twitter开源的雪花算法。</strong></p>
<p>雪花算法通过64位有特殊含义的数字来组成id。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95.d4rawio.png" alt="雪花算法"></p>
<p>首先<strong>第0位</strong>不用。</p>
<p>接下来的<strong>41位</strong>是<strong>时间戳</strong>。精度是<strong>毫秒</strong>，这个大小大概能表示个<code>69年</code>左右，因为时间戳随着时间流逝肯定是越来越大的，所以这部分决定了生成的id肯定是越来越大的。</p>
<p>再接下来的<strong>10位</strong>是指产生这些雪花算法的<strong>工作机器id</strong>，这样就可以让每个机器产生的id都具有相应的标识。</p>
<p>再接下来的<strong>12位</strong>，<strong>序列号</strong>，就是指这个工作机器里生成的递增数字。</p>
<p>可以看出，只要处于同一毫秒内，所有的雪花算法id的前42位的值都是一样的，因此在这一毫秒内，能产生的id数量就是 <code>2的10次方✖️2的12次方</code>，大概<code>400w</code>，肯定是够用了，甚至有点多了。</p>
<br>

<p><strong>但是！</strong></p>
<p>细心的兄弟们肯定也发现了，雪花算法它算出的数字动不动就比上次的数字多个几百几万的，也就是它生成的id是<strong>趋势递增</strong>的，并不是严格**+1自增**的，也就是说它并不太适合于根据范围来分表的场景。这是个非常疼的问题。</p>
<p>还有个<strong>小问题</strong>是，那10位工作机器id，我每次扩容一个工作机器，这个机器怎么知道自己的id是多少呢？是不是得从某个地方读过来。</p>
<p><strong>那有没有一种生成id生成方案，既能让分库分表能做到很好的支持动态扩容，又能像雪花算法那样并不依赖redis这样的第三方服务。</strong></p>
<p>有。这就是这篇文章的重点了。</p>
<br>

<h5 id="适合分库分表的uuid算法"><a href="#适合分库分表的uuid算法" class="headerlink" title="适合分库分表的uuid算法"></a>适合分库分表的uuid算法</h5><p>我们可以参考雪花算法的实现，设计成下面这样。注意下面的每一位，<strong>都是十进制</strong>，而不是二进制。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E9%80%82%E5%90%88%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8%E7%9A%84uuid%E7%AE%97%E6%B3%95.d43rawio.png" alt="适合分库分表的uuid算法"></p>
<p>开头的<strong>12位</strong>依然是时间，但并不是时间戳，雪花算法的时间戳精确到毫秒，我们用不上这么细，我们改为<code>yyMMddHHmmss</code>，注意开头的yy是两位，也就是这个方案能保证到2099年之前，id都不会重复，能用到重复，那也是真·百年企业。同样由于最前面是时间，随着时间流逝，也能保证id趋势递增。</p>
<p>接下来的<strong>10位</strong>，用<strong>十进制</strong>的方式表示工作机器的ip，就可以把12位的ip转为10位的数字，它可以保证全局唯一，只要服务起来了，也就知道自己的ip是多少了，不需要像雪花算法那样从别的地方去读取worker id了，又是一个小细节。</p>
<p><img src="https://cdn.xiaobaidebug.top/0bec52deb6276987.jpeg"></p>
<p>在接下来的<strong>6位</strong>，就用于生成序列号，它能支持每秒钟生成100w个id。</p>
<p>最后的<strong>4位</strong>，也是这个id算法最妙的部分。它<strong>前2位</strong>代表分库id，<strong>后2位</strong>代表分表id。也就是支持一共<code>100*100=1w</code>张分表。</p>
<br>

<p>举个例子，假设我只用了1个分库，当我一开始只有3张分表的情况下，那我可以通过配置，要求生成的uuid最后面的2位，取值只能是[0,1,2]，分别对应三个表。这样我生成出来的id，就能非常均匀的落到三个分表中，这还<strong>顺带解决了单个分表热点写入的问题。</strong></p>
<p>如果随着业务不断发展，需要新加入两张新的表(3和4)，同时第0张表有点满了，不希望再被写了，那就将配置改为[1,2,3,4]，这样生成的id就不会再插入到对应的0表中。同时还可以加入生成id的<strong>概率和权重</strong>来调整哪个分表落更多数据。</p>
<p>有了这个新的uuid方案，我们<strong>既可以保证生成的数据趋势递增，同时也能非常方便扩展分表</strong>。非常nice。</p>
<br>

<p>数据库有那么多种，mysql只是其中一种，那其他数据库也是要求主键自增吗？</p>
<br>

<h4 id="tidb的主键id不建议自增"><a href="#tidb的主键id不建议自增" class="headerlink" title="tidb的主键id不建议自增"></a>tidb的主键id不建议自增</h4><p>tidb是一款分布式数据库，作为mysql分库分表场景下的替代产品，可以更好的对数据进行分片。</p>
<p>它通过引入<strong>Range</strong>的概念进行数据表分片，比如第一个分片表的id在0<del>2kw，第二个分片表的id在2kw</del>4kw。这其实就是<strong>根据id范围进行数据库分表</strong>。</p>
<p>它的语法几乎跟mysql一致，用起来大部分时候是无感的。</p>
<p>但跟mysql有一点很不一样的就是，mysql建议id自增，但<strong>tidb却建议使用随机的uuid</strong>。原因是如果id自增的话，根据范围分片的规则，一段时间内生成的id几乎都会落到同一个分片上，比如下图，从<code>3kw</code>开始的自增uuid，几乎都落到<code>range 1</code>这个分片中，而其他表却几乎不会有写入，性能没有被利用起来。出现<strong>一表有难，多表围观</strong>的场面，这种情况又叫<strong>写热点</strong>问题。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%86%99%E7%83%AD%E7%82%B9%E9%97%AE%E9%A2%98.drawio.png" alt="写热点问题"></p>
<p>所以为了充分的利用多个分表的写入能力，tidb建议我们写入时使用<strong>随机id</strong>，这样数据就能被均匀分散到多个分片中。</p>
<br>

<h4 id="用户id不建议用自增id"><a href="#用户id不建议用自增id" class="headerlink" title="用户id不建议用自增id"></a>用户id不建议用自增id</h4><p>前面提到的不建议使用自增id的场景，都是技术原因导致的，而下面介绍的这个，单纯是因为业务。</p>
<p>举个例子吧。</p>
<p>如果你能知道一个产品每个月，新增的用户数有多少，这个对你来说会是有用的信息吗？</p>
<p>对程序员来说，可能这个信息价值不大。</p>
<p>但如果你是做投资的呢，或者是分析竞争对手呢？</p>
<p>那反过来。</p>
<p>如果你发现你的竞争对手，总能非常清晰的知道你的产品每个月新进的注册用户是多少人，你会不会心里毛毛的？</p>
<p>如果真出现了这问题，先不要想是不是有内鬼，先检查下你的用户表主键是不是自增的。</p>
<img src="https://cdn.xiaobaidebug.top/%E6%9C%89%E5%86%85%E9%AC%BC.jpeg" alt="有内鬼" style="zoom:30%;" />

<p><strong>如果用户id是自增的，那别人只要每个月都注册一个新用户，然后抓包得到这个用户的user_id，然后跟上个月的值减一下，就知道这个月新进多少用户了。</strong></p>
<p>同样的场景有很多，有时候你去小店吃饭，发票上就写了你是今天的第几单，那大概就能估计今天店家做了多少单。你是店家，你心里也不舒服吧。</p>
<p>再比如说一些小app的商品订单id，如果也做成自增的，那就很容易可以知道这个月成了多少单。</p>
<p>类似的事情有很多，这些场景都建议使用趋势递增的uuid作为主键。</p>
<p>当然，<strong>主键保持自增，但是不暴露给前端，那也行，那前面的话，你当我没说过</strong>。</p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>建表sql里主键边上的<code>AUTO_INCREMENT</code>，可以让主键自增，去掉它是可以的，但这就需要你在insert的时候自己设置主键的值。</p>
</li>
<li><p>建表sql里的 <code>PRIMARY KEY</code> 是用来声明主键的，如果去掉，那也能建表成功，但mysql内部会给你偷偷建一个 <code>ROW_ID</code>的隐藏列作为主键。</p>
</li>
<li><p>由于mysql使用<strong>B+树索引，叶子节点是从小到大排序的</strong>，如果使用自增id做主键，这样每次数据都加在B+树的最后，比起每次加在B+树中间的方式，加在最后可以有效<strong>减少页分裂的问题。</strong></p>
</li>
<li><p>在分库分表的场景下，我们可以通过redis等第三方组件来获得严格自增的主键id。如果不想依赖redis，可以参考雪花算法进行<strong>魔改</strong>，<strong>既能保证数据趋势递增，也能很好的满足分库分表的动态扩容。</strong></p>
</li>
<li><p>并不是所有数据库都建议使用自增id作为主键，比如<strong>tidb就推荐使用随机id</strong>，这样可以有效避免<strong>写热点</strong>的问题。而对于一些敏感数据，比如用户id，订单id等，如果使用自增id作为主键的话，外部通过抓包，很容易可以知道新进用户量，成单量这些信息，所以需要<strong>谨慎考虑</strong>是否继续使用自增主键。</p>
</li>
</ul>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我比较记仇，最近有不少兄弟们在评论区叫我diao毛。</p>
<p><strong>我都记住了。</strong></p>
<p>但是，只要兄弟们还能给右下角的<strong>点赞和在看</strong>来上那么一下的话。</p>
<p>我觉得，<strong>这口气，也不是不能忍。</strong></p>
<p>按照惯例，我应该在这里唯唯诺诺的求大家叫我两声<strong>靓仔</strong>的。</p>
<p>但我今天不想。</p>
<p>所以先这样。</p>
<p>我是小白，我们下期见。</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<br>

<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a> </li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a> </li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xiaobaidebug.top/2022/06/09/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="有时骚话连篇，有时硬核图解">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小白debug">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/09/golang%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E4%B8%80%E4%B8%AA%E5%8F%AA%E6%94%AF%E6%8C%81batch_call%E7%9A%84%E6%9C%8D%E5%8A%A1%EF%BC%9F/" class="post-title-link" itemprop="url">如何调用一个只支持batch_call的服务？</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-09 22:57:55" itemprop="dateCreated datePublished" datetime="2022-06-09T22:57:55+08:00">2022-06-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-10-30 10:34:18" itemprop="dateModified" datetime="2022-10-30T10:34:18+08:00">2022-10-30</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/golang%E9%9D%A2%E8%AF%95%E9%A2%98/" itemprop="url" rel="index"><span itemprop="name">golang面试题</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>文章持续更新，可以微信搜一搜「小白debug」第一时间阅读，回复【教程】获golang免费视频教程。本文已经收录在GitHub <a target="_blank" rel="noopener" href="https://github.com/xiaobaiTech/golangFamily">https://github.com/xiaobaiTech/golangFamily</a> , 有大厂面试完整考点和成长路线，欢迎Star。</p>
</blockquote>
<p>我们先来说下标题是什么意思。</p>
<br>

<p>为了更好的理解我说的是啥，我们来举个例子。</p>
<p>假设你现在在做一个<strong>类似B站</strong>的系统，里面放了各种视频。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220529201338638.png"></p>
<p>用户每天在里头上传各种视频。</p>
<p>按理说每个视频都要去<strong>审查</strong>一下有没有搞颜色，但总不能人眼挨个看吧。</p>
<p>毕竟唐老哥表示这玩意看多了，看太阳都是绿色的，所以会有专门训练过的<strong>算法服务</strong>去做检测。</p>
<p>但也不能上来就整个视频每一帧都拿去做审查吧，所以会在每个视频里根据<strong>时长</strong>和<strong>视频类型</strong>随机抽出好几张图片去做审查，比如视频标签是美女的，算法爱看，那多抽几张。标签是编程的，狗都不看，就少抽几张。</p>
<p>将这些抽出来的图片，送去审查。</p>
<br>

<p>为了实现这个功能，我们会以<strong>视频为维度</strong>去做审核，而每个视频里都会有N张<strong>数量不定的图片</strong>，下游服务是个使用<strong>GPU</strong>去检测图片的<strong>算法服务</strong>。</p>
<p><strong>现在问题来了</strong>，下游服务的算法开发告诉你，这些个下游服务，它<strong>不支持很高的并发</strong>，但请求传参里给你加了个数组，你可以<strong>批量（batch）传入</strong>一个比较大的图片数组，通过这个方式可以提升点图片处理量。</p>
<br>

<p>于是，我们的场景就变成。</p>
<p><strong>上游服务</strong>的<strong>入参</strong>是<strong>一个</strong>视频和它的N张图片，<strong>出参</strong>是这个视频是否审核通过。</p>
<p><strong>下游服务</strong>的<strong>入参</strong>是N张图片的，<strong>出参</strong>是这个视频是否审核通过。</p>
<p><img src="https://cdn.xiaobaidebug.top/batch_call%E4%B8%8A%E4%B8%8B%E6%B8%B8.drawio.png" alt="batch_call上下游"></p>
<br>

<p><strong>现在我们想要用上游服务接入下游服务。</strong>该怎么办？</p>
<p>看上去挺好办的，一把梭不就完事了吗？</p>
<p>当一个视频进来，就拿着视频的十多张图片作为一个batch去进行调用。</p>
<p><strong>有几个视频进来，就开几个这样的并发。</strong></p>
<p>这么做的结果就是，当并发大一点时，你会发现性能很差，并且性能非常不稳定，比如像下面的监控图一样一会3qps，一会15qps。处理的图片也只支持20qps左右。</p>
<p><strong>狗看了都得摇头。</strong></p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220528224806387.png" alt="图1-直接调用时qps很低"></p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220528225037987.png"></p>
<p>这可如何是好？</p>
<br>

<h3 id="为什么下游需要batch-call"><a href="#为什么下游需要batch-call" class="headerlink" title="为什么下游需要batch call"></a>为什么下游需要batch call</h3><p>本着<strong>先问是不是，再问为什么</strong>的精神，我们先看看为啥下游的要求会如此别致。</p>
<p>为什么同样都是处理多张图片，下游不搞成支持并发而要搞成批量调用（batch call）？</p>
<p>这个设定有点奇怪？</p>
<p>其实不奇怪，在算法服务中<strong>甚至很常见</strong>，举个例子你就明白了。</p>
<p>同样是处理多张图片，为了简单，我就假设是三张吧。如果是用<strong>单个cpu</strong>去处理的话。那不管是并发还是batch进来，由于cpu内部的<strong>计算单元有限</strong>，所以你可以简单理解为，这三张图片，就是<strong>串行</strong>去计算的。</p>
<p><img src="https://cdn.xiaobaidebug.top/cpu%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B2.drawio.png" alt="cpu处理图片时的流程"></p>
<p>我计算第一张图片是否能审核通过，跟第二张图片是否能审核通过，这两者没有逻辑关联，因此按道理两张图片是可以<strong>并行</strong>计算。</p>
<p>奈何我CPU计算单元有限啊，做不到啊。</p>
<p>但是。</p>
<p><strong>如果我打破计算单元有限的这个条件，给CPU加入超多计算单元，并且弱化一些对于计算没啥用处的组件，比如cache和控制单元。</strong>那我们就有足够的算力可以让这些图片的计算<strong>并行</strong>起来了。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%B9%B6%E8%A1%8C%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87.drawio.png" alt="并行处理图片"></p>
<p>是的，把CPU这么一整，它其实就变成了GPU。</p>
<p><img src="https://cdn.xiaobaidebug.top/GPU%E5%92%8CCPU%E7%9A%84%E5%8C%BA%E5%88%AB2.drawio.png" alt="GPU和CPU的区别"></p>
<p>上面的讲解只是为了方便理解，实际上，gpu会以更细的粒度去做并发计算，比如可以细到图片里的<strong>像素</strong>级别。</p>
<p>这也是为什么如果我们跑一些3d游戏的时候，需要用到显卡，因为它可以快速的并行计算画面里每个地方的光影，远近效果啥的，然后渲染出画面。</p>
<br>

<p><strong>回到为什么要搞成batch call的问题中。</strong></p>
<p>其实一次算法服务调用中，在数据真正进入GPU前，其实也使用了CPU做一些前置处理。</p>
<p>因此，我们可以简单的将一次调用的时间理解成做了下面这些事情。</p>
<p><img src="https://cdn.xiaobaidebug.top/GPU%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E6%97%B6%E7%9A%84%E6%B5%81%E7%A8%8B.drawio.png" alt="GPU处理图片时的流程"></p>
<p>服务由CPU逻辑和GPU处理逻辑组成，调用进入服务后，会有一些前置逻辑，它需要CPU来完成，然后才使用GPU去进行并行计算，将结果返回后又有一些后置的CPU处理逻辑。中间的GPU部分，管是计算1张图，还是计算100张图，只要算力支持，那它们都是并行计算的，耗时都差不多。</p>
<p>如果把这多张图片拆开，<strong>并发去调用</strong>这个算法服务，那就有 N组这样的CPU+GPU的消耗，而中间的并行计算，其实没有利用到位。</p>
<p>并且还会多了前置和后置的CPU逻辑部分，算法服务一般都是python服务，主流的一些web框架几乎都是以<strong>多进程</strong>，<strong>而不是多线程</strong>的方式去处理外部请求，这就有可能导致额外的<strong>进程间切换消耗</strong>。</p>
<p>当并发的请求多了，请求处理不过来，后边来的请求就需要等前边的处理完才能被处理，后面的请求耗时看起来就会变得特别大。这也是上面图1里，接口延时（latency）像过山车那样往上涨的原因。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220602225740411.png" alt="还是上面的图1的截图，一张图用两次哈哈"></p>
<p>按理说<strong>减少并发，增大每次调用时的图片数量</strong>，就可以解决这个问题。</p>
<p>这就是推荐batch call的原因。</p>
<p>但问题又来了。</p>
<p>每次调用，上游服务输入的是一个视频以及它的几张图片，调用下游时，batch的数量按道理就只能是这几张图片的数量，<strong>怎么才能增大batch的数量呢？</strong></p>
<p>这里的调用，就需要分为<strong>同步调用和异步调用</strong>了。</p>
<br>

<h3 id="同步调用和异步调用的区别"><a href="#同步调用和异步调用的区别" class="headerlink" title="同步调用和异步调用的区别"></a>同步调用和异步调用的区别</h3><p>同步调用，意思是上游发起请求后，<strong>阻塞等待</strong>，下游处理逻辑后返回结果给上游。常见的形式就像我们平时做的http调用一样。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%90%8C%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="同步调用"></p>
<p>异步调用，意思是上游发起请求后<strong>立马返回</strong>，下游收到消息后慢慢处理，处理完之后再通过某个形式通知上游。常见的形式是使用消息队列，也就是mq。将消息发给mq后，下游消费mq消息，触发处理逻辑，然后再把处理结果发到mq，上游消费mq的结果。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%AF%B7%E6%B1%82.png" alt="异步调用"></p>
<br>

<h3 id="异步调用的形式接入"><a href="#异步调用的形式接入" class="headerlink" title="异步调用的形式接入"></a>异步调用的形式接入</h3><p><img src="https://cdn.xiaobaidebug.top/%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F.drawio.png" alt="异步调用的实现方式"></p>
<p>回到我们文章开头提到的例子，当上游服务收到一个请求（一个视频和它对应的图片），这时候上游服务作为生产者将这个数据写入到mq中，请求返回。然后新造一个C服务，负责批量消费mq里的消息。这时候服务C就可以根据下游服务的性能控制自己的消费速度，比如一次性消费10条数据（视频），每个数据下面挂了10个图片，那我一次batch的图片数量就是10*10=100张，原来的10次请求就变为了1次请求。这对下游就相当的友好了。</p>
<p>下游返回结果后，服务C将结果写入到mq的另外一个topic下，由上游去做消费，这样就结束了整个调用流程。</p>
<br>

<p>当然上面的方案，如果你把mq换成数据库，一样是ok的，这时候服务C就可以不断的定时轮询数据库表，看下哪些请求没处理，把没处理的请求批量捞出来再batch call下游。不管是mq还是数据库，它们的作用无非就是<strong>作为中转，暂存数据，让服务C根据下游的消费能力，去消费这些数据。</strong></p>
<p>这样不管后续要加入多少个新服务，它们都可以在原来的基础上做扩展，如果是mq，加topic，如果是数据库，则加数据表，每个新服务都可以根据自己的消费能力去调整消费速度。</p>
<p><img src="https://cdn.xiaobaidebug.top/mq%E4%B8%B2%E8%81%94%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E6%80%A7%E8%83%BD%E7%9A%84%E6%9C%8D%E5%8A%A1.drawio.png" alt="mq串联多个不同性能的服务"></p>
<p><strong>其实对于这种上下游服务处理性能不一致的场景，最适合用的就是异步调用。而且涉及到的服务性能差距越大，服务个数越多，这个方案的优势就越明显。</strong></p>
<br>

<h3 id="同步调用的方式接入"><a href="#同步调用的方式接入" class="headerlink" title="同步调用的方式接入"></a>同步调用的方式接入</h3><p>虽然异步调用在这种场景下的优势很明显，但也有个缺点，就是它需要最上游的调用方能接受用异步的方式去消费结果。其实涉及到算法的服务调用链，都是比较耗时的，用异步接口非常合理。但合理归合理，有些最上游他不一定听你的，就是不能接受异步调用。</p>
<p>这就需要采用同步调用的方案，但怎么才能把同步接口改造得更适合这种调用场景，这也是这篇文章的重点。</p>
<br>

<h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><p>如果直接将请求打到下游算法服务，下游根本吃不消，因此首先需要做的就是给在上游调用下游的地方，加入一个速率限制（rate limit）。</p>
<p><strong>这样的组件一般也不需要你自己写，几乎任何一个语言里都会有现成的。</strong></p>
<p>比如golang里可以用<code>golang.org/x/time/rate</code>库，它其实是用令牌桶算法实现的限流器。如果不知道令牌桶是啥也没关系，不影响理解。</p>
<p><img src="https://cdn.xiaobaidebug.top/%E9%99%90%E6%B5%81%E5%99%A8%E9%80%BB%E8%BE%91.png" alt="限流器逻辑"></p>
<p>当然，这个限制的是<strong>当前这个服务</strong>调用下游的qps，也就是所谓的<strong>单节点限流</strong>。如果是多个服务的话，网上也有不少现成的<strong>分布式限流</strong>框架。但是，还是那句话，<strong>够用就好</strong>。</p>
<p>限流只能保证下游算法服务不被压垮，并不能提升单次调用batch的图片数量，有没有什么办法可以解决这个问题呢？</p>
<br>

<h4 id="参考Nagle算法的做法"><a href="#参考Nagle算法的做法" class="headerlink" title="参考Nagle算法的做法"></a>参考Nagle算法的做法</h4><p>我们熟悉的TCP协议里，有个算法叫Nagle算法，设计它的目的，就是为了避免一次传过少数据，提高数据包的有效数据负载。</p>
<p>当我们想要发送一些数据包时，数据包会被放入到一个缓冲区中，不立刻发送，那什么时候会发送呢？</p>
<p>数据包会在以下两个情况被发送：</p>
<ul>
<li>缓冲区的数据包长度达到某个长度（MSS）时。</li>
<li>或者等待超时（一般为<code>200ms</code>）。在超时之前，来的那么多个数据包，就是凑不齐MSS长度，现在超时了，不等了，立即发送。</li>
</ul>
<p>这个思路就非常值得我们参考。我们完全可以自己在代码层实现一波，实现也非常简单。</p>
<p>1.我们定义一个带锁的全局队列（链表）。</p>
<p>2.当上游服务输入一个视频和它对应的N张图片时，就加锁将这N张<strong>图片数据</strong>和一个<strong>用来存放返回结果的结构体</strong>放入到全局队列中。然后死循环读这个结构体，直到它有结果。就有点像阻塞等待了。</p>
<p>3.同时在服务启动时就起一个<strong>线程A</strong>专门用于<strong>收集</strong>这个全局队列的图片数据。<strong>线程A</strong>负责发起调用下游服务的请求，但只有在下面两个情况下会发起请求</p>
<ul>
<li>当收集的图片数量达到xx张的时候</li>
<li>距离上次发起请求过了xx毫秒（超时）</li>
</ul>
<p>4.调用下游结束后，再根据一开始传入的数据，将调用结果拆开来，送回到刚刚提到的<strong>用于存放结果的结构体</strong>中。</p>
<p>5.第2步里的死循环因为<strong>存放返回结果的结构体</strong>，有值了，就可以跳出死循环，继续执行后面的逻辑。</p>
<p><img src="https://cdn.xiaobaidebug.top/batch_call%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8%E6%94%B9%E9%80%A0.drawio%20(1).png" alt="batch_call同步调用改造"></p>
<p>这就像公交车站一样，公交车站不可能每来一个顾客就发一辆公交车，当然是希望车里顾客越多越好。上游每来一个请求，就把请求里的图片，也就是乘客，塞到公交车里，公交车要么到点发车（向下游服务发起请求），要么车满了，也没必要等了，直接发车。这样就保证了每次发车的时候公交车里的顾客数量足够多，发车的次数尽量少。</p>
<br>

<p>大体思路就跟上面一样，如果是用go来实现的话，就会更加简单。</p>
<p>比如第1步里的<strong>加锁全局队列</strong>可以改成<strong>有缓冲长度的channel</strong>。第2步里的”<strong>用来存放结果的结构体</strong>“，也可以改成<strong>另一个无缓冲channel</strong>。执行 res := &lt;-ch， 就可以做到<strong>阻塞等待</strong>的效果。</p>
<p>而核心的仿Nagle的代码也大概长下面这样。当然<strong>不看也没关系，反正你已经知道思路了</strong>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CallAPI</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	size := <span class="number">100</span></span><br><span class="line">	<span class="comment">// 这个数组用于收集视频里的图片，每个 IVideoInfo 下都有N张图片</span></span><br><span class="line">	videoInfos := <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line">	<span class="comment">// 设置一个200ms定时器</span></span><br><span class="line">	tick := time.NewTicker(<span class="number">200</span> * time.Microsecond)</span><br><span class="line">	<span class="keyword">defer</span> tick.Stop()</span><br><span class="line">  <span class="comment">// 死循环</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">select</span> &#123;</span><br><span class="line">		<span class="comment">// 由于定时器，每200ms，都会执行到这一行</span></span><br><span class="line">		<span class="keyword">case</span> &lt;-tick.C:</span><br><span class="line">			<span class="keyword">if</span> <span class="built_in">len</span>(videoInfos) &gt; <span class="number">0</span> &#123;</span><br><span class="line">				<span class="comment">// 200ms超时，去请求下游</span></span><br><span class="line">				limitStartFunc(videoInfos, <span class="literal">true</span>)</span><br><span class="line">				<span class="comment">// 请求结束后把之前收集的数据清空，重新开始收集。</span></span><br><span class="line">				videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line">			&#125;</span><br><span class="line">		<span class="comment">// AddChan就是所谓的全局队列</span></span><br><span class="line">		<span class="keyword">case</span> videoInfo, ok := &lt;-AddChan:</span><br><span class="line">			<span class="keyword">if</span> !ok &#123;</span><br><span class="line">				<span class="comment">// 通道关闭时，如果还有数据没有去发起请求，就请求一波下游服务</span></span><br><span class="line">				limitStartFunc(videoInfos, <span class="literal">false</span>)</span><br><span class="line">				videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				videoInfos = <span class="built_in">append</span>(videoInfos, videoInfo)</span><br><span class="line">				<span class="keyword">if</span> videoInfos 内的图片满足xx数量 &#123;</span><br><span class="line">					limitStartFunc(videoInfos, <span class="literal">false</span>)</span><br><span class="line">					videoInfos = <span class="built_in">make</span>([]IVideoInfo, <span class="number">0</span>, size)</span><br><span class="line">					<span class="comment">// 重置定时器</span></span><br><span class="line">					tick.Reset(<span class="number">200</span> * time.Microsecond)</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<br>

<p>通过这一操作，上游每来一个请求，都会将视频里的图片收集起来，堆到一定张数的时候再统一请求，大大提升了每次batch call的图片数量，同时也减少了调用下游服务的次数。<strong>真·一举两得</strong>。</p>
<p>优化的效果也比较明显，上游服务支持的qps从原来不稳定的3q~15q变成稳定的90q。下游的接口耗时也变得稳定多了，从原来的过山车似的飙到15s变成稳定的500ms左右。处理的图片的速度也从原来20qps提升到350qps。</p>
<p>到这里就已经大大超过业务需求的预期（40qps）了，够用就好，多一个qps都是浪费。</p>
<p>可以了，下班吧。</p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220528215806920.png"></p>
<p><img src="https://cdn.xiaobaidebug.top/image-20220529171810510.png"></p>
<br>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>为了充分利用<strong>GPU</strong>并行计算的能力，不少算法服务会希望上游通过加大<strong>batch</strong>的同时减少并发的方式进行接口调用。</li>
<li>对于上下游性能差距明显的服务，建议配合<strong>mq</strong>采用<strong>异步调用</strong>的方式将服务串联起来。</li>
<li>如果非得使用<strong>同步调用</strong>的方式进行调用，建议模仿<strong>Nagle算法</strong>的形式，攒一批数据再发起请求，这样既可以增大batch，同时减少并发，真·一举两得，<strong>亲测有效</strong>。</li>
</ul>
<br>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>讲了那么多可以提升性能的方式，现在需求来了，如果你资源充足，但时间不充足，那还是直接同步调用一把梭吧。</p>
<p>性能不够？<strong>下游加机器，gpu卡，买！</strong></p>
<p>然后下个季度再提起一个技术优化，<strong>性能提升xx%，cpu，gpu减少xx%。</strong></p>
<p>有没有闻到？</p>
<p>这是kpi的味道。</p>
<p>又是一个小细节，学到了的兄弟们评论区打个【<strong>学到了</strong>】。</p>
<br>

<hr>
<p>最近原创更文的阅读量稳步下跌，思前想后，夜里辗转反侧。</p>
<p>我有个不成熟的请求。</p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162506224.png" alt="" style="zoom:20%;" />

<br>

<p><strong>离开广东好长时间了，好久没人叫我靓仔了。</strong></p>
<p>大家可以在<strong>评论区</strong>里，叫我一靓仔吗？</p>
<p>我这么善良质朴的愿望，能被满足吗？</p>
<p>如果实在叫不出口的话，能帮我点下右下角的<strong>点赞和在看</strong>吗？</p>
<br>

<h6 id="别说了，一起在知识的海洋里呛水吧"><a href="#别说了，一起在知识的海洋里呛水吧" class="headerlink" title="别说了，一起在知识的海洋里呛水吧"></a>别说了，一起在知识的海洋里呛水吧</h6><p><strong>点击</strong>下方名片，关注公众号:【小白debug】<br><img src="https://cdn.xiaobaidebug.top/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E6%A0%87%E5%87%86%E8%89%B2%E7%89%88.png"></p>
<br>

<p>不满足于在留言区说骚话？</p>
<p>加我，我们建了个划水吹牛皮群，在群里，你可以跟你下次跳槽可能遇到的同事或面试官聊点有意思的话题。就<strong>超！开！心！</strong></p>
<img src="https://cdn.xiaobaidebug.top/image-20220522162616202.png" alt="" style="zoom:50%;" />

<p><img src="https://cdn.xiaobaidebug.top/006APoFYly1g5q9gn2jipg308w08wqdi.gif"></p>
<h3 id="文章推荐："><a href="#文章推荐：" class="headerlink" title="文章推荐："></a>文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/PP80aD-GQp7VtgyfHj392g">程序员防猝死指南</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/0-YBxU1cSbDdzcZEZjmQYA">TCP粘包 数据包：我只是犯了每个数据包都会犯的错 |硬核图解</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/YpQGsRyyrGNDu1cOuMy83w">动图图解！既然IP层会分片，为什么TCP层也还要分段？</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/./page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/./page/6/">6</a><a class="extend next" rel="next" href="/./page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt=""
      src="https://cdn.xiaobaidebug.top/image/aaaaaa%E5%A4%B4%E5%83%8F.png">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">有时骚话连篇，有时硬核图解</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">54</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
  </nav>
</div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://polarisxu.studygolang.com/" title="https:&#x2F;&#x2F;polarisxu.studygolang.com&#x2F;" rel="noopener" target="_blank">polarisxu</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://xargin.com/" title="https:&#x2F;&#x2F;xargin.com&#x2F;" rel="noopener" target="_blank">Xargin</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://eddycjy.com/" title="https:&#x2F;&#x2F;eddycjy.com&#x2F;" rel="noopener" target="_blank">脑子进煎鱼了</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://mytechshares.com/" title="https:&#x2F;&#x2F;mytechshares.com&#x2F;" rel="noopener" target="_blank">董泽润的技术笔记</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.qcrao.com/" title="https:&#x2F;&#x2F;www.qcrao.com&#x2F;" rel="noopener" target="_blank">码农桃花源</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.haohongfan.com/" title="https:&#x2F;&#x2F;www.haohongfan.com&#x2F;" rel="noopener" target="_blank">HHFCodeRv</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.qiyacloud.cn/" title="https:&#x2F;&#x2F;www.qiyacloud.cn" rel="noopener" target="_blank">奇伢云存储</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://asong.cloud/" title="https:&#x2F;&#x2F;asong.cloud&#x2F;" rel="noopener" target="_blank">Golang梦工厂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.syst.top/" title="https:&#x2F;&#x2F;www.syst.top&#x2F;" rel="noopener" target="_blank">吴亲强的深夜食堂</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.luozhiyun.com/" title="https:&#x2F;&#x2F;www.luozhiyun.com&#x2F;" rel="noopener" target="_blank">luozhiyun很酷</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>















  

  


</body>
</html>
